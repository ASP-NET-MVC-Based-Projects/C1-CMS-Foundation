/*
 * Created: 26. august 2010 16:36:46
 */


/**
 * @class
 * Acceptable.
 */
var IAcceptable = new function () {
	
	/** 
	 * Whitespace separated.
	 * @type {string}
	 */
	this.dragAccept = "type1 type2 type3";
	
	/**
	 * @param {IDraggable} binding
	 */
	this.accept = function ( binding ) {}
	
	/**
	 * Indicate acceptance when drag starts (whereever drag starts). OPTIONAL!
	 *
	this.showGeneralAcceptance = function () {}
	*/
	
	/**
	 * Don't indicate acceptance (whereever drag started). OPTIONAL!
	 *
	this.hideGeneralAcceptance = function () {}
	*/
	
	/**
	 * Indicate acceptance (onmouseover). OPTIONAL!
	 *
	this.showAcceptance = function () {}
	*/
	
	/**
	 * Don't indicate acceptance (onmouseout). OPTIONAL!
	 *
	this.hideAcceptance = function () {}
	*/
}

/**
 * @class
 * Action listener.
 */
var IActionListener = new function () {

	/**
	 * @param {Action} action
	 */
	this.handleAction = function ( action ) {}
}

/**
 * @class
 * Activatable binding.
 * @see {DockBinding}
 * @see {DialogBinding}
 */
var IActivatable = new function () {
	
	/**
	 * @type {boolean}
	 */
	this.isActivatable = true;
	
	/**
	 * Activate.
	 */
	this.activate = function () {}
	
	/**
	 * Deactivate
	 */
	this.deActivate = function () {}
}

/**
 * @class
 * Activation-aware binding.
 * @see {DockBinding}
 * @see {DialogBinding}
 */
var IActivationAware = new function () {
	
	/**
	 * @implements {IActivationAware}
	 * @type {boolean}
	 */
	this.isActivationAware = true;
	
	/**
	 * @type {boolean}
	 */
	this.isActivated = false;
	
	/**
	 * Invoked when the nearest containing 
	 * {@link IActivatable} gets activated.
	 */
	this.onActivate = function () {}
	
	/**
	 * Invoked when the nearest containing 
	 * {@link IActivatable} gets activated.
	 */
	this.onDeactivate = function () {}
}

/**
 * @class
 * BroadcastListener. 
 * @see {EventBroadcaster}
 */
var IBroadcastListener = new function () {
	
	/**
	 * Handle broadcast.
	 * @param {string} broadcast
	 * param {object} optional
	 */
	this.handleBroadcast = function ( broadcast, optional ) {}
}

/**
 * @class
 * Crawler handler. 
 * @see {UICrawler}
 */
var ICrawlerHandler = new function () {

	/**
	 * @param {Crawler} crawler
	 */
	this.handleCrawler = function ( crawler ) {}
}

/**
 * @class
 * @implements {IFocusable}
 */
var IData = new function () {
	
	/**
	 * @implements {IFocusable}
	 * @type {boolean}
	 */
	this.isFocusable = true;
	
	/**
	 * Validate.
	 * @return {boolean}
	 */
	this.validate = function () {};
	
	/**
	 * Manifest. This will write form elements into page DOM 
	 * so that the server recieves something on form submit.
	 * @return {Binding} Although we probably return null...
	 */
	this.manifest = function () {};
	
	/**
	 * Mark binding dirty and set a flag in the local DataManager. 
	 */
	this.dirty = function () {};
	
	/**
	 * Remove the dirty mark.
	 */
	this.clean = function () {};
	
	/**
	 * Focus.
	 * @implements {IFocusable}
	 */
	this.focus = function () {};
	
	/**
	 * Blur.
	 * @implements {IFocusable}
	 */
	this.blur = function () {};
	
	/**
	 * Get name.
	 * @return {string}
	 */
	this.getName = function () {};
	
	/**
	 * Get value. This is intended for serverside processing.
	 * @return {string}
	 */
	this.getValue = function () {};
	
	/**
	 * Set value.
	 * @param {string} value
	 */
	this.setValue = function ( value ) {};
	
	/**
	 * Get result. This is intended for clientside processing.
	 * @return {object}
	 */
	this.getResult = function () {};
	
	/**
	 * Set result.
	 * @see {DataManager#populateDataBindings}
	 * @param {object} result
	 */
	this.setResult = function ( result ) {};
}

/**
 * @class
 * DialogHandler.
 */
var IDialogResponseHandler = new function () {
	
	/**
	 * Handle broadcast.
	 * @param {object} response
	 * @param {object} result Optional
	 */
	this.handleDialogResponse = function () { response, result }
}

/**
 * Load handler.
 */
var IDOMHandler = new function () {
	
	/**
	 * Fire on DOMContentLoaded.
	 */
	this.fireOnDOM = function () {};
};

/**
 * @class
 * Draggable.
 */
var IDraggable = new function () {
	
	/**
	 * @type {string}
	 */
	this.dragType = "type";
	
	/**
	 * @return {string}
	 */
	this.getImage = function () {}
	
	/**
	 * Indicate drag. OPTIONAL!
	 *
	this.showDrag = function () {}
	*/
	
	/**
	 * Don't indicate drag. OPTIONAL!
	 *
	this.hideDrag = function () {}
	*/
}

/**
 * @class
 * Drag handler.
 */
var IDragHandler = new function () {
	
	/**
	 * @param {Point} point
	 */
	this.onDragStart = function ( point ) {}
	
	/**
	 * @param {Point} diff
	 */
	this.onDrag = function ( diff ) {}
	
	/**
	 * @param {Point} diff
	 */
	this.onDragStop = function ( diff ) {}
}

/**
 * @class
 */
var IEditorControlBinding = new function () {
	
	/**
	 * Indicates that editors should not blur 
	 * the toolbars when binding is handled.
	 * @see {TinyMCE_CompositeTheme#initialize}
	 * @type {boolean}
	 */
	this.isEditorControlBinding = true;
}

/**
 * @class
 * DOM2 EventListener interface.
 */
var IEventListener = new function () {

	/**
	 * @param {Event} e
	 */
	this.handleEvent = function ( e ) {}
}

/**
 * @class
 */
var IFit = new function () {

	/**
	 * Is fit?
	 * @type {boolean}
	 */
	this.isFit = true;
	
	/**
	 * Fit!
	 * @return {boolean} True if dimension changed
	 */
	this.fit = function () {
		
		return true;
	};
}

/**
 * @class
 */
var IFlexible = new function () {

	/**
	 * Flex.
	 */
	this.flex = function () {}
}

/**
 * @class
 * This fellow is supposed to be focused specifically by use of the tab key. 
 */
var IFocusable = new function () {

	/**
	 * @type {boolean}
	 */
	this.isFocusable = true;
	
	/**
	 * @type {boolean}
	 */
	this.isFocused = false;
	
	/**
	 * Focus.
	 */
	this.focus = function () {
	
		this.dispatchAction ( Binding.ACTION_FOCUSED );
	}
	
	/**
	 * Blur.
	 */
	this.blur = function () {
	
		this.dispatchAction ( Binding.ACTION_BLURRED );
	}
}

/**
 * @class
 * Image profile interface.
 */
var IImageProfile = new function () {

	/**
	 * Get default image.
	 * @return {string}
	 */
	this.getDefaultImage = function () {}

	/**
	 * Get hover image.
	 * @return {string}
	 */
	this.getHoverImage = function () {}
	
	/**
	 * Get active image.
	 * @return {string}
	 */
	this.getActiveImage = function () {}
	
	/**
	 * Get disabled image.
	 * @return {string}
	 */
	this.getDisabledImage = function () {}
}

/**
 * @class
 * Key event handler.
 */
var IKeyEventHandler = new function () {
	
	/**
	 * Handle key event.
	 */
	this.handleKeyEvent = function () {};
}

/**
 * @class
 * Label interface.
 */
var ILabel = new function () {
	
	/**
	 * @return {string}.
	 */
	this.getLabel = function () {}
	
	/**
	 * @return {string}.
	 */
	this.getImage = function () {}
	
	/**
	 * @return {string}.
	 */
	this.getToolTip = function () {}
}

/**
 * @class
 * Load handler.
 */
var ILoadHandler = new function () {
	
	/**
	 * Fire on load.
	 */
	this.fireOnLoad = function () {}
};

/**
 * @class
 * Menucontainer.
 */
var IMenuContainer = new function () {
	
	/**
	 * @return {boolean}
	 */
	this.isOpen = function () {}
	
	/**
	 * @param {Binding} binding
	 */
	this.setOpenElement = function ( binding ) {}
}

/**
 * @class
 * Resize handler.
 */
var IResizeHandler = new function () {
	
	/**
	 * Fire on load.
	 */
	this.fireOnResize = function () {}
}

/**
 * @class
 */
var ISourceEditorComponent = new function () {
	
	/** 
	 * @param {SourceEditorBinding} editor
	 * @param {HTMLIframeElement} frame
	 * @type {CodePress} engine
	 */
	this.initializeSourceEditorComponent = function ( editor, frame, engine ) {}
}

/**
 * Update handler interface.
 */
var IUpdateHandler = new function () {

	/**
	 * Handle element update?
	 * @param {Element} newelement
	 * @param {Element} oldelement
	 * @returns {boolean} 
	 */
	this.handleElement = function ( newelement, oldelement ) {};
	
	/**
	 * Update element.
	 * @implements {IUpdateHandler}
	 * @param {Element} newelement
	 * @param {Element} oldelement
	 * @returns {boolean} 
	 */
	this.updateElement = function ( newelement, oldelement ) {};
}

/**
 * @class
 */
var IWysiwygEditorComponent = new function () {
	
	/**
	 * @param {WysiwygEditorBinding} editor
	 * @param {TinyMCE_Engine} engine
 	 * @param {TinyMCE_Control} instance
 	 * @param {TinyMCE_CompositeTheme} theme
	 */
	this.initializeComponent = function ( editor, engine, instance, theme ) {}
}

/**
 * @class
 */
var IWysiwygEditorContentChangeHandler = new function () {
	
	/**
	 * Handle content change.
	 */
	this.handleContentChange = function () {}
}

/**
 * @class
 */
var IWysiwygEditorNodeChangeHandler = new function () {
	
	/**
	 * @param {DOMElement} element
	 */
	this.handleNodeChange = function ( element ) {}
}

/**
 * @class
 * Sort of an array with added methods. Not as flexible, but easier to read. 
 * All this stuff was written before the new Array methods of JS1.6 - otherwise 
 * we would have attempted to simply simply emulate these by expando on Explorer.
 * @param {object} arg Optional
 */
function List ( arg ) {
	
	/**
	 * @type {int}
	 */
	this._index = 0;
	
	/**
	 * @type {array}
	 */
	this._array = [];
	
	/*
	 * Initialize from argument.
	 */
	if ( arg ) {
		this.init ( arg );
	}
	
	return this;
}

/**
 * Populate from specified array or NodeList.
 * @param {object} This should be either an array or a NodeList object.
 */
List.prototype.init = function ( list ) {

	var isArray = list.splice != null;
	
	if ( isArray ) {
		this._array = list;
	} else {
		var i = 0, entry;
		while (( entry = list [ i++ ]) != null ) {
			this._array.push ( entry );
		}
	}
	this.reset ();
}

/**
 * Add object and return it.
 * @param {object} object
 * @return {object}
 */
List.prototype.add = function ( object ) {

	this._array.push ( object );
	return object;
}

/**
 * Add object first and return it.
 * @param {object} object
 * @return {object}
 */
List.prototype.addFirst = function ( object ) {

	this._array.unshift ( object );
	return object;
}

/**
 * @param {int} index
 * @return {object}
 */
List.prototype.get = function ( index ) {
	
	var result = null;
	if ( this._array [ index ]) {
		result = this._array [ index ];
	} 
	return result;
}

/**
 * @param {int} index
 * @param {object} value
 */
List.prototype.set = function ( index, value ) {

	this._array [ index ] = value;
}

/**
 * Delete entry at specified index.
 * @param {int} index
 */
List.prototype.del = function ( index ) {

	this._array.splice ( index, 1 );
}

/**
 * Is entry added?
 * @param {object} entry
 */
List.prototype.has = function ( entry ) {
	
	var result = false;
	var i = 0, e;
	while (( e = this._array [ i++ ]) != null ) {
		if ( e == entry ) {
			result = true;
			break;
		}
	}
	return result;
}		
		
/**
 * @return {int}
 */
List.prototype.getLength = function () {

	return this._array.length;
}

/**
 * @return {boolean}
 */
List.prototype.hasEntries = function () {

	return this.getLength () > 0;
}

/**
 * @return {boolean}
 */
List.prototype.hasNext = function () {

	return this._index < this._array.length;
}

/**
 * @return {object}
 */
List.prototype.getNext = function () {

	var result = null;
	if ( this.hasNext ()) {
		result = this._array [ this._index ++ ];
	}
	return result;
}

/**
 * Get following entry.
 * @param {object} entry
 * @return {object}
 */
List.prototype.getFollowing = function ( entry ) {

	var result = null;
	var i = 0, e = null;
	
	while (( e = this._array [ i ]) != null && !result ) {
		if ( e == entry && this._array [ i + 1 ]) {
			result = this._array [ i + 1 ];
		}
		i++;
	}
	return result;
}

/**
 * Get preceding.
 * @param {object} entry
 * @return {object}
 */
List.prototype.getPreceding = function ( entry ) {
	
	var result = null;
	var i = 1, e = null;
	
	while (( e = this._array [ i ]) != null && !result ) {
		if ( e == entry && this._array [ i - 1 ]) {
			result = this._array [ i - 1 ];
		}
		i++;
	}
	return result;
}

/**
 * Get first occuring index of a given entry.  
 * @param {object} entry
 * @return {int}
 */
List.prototype.getIndex = function ( entry ) {
	
	var result = -1;
	
	if ( this._array.indexOf != null ) {
		result = this._array.indexOf ( entry );
	} else {
		var index = 0;
		this.each ( function ( e ) {
			var res = true;
			if ( e == entry ) {
				result = index;
				res = false;
			}
			index ++;
			return res;
		});
	}
	return result;
}

/**
 * @return {List}
 */
List.prototype.reset = function () {

	this._index = 0;
	return this;
}

/**
 * @return {List}
 */
List.prototype.clear = function () {

	this._array = [];
	return this.reset ();
}

/**
 * @param {function} action The action can return false to discontinue iteration.
 * @param {object} thisp
 */
List.prototype.each = function ( action, thisp ) {

	this.reset ();
	var is = true;
	while ( is != false && this.hasNext ()) {
		var index = this._index;
		is = action.call ( thisp, this.getNext (), index );
	}
	this.reset ();
}

/**
 * @return {List}
 */
List.prototype.copy = function () {

	return new List ( this._array );
}

/**
 * @return {List}
 */
List.prototype.reverse = function () {

	this._array.reverse ();
	return this;
}

/**
 * Extract first entry. This method changes the length of the list.
 * @return {object}
 */
List.prototype.extractFirst = function () {

	return this._array.shift ();
}

/**
 *  Extract last entry. This method changes the length of the list.	
 * @return {object}
 */
List.prototype.extractLast = function () {

	return this._array.pop ();
}

/**
 * Get first entry.
 */
List.prototype.getFirst = function () {
	
	return this.get ( 0 );
}

/**
 * Get last entry.
 */
List.prototype.getLast = function () {
	
	return this.get ( this.getLength () - 1 );
}

/**
 * Amazing.
 */
List.prototype.toString = function () {
	
	return this._array.toString ();
}

/**
 * @return {array}
 */
List.prototype.toArray = function () {
	
	return this._array;
}

/**
 * Add all entries from another list.
 * @param {List} list
 * @return {List}
 */
List.prototype.merge = function ( list ) {

	list.reset ();
	while ( list.hasNext ()) {
		this.add ( list.getNext ());
	}
	return this;
}

/**
 * Dispose.
 */
List.prototype.dispose = function () {
	
	var i = this._array.length - 1;
	while ( i >= 0 ) {
		this._array [ i-- ] = null;
	}
	this._array = null;
	this._index = null;
}

/**
 * @class
 * @param @optional {Hashmap} map
 */
function Map ( map ) {

	/**
	 * @type {HashMap<object><object>
	 */	
	this._map = {};
	
	/*
	 * Populate from optional constructor object.
	 */
	if ( map != null ) {
		for ( var key in map ) {
			this.set ( key, map [ key ]);
		}
	}
}

Map.prototype._map = {};

/**
 * Get entry. Notice that an invalid key will not be tolerated 
 * here. Always use method "has" to check for key existance first.
 * @param {object} key
 */
Map.prototype.get = function ( key ) {
	
	var result = null;
	if ( this.has ( key )) {
		result = this._map [ key ];
	} else {
		var cry = "Map: Invalid key: " + key;
		SystemLogger.getLogger ( "Map" ).error ( cry );
		SystemDebug.stack ( arguments );
		if ( Application.isDeveloperMode ) {
			alert ( cry );
		}
	}
	return result;
}

/**
 * Set entry.
 * @param {object} key
 * @param {object} value
 */
Map.prototype.set = function ( key, value ) {
	
	this._map [ key ] = value;
}

/**
 * Delete entry.
 * @param {object} key
 */
Map.prototype.del = function ( key ) {
	
	delete this._map [ key ];
}

/**
 * Has entry?
 * @param {object} key
 * @return {boolean}
 */
Map.prototype.has = function ( key ) {
	
	return typeof this._map [ key ] != "undefined";
}

/**
 * Each entry.
 * @param {function} action
 */
Map.prototype.each = function ( action ) {
	
	for ( var key in this._map ) {
		var isContinue = action ( 
			key, 
			this._map [ key ]
		);
		if ( isContinue == false ) {
			break;
		}
	}
}

/**
 * Has entries?
 * @retun {boolean}
 */
Map.prototype.hasEntries = function () {
	
	var result = false;
	for ( var key in this._map ) {
		result = true;
		break;
	}
	return result;
}

/**
 * How many entries?
 * @retun {int}
 */
Map.prototype.countEntries = function () {
	
	var result = 0;
	for ( var key in this._map ) {
		result ++;
	}
	return result;
}

/** 
 * Convert to list (listing keys or values).
 * @param {boolean} isKey
 */
Map.prototype.toList = function ( isKey ) {
	
	var list = new List ();
	for ( var key in this._map ) {
		list.add (
			isKey ? key : this._map [ key ]
		);
	}
	return list;
}

/**
 * Copy.
 * @return {Map}
 */
Map.prototype.copy = function () {
	
	var map = new Map ();
	for ( var key in this._map ) {
		map.set ( key, this._map [ key ]);
	}
	return map;
}

/**
 * This will modify the original Map.
 * @return {Map}
 */
Map.prototype.inverse = function () {
	
	var map = new Map ();
	for ( var key in this._map ) {
		map.set ( this._map [ key ], key );
	}
	return map;
}

/**
 * Empty map.
 */
Map.prototype.empty = function () {
	
	for ( var key in this._map ) {
		delete this._map [ key ];
	}
}

/**
 * Dispose.
 * TODO: Invoke "dispose" on entries?
 */
Map.prototype.dispose = function () {
	
	for ( var key in this._map ) {
		this._map [ key ] = null;
	}
}

/**
 * @class
 * Global broadcast messages.
 * @see {EventBroadcaster}
 * 
 * Don't instantiate this class manually. Access through 
 * instance variable "BroadcastMessages" declared below.
 * This instance should be considered a singleton class.
 */
function _BroadcastMessages () {}

/*
 * Public fields.
 */
_BroadcastMessages.prototype = {
	
	/*
	 * Application status
	 */
	APPLICATION_STARTUP					: "application startup",
	APPLICATION_LOGIN					: "application login",
	APPLICATION_LOGOUT					: "application logout",
	APPLICATION_OPERATIONAL				: "application operational",
	APPLICATION_ONSHUTDOWN				: "application onshutdown",
	APPLICATION_SHUTDOWN				: "application shutdown",
	APPLICATION_ERROR					: "application error",
	APPLICATION_BLURRED					: "application blurred",
	APPLICATION_FOCUSED					: "application focused",
	APPLICATION_KICKSTART				: "application kickstart",

	/*
	 * Mouse events
	 */
	MOUSEEVENT_MOUSEDOWN 				: "mouseevent mousedown",
	MOUSEEVENT_MOUSEUP 					: "mouseevent mouseup",
	MOUSEEVENT_MOUSEMOVE 				: "mouseevent mousemove",
	
	/*
	 * WindowManager keys
	 */
	$WINKEY_LOADED						: "${windowkey} loaded",
	$WINKEY_UNLOADED					: "${windowkey} unloaded",
	$WINKEY_EVALUATED					: "${windowkey} evaluated",
	$WINKEY_RESIZED						: "${windowkey} resized",
	$WINKEY_HRESIZED					: "${windowkey} horizontally resized",
	$WINKEY_VRESIZED					: "${windowkey} vertically resized",
	
	/*
	 * Startup milestones
	 */
	LOADED_NAVIGATOR					: "navigator loaded",
	LOADED_MAINSTAGE					: "mainstage loaded",
	LOCALSTORE_INITIALIZED				: "localstore initialized",
	PERSISTANCE_INITIALIZED				: "persistance initialized",
	AUDIO_INITIALIZED					: "audio initialized",
	STAGE_INITIALIZED					: "stage initialized",
	
	/*
	 * Keys
	 */
	KEY_SHIFT_DOWN						: "shiftkeydown",
	KEY_SHIFT_UP						: "shiftkeyup",
	KEY_CONTROL_DOWN					: "controlkeydown",
	KEY_CONTROL_UP						: "controlkeyup",
	KEY_ARROW							: "arrowkey",
	KEY_ENTER							: "enterkeydown",
	KEY_ESCAPE							: "escapekeydown",
	KEY_SPACE							: "spacekeydown",
	KEY_TAB								: "tabkeydown",
	KEY_ALT								: "altkeydown",
	KEY_CONTROLTAB						: "controltabkeysdown",
	
	/*
	 * Dragndrop
	 */
	TYPEDRAG_START						: "typedrag start",
	TYPEDRAG_STOP						: "typedrag stop",
	TYPEDRAG_PAUSE						: "typedrag pause",
	
	/*
	 * Dock events
	 */
	DOCK_MAXIMIZED						: "dockmaximized",
	DOCK_MINIMIZED						: "dockminimized",
	DOCK_NORMALIZED						: "docknormalized",
	DOCKTABBINDING_SELECT				: "docktab select",
	
	/*
	 * Tree events
	 */
	SYSTEMTREEBINDING_REFRESH			: "systemtree refresh",
	SYSTEMTREEBINDING_REFRESHALL		: "systemtree refresh all",
	SYSTEMTREEBINDING_REFRESHING		: "systemtree refreshing",
	SYSTEMTREEBINDING_REFRESHED			: "systemtree refreshed",
	SYSTEMTREEBINDING_CUT  				: "systemtree cut",
	SYSTEMTREEBINDING_COPY				: "systemtree copy",
	SYSTEMTREEBINDING_PASTE 			: "systemtree paste",
	SYSTEMTREEBINDING_COLLAPSEALL		: "systemtree collapse all",
	SYSTEMTREENODEBINDING_FOCUS			: "systemtreenode focus",
	SYSTEMTREEBINDING_LOCKTOEDITOR		: "systemtreenode lock to editor",
	SYSTEMTREENODEBINDING_FORCE_OPEN	: "systemtreenode force open",
	SYSTEMTREENODEBINDING_FORCING_OPEN	: "systemtreenode forcing open",
	SYSTEMTREENODEBINDING_FORCED_OPEN	: "systemtreenode forced open",
	
	/*
	 * Start page
	 */
	START_COMPOSITE						: "startcomposite",
	STOP_COMPOSITE						: "stopcomposite",
	COMPOSITE_START						: "compositestart",
	COMPOSITE_STOP						: "compositestop",
	
	/*
	 * View events.
	 */
	VIEW_OPENING						: "view opening",
	VIEW_OPENED							: "view opened",
	VIEW_COMPLETED						: "view completed",
	CLOSE_VIEW							: "close view",
	CLOSE_VIEWS							: "close views", // close all FLOWHANDLE views!
	VIEW_CLOSED							: "view closed",
	
	/*
	 * Editor events
	 */
	TINYMCE_INITIALIZED					: "tinymce initialized",
	CODEPRESS_INITIALIZED				: "codepress initialized",
	VISUALEDITOR_FOCUSED				: "visualeditor focused", // TODO?
	VISUALEDITOR_BLURRED				: "visualditor blurred", // TODO?
	VISUALEDITOR_HACKED					: "visualeditor hacked",
	
	/*
	 * Misc events
	 */
	PERSPECTIVE_CHANGED					: "perspective changed",
	PERSPECTIVES_NONE					: "no perspectives",
	SYSTEMLOG_OPENED					: "systemlog opened",
	SYSTEMLOG_CLOSED					: "systemlog closed",
	SYSTEMACTION_INVOKE					: "systemaction invoke",
	SYSTEMACTION_INVOKED				: "systemaction invoked",
	SYSTEM_ACTIONPROFILE_PUBLISHED		: "system actionprofile published",
	NAVIGATOR_TREENODE_SELECTED			: "navigator treenode selected",
	MODAL_DIALOG_OPENED					: "modal dialog invoked",
	MODAL_DIALOG_CLOSED					: "modal dialog closed",
	COVERBINDING_MOUSEDOWN 				: "userinterfacecoverbinding mousedown",
	SERVER_OFFLINE						: "server offline",
	SERVER_ONLINE						: "server online",
	OFFLINE_FLASH_INITIALIZED			: "offline flash initialized",
	CLOSE_CURRENT						: "close current",
	CLOSE_ALL							: "close all",
	CLOSE_ALL_DONE						: "close all done",
	SAVE_CURRENT						: "save current",
	CURRENT_SAVED						: "current saved",
	SAVE_ALL							: "save all",
	SAVE_ALL_DONE						: "save all done",
	DOCKTAB_DIRTY						: "docktab dirty",
	DOCKTAB_CLEAN						: "docktab clean",
	BINDING_RELATE						: "binding relate",
	LOCALIZATION_CHANGED				: "localization changed",
	XHTML_MARKUP_ON						: "xhtml markup on",
	XHTML_MARKUP_OFF					: "xhtml markup off",
	XHTML_MARKUP_ACTIVATE				: "xhtml markup activate",
	XHTML_MARKUP_DEACTIVATE				: "xhtml markup deactivate",
	HIGHLIGHT_KEYWORDS					: "highlight keywords",
	BIND_TOKEN_TO_VIEW					: "bind entitytoken to view",
	STAGEDIALOG_OPENED					: "stage dialog opened",
	INVOKE_DEFAULT_ACTION				: "invoke default action",
	
	/*
	 * Server messages for EventBroadcaster.
	 */
	LANGUAGES_UPDATED					: "LocalesUpdated",
	FROMLANGUAGE_UPDATED				: "ForeignLocaleChanged", // tree builder language
	TOLANGUAGE_UPDATED					: "ActiveLocaleChanged", // page authoring language
	
	/*
	 * MessageQueue.
	 */
	MESSAGEQUEUE_REQUESTED				: "messagequeue requested", // when new actions are requested
	MESSAGEQUEUE_EVALUATED				: "messagequeue evaluated", // when all actions are done executing
	
	/*
	 * Mostly systemperformance
	 *
	MICROSOFTAJAXREQUEST				: "microsoft ajax request",
	POSTBACK_START						: "postback start",
	POSTBACK_STOP						: "postback stop",
	UPDATEPANEL_UPDATING				: "updatepanel updating",
	UPDATEPANELS_UPDATING				: "updatepanels updating",
	UPDATEPANELS_UPDATED				: "updatepanels updated",
	*/
	
	UPDATE_LANGUAGES					: "update languages"
}

/**
 * The instance that does it.
 * @type {_BroadcastMessages}
 */
var BroadcastMessages = new _BroadcastMessages ();

/**
 * @class
 */
function _EventBroadcaster () {}

_EventBroadcaster.prototype = {

	/**
	 * @type {HashMap<string><array<IBroadcastListener>>}
	 */
	_broadcasts : {},
	
	/**
	 * Add subscription.
	 * @param {string} message The subscription message.
	 * @param {object} subscriber The subscribing object. 
	 * Should implement method <code>handleBroadcast</code>.
	 */
	subscribe : function ( message, subscriber ) {
	
		if ( message != null ) {
			if ( !Interfaces.isImplemented ( IBroadcastListener, subscriber, true )) {
				throw ( "IBroadcastListener not implemented: " + message );
			} else if ( !this._broadcasts [ message ]) {
				this._broadcasts [ message ] = [ subscriber ];
			} else {
				this._broadcasts [ message ].push ( subscriber );
			}
		} else {
			SystemDebug.stack ( arguments );
			throw "Undefined broadcast: " + subscriber;
		}
	},
	
	/**
	 * Remove subscription.
	 * @param {string} message
	 * @param {object} unsubscriber
	 */
	unsubscribe : function ( message, unsubscriber ) {
	
		if ( message != null ) {
			if ( Interfaces.isImplemented ( IBroadcastListener, unsubscriber )) {
				var i = 0, subscriber, subscribers = this._broadcasts [ message ];
				if ( subscribers ) {
					while ( i < subscribers.length ) {
						subscriber = subscribers [ i ];
						if ( subscriber == unsubscriber ) {
							subscribers.splice ( i, 1 );
							break;
						}
						i++;
					}
				}
			}
		} else {
			throw "Undefined broadcast" + unsubscriber;
		}
	},
	
	/**
	 * Message has subscribers?
	 * @param {string} message
	 * @return {boolean}
	 */
	hasSubscribers : function ( message ) {
		
		var subscribers = this._broadcasts [ message ];
		return subscribers != null && subscribers.length > 0; 
	},
	
	/**
	 * Broadcast message to subscribers. 
	 * @param {string} message
	 * @param @optional {object} Passed as argument to subscribers
	 */
	broadcast : function ( message, optional ) {
		
		if ( message != null ) {
			var i = 0, subscribers = this._broadcasts [ message ];
			var list = [];
			if ( subscribers != null ) {
			
				/*
				 * This will store possible failed subscribers.
				 */
				var exceptions = new List();
			
				/*
				 * First collect in a temp list. This will 
				 * prevent sudden unsubscribers from modifying 
				 * the length of the list while we iterate.
				 */
				while ( i < subscribers.length ) {
					list.push ( subscribers [ i++ ]);
				}
				
				i = 0;
				while ( i < list.length ) {
					var subscriber = list [ i ];
					try {
						subscriber.handleBroadcast ( message, optional );
					}
					catch ( exception ) {		
						exceptions.add ( subscriber );
						var cry = "Exception in " + new String ( subscriber ) + 
							" on broadcast '" + message + "':" +  
							new String ( exception );
						SystemLogger.getLogger ( "EventBroadcaster" ).error ( cry );
						SystemDebug.stack ( arguments );
						if ( Application.isDeveloperMode ) {
							alert ( cry );
							throw ( exception );
						}
					}
					i++;
				}
				if ( exceptions.hasEntries ()) { // brutally exclude subscribers that raised exceptions
					exceptions.each ( function ( subscriber ) {
					 	EventBroadcaster.unsubscribe ( message, subscriber );
					});
				}
			}
		} else {
			SystemDebug.stack ( arguments );
			throw "Undefined broadcast";
		}
	}
}

/*
 * The instance that does it.
 */
var EventBroadcaster = new _EventBroadcaster ();

/**
 * @class
 * Don't instantiate this class manually. Access through 
 * instance variable "Constants" declared below. This 
 * instance should be considered a singleton class.
 */
function _Constants () {}

/*
 * Don't use these variables. They will 
 * be nulled by the end of this file.
 */
var temppath = document.location.pathname;
var temproot = temppath.substring ( 0, temppath.lastIndexOf ( "/" ));

/*
 * Public fields.
 */
_Constants.prototype = {
		
	COMPOSITE_HOME				: "http://www.composite.net",
	DUMMY_LINK					: "javascript:void(false);",
	
	APPROOT     				: temproot,
	TEMPLATESROOT     			: temproot + "/templates",
	SKINROOT     				: temproot + "/skins/system", // TODO: unhardcode this!
	TINYMCEROOT					: temproot + "/content/misc/editors/wysiwygeditor/tiny_mce", // TODO: deprecate this!
	TINYROOT					: temproot + "/content/misc/editors/visualeditor/tiny_mce",

	/*
	 * Web service desciptions.
	 */
	URL_WSDL_SETUPSERVICE		: temproot + "/services/Setup/SetupService.asmx?WSDL",
	URL_WSDL_CONFIGURATION		: temproot + "/services/Configuration/ConfigurationService.asmx?WSDL", 
	URL_WSDL_LOGINSERVICE		: temproot + "/services/Login/Login.asmx?WSDL",
	URL_WSDL_INSTALLSERVICE		: temproot + "/services/Installation/InstallationService.asmx?WSDL",
	URL_WSDL_MESSAGEQUEUE 		: temproot + "/services/ConsoleMessageQueue/ConsoleMessageQueueServices.asmx?WSDL",
	URL_WSDL_EDITORCONFIG 		: temproot + "/services/WysiwygEditor/ConfigurationServices.asmx?WSDL",
	URL_WSDL_FLOWCONTROLLER		: temproot + "/services/FlowController/FlowControllerServices.asmx?WSDL",
	URL_WSDL_STRINGSERVICE 		: temproot + "/services/StringResource/StringService.asmx?WSDL",
	URL_WSDL_TREESERVICE  		: temproot + "/services/Tree/TreeServices.asmx?WSDL",
	URL_WSDL_XHTMLTRANSFORM		: temproot + "/services/WysiwygEditor/XhtmlTransformations.asmx?WSDL",
	URL_WSDL_SECURITYSERVICE	: temproot + "/services/Tree/SecurityServices.asmx?WSDL",
	URL_WSDL_READYSERVICE		: temproot + "/services/Ready/ReadyService.asmx?WSDL",
	URL_WSDL_LOCALIZATION		: temproot + "/services/Localization/LocalizationService.asmx?WSDL",
	URL_WSDL_SOURCEVALIDATION	: temproot + "/services/SourceEditor/SourceValidationService.asmx?WSDL",
	URL_WSDL_MARKUPFORMAT		: temproot + "/services/SourceEditor/MarkupFormatService.asmx?WSDL",
	URL_WSDL_SEOSERVICE			: temproot + "/services/SearchEngineOptimizationKeyword/SearchEngineOptimizationKeyword.asmx?WSDL",
	URL_WSDL_PAGESERVICE		: temproot + "/services/Page/PageService.asmx?WSDL",
	URL_WSDL_DIFFSERVICE		: temproot + "/services/StringResource/DiffService.asmx?WSDL",
	
	/*
	 * Namespaces.
	 */ 
	NS_XHTML					: "http://www.w3.org/1999/xhtml",
	NS_UI						: "http://www.w3.org/1999/xhtml",
	NX_XUL						: "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
	NS_XBL						: "http://www.mozilla.org/xbl",
	NS_WSDL						: "http://schemas.xmlsoap.org/wsdl/",
	NS_SOAP						: "http://schemas.xmlsoap.org/wsdl/soap/",
	NS_ENVELOPE					: "http://schemas.xmlsoap.org/soap/envelope/",
	NS_ENCODING					: "http://schemas.xmlsoap.org/soap/encoding/",
	NS_SCHEMA					: "http://www.w3.org/2001/XMLSchema",
	NS_SCHEMA_INSTANCE			: "http://www.w3.org/1999/XMLSchema-instance",
	NS_DOMPARSEERROR			: "http://www.mozilla.org/newlayout/xml/parsererror.xml",
	NS_NS						: "http://www.w3.org/2000/xmlns/",
	NS_PERSISTANCE				: "http://www.composite.net/ns/localstore/persistance",
	NS_FUNCTION					: "http://www.composite.net/ns/function/1.0",
	
	/*
	 * Estimates the size of a scrollbar on various systems, platforms and settings.
	 * The estimate is considered correct within a factor of plus/minus 19 pixels.
	 */
	SCROLLBAR_DIMENSION_HARDCODED_VALUE : 19
}

/**
 * The instance that does it.
 * @type {_Constants}
 */
var Constants = new _Constants ();

/*
 * Cleaning up the global scope.
 */
temppath = null;
temproot = null;

/**
 * @class
 * Don't instantiate this class manually. Access through 
 * instance variable "Client" declared below. This 
 * instance should be considered a singleton class.
 */
function _Client () {
	
	var agent = navigator.userAgent.toLowerCase ();
	var platform = navigator.platform.toLowerCase ();
	
	var isMozilla = typeof document.createTreeWalker != "undefined";
	var isPrism = isMozilla && ( agent.indexOf ( "webrunner" ) >-1 || agent.indexOf ( "prism" ) >-1 );
	var hasTransitions = history.pushState != null;

	this.isMozilla = isMozilla;
	this.isWebKit = agent.indexOf ( "webkit" ) >-1;
	this.isExplorer = !isMozilla;
	this.isExplorer6 = this.isExplorer && ( agent.indexOf ( "msie 6.0" ) > -1 || agent.indexOf ( "msie 6.1" ) > -1 );
	this.isExplorer8 = this.isExplorer && window.XDomainRequest != null;
	this.isPrism = isPrism;
	this.isWindows = platform.indexOf ( "win" ) > -1;
	this.isVista = this.isWindows && agent.indexOf ( "windows nt 6" ) > -1;
	
	var version = this._getFlashVersion ();
	this.hasFlash = ( version && version >= 9 );
	this.hasTransitions = hasTransitions;

	return this;
}

/*
 * Public fields.
 */
_Client.prototype = {
	
	/** 
	 * Is Internet Explorer?
	 * @type {boolean} 
	 */
	isExplorer : false,
	
	/**
	 * Is Gecko derivate? 
	 * @type {boolean} 
	 */
	isMozilla : false,
	
	/** 
	 * True for Mozilla Prism.
	 * @type {boolean} 
	 */
	isPrism : false,
	
	/**
	 * Has Flash version 10 minimum? 
	 * @type {boolean} 
	 */
	hasFlash : false,
	
	/**
	 * Is Microsoft Windows? Macintosh and Linux 
	 * distros uniformely treated as not-Windows.
	 * @type {boolean}
	 */
	isWindows : false,
	
	/**
	 * Is Vista or Windows 7? As opposed to Windows XP.
	 * @type {boolean}
	 */
	isVista : false,
	
	/**
	 * Supports CSS transitions?
	 * @type {boolean}
	 */
	hasTransitions : false,

	/**
	 * Get Flash version.
	 * @return {int}
	 */
	_getFlashVersion : function () {
	
		var result = null;
		var maxversion = 10; // maximum version tested for
		
		// detect flash version
		try {
			if ( this.isMozilla == true ) {
				if ( typeof navigator.plugins [ "Shockwave Flash" ] != "undefined" ) {
					var plugin = navigator.plugins [ "Shockwave Flash" ];
					if ( plugin ) {
						var desc = plugin.description;
						if ( desc != null ) {
							result = desc.charAt ( desc.indexOf ( "." ) - 1 );
						}
					}
				}
			} else {
			    for ( var i = 2; i <= maxversion; i++ ) {
			        try {
						new ActiveXObject ( "ShockwaveFlash.ShockwaveFlash." + i );
						result = i;
					} catch ( exception ) {
						continue;
					}
				}
			}
		}
		catch ( exception ) {};
		return result;
	},
	
	/**
	 * Client qualified for the awesome Composite C1 experience?
	 * @return {boolean}
	 */
	qualifies : function () {
		
		var result = true;
		var isOldFox = false;
		if ( this.isMozilla && !this.isWebKit ) {
			isOldFox = ( document.documentElement.mozMatchesSelector == null );
		}
		if ( this.isWebKit || window.opera != null || isOldFox || this.isExplorer6 ) {
			result = false;
		}
		return result;
	}
}

/**
 * The instance that does it.
 * @type {_Client}
 */
var Client = new _Client ();

SystemLogger.TAB_SEQUENCE = "&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;";

SystemLogger.LEVEL_INFO		= "info";
SystemLogger.LEVEL_DEBUG	= "debug";
SystemLogger.LEVEL_ERROR	= "error";
SystemLogger.LEVEL_WARN		= "warn";
SystemLogger.LEVEL_FATAL	= "fatal";
SystemLogger.LEVEL_FINE		= "fine";

/**
 * @type {boolean}
 */
SystemLogger.isFlushing = false;

/**
 * @class
 * Don't use constructor! Please use syntax SystemLogger.getLogger ( "string" )
 * @param {string} indentifier
 */
function SystemLogger ( identifier ) {
	
	/**
	 * @private
	 * @type {string}
	 */
	this.identifier = identifier;
}

/**
 * Info.
 */
SystemLogger.prototype.info = function ( message ) {
	SystemLogger.log ( this.identifier, SystemLogger.LEVEL_INFO, message );
}

/**
 * Debug.
 */
SystemLogger.prototype.debug = function ( message ) {
	
	if ( message == "page" ) {
		alert ( arguments.caller.callee );
	}
	
	SystemLogger.log ( this.identifier, SystemLogger.LEVEL_DEBUG, message );
}

/**
 * Error.
 */
SystemLogger.prototype.error = function ( message ) {
	SystemLogger.log ( this.identifier, SystemLogger.LEVEL_ERROR, message );
}

/**
 * Message.
 */
SystemLogger.prototype.warn = function ( message ) {
	SystemLogger.log ( this.identifier, SystemLogger.LEVEL_WARN, message );
}

/**
 * Fatal.
 */
SystemLogger.prototype.fatal = function ( message ) {
	SystemLogger.log ( this.identifier, SystemLogger.LEVEL_FATAL, message );
}

/**
 * Fine.
 */
SystemLogger.prototype.fine = function ( message ) {
	SystemLogger.log ( this.identifier, SystemLogger.LEVEL_FINE, message );
}



// STATIC PROPERTIES AND METHODS ....................................

/*
 * @type {HashMap<string><SystemLogger>}
 */
SystemLogger.loggers = {};

/**
 * TODO: datatype this!
 * @type {List}
 */
SystemLogger.buffer = new List ();

/**
 * Collect logs in buffer only.
 * Invoked by {@link Application}
 */
SystemLogger.suspend = function () {
	
	SystemLogger.outputWindow	= null;
	SystemLogger.outputDocument = null;
	SystemLogger.outputElement 	= null;
	
	SystemLogger.log = SystemLogger.bufferLog;
}

/**
 * Flush buffer to screen.
 * Invoked by {@link Application}
 * @param {DOMDocumentView} win
 */
SystemLogger.unsuspend = function ( win ) {
	
	SystemLogger.outputWindow	= win;
	SystemLogger.outputDocument = win.document;
	SystemLogger.outputElement 	= win.document.body;
	
	SystemLogger.log = SystemLogger.outputLog;
	SystemLogger.flushBuffer ();
}

/**
 * @param {string} indentifier
 */
SystemLogger.getLogger = function ( identifier ) {

	var logger = SystemLogger.loggers [ identifier ];
	if ( !logger ) {
		logger = new SystemLogger ( identifier );
		SystemLogger.loggers [ identifier ] = logger;
	}
	return logger;
}

/**
 * During starup, all logs are collected in a buffer. The buffer 
 * can be flushed to screen by calling this method.
 */
SystemLogger.flushBuffer = function () {
	
	SystemLogger.buffer.reset ();
	SystemLogger.isFlushing = true;
	
	if ( SystemLogger.buffer.hasEntries ()) {
		while ( SystemLogger.buffer.hasNext ()) {
			var entry = SystemLogger.buffer.getNext ();
			this.log ( 
				entry.identifier,
				entry.level,
				entry.message
			);
		}
	}
	SystemLogger.isFlushing = false;
}

/**
 * Simply collect logs in a buffer.
 * @param {string} identifier
 * @param {string} level
 * @param {string} message
 */
SystemLogger.bufferLog = function ( identifier, level, message ) {
	
	message = String ( message );
	
	SystemLogger.buffer.add ({
		identifier	: identifier,
		level 		: level,
		message 	: message
	});
}

/**
 * Display logs on screen (while still collecting them in a buffer).
 * @param {string} level
 * @param {string} message
 */
SystemLogger.outputLog = function ( identifier, level, message ) {

	message = String ( message );
	 
	if ( !SystemLogger.isFlushing ) {
		SystemLogger.bufferLog ( 
			identifier, 
			level, 
			message 
		);
	}
	
	var win		= SystemLogger.outputWindow;
	var doc		= SystemLogger.outputDocument;
	var elm		= SystemLogger.outputElement;
	var div 	= doc.createElement ( "div" );
	var span 	= doc.createElement ( "span" );
	var pre 	= doc.createElement ( "pre" );
	
	/*
	 * Only mozilla seems to grok the intention 
	 * of tabs and newlines in PRE elements....
	 */
	if ( Client.isExplorer ) {
		message = message.replace ( /</g, "&lt;" );
		message = message.replace ( />/g, "&gt;" );
		message = message.replace ( /\n/g, "<br/>" );
		message = message.replace ( /\t/g, SystemLogger.TAB_SEQUENCE );
		pre.innerHTML = message;
	} else {
		pre.textContent = message;
	}
	
	div.className = level;
	span.innerHTML = identifier;
	div.appendChild ( span );
	div.appendChild ( pre );
	//if ( level == SystemLogger.LEVEL_FATAL ) { // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		elm.insertBefore ( div, elm.firstChild );
	//}
	
	win.scrollTo ( 0, 0 );
}

/** 
 * By default, collecting logs in buffer.
 * @param {string} level
 * @param {string} message
 */
SystemLogger.log = SystemLogger.bufferLog;

/**
 * Clear all log entries.
 */
SystemLogger.clear = function () {
	
	SystemLogger.buffer = new List ();
	var doc = SystemLogger.outputDocument;
	if ( doc ) {
		doc.body.innerHTML = "";
	}
}

/**
 * Factory method in order to emulate SystemLogger syntax.
 * @param {object} object
 */
SystemTimer.getTimer = function ( object ) {
	
	return new SystemTimer ( object.toString ());
}

/**
 * @class
 * Simple stopwatch utility. Note that timing in 
 * Javascript should never be considered 100% reliable.
 */
function SystemTimer ( id ) {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SystemTimer" );
	
	/**
	 * @type {string}
	 */
	this._id = id;
	
	/**
	 * @type {int}
	 */
	this._time = new Date ().getTime ();
}

/**
 * Reset timer.
 */
SystemTimer.prototype.reset = function () {
	
	this._time = new Date ().getTime ();
}

/**
 * Report time to system log.
 * @param {string} message
 */
SystemTimer.prototype.report = function ( message ) {
	
	this.logger.debug ( this._id +": " + this.getTime () + ( message ? ": " + message : "" ));
}

/**
 * Get time in milliseconds.
 * @return {int}
 */
SystemTimer.prototype.getTime = function () {
	
	return new Date ().getTime () - this._time;
}

/**
 * @class
 * Debug that system.
 */
function _SystemDebug () {}

_SystemDebug.prototype = {
	
	_logger : SystemLogger.getLogger ( "SystemDebug" ),
	_stacklength : parseInt ( 5 ),

	/**
	 * Print sort of a strack trace.
	 * @param {object} args
	 * @param @optional {int} length
	 * @return
	 */
	stack : function ( args, length ) {
		
		this._stackMozilla ( args, length );
		/*
		if ( Client.isMozilla == true ) {
			this._stackMozilla ( args, length );
		} else {
			this._logger.debug ( "TODO!" );
		}
		*/
	},

	/**
	 * Stack Mozilla.
	 * @param {object} args
	 * @param @optional {int} length
	 */
	_stackMozilla : function ( args, length ) {
		
		length = length ? length : this._stacklength;
		if ( Client.isMozilla && args.callee || args.caller ) {
			var caller = Client.isMozilla ? args.callee.caller : args.caller.callee;
			var stack = "";
			
			var i = 0;
			while ( caller != null && i++ < length ) {
				stack += "\n#" + i + "\n";
				stack += caller.toString ();
				caller = caller.caller;
				stack += "\n";
			}
			
			this._logger.error ( stack );
		} else {
			this._logger.error ( "(Error stack unreachable!)" );
		}
	}

}

/*
 * The instance that does it.
 * @type {_SystemDebug}
 */
var SystemDebug = new _SystemDebug;


/**
 * @class
 * Primitively checks an object instance for an interface implementation. 
 * TODO: build up some sort of status repport for debugging.
 */
function _Interfaces () {
	
	/**
	 * This logger could probably report a detailed result.
	 * @type {SystemLogger}
	 */
	var logger = SystemLogger.getLogger ( "Interfaces" );
	
	/**
	 * Is interface implemented by instance object?
	 * @param {object} interfais (not using reserved keyword here)
	 * @param {object} instance
	 * @param {object} isLogging
	 * @return {boolean}
	 */
	this.isImplemented = function ( interfais, instance, isLogging ) {
		
		var isImplemented = true;
		for ( var property in interfais ) {
			if ( typeof instance [ property ] == Types.UNDEFINED ) {
				isImplemented = false;
			} else if ( typeof interfais [ property ] != typeof instance [ property ]) {
				isImplemented = false;
			}
			if ( !isImplemented ) {
				break;
			}
		}
		if ( !isImplemented ) {
			if ( isLogging ) {
				logger.fine ( instance + " invalid. Interface check abandoned at: " + property );
			}
		}
		return isImplemented;
	}
}

var Interfaces = new _Interfaces;

/**
 * @class
 */
function _Types () {}

_Types.prototype = {
	
	/**
	 * @type {SystemLogger}
	 */
	_logger : SystemLogger.getLogger ( "Types" ),
	
	BOOLEAN 	: "boolean",
	STRING 	 	: "string",
	NUMBER 		: "number",
	FUNCTION 	: "function",
	UNDEFINED	: "undefined",
	
	/**
	 * Autocast string to an inferred type.
	 * To be used with caution and scepsis. 
	 * @param {string} string
	 * @return {object}
	 */
	castFromString : function ( string ) {
		
		var result = string;
		
		if ( parseInt ( result ).toString () == result ) {
			result = parseInt ( result );
		}
		else if ( parseFloat ( result ).toString () == result ) {
			result = parseFloat ( result );
		}
		else if ( result == "true" || result == "false" ) {
			result = eval ( result );
		} else {
			/*
			 * Note this trick! This way, we can minimize the amount 
			 * of code where we have to duplicate the decode stuff. 
			 * It always fails, because its not a URI, but it worx...
			 * UPDATE: IT DOESN'T WORK! IMAGE EDITOR CANNOT HANDLE ÆØÅ
			try {
				result = decodeURIComponent ( result );
			} catch ( exception ) {
				this._logger.error ( exception )
			}
			*/
		}
		
		return result;
	},
	
	/**
	 * Is it defined?
	 * @param {object} arg
	 * @return {boolean}
	 */
	isDefined : function ( arg ) {
		
		return typeof arg != Types.UNDEFINED;
	},
	
	/**
	 * Is it a function?
	 * @param {object} arg
	 * @return {boolean}
	 */
	isFunction : function ( arg ) {
		
		return typeof arg == Types.FUNCTION;
	}
}

/**
 * The instance that does it!
 * @type {_Types}
 */
var Types = new _Types ();

/**
 * Mimetypes.
 */
var MimeTypes = {
	
	JPG						: "image/jpeg",
	GIF						: "image/gif", 
	PNG						: "image/png",
	
	CSS						: "text/css",
	JAVASCRIPT				: "text/javascript",
	TEXT					: "text/plain",
	HTML					: "text/html",
	XHTML					: "applcication/xhtml+xml",
	
	FLASH 					: "application/x-shockwave-flash",
	QUICKTIME 				: "video/quicktime",
	SHOCKWAVE 				: "application/x-director",
	WINMEDIA 				: "application/x-mplayer2",
	
	COMPOSITEPAGES			: "application/x-composite-page",
	COMPOSITEFUNCTION 		: "application/x-composite-function"
}

/**
 * @class
 * Search tokens are used to filter the content of a {@link SystemTreeBinding}.
 */
window.SearchTokens = new function () {
	
	/*
	 * Tokens indexed by key. This list should be manually maintained 
	 * to match available search tokens provided by the mighty server. 
	 * This will make sure that we don't misspell these strings.
	 */
	var tokens = {
		
		// searching gif, jpeg and png files.
		"MediaFileElementProvider.WebImages" : null,
		// searching flash, quicktime, director and windows media files.
		"MediaFileElementProvider.EmbeddableMedia" : null,
		// searching functions that return XhtmlDocument (suitable for rendering) 
		"AllFunctionsElementProvider.XhtmlDocument": null,
		// searching functions that are sutable for Xslt function's function call section
		"AllFunctionsElementProvider.XsltFunctionCall": null
	}
	
	/**
	 * Get token by key.
	 * @param {string} key 
	 */
	this.getToken = function ( key ) {
		
		var result = null;
		if ( this.hasToken ( key )) {
			result = tokens [ key ];
		} else {
			throw "Unknown search token key: " + key;
		}
		return result;
	}
	
	/**
	 * Has token?
	 * @param {string} key
	 * @return {boolean}
	 */
	this.hasToken = function ( key ) {
		
		return typeof tokens [ key ] != Types.UNDEFINED;
	}
	
	/*
	 * Fetch tokens on login.
	 */
	EventBroadcaster.subscribe ( BroadcastMessages.APPLICATION_LOGIN, {
		handleBroadcast : function () {
			new List ( TreeService.GetSearchTokens ( true )).each ( 
				function ( token ) {
					if ( SearchTokens.hasToken ( token.Key )) {
						tokens [ token.Key ] = token.Value;
					} else {
						alert ( "SearchTokens need updating!" );
					}
				}
			);
		}
	});
}

/**
 * @class
 */
window.StringBundle = new function () {
	
	var logger = SystemLogger.getLogger ( "StringBundle" );
	
	/*
	 * Provider shorthand.
	 */
	this.UI = "Composite.Management";
	
	/*
	 * Mapping providers.
	 * @type {HashMap<string><HashMap<string><string>>}
	 */
	var providers = {};
	
	/**
	 * Populate provider via webservice.
	 * @param {string} providername
	 * @param {HashMap} provider
	 * @param {HashMap}
	 */
	function resolve ( providername, provider ) {
		
		var list = new List (
			StringService.GetLocalisation ( providername )
		);
		if ( list.hasEntries ()) {
			list.each (
				function ( entry ) {
					provider [ entry.Key ] = entry.Value;
				}
			);
		} else {
			throw "No strings from provider: " + providername;
		}
	}
	
	/**
	 * Get string!
	 * @param {string} providername
	 * @param {string} stringkey
	 * @return {string}
	 */
	this.getString = function ( providername, stringkey ) {
		
		var result = null;
		
		if ( window.StringService != null ) {
			try {
				if ( providername == "ui" ) {
					providername = StringBundle.UI;
				}
				if ( !providers [ providername ] ) {
					var provider = providers [ providername ] = {};
					resolve ( providername, provider );
				}
				if ( providers [ providername ]) {
					result = providers [ providername ][ stringkey ]
				}
				if ( !result ) {
					throw "No such string: " + stringkey;
				}
			} catch ( exception ) {
				var cry = "StringBundle exception in string " + providername + ":" + stringkey;
				logger.error ( cry );
				if ( Application.isDeveloperMode ) {
					alert ( cry );
				}
			}
		}
		return result;
	}
}

/**
 * Building unique keys.
 */
function _KeyMaster () {}

_KeyMaster.prototype = {
	
	_uniqueKeys : {},
		
	/**
	 * Build a unique key string for whoever may be interrested.
	 * @return {string}
	 */
	getUniqueKey : function () {
		var key = new String ( "key" + Math.random ().toString ().split ( "." )[ 1 ]);
		if ( this._uniqueKeys [ key ] != null ) {
			return this.getUniqueKey ();
		}
		this._uniqueKeys [ key ] = true;
		return key;
	},
	
	/**
	 * Is string generated by KeyMaster?
	 * @param {string} key
	 * @return {boolean}
	 */
	hasKey : function ( key ) {
		
		var result = false;
		if ( this._uniqueKeys [ key ]) {
			result = true;
		}
		return result;
	}
}

/**
 * The instance that does it.
 */
var KeyMaster = new _KeyMaster ();

/**
 * @class
 * Image provider.
 */
function _ImageProvider () {}

_ImageProvider.prototype = {

	/**
	 * @type {SystemLogger}
	 */
	_logger : SystemLogger.getLogger ( "ImageProvider" ),
		
	/**
	 * Service URL.
	 */
	SERVICE_URL : "services/Icon/GetIcon.ashx",
	
	/**
	 * Default icon provider.
	 */
	UI : "Composite.Icons",
	
	/**
	 * @param {object} object
	 */
	getImageURL : function ( object, size ) {
	
		var result = null;
		var url = Constants.APPROOT + "/" + this.SERVICE_URL + "?resourceName=${name}&resourceNamespace=${hash}&size=${size}";
		var hash = object.ResourceNamespace;
		var name = object.ResourceName;
		size = size ? size : "DEFAULT";
		
		if ( name != null && hash != null ) {
			result = url
				.replace ( "${name}", name )
				.replace ( "${hash}", hash )
				.replace ( "${size}", size );
			if ( size == "DEFAULT" ) {
				result = result.split ( "&size=DEFAULT" )[ 0 ];
			}
		} else {
			throw "Could not compute image URL.";
		}
		return result;
	}
}

/**
 * The instance that does it.
 */
var ImageProvider = new _ImageProvider ();

/**
 * @class
 * Resolving dollar dollar super syntax.
 */
function _Resolver () {}

_Resolver.prototype = {
	
	_logger : SystemLogger.getLogger ( "Resolver" ),
	
	/**
	 * Resolve that string.
	 * @param {string} string
	 * @return {string}
	 */
 	resolve : function ( string ) {
		
		if ( typeof string != Types.UNDEFINED ) {
			
			// could be interpretated as a number by Javascript.
			string = String ( string );
		
			// TODO: refactor these - introduce generalized prefix such as "shortcut:root" or something.
			string = string.replace ( "${root}", Constants.APPROOT );
			string = string.replace ( "${skin}", Constants.SKINROOT );
			string = string.replace ( "${tinymce}", Constants.TINYMCEROOT );
			string = string.replace ( "${tiny}", Constants.TINYROOT );
			
			// ${icon:Composite.Icons,fister-loeg-sovs(32)}
			
			if ( string.indexOf ( "${icon:" ) >-1 ) {
				string = this._resolveImage ( string );
			}
			else if ( string.indexOf ( "${string:" ) >-1 ) {
				string = this._resolveString ( string );
			}
		}
		return string;
	},
	
	/**
	 * Substitue string of type "loading {0} to {1} and {2}" with array entries.
	 * @param {string} string
	 * @param {array} vars
	 * @return {string}
	 */
	resolveVars : function ( string, vars ) {
		
		var i = 0;
		while ( i < vars.length ) {
			string = string.replace ( "{" + i + "}", vars [ i ]);
			i++;
		}
		return string;
	},
	
	/**
	 * Resolve string of syntax ${string:ProviderName:ResourceName} 
	 * where ProviderName is optional and will default.
	 * @param {string} string
	 * @return {string}
	 */
	_resolveString : function ( string ) {
		
		var result = null;
		var provider = null;
		var key = string.split ( "${string:" )[ 1 ].split ( "}" )[ 0 ];
		
		if ( key.indexOf ( ":" ) >-1 ) {
			provider = key.split ( ":" ) [ 0 ];
			key = key.split ( ":" ) [ 1 ];
		} else {
			provider = StringBundle.UI;
		}
		result = StringBundle.getString ( provider, key );
		if ( !result ) {
			result = "(?)";
		}
		return result;
	},
	
	/**
	 * Resolve image of syntax ${icon:ProviderName:ResourceName(size)}
	 * where ProviderName and size are optional and will default.
	 * Example: "${icon:previous(large)}"
	 * @param {string} string
	 * @return {string}
	 */
	_resolveImage : function ( string ) {
		
		var result = null;
		var provider = null;
		var resource = null;
		var size = null;
		
		resource = string.split ( "${icon:" )[ 1 ].split ( "}" )[ 0 ];
		
		if ( resource.indexOf ( ":" ) >-1 ) {
			provider = resource.split ( ":" ) [ 0 ];
			resource = resource.split ( ":" ) [ 1 ];
		} else {
			provider = ImageProvider.UI;
		}
		if ( resource.indexOf ( "(" ) >-1 ) {
			size = resource.split ( "(" ) [ 1 ].split ( ")" )[ 0 ];
			resource = resource.split ( "(" ) [ 0 ];
		}
		result = ImageProvider.getImageURL ({
			ResourceNamespace : provider,
			ResourceName : resource
		}, size );
		
		return result;
	}
}

/**
 * The instance that does it.
 */
var Resolver = new _Resolver ();

/**
 * @class
 * Download stuff.
 */
function _Download () {}

/**
 * Init download. The server must be rigged up to display a download dialog.
 * @param {string} url
 */
_Download.prototype.init = function ( url ) {
	
	var win = top.app.bindingMap.downloadwindow;
	win.setURL ( url );
}

/**
 * The instance that does it.
 */
var Download = new _Download ();

/**
 * @class
 * TODO: Dont use cookies! Define a functional Persistance instead.
 */
function _Cookies () {}
var Cookies = new _Cookies ();

_Cookies.prototype = {
	
	/**
	 * Create new cookie.
	 * @param {string} name
	 * @param {string} value
	 * @param {string} days
	 */
	createCookie : function ( name, value, days ) {
	
		var expires = "";
		if ( days ) {
			var date = new Date ();
			date.setTime ( date.getTime () + ( days * 24 * 60 * 60 * 1000 ));
			expires = "; expires=" + date.toGMTString ();
		}
		document.cookie = name + "=" + escape ( value ) + expires + "; path=/";
		return this.readCookie ( name );
	},
	
	/**
	 * Read existing cookie.
	 * @param {string} name
	 * @return {string}
	 */
	readCookie : function ( name ) {
	
		var result = null;
		var nameEQ = name + "=";
		var ca = document.cookie.split ( ";" );
		for( var i=0; i < ca.length; i++ ) {
			var c = ca [i];
			while ( c.charAt ( 0 )== " " ) c = c.substring ( 1, c.length );
			if ( c.indexOf ( nameEQ ) == 0 ) {
				result = unescape ( c.substring ( nameEQ.length, c.length ));
			}
		}
		return result;
	},
	
	/**
	 * No more cookie.
	 * @param {string} name
	 */
	eraseCookie : function ( name ) {
	
		this.createCookie ( name, "", -1 );
	}
}

/**
 * @class
 * This would control the statusbar near the bottom of the app window. 
 * Access this fellow through instance variable StatusBar declared below.
 */
function _StatusBar () {
	
	/**
	 * Time in milliseconds before 
	 * text gets faded out.
	 */
	this.AUTOCLEAR_TIMEOUT = 5 * 1000;
	
	/**
	 * Toolbar groups.
	 */
	this.GROUP_LANGUAGETOOLS = "languagetools";
	
	/**
	 * Handy when statusbar bindings are to be constructed from other windows.
	 * @type {HTMLDocument}
	 */
	this.document = null;
	
	/*
	 * Read current statusbar state.
	 */
	this.state = null;
	this.ERROR = "error";
	this.WARN = "warn";
	this.BUSY = "busy";
	this.READY = "ready";
	
	/*
	 * statusbar tool groups.
	 * @type {Map<string><ToolBarGroupBinding>}
	 */
	this._groups = new Map ();
	
	/*
	 * Privates.
	 */
	var logger = SystemLogger.getLogger ( "StatusBar" );
	var statusbar = null;
	
	var icon_error 		= "${icon:error}";
	var icon_warn 		= "${icon:warning}";
	var icon_busy 		= "${icon:loading}";
	var icon_ready 		= "${icon:message}";
	
	var message_error 	= null;
	var message_warn 	= null;
	var message_busy 	= null;
	var message_ready 	= null;
	
	/**
	 * Initialize.
	 * @param {StageStatusBarBinding} binding
	 */
	this.initialize = function ( binding ) {
		
		message_error 	= StringBundle.getString ( "ui", "Website.App.StatusBar.Error" );
		message_warn 	= StringBundle.getString ( "ui", "Website.App.StatusBar.Warn" );
		message_busy 	= StringBundle.getString ( "ui", "Website.App.StatusBar.Busy" );
		message_ready 	= StringBundle.getString ( "ui", "Website.App.StatusBar.Ready" );
		
		statusbar = binding;
		this.document = binding.bindingDocument;
	}
	
	// STATUSBAR MESSAGES .............................................................
	
	/**
	 * Show error. Clear manually!
	 * @param {string} message
	 * @param {array} vars
	 */
	this.error = function ( message, vars ) {
		
		this.state = StatusBar.ERROR;
		message = message ? message : message_error;
		show ( message, icon_error, vars, false );
	}
	
	/**
	 * Show warning. Clear manually!
	 * @param {string} message
	 * @param {array} vars
	 */
	this.warn = function ( message, vars ) {
		
		this.state = StatusBar.WARN;
		message = message ? message : message_warn;
		show ( message, icon_warn, vars, false );
	}
	
	/**
	 * Indicate busy. Clear manually!
	 * @param {string} message
	 * @param {array} vars
	 */
	this.busy = function ( message, vars ) {
		
		this.state = StatusBar.BUSY;
		message = message ? message : message_busy;
		show ( message, icon_busy, vars, false );
	}
	
	/**
	 * Indicate ready. This will clear itself automatically.
	 * @param {string} message
	 * @param {array} vars
	 */
	this.ready = function ( message, vars ) {
		
		this.state = StatusBar.READY;
		message = message ? message : message_ready;
		show ( message, icon_ready, vars, true );
	}
	
	/**
	 * Show custom message and icon.
	 * @param {string} message
	 * @param {string} icon
	 * @param {array} vars
	 * @param {boolean} isAutoClear
	 */
	this.report = function ( message, icon, vars, isAutoClear ) {
		
		this.state = null;
		show ( message, icon, vars, isAutoClear );
	}
	
	/**
	 * Clear message and icon.
	 */
	this.clear = function () {
		
		this.state = null;
		if ( statusbar ) {
			statusbar.clear ();
		}
	}
	
	/**
	 * Show message.
	 * @param {string} message
	 * @param {string} icon
	 * @param {array} vars
	 * @param {boolean} isAutoClear
	 */
	function show ( message, icon, vars, isAutoClear ) {
		
		if ( vars ) {
			message = Resolver.resolveVars ( message, vars );
		}
		if ( statusbar ) {
			statusbar.setLabel ( message );
			statusbar.setImage ( icon );
			if ( isAutoClear ) {
				statusbar.startFadeOut ( StatusBar.AUTOCLEAR_TIMEOUT );
			}
		} else {
			logger.error ( "Message not initialized for display: " + message );
		}
	}
	
	
	// STATUSBAR TOOLS ................................................................
	
	/** 
	 * @param {string} name
	 * @param {Binding} binding
	 */
	this.addToGroup = function ( name, binding ) {
		
		if ( !this._groups.has ( name )) {
			this._groups.set ( name, statusbar.addRight (
				ToolBarGroupBinding.newInstance ( this.document )
			));
		}
		this._groups.get ( name ).add ( binding );
	}
}

/*
 * The instance that does it.
 */
var StatusBar = new _StatusBar ();

/**
 * @class
 * This fellow handles localisation of the public
 * website (and not the admininstration module).
 */
function _Localization () {
	
	EventBroadcaster.subscribe ( BroadcastMessages.APPLICATION_LOGIN, this );
	EventBroadcaster.subscribe ( BroadcastMessages.LANGUAGES_UPDATED, this );
	EventBroadcaster.subscribe ( BroadcastMessages.FROMLANGUAGE_UPDATED, this );
}

_Localization.prototype = {
	
	/**
	 * Available languages. Each entry in the list has the following properties: 
	 * Name
     * IsoName
     * UrlMappingName
     * IsCurrent
     * SerializedActionToken         
	 * @type {List<object>}
	 */
	languages : null,
		
	/**
	 * The source language.
	 * @type {string}
	 */
	source : null,
	
	/**
	 * The target language.
	 * @type {string}
	 */
	target : null,
	
	/**
	 * @implements {IBroadcastListener}
	 * @param {string} broadcast
	 * @param {object} arg
	 */
	handleBroadcast : function ( broadcast, arg ) {
		
		/*
		 * Get list of languages.
		 */
		switch ( broadcast ) {
			case BroadcastMessages.APPLICATION_LOGIN :
			case BroadcastMessages.LANGUAGES_UPDATED :
				var languages = LocalizationService.GetActiveLocales ( true );
				if ( languages.length >= 1 ) {
					this.languages = new List ( languages );
				} else {
					this.languages = null;
				}
				EventBroadcaster.broadcast ( BroadcastMessages.UPDATE_LANGUAGES, this.languages );
				break;
		}
		
		/*
		 * Get current languages.
		 */
		switch ( broadcast ) {
			case BroadcastMessages.APPLICATION_LOGIN :
			case BroadcastMessages.FROMLANGUAGE_UPDATED :
				var locales = LocalizationService.GetLocales ( true );
				this.source = locales.ForeignLocaleName;
				this.target = locales.ActiveLocaleName;
				
				/*
				 * Who needs this? Delete?
				 */
				EventBroadcaster.broadcast ( BroadcastMessages.LOCALIZATION_CHANGED, {
					source : locales.ForeignLocaleName,
					target : locales.ActiveLocaleName
				});
				break;
		}
	}
}

/**
 * The instance that does it!
 * @type {_Localization}
 */
var Localization = new _Localization ();

function _Validator () {}

_Validator.prototype = {
		
	/**
	 * Validate.
	 * @param {String} string
	 * @param {String} key
	 * @param {boolean} isInformed
	 * @returns {boolean}
	 */
	validate : function ( string, key, isInformed ) {
	
		var result = true;
		var response = SourceValidationService.ValidateSource ( string, key );
		if ( response != "True" ) {
			if ( isInformed == true ) {
				this._dialog ( response );
			}
			result = false;
		}
		return result;
	},

	/**
	 * Validate by presenting a dialog in case of non-validating input.
	 * @param {String} string
	 * @param {String} key
	 * @param {boolean} isInformed
	 * @returns {boolean}
	 */
	validateInformed : function ( string, key ) {
		
		return this.validate ( string, key, true );
	},
	
	/**
	 * In case of non-validating source, present a clarifying dialog. 
	 * @param {String} string
	 */
	_dialog : function ( string ) {
		
		/*
		 * Timeout allows any previous method to returnvalue first.
		 */
		setTimeout ( function () {
			Dialog.error ( "Source Invalid", string );
		}, 0 );
	}
};

var Validator = new _Validator ();

/**
 * @class
 * Gateway for common DOM event management, emulating   
 * DOM2 EventListener interface for Internet Explorer
 */
function _DOMEvents () {}

_DOMEvents.prototype = {
	
	_logger : SystemLogger.getLogger ( "DOMEvents" ),
	
	/*
	 * In order to avoid spelling mistakes, please use these constants.
	 */
	MOUSEDOWN 		: "mousedown",
	MOUSEUP 		: "mouseup",
	MOUSEOVER 		: "mouseover",
	MOUSEOUT 		: "mouseout",
	MOUSEMOVE 		: "mousemove",
	CLICK 			: "click",
	DOUBLECLICK 	: "dblclick",
	KEYPRESS		: "keypress",
	KEYDOWN			: "keydown",
	KEYUP			: "keyup",
	CONTEXTMENU		: "contextmenu",
	SCROLL			: "scroll",
	LOAD			: "load",
	BEFOREUNLOAD	: "beforeunload",
	UNLOAD			: "unload",
	RESIZE 			: "resize",
	FOCUS			: "focus",
	BLUR			: "blur",
	SUBMIT			: "submit",
	CUT				: "cut",
	COPY			: "copy",
	PASTE			: "paste",
	DOM				: "DOMContentLoaded",
	
	/*
	 * Explorer specific events. Note that "mouseenter" and 
	 * "mouseleave" pseudosupport has been hacked into Mozilla.
	 */
	ACTIVATE		: "activate",
	DEACTIVATE		: "deactivate",
	MOUSEENTER 		: "mouseenter",
	MOUSELEAVE 		: "mouseleave",
	SELECTSTART		: "selectstart",
	FOCUSIN			: "focusin",
	FOCUSOUT		: "focusout",
	
	/*
	 * These are Explorer native, but can be emulated in Mozilla.
	 */
	BEFOREUPDATE	: "beforeupdate",
	AFTERUPDATE		: "afterupdate",
	ERRORUPDATE		: "errorupdate",
	
	/*
	 * Tracking event listeners attached.
	 */
	_count : 0,
	
	/**
	 * Add event Listener.
	 * @param {DOMElement} target
	 * @param {string} event
	 * @param {IEventListener} handler
	 * @param {boolean} isReverse Don't use this Mozilla-only flag!
	 */
	addEventListener : function ( target, event, handler, isReverse ) {
		
		this._count ++;
		
		this._eventListener ( 
			true, 
			target, 
			event, 
			handler, 
			isReverse 
		);
		
		/*
		 * Clearing eventlisteners on unload. This should 
		 * in theory minimize memory leaks (clearly not!).
		 */
		if ( target && typeof target.nodeType != Types.UNDEFINED ) {
			if ( target.nodeType == Node.ELEMENT_NODE ) {
				var win = DOMUtil.getParentWindow ( target );
				if ( win ) {
					var unleaker = {
						handleEvent : function () {
							DOMEvents.removeEventListener ( 
								target, 
								event, 
								handler, 
								isReverse 
							);
							DOMEvents.removeEventListener ( win, DOMEvents.UNLOAD, unleaker );
						}
					}
					DOMEvents.addEventListener ( win, DOMEvents.UNLOAD, unleaker );
				}	
			}
		}
	},
	
	/**
	 * Remove event listener.
	 * @param {DOMElement} target
	 * @param {string} event
	 * @param {IEventListener} handler
	 * @param {boolean} isReverse
	 */
	removeEventListener : function ( target, event, handler, isReverse ) {
		
		this._count --;
		
		this._eventListener ( 
			false, 
			target, 
			event, 
			handler, 
			isReverse
		);
	},
	
	/**
	 * @param {Event} e
	 * @return {DOMElement}
	 */
	getTarget : function ( e ) {
		
		return e ? ( e.target ? e.target : e.srcElement ) : null;
	},
	
	/**
	 * Stop event propagation.
	 * @param {Event} e
	 */
	stopPropagation : function ( e ) {
		
		try {
			if ( e.stopPropagation != null ) {
				e.stopPropagation ();
			} else {
				e.cancelBubble = true;
			}
		} catch ( exception ) {
			/*
			 * May happen in explorer if the event window has been unloaded.
			 */
			if ( Application.isDeveloperMode == true ) { 
				this._logger.error ( exception );
			}
		}
	},
	
	/**
	 * Prevent event default.
	 * @param {Event} e
	 */
	preventDefault : function ( e ) {
	
		try {
			if ( e.preventDefault ) {
				e.preventDefault ();
			} else {
				e.returnValue = false;
			}
		} catch ( exception ) {
			/*
			 * May happen in explorer if the event window has been unloaded.
			 */
			if ( Application.isDeveloperMode == true ) { 
				this._logger.error ( exception );
			}
		}
	},
	
	/**
	 * Was it a right click? Can never remember the "2" involved here...
	 * @param {MouseEvent} e
	 */
	isRightButton : function ( e ) {
		
		return e.button == 2 ? true : false;
	},
	
	/**
	 * @param {IEventListener} handler
	 */
	cleanupEventListeners : function ( handler ) {
		
		this._deleteWrappedHandler ( handler );
	},
	
	/**
	 * Not recommended ( mozilla only).
	 * @param {Event} e
	 */
	isCurrentTarget : function ( e ) {
		
		var result = false;
		if ( Client.isMozilla == true ) {
		 	result = e.target == e.currentTarget;
		}
		return true;
	},
	
	// PRIVATE FUNCTIONS ......................................................
	
	/**
	 * Is node child of parent? Used to emulate 
	 * IE native "mouseenter" and "mouseleave".
	 * TODO: Move to DOMUtil?
	 * @param {DOMElement} parent
	 * @param {DOMElement} child
	 * @return {boolean}
	 */
	_isChildOf : function ( parent, child ) {
		
		var result = true;
		if ( parent == child) {
			result = false;
		}
		if ( result == true ) {
			while ( child != null && child.nodeType != Node.DOCUMENT_NODE && child != parent ) {
				child = child.parentNode;
			}
			result = ( child == parent );
		}
		return result;
	},
	
	/**
	 * @param {boolean} isAdd
	 * @param {DOMElement} target
	 * @param {string} event
	 * @param {IEventListener} handler
	 * @param {function} caller
	 */
	_eventListener : function ( isAdd, target, event, handler, isReverse, caller ) {
		
		if ( Interfaces.isImplemented ( IEventListener, handler, true )) {
			if ( typeof event != Types.UNDEFINED ) {
				if ( Client.isExplorer == true ) {
					handler = this._getWrappedHandler ( target, event, handler, caller );
					target [ this._getAction ( isAdd )] ( "on" + event, handler );
				} else {
					switch ( event ) {
						/*
						 * Note that the "mouseenter" and "mouseleave" events are 
						 * registered in Mozilla as "mouseover" and "mouseout"  
						 * event though the IE native behavior is emulated. This 
						 * implies that you have to listen for both "mouseover" 
						 * and "mouseenter" event event though only the latter was added!
						 */
						case DOMEvents.MOUSEENTER :
						case DOMEvents.MOUSELEAVE :
							event = event == DOMEvents.MOUSEENTER ? DOMEvents.MOUSEOVER : DOMEvents.MOUSEOUT;
							target [ this._getAction ( isAdd )] ( event, {
								handleEvent : function ( e ) {
									var rel = e.relatedTarget;
									if ( e.currentTarget == rel || DOMEvents._isChildOf ( e.currentTarget, rel )) {}
									else {
										handler.handleEvent ( e );
									}
								}
							}, isReverse ? true : false );
							break;
						default :
							target [ this._getAction ( isAdd )] ( event, handler, isReverse ? true : false );
							break;
					}
				}
			} else {
				throw "No such event allowed!";
			}
		}
	},
	
	/**
	 * Get that action.
	 * @param {boolean} isAdd
	 * @return {string}
	 */
	_getAction : function ( isAdd ) {
		
		var result = null;
		switch ( isAdd ) {
			case true :
				result = Client.isMozilla == true ? "addEventListener" : "attachEvent";
				break;
			case false :
				result = Client.isMozilla == true ? "removeEventListener" : "detachEvent";
				break;
		}
		return result;
	},
	
	// EXPLORER SPECIFIC ...............................................
	
	/**
	 * Explorer expects functions, not objects, as event handlers. 
	 * This fellow will return a function which in turn invokes the 
	 * designated method <code>handleEvent</code> on the object. 
	 * The error handling is especially elaborate around here.
	 * @param {DOMElement} target
	 * @param {string} event
	 * @param {IEventListener} handler
	 * @param {function} caller
	 * @return {function}
	 */
	_getWrappedHandler : function ( target, event, handler, caller ) {
		
		var result = null;
		try {
			if ( !handler._domEventHandlers ) {
				handler._domEventHandlers = {};
			}
			if ( !handler._domEventHandlers [ target ]) {
				handler._domEventHandlers [ target ] = {};
			}
			if ( !handler._domEventHandlers [ target ][ event ]) {
				var win = target.nodeType ? DOMUtil.getParentWindow ( target ) : target;
				if ( win ) {
					handler._domEventHandlers [ target ][ event ] = function () {
						if ( win.event && handler ) {
							handler.handleEvent ( win.event );
						}
					}
				}
			}
			result = handler._domEventHandlers [ target ][ event ];
		} catch ( exception ) {
			this._report ( target, event, handler, caller );
		}
		
		return result;
	},
	
	_deleteWrappedHandler : function ( handler ) {
		
		for ( var target in handler._domEventHandlers ) {
			if ( target ) {
				for ( var event in handler._domEventHandlers [ target ]) {
					if ( event ) {
						delete handler._domEventHandlers [ target ][ event ];
					}
				}
			}
			delete handler._domEventHandlers [ target ];
		}
	},

	/**
	 * Patching Explorers miserable error repporting.
	 * @param {DOMElement} target
	 * @param {string} event
	 * @param {IEventListener} handler
	 * @param {function} caller
	 */	
	_report : function ( target, event, handler, caller ) {
		
		alert ( 
			"DOMEvents.getWrappedHandler malfunction.\n\n" +
			"\ttarget: " + ( target ? target.nodeName : target ) + "\n" +
			"\tevent: " + event + "\n" +
			"\thandler: " + handler + "\n\n" +
			"Offending invoker: " + ( 
				caller.callee ? caller.callee.toString () : caller.constructor 
			)
		);
	}
}

/**
 * The instance that does it.
 * @type {_DOMEvents}
 */
var DOMEvents = new _DOMEvents ();

/**
 * @class
 * DOMSerialzier.
 */
function _DOMSerializer () {}

_DOMSerializer.prototype = {
	
	_serializer : ( Client.isMozilla ? new XMLSerializer () : null ),

	/**
	 * @param {DOMNode} node This should be an element or a document node.
	 * @param {boolean} isPrettyPrint Works in Mozilla only!
	 * @return {string}
	 */
	serialize : function ( node, isPrettyPrint ) {
		
		var result = null;
		var element = node;
		
		if ( node.nodeType == Node.DOCUMENT_NODE ) {
			element = node.documentElement;
		}
		if ( Client.isMozilla == true ) {
			if ( isPrettyPrint == true ) {
				element = element.cloneNode ( true );
				element = DOMFormatter.format ( element, DOMFormatter.INDENTED_TYPE_RESULT );
			}
			result = this._serializer.serializeToString ( element );
		} else {
			result = element.xml;
		}
		return result;
	}
}

/**
 * The instance that does it.
 * @type {_DOMSerializer}
 */
var DOMSerializer = new _DOMSerializer ();

/** 
 * @class
 * DOMFormatter. Only to be used for debugging purposes - works only in Mozilla.
 */
window.DOMFormatter = new function () {

	var TAB = "\t";
	var NEW = "\n";
	var WHITESPACE = new RegExp ( /[^\t\n\r ]/ );
	this.ignoreCDATASections = false;

	/**
	 * Nodetree indenter.
	 * @param {DOMElement} oElement
	 * @return {DOMElement} oElement indented
	 * @ignore
	 */
	function indent ( oElement ) {
	
		var doc = oElement.ownerDocument;
	
		var doindent = function ( node, iTabs ) {
			if ( node.hasChildNodes () && node.firstChild.nodeType != Node.TEXT_NODE ) {
				var sTabs = "", i = 0; 
				while ( i++ < iTabs ) {
					sTabs += TAB;
				}
				var nextnode = node.firstChild;
				while ( nextnode ) {
					switch ( nextnode.nodeType ) {
						case Node.ELEMENT_NODE :
							if ( nextnode == node.lastChild ) {
								node.appendChild ( doc.createTextNode ( NEW + sTabs ));
							}
							node.insertBefore ( doc.createTextNode ( NEW + sTabs + TAB ), nextnode );
							doindent ( nextnode, iTabs + 1 );
							break;
						case Node.COMMENT_NODE :
						case Node.PROCESSING_INSTRUCTION_NODE :
						case Node.CDATA_SECTION_NODE : 
							node.insertBefore ( doc.createTextNode ( NEW + sTabs + TAB ), nextnode );
							break;
					}
					if ( nextnode.nodeType ==  Node.CDATA_SECTION_NODE ) {
						if ( !this.ignoreCDATASections ) {
							formatCDATASection ( nextnode, sTabs + TAB );
						}
					}
					nextnode = nextnode.nextSibling;
				}
			}
		}
		doindent ( oElement, 0 );
	}
	
	/**
	 * Whitespace stripper.
	 * @param {DOMElement} oElement
	 * @return {DOMElement} oElement stripped
	 * @ignore
	 *
	 * TODO: check status on normalize method 
	 * TODO: check isElementContentWhitespace
	 * TODO: handle intext carriage returns
	 */
	function strip ( oElement ) {

		var aFilter = [];
		var oFilter = {
			acceptNode : function ( oElement ) {
				return ( !WHITESPACE.test ( oElement.nodeValue )) ? 
				NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
			}
		}
		var oWalker = oElement.ownerDocument.createTreeWalker ( 
			oElement, 
			NodeFilter.SHOW_TEXT, 
			oFilter, 
			true 
		);
		while ( oWalker.nextNode ()) aFilter.push ( oWalker.currentNode );
		var i = 0, oNode;
		while (( oNode = aFilter [ i++ ]) != null ) {
			oNode.parentNode.removeChild ( oNode );
		}
	}
	
	/**
	 * Format CDATA section text. Depending on the content scenario, this can be 
	 * controversial. For most common use (scripting language embedding) it will work 
	 * out fine. User can disable the feature by setting property ignoreCDATASections.
	 * @param {DOMCDATASectionNode} node
	 * @param {string} indent
	 * @ignore
	 *
	 * TODO: too many assumptions in routine?
	 * TODO: leaves a trailing empty line
	 * TODO: qa this routine
	 */
	function formatCDATASection ( node, indent ) {
	
		if ( node.textContent.indexOf ( NEW ) >-1 ) {
		
			var split = node.textContent.split ( NEW );
			var result = "", line, level = 0, isFirst = true;
			
			while (( line = split.shift ()) != null ) {
				
				// first line indentation level is now base reference level
				if ( level == 0 && line.charAt ( 0 ) == TAB ) {
					while ( line.charAt ( level++ ) == TAB ) {}
				}
				line = line.substring ( level, line.length );
				if ( split.length > 0 ) {
					result += indent + TAB + line;
					result += isFirst ? "" : "\n";
				}
				else {
					result += indent + line;
					indent = indent.slice ( 1, indent.length );
					node.parentNode.appendChild ( doc.createTextNode ( NEW + indent ));
				}
				isFirst = false;
			}
			node.textContent = result;
		}
	}
	
	/**
	 * Format that element.
	 * @param {DOMElement} oElement
	 * @param {int} iType Optional, stripped or indented (default)
	 * @return {DOMElement} oElement
	 */
	this.format = function ( oElement, iType ) {
		
		var STRIPPED_TYPE_RESULT = 1;
		
		if ( document.createTreeWalker ) {
			try {
				strip ( oElement );
				if ( iType != STRIPPED_TYPE_RESULT ) {
					indent ( oElement );
				}
			}
			catch ( exception ) {
				throw new Error ( exception );
			}
		}
		return ( oElement );
	}
}

DOMFormatter.INDENTED_TYPE_RESULT = 0;
DOMFormatter.STRIPPED_TYPE_RESULT = 1;

/**
 * Accessed through instance variable "DOMUtil" defined way below.
 */
function _DOMUtil () {}
_DOMUtil.prototype = {
		
	_logger	: SystemLogger.getLogger ( "DOMUtil" ),
	
	MSXML_MAXVERSION	: 6,
	MSXML_MINVERSION 	: 1,
	MSXML_HTTPREQUEST	: "MSXML2.XMLHTTP.{$version}.0",
	MSXML_DOMDOCUMENT	: "MSXML2.DOMDocument.{$version}.0",
	MSXML_FREETHREADED	: "MSXML2.FreeThreadedDOMDocument.{$version}.0",
	MSXML_XSLTEMPLATE	: "MSXML2.XSLTemplate.{$version}.0",
	
	/**
	 * You've been ActiveX'ed.
	 * @param {string} signature
	 */
	getMSComponent : function ( signature ) {
	
		var sig, result = null, version = this.MSXML_MAXVERSION;
		while ( !result && version >= this.MSXML_MINVERSION ) {
			try {
				sig = signature.replace ( "{$version}", version );
				result = new ActiveXObject ( sig );
			} catch ( exception ) {}
			version--;
		}
		return result;
	},
	
	/**
	 * Builds a XmlHttpRequest.
	 * @return {XMLHTTPRequest}
	 */
	getXMLHTTPRequest : function () {
	
		var result = null;
		if ( Client.isExplorer ) {
			result = this.getMSComponent ( this.MSXML_HTTPREQUEST );
		} else {
			result = new XMLHttpRequest ();
		}
		return result;
	},
	
	/**
	 * Builds a DOM document.
	 * @return {DOMDocument}
	 * @param {boolean} isFreeThreaded
	 */
	getDOMDocument : function ( isFreeThreaded ) {
	
		var result = null;
		if ( Client.isExplorer ) {
			result = this.getMSComponent ( isFreeThreaded ? this.MSXML_FREETHREADED : this.MSXML_DOMDOCUMENT );
		} else {
			/*
			 * There is an encoding fokup in Firefox 3 when using the command  
			 * document.implementation.createDocument ( "", "", null ).  
			 * See bug 431701 (claimed fixed for FF 3.0.4, but that's a lie).
			 */
			var doc = XMLParser.parse ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?><ROOT/>" );
			doc.removeChild ( doc.documentElement );
			result = doc;
		}
		return result;
	},
	
	/**
	 * @return {MSXMLXSLTemplate}
	 */
	getMSXMLXSLTemplate : function () {
		
		var result = null;
		if ( Client.isExplorer ) {
			result = this.getMSComponent ( this.MSXML_XSLTEMPLATE );
		}
		return result;
	},
	
	/**
	 * Get the localname of a DOM element.
	 * @param {DOMElement} element
	 * @return {string}
	 */
	getLocalName : function ( element ) {
	
		var result = null;
		if ( element.localName ) {
			result = element.localName;
		} else if ( element.baseName ) {
			result = element.baseName;
		} else {
			result = element.nodeName.toLowerCase (); // HTMLElement in explorer!
		}
		return result;
	},
	
	/**
	 * Get computed style.
	 * @param {DOMElement} element
	 * @param {string} styleprop
	 */
	getComputedStyle : function ( element, styleprop ) {
	
		var result = null;
		if ( Client.isExplorer ) {
			if ( element.currentStyle != null ) {
				result = element.currentStyle [ styleprop ];
			} else {
				this._logger.error ( "Could not compute style for element " + element.nodeName );
				SystemDebug.stack ( arguments );
			}
		} else {
			result = element.ownerDocument.defaultView
				.getComputedStyle ( element, null ).getPropertyValue ( styleprop );
		}
		return result;
	},
	
	/**
	 * Get max z-index.
	 * @param {DOMDocument} doc
	 */
	getMaxIndex : function ( doc ) {
	
		var max = 0, elements = new List ( doc.getElementsByTagName ( "*" ));
		elements.each ( function ( element ) {
			var index = CSSComputer.getZIndex ( element );
			if ( index > max ) {
				max = index;
			}
		});
		return max;
	},
	
	/**
	 * Get the ordinal position of a DOM element within it's container (skipping textnodes). 
	 * @param {DOMElement} element
	 * @param {boolean} isSimilar If set to true, count only elements of equal nodeName.
	 * @return {int}
	 */
	getOrdinalPosition : function ( element, isSimilar ) {
		
		var result = null;
		var position = -1;
		var localName = this.getLocalName ( element );
		var children = new List ( element.parentNode.childNodes );
		
		while ( children.hasNext ()) {
			var child = children.getNext ();
			if ( child.nodeType == Node.ELEMENT_NODE ) {
				if ( !isSimilar || this.getLocalName ( child ) == localName ) {
					position ++;
					if ( child == element || ( child.id != "" && child.id == element.id )) { // spell it out for ie!
						result = position;
						break;
					}
				}
			}
		}
		return result;
	},
	
	/**
	 * @param {DOMElement} element
	 * @param {boolean} isSimilar If set to true, count only elements of equal nodeName.
	 * @return {boolean}
	 */
	isFirstElement : function ( element, isSimilar ) {
	
		return ( this.getOrdinalPosition ( element, isSimilar ) == 0 );
	},
	
	/**
	 * @param {DOMElement} element
	 * @param {boolean} isSimilar If set to true, count only elements of equal nodeName.
	 * @return {boolean}
	 */
	isLastElement : function ( element, isSimilar ) {
	
		var elements = element.parentNode.getElementsByTagName (
			isSimilar ? this.getLocalName ( element ) : "*" 
		);
		return ( this.getOrdinalPosition ( element ) == elements.length );
	},
	
	/**
	 * Get the window object associated to a given node. 
	 * @param {DOMNode} node
	 * @return {window}
	 */
	getParentWindow : function ( node ) {
		
		var doc = node.nodeType == Node.DOCUMENT_NODE ? node : node.ownerDocument;
		return doc.defaultView ? doc.defaultView : doc.parentWindow;
	},
	
	/**
	 * Get the text content of a node.
	 * @param {DOMNode} node
	 * @return {string}
	 */
	getTextContent : function ( node ) {
	
		var result = null;
		if ( node.textContent ) {
			result = node.textContent;
		} else if ( node.text ) {
			result = node.text;
		} else {
			result = node.innerText;
		}	
		return result;
	},
	
	/**
	 * Set the text content of a node.
	 * @param {DOMNode} node
	 * @param {string} text
	 */
	setTextContent : function ( node, text ) {
		
		text = String ( text );
		if ( node.textContent ) {
			node.textContent = text;
		} else if ( node.text ) {
			node.text = text;
		} else {
			node.innerText = text;
		}
	},
	
	/**
	 * Get ancestor by localname (nodename with no namespace prefix).
	 * @param {string} nodeName
	 * @param {DOMNode} node
	 * @param {boolean} isTraverse If true, cross iframe boundaries
	 * @return {DOMElement}
	 */
	getAncestorByLocalName : function ( nodeName, node, isTraverse ) {
		
		var result = null;
		while ( result == null ) {
			node = node.parentNode;
			if ( node.nodeType == Node.DOCUMENT_NODE ) {
				if ( isTraverse == true ) {
					var win = this.getParentWindow ( node );
					node = win.frameElement;
				} else {
					break;
				}
			}
			if ( this.getLocalName ( node ) == nodeName ) {
				result = node;
			}
		}
		return result;
	},
	
	/**
	 * Does element contain a node?
	 * @param {DOMElement} element
	 * @param {DOMNode} node
	 */
	contains : function ( element, node ) {
		
		return element.contains ? 
			element != node && element.contains ( node ) : 
			!!( element.compareDocumentPosition ( node ) & 16 );
	},
	
	/**
	 * CreateElementNS. For HTML documents, this is simply simulated in explorer.
	 * @param {URI} namespaceURI
	 * @param {string} nodeName
	 * @parm {DOMDocument} ownerDocument
	 * @return {DOMElement}
	 */
	createElementNS : function ( namespaceURI, nodeName, ownerDocument ) {
		
		var result = null;
		if ( ownerDocument == null ) { // always forget this argument...
			alert ( "DOMUtil#createElementNS : Missing argument (DOMDocument)" );
		} else {
			if ( Client.isMozilla ) {
				result = ownerDocument.createElementNS ( namespaceURI, nodeName );
			} else {
				if ( ownerDocument.xml != null ) {
					result = ownerDocument.createNode ( 
						Node.ELEMENT_NODE, nodeName, namespaceURI 
					);
				} else {
					result = ownerDocument.createElement ( nodeName );
				}
			}
		}
		return result;
	},
	
	/**
	 * Get elements by tagname in the XHTML namespace. DOM3 style 
	 * qualified namespaces seems to be required for Gecko 1.9 alpha.
	 * TODO: DEPRECATE THIS UNIVERSALLY AT SOME POINT! - MARKING @DEPRECATED FOR NOW!
	 * @deprecated
	 * @param {DOMNode} node
	 * @param {string} tagname
	 * @return {NodeList} this would be an simple array in explorer...
	 */
	getElementsByTagName : function ( node, tagname ) {
		
		var result = null;
		if ( Client.isMozilla ) {
			result = node.getElementsByTagNameNS ( Constants.NS_XHTML, tagname );
		} else {
			result = node.getElementsByTagName ( tagname );
		}
		return result;
	},
	
	/**
	 * Get next element sibling.
	 * @param {DOMElement} element
	 * @return {DOMElement}
	 */
	getNextElementSibling : function ( element ) {
		
		return Client.isExplorer ? element.nextSibling : element.nextElementSibling;
	},
	
	/**
	 * Get previous element sibling.
	 * @param {DOMElement} element
	 * @return {DOMElement}
	 */
	getPreviousElementSibling : function ( element ) {
		
		return Client.isExplorer ? element.previousSibling : element.previousElementSibling;
	},
	
	/**
	 * Clone node. This seems to terminate encoding in Firefox 3.0.4, 
	 * so we slip it through a serializer and suck it back up with a parser.   
	 * The bug is verified fixed in Firefox 3.1 - no known bug number!
	 * TODO: DEPRECATE THIS UNIVERSALLY - MARKING @DEPRECATED FOR NOW
	 * @deprecated
	 * @param {DOMNode} node
	 */
	cloneNode : function ( node ) {
		
		var result = null;
		if ( Client.isMozilla == true ) {
			result = XMLParser.parse ( DOMSerializer.serialize ( node ));
		} else {
			result = node.cloneNode ( true );
		}
		return result;
	},
	
	/**
	 * Find position of element in local coordinate space 
	 * (relative to the nearest positioned ancestor).
	 * @param {DOMElement} element
	 * @return {Point}
	 */
	getLocalPosition : function ( element ) {
		
		var result = new Point ( element.offsetLeft, element.offsetTop );
		
		if ( Client.isExplorer && element.parentNode && element.parentNode.currentStyle ) {
			if ( element.parentNode.currentStyle.position == "static" ) {
				var point = this.getLocalPosition ( element.parentNode );
				result.x += point.x;
				result.y += point.y;
			}
		}
		return result;
	},
	
	/**
	 * Find position of element relative to the elements viewport. 
	 * @param {DOMElement} element
	 * @return {Point}
	 */
	getGlobalPosition : function ( element ) {
	
		return this._getPosition ( element, false );
	},
	
	/**
	 * Find position of element relative to the top viewport. 
	 * @param {DOMElement} element
	 * @return {Point}
	 */
	getUniversalPosition : function ( element ) {
	
		return this._getPosition ( element, true );
	},
	
	/**
	 * Find position. 
	 * @param {DOMElement} element
	 * @param {boolean} isUniversal
	 * @return {Point}
	 * @ignore
	 */
	_getPosition : function ( element, isUniversal ) {
		
		var result = null;
		
		/*
		 * Explorer and Firefox 3.0
		 */
		if ( typeof element.getBoundingClientRect != Types.UNDEFINED ) {
			
			var rect = element.getBoundingClientRect ();
			result = {
				x : rect.left,
			 	y : rect.top
			}
			if ( Client.isMozilla ) { 
				// why would mozilla steal this method and implement it differently?
				result.x -= element.scrollLeft;
				result.y -= element.scrollTop;
			}
		
		/*
		 * Firefox 2.0
		 */
		} else {
			result = {
				x : element.offsetLeft - element.scrollLeft,
				y : element.offsetTop - element.scrollTop
			}
			while ( element.offsetParent ) {
				element = element.offsetParent;
				result.x += ( element.offsetLeft - element.scrollLeft );
				result.y += ( element.offsetTop - element.scrollTop );
			}
			
		}
		if ( isUniversal ) {
			var win = DOMUtil.getParentWindow ( element );
			if ( win ) {
				var frame = win.frameElement;
				if ( frame ) {
					var add = DOMUtil.getUniversalPosition ( frame );
					result.x += add.x;
					result.y += add.y;
				}
			}
		}
		return new Point ( result.x, result.y );
	},
	
	/**
	 * @param {MouseEvent} e
	 */
	getGlobalMousePosition : function ( e ) {
	
		return this._getMousePosition ( e, false );
	},
	
	/**
	 * @param {MouseEvent} e
	 */
	getUniversalMousePosition : function ( e ) {
	
		return this._getMousePosition ( e, true );
	},
	
	/**
	 * @param {MouseEvent} e
	 * @param {boolean} isUniversal
	 * @ignore
	 */
	_getMousePosition : function ( e, isUniversal ) {
		
		var element = DOMEvents.getTarget ( e );
		
		var result = {
			x : e.pageX ? e.pageX : e.clientX,
			y : e.pageY ? e.pageY : e.clientY
		}
		
		/*
		 * Vaguely hardcoded to compensate only for the BODY scroll!
		 */
		if ( Client.isMozilla ) {
			var doc = element.ownerDocument;
			var win = this.getParentWindow ( doc );
			result.x -= win.pageXOffset;
			result.y -= win.pageYOffset;
		}
		
		if ( isUniversal ) {
			var frame = this.getParentWindow ( element ).frameElement;
			if ( frame ) {
				var add = this.getUniversalPosition ( frame );
				result.x += add.x;
				result.y += add.y;
			}
		}
		return result;
	}
}

/**
 * The instance that does it.
 * @type {_DOMUtil}
 */
var DOMUtil = new _DOMUtil ();

/**
 * @class
 */
function _XMLParser () {}

_XMLParser.prototype = {
	
	_logger : SystemLogger.getLogger ( "XMLParser" ),
	_domParser : ( window.DOMParser != null ? new DOMParser () : null ),
	
	/**
	 * @param {string} xml
	 * @param @optional {boolean} If true, ignore all parse errors.
	 * @return {DOMDocument}
	 */
	parse : function ( xml, isIgnore ) {
	
		var doc = null;
		
		if ( xml != null ) {
			if ( this._domParser != null ) {
				try {
				doc = this._domParser.parseFromString ( xml, "text/xml" );
				} catch ( e ) {
					alert ( xml )
				}
				if ( doc.documentElement.namespaceURI == Constants.NS_DOMPARSEERROR ) {
					if ( !isIgnore ) {
						this._logger.error ( DOMSerializer.serialize ( doc.documentElement, true ));
		        		if ( Application.isDeveloperMode ) {
							alert ( "XMLParser failed: \n\n" + DOMSerializer.serialize ( doc.documentElement, true ));
						}
					}
	        		doc = null;
	        	}
			} else {
				doc = DOMUtil.getDOMDocument ();
				doc.loadXML ( xml );
				if ( doc.parseError.errorCode != 0 ) {
					if ( !isIgnore ) {
						this._logger.error ( "XMLParser failed!" );
						if ( Application.isDeveloperMode ) {
							alert ( "XMLParser failed!" );
						}
					}
					doc = null;
				}
			}
		} else {
			throw "XMLParser: No XML input to parse!";
		}
		
		return doc;
	},
	
	/**
	 * Is xml parsable as full document? Note that we allow a string  
	 * with no XML declaration. This may not be the best idea... 
	 * @param {string} xml
	 * @param @optional {boolean} hasDialog If true, automatically show a dialog
	 */
	isWellFormedDocument : function ( xml, hasDialog ) {
		
		var result = true;
		var dec = '<?xml version="1.0" encoding="UTF-8"?>';
		if ( xml.indexOf ( "<?xml " ) == -1 ) {
			xml = dec + xml;
		}
		var string = SourceValidationService.IsWellFormedDocument ( xml );
		
		if ( string != "True" ) {
			result = false;
			if ( hasDialog == true ) {
				this._illFormedDialog ( string );
			}
		}
		
		return result;
	},
	
	/**
	 * Is xml parsable as full document fragment?
	 * @param {string} xml
	 * @param @optional {boolean} hasDialog  If true, automatically show a dialog
	 */
	isWellFormedFragment : function ( xml, hasDialog ) {
		
		var result = true;
		var string = SourceValidationService.IsWellFormedFragment ( xml );
		
		if ( string != "True" ) {
			result = false;
			if ( hasDialog == true ) {
				this._illFormedDialog ( string );
			}
		}
		
		return result;
	},
	
	/**
	 * In case of malformed XML, analyze server parser 
	 * exception and present a clarifying dialog. 
	 * @param {String} string
	 */
	_illFormedDialog : function ( string ) {
		
		/*
		 * Timeout allows any previous method to returnvalue first.
		 */
		setTimeout ( function () {
			Dialog.error ( "Not well-formed", string );
		}, 0 );
	}
}

/**
 * The instance that does it.
 * @type {_XMLParser}
 */
var XMLParser = new _XMLParser ();

/**
 * @class
 */
function XPathResolver () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "XPathResolver" );

	/**
	 * @type {XPathEvaluator}
	 */
	this._evaluator = window.XPathEvaluator ? new XPathEvaluator () : null;
	
	/**
 	 * @type {HashMap<string><string>}
 	 */
	this._nsResolver = null;
}

/**
 * @param {HashMap<string><string>} hashMap
 */
XPathResolver.prototype.setNamespacePrefixResolver = function ( hashMap ) {

	if ( this._evaluator ) {
		this._nsResolver = {
			lookupNamespaceURI : function ( prefix ) {
				return hashMap [ prefix ];
			}
		}
	} else {
		this._nsResolver = hashMap;
	 }
}

/**
 * In effect implementing Microsofts "selectSingleNode" method.
 * @param {string} xpath
 * @param {DOMNode} node
 * @param {boolean} isMultiple
 * @return {DOMElement)
 */
XPathResolver.prototype.resolve = function ( xpath, node, isMultiple ) {
	
	var result = null;
	try {
		if ( this._evaluator ) {
			result = this._evaluateDOMXpath ( xpath, node, isMultiple ? true : false );	
		} else {
			result = this._evaluateMSXpath ( xpath, node, isMultiple ? true : false );
		}
	} catch ( exception ) {
		alert ( "XPathResolver#resolve: " + exception );
		if ( exception.stack ) {
			alert ( exception.stack );
		} else {
			alert ( arguments.caller.callee.toString ());
		}
		throw exception;
	}
	return result;
}

/**
 * In effect implementing Microsofts "selectNode" method.
 * @param {string} xpath
 * @param {DOMNode} node
 * @return {List)
 */
XPathResolver.prototype.resolveAll = function ( xpath, node ) {

	return this.resolve ( xpath, node, true );
}

/**
 * Evaluate DOM3 style.
 * @param {string} xpath
 * @param {DOMNode} node
 * @param {boolean} isMultiple
 * @return {object) Either a DOMElement or a List (depends on isMultiple).
 * @private
 */
XPathResolver.prototype._evaluateDOMXpath = function ( xpath, node, isMultiple ) {
	
	var result = null;
	
	if ( node ) {
		var result = this._evaluator.evaluate ( 
			xpath, node, this._nsResolver, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null 
		);
		if ( isMultiple ) {
			var list = new List ();
			while (( node = result.iterateNext ()) != null ) {
				list.add ( node );
			}
			result = list;
		} else {
			result = result.iterateNext ();
		}
	} else {
		var cry = "XPathResolver#_evaluateDOMXpath: No DOMNode to evaluate!";
		if ( Application.isDeveloperMode ) {
			alert ( cry );
		} else {
			this.logger.fatal ( cry );
		}
	}
	return result;
}

/**
 * Evaluate Microsoft style.
 * @param {string} xpath
 * @param {DOMNode} node
 * @param {boolean} isMultiple
 * @return {object) Either a DOMElement or a List
 * @private
 */
XPathResolver.prototype._evaluateMSXpath = function ( xpath, node, isMultiple ) {
	
	var doc = ( node.nodeType == Node.DOCUMENT_NODE ? node : node.ownerDocument );
	
	/*
	 * define selectionnamespaces on each xpath evaluation. this way, one 
	 * single XPathResolver can be used to evaluate multiple documents. 
	 * TODO: why doesnt it work when reading getProperty?
	 */
	var nsDeclarations = "";
	for ( var prefix in this._nsResolver ) {
		nsDeclarations += "xmlns:" + prefix + "=\"" + this._nsResolver [ prefix ] + "\" ";	
	}
	doc.setProperty ( "SelectionNamespaces", nsDeclarations );	
	
	if ( isMultiple ) {
		var list = new List ();
		var i = 0, nodes = node.selectNodes ( xpath );
		while ( i < nodes.length ) {
			list.add ( nodes.item ( i++ ));
		}
		result = list;
	} else {
		result = node.selectSingleNode ( xpath );
	}
	return result;
}

/**
 * @class
 * XSL transformers rule.
 */
function XSLTransformer () {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "XSLTransformer" );
	
	/**
	 * @type {MSXMLXSLTemplate}
	 */
	this._processor = null;
	
	/**
	 * @type {MSXMLXSLTemplate}
	 */
	this._cache = null;
}

/**
 * Import stylesheet.
 * @param {string} url
 */
XSLTransformer.prototype.importStylesheet = function ( url ) {
	
	var stylesheet = this._import ( 
		Resolver.resolve ( url )
	);
	
	if ( Client.isMozilla ) {
		this._processor = new XSLTProcessor ();
		this._processor.importStylesheet ( stylesheet );
	} else {	
		this._cache = DOMUtil.getMSXMLXSLTemplate ();
		this._cache.stylesheet = stylesheet;
	}
}

/**
 * @param {string} url
 * @return {DOMDocument}
 */
XSLTransformer.prototype._import = function ( url ) {

	var result = null;

	if ( Client.isMozilla ) {
	
		var request = DOMUtil.getXMLHTTPRequest ();
		request.open ( "get", Resolver.resolve ( url ),  false );
		request.send ( null );
		result = request.responseXML;
		
	} else {
		
		var result = DOMUtil.getDOMDocument ( true );
		result.async = false;
		result.load ( url );
	}
	
	return result;
}

/**
 * @param {DOMDocument} dom
 * @return {DOMDocument}
 */
XSLTransformer.prototype.transformToDocument = function ( dom ) {
	
	var result = null;
	if ( Client.isMozilla ) {
		result = this._processor.transformToDocument ( dom );
	} else {
		alert ( "TODO!" );
	}
	return result;
	
}

/**
 * @param {DOMDocument} dom
 * @param {boolean} isPrettyPrint
 * @return {string}
 */
XSLTransformer.prototype.transformToString = function ( dom, isPrettyPrint ) {
	
	var result = null;
	if ( Client.isMozilla ) {
		var doc = this.transformToDocument ( dom );
		result = DOMSerializer.serialize ( doc, isPrettyPrint ); 
	} else {
		var proc = this._cache.createProcessor ();
		proc.input = dom;
		proc.transform ();
		result = proc.output;
	}
	return result;
}

/**
 * Handy interface for messing what an elements classname. 
 */ 
function _CSSUtil () {}

_CSSUtil.prototype = {
	
	/**
	 * Get the current CSS classname of a DOM element.
	 * @param {DOMElement} element
	 * @return {string}
	 */
	_getCurrent : function ( element ) {
		var current = element.style ? element.className : element.getAttribute ( "class" );
		current = current ? current : "";
		return current;
	},
	
	/**
	 * Check for occurance of substring.
	 * @param {string} current
	 * @param {string} sub
	 * @return boolean
	 */
	_contains : function ( current, sub ) {
		return current.indexOf ( sub ) >-1;
	},
	
	/**
	 * Cumulative builder for whitespace-separated strings
	 * @param {string} current
	 * @param {string} sub
	 * @return {string}
	 */
	_attach : function ( current, sub ) {
		return current + ( current == "" ? "" : " " ) + sub;
	},
	
	/**
	 * Cumulative destroyer of whitespace-separated strings. 
	 * @param {string} current
	 * @param {string} sub
	 * @return {string}
	 */
	_detach : function ( current, sub ) {
		if ( this._contains ( current, " " + sub )) {
			sub = " " + sub;
		}
		return current.replace ( sub, "" );
	},
	
	/**
	 * Attach CSS classname to a DOM element.
	 * @param {DOMElement} element
	 * @param {string} classname
	 */
	attachClassName : function ( element, classname ) {
	
		if ( element.classList != null ) {
			if ( !element.classList.contains ( classname )) {
				element.classList.add ( classname );
			}
		} else {
			var current = this._getCurrent ( element );
			if ( !this._contains ( current, classname )) {
				current = this._attach ( current, classname );
			}
			if ( element.style != null ) {
				element.className = current;
			} else {
				element.setAttribute ( "class", current );
			}
		}
	},

	/**
	 * Detach CSS classname from a DOM element.
	 * @param {DOMElement} element
	 * @param {string} classname
	 */
	detachClassName : function ( element, classname ) {
		
		if ( element.classList != null ) {
			if ( element.classList.contains ( classname )) {
				element.classList.remove ( classname );
			}
		} else {
			var current = this._getCurrent ( element );
			if ( this._contains ( current, classname )) {
				current = this._detach ( current, classname );
			}
			if ( element.style != null ) {
				element.className = current;
			} else {
				if ( current == "" ) {
					element.removeAttribute ( "class" );
				} else {
					element.setAttribute ( "class", current );
				}
			}
		}
	},
	
	/**
	 * @param {DOMElement} element
	 * @param {string} classname
	 */
	hasClassName : function ( element, classname ) {
		
		var result = false;
		if ( element.classList != null ) {
			result = element.classList.contains ( classname );
		} else {
			result = this._contains ( this._getCurrent ( element ), classname );
		}
		return result;
	}
}

/**
 * The instance that does it.
 * @type {_CSSUtil}
 */
var CSSUtil = new _CSSUtil ();

/**
 * @class 
 * This class functions primarily as an assistant for {@link FlexBoxBinding}.
 */
function _CSSComputer () {}

_CSSComputer.prototype = {
	
	_margins : {
		top		: Client.isExplorer ? "marginTop" : "margin-top",
		right	: Client.isExplorer ? "marginRight" : "margin-right",
		bottom	: Client.isExplorer ? "marginBottom" : "margin-bottom",
		left	: Client.isExplorer ? "marginLeft" : "margin-left"
	},
	
	_paddings : {
		top		: Client.isExplorer ? "paddingTop" : "padding-top",
		right	: Client.isExplorer ? "paddingRight" : "padding-right",
		bottom	: Client.isExplorer ? "paddingBottom" : "padding-bottom",
		left	: Client.isExplorer ? "paddingLeft" : "padding-left"
	},
	
	_borders : {
		top		: Client.isExplorer ? "borderTopWidth" : "border-top-width",
		right	: Client.isExplorer ? "borderRightWidth" : "border-right-width",
		bottom	: Client.isExplorer ? "borderBottomWidth" : "border-bottom-width",
		left	: Client.isExplorer ? "borderLeftWidth" : "border-left-width"
	},
	
	/** 
	 * @param {object} comples
	 * @param {DOMElement} element
	 * @return {object}
	 */
	_getComplexResult : function ( complex, element ) {
	
		var result = {};
		for ( var entry in complex ) {
			var ent = parseInt ( 
				DOMUtil.getComputedStyle ( element, complex [ entry ])
			);
			result [ entry ] = isNaN ( ent ) ? 0 : ent;
		}
		return result;
	},
	
	/**
	 * This should only be expected to work well for "px" units.
	 * Returns an object with four properties: top, right, bottom, left.
	 * @param {DOMElement} element
	 * @return {object}
	 */
	_getMargin : function ( element ) {
		return this._getComplexResult ( this._margins, element );
	},
	
	/**
	 * This should only be expected to work well for "px" units.
	 * Returns an object with four properties: top, right, bottom, left.
	 * @param {DOMElement} element
	 * @return {object}
	 */
	getPadding : function ( element ) {
		return this._getComplexResult ( this._paddings, element );
	},
	
	/**
	 * This should only be expected to work well for "px" units.
	 * Returns an object with four properties: top, right, bottom, left.
	 * @param {DOMElement} element
	 * @return {object}
	 */
	getBorder : function ( element ) {
		return this._getComplexResult ( this._borders, element );
	},
	
	/**
	 * TODO: Rename this.
	 * @param {DOMElement} element
	 * @return {string}
	 */
	getPosition : function ( element ) {
		return DOMUtil.getComputedStyle ( element, "position" );
	},
	
	/**
	 * @param {DOMElement} element
	 * @return {string}
	 */
	getFloat : function ( element ) {
		return DOMUtil.getComputedStyle ( element, Client.isExplorer ? "styleFloat" : "float" );
	},
	
	/**
	 * @param {DOMElement} element
	 * @return {int}
	 */
	getZIndex : function ( element ) {
		return parseInt (
			DOMUtil.getComputedStyle ( element, Client.isExplorer ? "zIndex" : "z-index" )
		);
	},
	
	/**
	 * @param {DOMElement} element
	 * @return {string}
	 */
	getBackgroundColor : function ( element ) {
		return DOMUtil.getComputedStyle ( element, Client.isExplorer ? "backgroundColor" : "background-color" );
	}
}

/**
 * The instance that does it.
 * @type {_CSSComputer}
 */
var CSSComputer = new _CSSComputer ();

/**
 * @class
 * Centralizes interaction with TreeService.
 */
var System = new function () {
	
	var logger = SystemLogger.getLogger ( "System" );
	var root = null;
	
	/**
	 * Has perspectives mounted?
	 */
	this.hasActivePerspectives = false;

	/**
	 * Get the alpha node.
	 * @return {SystemNode}
	 */
	this.getRootNode = function () {
		
		if ( root == null ) {
			root = new SystemNode ( TreeService.GetRootElements ( "" )[ 0 ]);
		}
		return root;
	}
	
	/**
	 * Get the main "area" nodes (the buttons in the outlook menu).
	 * For some security related reason, this must be done especial.
	 * @return {List<SystemNode>}
	 */
	this.getPerspectiveNodes = function () {	
		
		var result = new List ();
		var response = TreeService.GetActivePerspectiveElements ( "dummy" );
		
		var list = new List ( response );
		if ( list.hasEntries ()) {
			this.hasActivePerspectives = true;
			list.each ( function ( element ) {	
				result.add ( 
					new SystemNode ( element )
				);
			});
		} else {
			EventBroadcaster.broadcast ( BroadcastMessages.PERSPECTIVES_NONE );
		}
		return result;
		
	}
	
	/**
	 * Get child nodes, optionally by search token.
	 * @param {SystemNode} node
	 * @param {string} searchToken Optional
	 * @return {List<SystemNode>}
	 */
	this.getChildNodes = function ( node, searchToken ) {
	
		var result		= new List ();
		var response 	= null;
		
		if ( searchToken ) {
			if ( SearchTokens.hasToken ( searchToken )) {
				searchToken = SearchTokens.getToken ( searchToken );
			}
			response = TreeService.GetElementsBySearchToken ( node.getData (), searchToken );
		} else {
			response = TreeService.GetElements ( node.getData ());
		}
		new List ( response ).each ( function ( element ) {	
			var newnode = new SystemNode ( element );
			if ( searchToken ) {
				newnode.searchToken = searchToken;
			}
			result.add ( newnode );
		});
		return result;
	}
	
	/**
	 * Get branch. This will *not* return a tree structure, but the structure 
 	 * can be inferred from a sequential parsing of the returned map. 
	 * @param {List<SystemNode>} nodes A list of open sub-treenodes.
	 * @return {Map<string><List<SystemNode>>}
	 */
	this.getDescendantBranch = function ( nodes ) {
	
		var map = new Map ();
		var arg = [];
		
		nodes.each ( function ( node ) {
			arg.push ({
				ProviderName : node.getProviderName (),
				EntityToken : node.getEntityToken (),
				Piggybag : node.getPiggyBag ()
			});
		});
		
		var response = TreeService.GetMultipleChildren ( arg );
		var triples = new List ( response );
		
		while ( triples.hasNext ()) {
			this._listNodesInMap ( triples.getNext (), map );
		}
		
		return map;
	}
	
	/**
	 * This will *not* return a tree structure, but the structure 
 	 * can be inferred from a sequential parsing of the returned map. 
	 * @param {string} rootToken The current perspective token.
	 * @param {string} token 
	 * @param {List<SystemNode>} nodes A list of open treenodes in the whole tree.
	 * @return {Map<string><List<SystemNode>>}
	 */
	this.getInvisibleBranch = function ( rootToken, token, nodes ) {
		
		var map = new Map ();
		var arg = [];
		
		nodes.each ( function ( node ) {
			arg.push ({
				ProviderName : node.getProviderName (),
				EntityToken : node.getEntityToken (),
				Piggybag : node.getPiggyBag ()
			});
		});
		
		var response = TreeService.FindEntityToken ( rootToken, token, arg );
		
		if ( response instanceof SOAPFault ) {
		
			logger.error ( response.getFaultString ());
			if ( Application.isDeveloperMode ) {
				alert ( response.getFaultString ());
			}
			map = null;
			
		} else {
			
			var triples = new List ( response );
			while ( triples.hasNext ()) {
				this._listNodesInMap ( triples.getNext (), map );
			};
		}
		
		return map;
	}
	
	/**
	 * @param {object} triple
	 * @param {Map<string><List<SystemNode>>} map
	 */
	this._listNodesInMap = function ( triple, map ) {
		
		var list = new List ();	
		var key = triple.ElementKey; //triple.ProviderName + triple.EntityToken;
		var elements = new List ( triple.ClientElements );
		
		map.set ( key, list );
		while ( elements.hasNext ()) {
			var element = elements.getNext ();
			list.add ( new SystemNode ( element ));
		}
	}
	
	/**
	 * Get child nodes by search token.
	 * @param {SystemNode} node
	 * @param {string} searchToken Optional
	 * @return {List<SystemNode>}
	 */
	this.getChildNodesBySearchToken = function ( node, searchToken ) {
	
		return this.getChildNodes ( node, searchToken );
	}
	
	/**
	 * Get named roots (nodes for a given root).
	 * @param {string} key
	 * @param {string} searchToken Optional
	 * @return {List<SystemNode>}
	 */
	this.getNamedRoots = function ( key, searchToken ) {
	
		var result = new List ();
		var response = null; 
		
		if ( searchToken ) {
			if ( SearchTokens.hasToken ( searchToken )) {
				searchToken = SearchTokens.getToken ( searchToken );
			}
			response = TreeService.GetNamedRootsBySearchToken ( key, searchToken );
		} else {
			response = TreeService.GetNamedRoots ( key );
		}
		
		new List ( response ).each ( function ( element ) {	
			var node = new SystemNode ( element );
			if ( searchToken ) {
				node.searchToken = searchToken;
			}
			result.add ( node );
		});
		return result;
	}
	
	/**
	 * Get named roots by search token.
	 * @param {string} key
	 * @param {string} searchToken
	 * @return {List<SystemNode>}
	 */
	this.getNamedRootsBySearchToken = function ( key, searchToken ) {
		
		return this.getNamedRoots ( key, searchToken );
	}
	
	/**
	 * Compile action list.
	 * @param {SystemNode} node
	 * @param {object} element
	 * @param {List} actions
	 * @ignore
	 */
	function compileActionList ( node, element, actions ) {
	
		var index = element.ClientElementActionGroupId;
		if ( index != null ) {
			var items = actions.get ( index ).ClientElementActionGroupItems;
			if ( items && items.length > 0 ) {
				node.setActionList ( 
					new List ( items )
				);
			}
		}
	}
}

/**
 * This doesn't really do much for us.
 * @param {SystemNode} node
 */
SystemNode.dispose = function ( node ) { 
	
	for ( var prop in node ) {
		node [ prop ] = null;
	}
}

/**
 * Tagged actions go here.
 * @type {Map<string><SystemNode>}
 */
SystemNode.taggedNodes = new Map ();

/**
 * @class
 * @param {object} data
 */
function SystemNode ( data ) {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SystemNode" );
	
	/**
	 * @type {object}
	 * @private
	 */
	this._data = data;
	
	/**
	 * Exposes associated actions ordered by group name.
	 * @type {Map<string><List<SystemAction>>}
	 */
	this._actionProfile = null;
	
	/**
	 * @type {HashMap<string><string>}
	 * @private
	 */
	this._propertyBag = null;
	
	/*
	 * Note that we register all actions in the constructor!
	 */
	this._registerSystemActions ();
	
	/*
	 * Set by {@link System} when the SystemNode is first created.
	 */
	this.searchToken = null;
	
	/*
	 * Register tagged node.
	 */
	if ( this._data.TagValue != null ) {
		SystemNode.taggedNodes.set (
			this._data.TagValue,
			this
		);
	}
}

/**
 * Identifies systemnode.
 */
SystemNode.prototype.toString = function () {
	
	return "[SystemNode]";
}

/**
 * Scan the associated action keys and register 
 * all SystemActions not already indexed.
 */
SystemNode.prototype._registerSystemActions = function () {
	
	var self = this;
	
	new List ( this._data.ActionKeys ).each ( function ( key ) {
		if ( !SystemAction.actionMap.has ( key )) {
			new List ( self._data.Actions ).each ( function ( action ) {
				var category = action.ActionCategory.Name;
				if ( SystemAction.hasCategory ( category )) {
					var systemAction = new SystemAction ( action );
					SystemAction.actionMap.set ( 
						action.ActionKey, 
						systemAction
					);
				} else {
					throw "No such action category: " + category;
				}
			});
		}
	});
}

/**
 * Expose the data structure for serialization back into SOAP.
 * @returns {object}
 */
SystemNode.prototype.getData = function () {
	
	return this._data;
}

/**
 * Get children. Notice that searchTokens are automatically inherited by child nodes!
 * @return {List<SystemNode>}
 */
SystemNode.prototype.getChildren = function () {

	var result = null;
	if ( this.searchToken ) {
		result = System.getChildNodesBySearchToken ( this, this.searchToken );
	} else {
		result = System.getChildNodes ( this );
	}
	return result;
}

/** 
 * Get branch. This will *not* return a tree structure, but the structure 
 * can be inferred from a sequential parsing of the returned map. More 
 * nodes may be returned than are actually present in the branch at 
 * this exact moment.
 * @param {List<SystemNode>} list
 * @return {Map<string><List<SystemNode>>}
 */
SystemNode.prototype.getDescendantBranch = function ( list ) {
	
	return System.getDescendantBranch ( list );
}

/**
 * @return {string}
 */
SystemNode.prototype.getLabel = function () {

	return this._data.Label;
}

/**
 * @return {string}
 */
SystemNode.prototype.getProviderName = function () {

	return this._data.ProviderName;
}

/**
 * @return {string}
 */
SystemNode.prototype.getEntityToken = function () {

	return this._data.EntityToken;
}

/**
 * @return {string}
 */
SystemNode.prototype.getPiggyBag = function () {
	
	var result = this._data.Piggybag;
	if ( result == null ) {
		result = "";
	}
	return result;
}

/**
 * Used to uniquely identify the SystemNode, the handle is 
 * simply a concatenation of ProviderName and EntityToken.
 * @return {string}
 */
SystemNode.prototype.getHandle = function () {
	
	return this._data.ElementKey;
}

/**
 * Not all nodes may be tagged!
 * @return {string}
 */
SystemNode.prototype.getTag = function () {
	
	return this._data.TagValue;
}

/**
 * @return {ImageProfile}
 * @param {string} size
 * @return {ImageProfile}
 */
SystemNode.prototype.getImageProfile = function ( size ) {
 	
 	return new ImageProfile ({
		image : ImageProvider.getImageURL ( 
			this._data.Icon,
			size
		),
		imageActive :  ImageProvider.getImageURL ( 
			this._data.OpenedIcon ? this._data.OpenedIcon : this._data.Icon,
			size
		)
	});
}

/**
 * Get the node description.
 * @return {string}
 */
SystemNode.prototype.getToolTip = function () {
	
	var result = null;
	if ( typeof this._data.ToolTip != "undefined" ) {
		result = this._data.ToolTip;
	}
	return result;
}

/**
 * Get propertybag.
 * @return {HashMap<string><string>}
 */
SystemNode.prototype.getPropertyBag = function () {
	
	if ( !this._propertyBag && this._data.PropertyBag && this._data.PropertyBag.length != 0 ) {
		var map = {}
		new List ( this._data.PropertyBag ).each ( function ( entry ) {
			map [ entry.Key ] = entry.Value;
		});
		this._propertyBag = map;
	}
	return this._propertyBag;
}

/**
 * @return {boolean}
 */
SystemNode.prototype.hasChildren = function () {

	return this._data.HasChildren;
}

/**
 * Get the actionProfile assoicated the this node. 
 * Actions of the category DeveloperMode will 
 * not be included in operational mode.
 */
SystemNode.prototype.getActionProfile = function () {
	
	if ( this._actionProfile == null && this._data.ActionKeys != null && this._data.ActionKeys.length > 0 ) {

		var map = new Map ();
		var self = this;
		
		new List ( this._data.ActionKeys ).each ( function ( key ) {
			if ( SystemAction.actionMap.has ( key )) {
			
				var action = SystemAction.actionMap.get ( key );
				var isValid = true;
				
				if ( action.getCategory () == SystemAction.categories.DeveloperMode ) {
					if ( !Application.isDeveloperMode ) {
						isValid = false;
					}
				}
				if ( isValid ) {
					var id = action.getGroupID ();
					if ( !map.has ( id )) {
						map.set ( id, new List ());
					}
					var list = map.get ( id );
					list.add ( action );
				}
			} else {
				throw "No details for action key: " + key;
			}
		});
			
		this._actionProfile = map;
	}
	
	return this._actionProfile;
}

/**
 * Test for drag type.
 * @return {boolean}
 */
SystemNode.prototype.hasDragType = function () {
	
	return this._data.DragType != null;
}

/**
 * Test for drag type.
 * @return {string}
 */
SystemNode.prototype.getDragType = function () {
	
	return this._data.DragType;
}


/**
 * Test for drag accept.
 * @return {boolean}
 */
SystemNode.prototype.hasDragAccept = function () {
	
	return this._data.DropTypeAccept != null;
}

/**
 * Get drag accept.
 * @return {List<string>}
 */
SystemNode.prototype.getDragAccept = function () {
	
	return new List ( 
		this._data.DropTypeAccept 
	);
}

/**
 * Test for detailed drag support.
 * @return {boolean}
 */
SystemNode.prototype.hasDetailedDropSupport = function () {
	
	//alert ( "We don't yet support detailed drag on individual treenodes!" );
	return this._data.DetailedDropSupported == true;
}

/*
 * Is from-language node?
 * @return {boolean}
 *
SystemNode.prototype.isFromLanguage = function () {
	
	return this._data.IsForeignLocale == true;
}
*/

/**
 * Is disabled?
 * @return {boolean}
 */
SystemNode.prototype.isDisabled = function () {
	
	return this._data.IsDisabled == true;
}

/**
 * The controversial property the decides whether 
 * or not thee treenode may recieve auto-focus.
 * @return {boolean}
 */
SystemNode.prototype.isTreeLockEnabled = function () {
	
	return this._data.TreeLockEnabled == true;
}

/**
 * Dispose. INVOKING THIS MAY INTRODUCE ERRORS!
 * TODO: Of course this should be made to work.
 */
SystemNode.prototype.dispose = function () {
	
	SystemNode.dispose ( this );
}

/*
 * Action types.
 */
SystemAction.OPEN_DOCUMENT ="OpenDocument";
SystemAction.OPEN_MODAL_DIALOG ="OpenModalDialog";

/*
 * Action tags.
 */
SystemAction.TAG_CHANGEFROMLANGUAGE = "ChangeFromLocale";

/**
 * Determines allowed categories and category display order.isInToolBar
 * @type {HashMap}
 */
SystemAction.categories = {

	Edit			: "Edit",
	Add				: "Add",
	Delete			: "Delete",
	Other			: "Other",
	DeveloperMode	: "DeveloperMode"
}

/**
 * Tagged actions go here.
 * @type {Map<string><SystemAction>}
 */
SystemAction.taggedActions = new Map ();

/**
 * This is maintained by the SystemNodes.
 * @see {SystemNode#_registerSystemActions}
 * @type {Map<string><SystemAction>}
 */
SystemAction.actionMap = new Map ();

/**
 * Invoke that action.
 * @param {SystemAction} action
 * @param {object} arg This can be either a SystemNode or a List of SystemNodes.
 */
SystemAction.invoke = function ( action, arg ) {
	
	var node = arg;
	
	if ( node instanceof SystemNode ) {
		Application.lock ( SystemAction );
		action.logger.debug ( "Execute \"" + action.getLabel () + "\" on \"" + node.getLabel () + "\"." );
		setTimeout ( function () { // timeout allow pressed buttons to unpress
			TreeService.ExecuteSingleElementAction ( 
				node.getData (),
				action.getHandle (),
				Application.CONSOLE_ID
			);
			MessageQueue.update ();
			Application.unlock ( SystemAction );
		}, 0 );
	} else {
		throw "Multiple actiontargets not supported.";
	}
	
	/*
	 * A list of nodehandles.
	 * @type {array<object>}
	 *
	var nodeHandleList = [];
	
	MULTIPLE SELECTIONS SETUP!
	
	ExplorerBinding.getFocusedTreeNodeBindings ().each ( 
		function ( treeNodeBinding ) {
			var systemNode = treeNodeBinding.node;
			nodeHandleList.push ( 
				systemNode.getHandle ()
			);
		}
	);
	
	if ( nodeHandleList.length > 0 ) {
		
		var actionHandle = action.getHandle ();
		var serviceResponse = TreeService.ExecuteElementAction ( 
			nodeHandleList,
			actionHandle,
			Application.CONSOLE_ID
		);
		
		MessageQueue.update ();
	}
	*/
	
	/*
	var systemNode = null;
	
	var list = ExplorerBinding.getFocusedTreeNodeBindings ();
	if ( list.hasEntries ()) {
		var treeNodeBinding = list.getFirst ();
		var systemNode = treeNodeBinding.node;
	}
		
	if ( systemNode ) {
		var serviceResponse = TreeService.ExecuteSingleElementAction ( 
			node.getData (),
			action.getHandle (),
			Application.CONSOLE_ID
		);
		MessageQueue.update ();
	}
	*/
}

/**
 * Invoke tagged action.
 * @param {string} taggednode
 * @param {string} taggedaction
 */
SystemAction.invokeTagged = function ( taggedaction, taggednode ) {
	
	action = SystemAction.taggedActions.get ( taggedaction );
	node = SystemNode.taggedNodes.get ( taggednode );
	SystemAction.invoke ( action, node );
}

/**
 * Check action category before displaying in GUI. So that we 
 * don't wonder what happens to newly introduced categories.
 * @param {string} string
 * @return {boolean}
 */
SystemAction.hasCategory = function ( category ) {

	return SystemAction.categories [ category ] ? true : false;
}

/**
 * @param {object} object
 */
function SystemAction ( object ) {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SystemAction" );
	
	/**
	 * @type {object}
	 * @private
	 */
	this._data = object;
	
	/*
	 * Register tagged action.
	 */
	if ( this._data.TagValue != null ) {
		SystemAction.taggedActions.set (
			this._data.TagValue,
			this
		);
	}
}

/**
 * Identifies object.
 */
SystemAction.prototype.toString = function () {
	
	return "[SystemAction]";
}

/**
 * Get the actionProfilehHandle.
 * @return {object}
 */
SystemAction.prototype.getHandle = function () {

	return this._data.ActionToken;
}

/**
 * Get the ActionKey. TODO: DID THIS WORK?
 * @return {string}
 */
SystemAction.prototype.getKey = function () {

	return this._data.ActionKey;
}

/**
 * Get the action label.
 * @implements {ILabel}
 * @return {string}
 */
SystemAction.prototype.getLabel = function () {

	return this._data.Label;
}

/**
 * Get the image associated to the action.
 * @implements {ILabel}
 * @return {string}
 */
SystemAction.prototype.getImage = function () {

	return ImageProvider.getImageURL ( this._data.Icon );
}

/**
 * Get the disabled-image.
 * TODO: Implement this feature on server!
 * @see {SystemAction#isDisabled}
 * @implements {ILabel}
 * @return {string}
 */
SystemAction.prototype.getDisabledImage = function () {

	return null;
}

/**
 * Get the action description.
 * @implements {ILabel}
 * @return {string}
 */
SystemAction.prototype.getToolTip = function () {

	return this._data.ToolTip;
}

/**
 * Get action category.
 * @return {string}
 */
SystemAction.prototype.getCategory = function () {

	return this._data.ActionCategory.Name;
}

/**
 * Get group name.
 * @return {string}
 */
SystemAction.prototype.getGroupID = function () {
	
	return this._data.ActionCategory.GroupId;
}

/**
 * Is in toolbar?
 * @return {boolean}
 */
SystemAction.prototype.isInToolBar = function () {

	return this._data.ActionCategory.IsInToolbar;
}

/**
 * Is in folder?
 * @return {boolean}
 */
SystemAction.prototype.isInFolder = function () {

	return this._data.ActionCategory.IsInFolder;
}

/**
 * @return {string}
 */
SystemAction.prototype.getFolderName = function () {

	var result = null;
	if ( this.isInFolder ()) {
		result = this._data.ActionCategory.FolderName;
	}
	return result;
}

/**
 * Is action disabled?
 * @return {boolean}
 */
SystemAction.prototype.isDisabled = function () {

	return this._data.Disabled;
}

/**
 * Is checkbox?
 * @return {boolean}
 */
SystemAction.prototype.isCheckBox = function () {
	
	return typeof this._data.CheckboxStatus != Types.UNDEFINED;
}

/**
 * Get tag value.
 * @return {string}
 */
SystemAction.prototype.getTag = function () {
	
	var result = null;
	if ( typeof this._data.TagValue != "undefined" ) {
		result = this._data.TagValue;
	}
	return result;
}

/**
 * Is checked?
 * @return {boolean}
 */
SystemAction.prototype.isChecked = function () {
	
	var result = null;
	if ( this.isCheckBox ()) {
		result = this._data.CheckboxStatus == "Checked";
	} else {
		throw "Not a checkbox!";
	}
	return result;
}

/*
 * ----------------------------------------------------------------------------
 * "THE BEER-WARE LICENSE" (Revised):
 * Composite.NET wrote this file. As long as you retain this notice 
 * you can do whatever you want with this stuff. If we meet some day, 
 * and you think this stuff is worth it, you can buy us a beer in return.
 * ----------------------------------------------------------------------------
 */

/**
 * This fellow will manage form request and server response to produce an AJAH-style 
 * webpage interface. The form is posted without reloading the page, the response is 
 * compared to the previous response and differing sections will be updated on the page. 
 * This has been coded as a newable class to maximize visibility in your JS-aware IDE, 
 * but there should in fact be only one instance running; it is declared near the end 
 * of this file (scroll down) and accessed through instance variable "UpdateManager".
 */
function _UpdateManager () { // notice the underscore!
	
	var instance = null;
	if ( !window.UpdateManager ) {
		this._construct ();
		instance = this;
	}
	return instance;
}

_UpdateManager.prototype = {
	
	/** 
	 * Version string.
	 * @type {string}
	 */
	version : "0.1",
		
	/**
	 * Attach this classname to any form on the page to make it postback without page refresh.
	 * @type {string}
	 */
	CLASSNAME_FORM : "updateform",

	/**
	 * Attach this classname to one or more elements to make them update without page refresh.
	 * @type {string} 
	 */
	CLASSNAME_ZONE : "updatezone",
	
	/**
	 * Considered experimental until further notice: Attach this classname to block updates!
	 * @type {string}
	 */
	CLASSNAME_GONE : "updategone",
	
	/**
	 * This event is dispatched from the documentElement BEFORE any new request to the 
	 * server is made. The event is fired regardless of whether or not the page is 
	 * actually being updated. Note the the event is also fired once for each page 
	 * update, though not with the documentElement as target. Note that we use  
	 * the same event name because IE handles a limited list of available names. 
	 * @see {Update#EVENT_BEFOREUPDATE}
	 * @type {string}
	 */
	EVENT_BEFOREUPDATE : "beforeupdate",
	
	/**
	 * This event is dispatched from the documentElement AFTER any new request to the 
	 * server has been handled. The event is fired regardless of whether or not the 
	 * page was actually updated. Note the the event is also fired once for each 
	 * page update, though not with the documentElement as target
	 * @see {Update#EVENT_AFTERUPDATE}
	 * @type {string}
	 */
	EVENT_AFTERUPDATE : "afterupdate",
	
	/**
	 * Fires when an error occurs - one that is recognized by the code, that is. 
	 * If you intercept this DOM event, you can ask for the error message as a 
	 * property of the UpdateManager.
	 * @see {UpdateManager#error}
	 * @see {UpdateManager#errormessage}
	 * @type {string}
	 */
	EVENT_ERRORUPDATE : "errorupdate",
	
	/**
	 * If this property is specified by serverside magic, we can avoid rendering the page  
	 * twice. Note that the page may be rendered twice by the server, not on the client.
	 * @type {string}
	 */
	xhtml : null,
	
	/**
	 * An summary is collected here during the update phase. 
	 * @type {string}
	 */
	summary : null,
	
	/**
	 * Flip this property to enable normal form post.
	 * @type {boolean}
	 */
	isEnabled : true,
	
	/**
	 * You should set this to true while developing. This will allow  
	 * the UpdateManager to inform you about possible execution errors.  
	 * @type {boolean}
	 */
	isDebugging : false,
	
	/**
	 * True while posting request or parsing response. While true, all further postback is disabled.
	 * TODO: Disabling further postback, is this a good idea?
	 * @type {boolean}
	 */
	isUpdating : false,
	
	/**
	 * Are elements candidates for "soft" attribute update? When true, elements may have 
	 * their attributes updated WITHOUT replacing the original element with a new one - 
	 * though if something in the descendant DOM tree changed, replacement may still occur. 
	 * 1) The element must have an id attribute specified for this to work. 
	 * @type {boolean}
	 */
	hasSoftAttributes : false,
	
	/**
	 * Are elements candidates for "soft" insertion or deletion? Instead of simly replacing 
	 * the parent, child elements may by be appended or removed using delicate DOM methods. 
	 * Switching the ordinal position of elements is NOT supported, only insert and delete, 
	 * since movement of existing elements is destructive the "hard" way. Requirements are: 
	 * 1) All children must be Element nodes (or whitespace text).
	 * 2) All children must have an id attribute specified.
	 * @type {boolean}hasSoftChildren
	 */
	hasSoftSiblings : false,
	
	/**
	 * The latest response string sent from server (before it is  
	 * converted into DOM). This can be analyzed in case of errors.
	 * @see {UpdateAssistant#getXMLHttpRequest}
	 * @type {string}
	 */
	pendingResponse : null,
	
	/**
	 * This holds the latest document DOM as it was sent 
	 * from the server. It is updated on each request.
	 * @type {DOMDocument}
	 */
	currentDOM : null,
	
	/**
	 * Holds the latest error message string, if any. 
	 * @see {UpdateManager#error}
	 * @type {string}
	 */
	errormessage : null,
	
	/**
	 * The assistant performs the stuff we don't want to focus on here.  
	 * @type {UpdateAssistant}
	 */
	_assistant : null,
	
	/**
	 * Objects with two props: ID of Element to delete, Element to insert instead.
	 * @type {Array<Update>}
	 */
	_updates : null,
	
	/**
	 * Keep track of ReplaceUpdate element IDs to minimize crawling efforts.
	 * @type {HasMap<boolean>}
	 */
	_replaced : null,
	
	/**
	 * NET special: These form element will be updated on each  
	 * request, although it is possible not needed for all of them.
	 * @type {Array<String>}
	 */
	_dotnetnames : [ 
	                 "__VIEWSTATE", 
	                 "__EVENTVALIDATION", 
	                 "__EVENTTARGET", 
	                 "__EVENTARGUMENT",
	                 "__LASTFOCUS" ],
	
	/**
	 * List of plugins should be assembled on startup (before window.onload)
	 * @type {Array<object>}
	 */
	plugins : [],
	
	/**
	 * Identification.
	 * @return {string}
	 */
	toString : function () {
		
		return "[object UpdateManager]";
	},
	
	/**
	 * Constructor action: Confirming well-formed markup.
	 */
	_construct : function ( xhtml ) {
		
		var root = document.documentElement;
		var xmlns = root.namespaceURI;
		if ( xmlns == null ) {
			xmlns = new String ( root.getAttribute ( "xmlns" ));
		}
		if ( xmlns == "http://www.w3.org/1999/xhtml" ) {
			this._addListener ( window, "load" );
			this._addListener ( window, "unload" );
		} else {
			this.error ( "Not an XHTML document!" );
		}
	},
	
	/**
	 * Invoked once, on window load. If the xhtml property is specified,  
	 * we can now parse it into a DOM document. Otherwise we request it.
	 */
	_setup : function () {
		
		if ( this.isEnabled ) {
			this.isEnabled = this.setupForms ();
			if ( this.isEnabled ) {
				if ( this.xhtml != null ) {
					if ( typeof this.xhtml == "string" ) {
						var markup = decodeURIComponent ( this.xhtml );
						this.currentDOM = UpdateAssistant.parse ( markup );
					} else {
						throw new TypeError ();
					}
				} else {
					var _this = this;
					UpdateAssistant.getXMLHttpRequest ( "get", window.location.toString (), {
						handleResponse : function ( dom ) {
							_this.currentDOM = dom;
						}
					}).send ( null );
				}
			}
		}
	},
	
	/**
	 * Setup all forms on window load. Also invoked after some 
	 * page updates, since the update may have replaced a form.
	 * @see {Update#_afterUpdate}
	 * @return {boolean} True when forms were setup
	 */
	setupForms : function () {
		
		var hasSetup = false;
		Array.forEach ( document.forms, function ( form ) {
			if ( form.className.indexOf ( this.CLASSNAME_FORM ) >-1 ) {
				if ( !form.__isSetup ) {
					this._setupForm ( form );
					form.__isSetup = true;
				}
				hasSetup = true;
			}
		}, this );
		return hasSetup;
	},
	
	/**
	 * Intercepting form submit.
	 * @param {HTMLFormElement} form
	 */
	_setupForm : function ( form ) {
		
		var _this = this;
		this._addListener( form, "submit" );
		
		form.__submit = form.submit;
		form.submit = function () {
			if ( _this.isEnabled ) {
				_this._submit ( form );
			} else {
				form.__submit ();
			}
			return false;
		};
	},
	
	/**
	 * Add event listener.
	 * @param {object} target
	 * @param {string} type
	 * @param {object} handler
	 */
	_addListener : function ( target, type ) {
		
		if ( target.addEventListener != null ) {
			target.addEventListener ( type, this, false );
		} else {
			var _this = this;
			target.attachEvent ( "on" + type, function () {
				_this.handleEvent ( window.event );
			});
		}
	},
	
	/**
	 * DOM event listener.
	 * @param {Event} e
	 */
	handleEvent : function ( e ) {
		
		switch ( e.type ) {
			
			case "load" :
				if ( this.isEnabled ) {
					this._setup ();
				}
				break;
				
			case "unload" :
				this.isEnabled = false;
				break;
				
			case "submit" :
				if ( this.isEnabled ) {
					if ( document.all ) {
						e.returnValue = false;
					} else {
						e.preventDefault ();
					}
					var form = e.target ? e.target : e.srcElement;
					this._submit ( form );
				}
				break;
		}
	},
	
	/**
	 * Submit form. Note that we block further postback until response is handled.
	 * @param {HTMLFormElement} form
	 */
	_submit : function ( form ) {
		
		if ( !this.isUpdating ) {
			this.isUpdating = true; // reversed in method handleResponse below
			UpdateAssistant.dispatchEvent ( document.documentElement, this.EVENT_BEFOREUPDATE );
			this._postRequest ( form );
		}
	},
	
	/** 
	 * Update the page.
	 * @param {Document} dom
	 */
	handleResponse : function ( dom ) {
		
		if ( this.isEnabled ) { // the window might have been unloaded while response was pending
		
			this.summary = new String ( "" );
			this.errors = new String ( "" );
			
			if ( dom != null ) {
				
				// isolate update zones
				var newzones = UpdateAssistant.getUpdateZones ( dom ); 
				var oldzones = UpdateAssistant.getUpdateZones ( this.currentDOM );
					
				// clear old updates
				this._updates = [];
				this._replaced = {};
				
				// collect updates
				newzones.forEach ( function ( newzone, index ) {
					var oldzone = oldzones [ index ];
					this._crawl ( newzone, oldzone );
				}, this );
				
				// apply updates
				this._updates.forEach ( function ( update, index ) {
					update.update ();
					update.dispose ();
				}, this );
				
				// NET specials
				this._dotnetnames.forEach ( function ( name ) {
					this._fixdotnet ( dom, name );
				}, this );
				
				// prepare next update
				this.currentDOM = dom;
			}
		}
		
		// request end stuff
		this.isUpdating = false;
		UpdateAssistant.dispatchEvent ( document.documentElement, this.EVENT_AFTERUPDATE );
	},
	
	/**
	 * Don't update the page. But we may still need to tell the world... 
	 */
	handleSimilarResponse : function () {
		
		UpdateAssistant.dispatchEvent ( document.documentElement, this.EVENT_AFTERUPDATE );
	},
	
	/**
	 * Crawl elements.
	 * @param {Element} newnode
	 * @param {Element} oldnode
	 * @param {Element} element While iterating, this elements has the last specified ID. 
	 * @param {string} id The ID of aforementioned element.
	 * @return {boolean}
	 */
	_crawl : function ( newnode, oldnode, element, id ) {
		
		var result = true;
		
		var classname = oldnode.getAttribute ( "class" );
		if ( classname == null || classname.indexOf ( this.CLASSNAME_GONE ) == -1 ) {
			if ( oldnode.nodeType == Node.ELEMENT_NODE ) {
				var oldid = oldnode.getAttribute ( "id" );
				if ( oldid != null ) {
					element = newnode;
					id = oldid;
				}
			}
			if ( result = this._check ( newnode, oldnode, element, id )) {
				var child1 = newnode.firstChild;
				var child2 = oldnode.firstChild;
				while ( child1 != null && child2 != null && !this._replaced [ id ]) {
					switch ( child1.nodeType ) {
						case Node.TEXT_NODE :
							result = this._check ( child1, child2, element, id );
							break;
						case Node.DOCUMENT_NODE :
						case Node.ELEMENT_NODE :
							result = this._crawl ( child1, child2, element, id );
							break;
					}
					if ( this._replaced [ id ]) {
						result = false;
					} else {
						child1 = child1.nextSibling;
						child2 = child2.nextSibling;
					}
				}
			}
		}
		return result;
	},
	
	/**
	 * Are two nodes similar? If not, push new update to this._updates.
	 * @param {Node} newnode
	 * @param {Node} oldnode
	 * @param {Element} element
	 * @param {string} id
	 * @return {boolean}
	 */
	_check : function ( newnode, oldnode, element, id ) {
		
		var result = true;
		var plugin = null;
		var isSoftUpdate = false;
		var isPluginUpdate = false;
		
		if (( newnode != null && oldnode == null ) || ( newnode == null && oldnode != null )) {  
			result = false;
		} else if ( result = newnode.nodeType == oldnode.nodeType ) {
			switch ( oldnode.nodeType ) {
				case Node.ELEMENT_NODE :
					if ( newnode.namespaceURI != oldnode.namespaceURI || newnode.nodeName != oldnode.nodeName ) {
						result = false;
					} else if ( result = ( newnode.nodeName == oldnode.nodeName )) {
						var oldid = oldnode.getAttribute ( "id" );
						var newid = newnode.getAttribute ( "id" );
						if ( oldid != null && newid != null ) {
							if ( oldid != newid ) {
								result = false;
							} else if (( plugin = this._getPlugin ( newnode, oldnode )) != null ) {
								if ( plugin.updateElement ( newnode, oldnode )) {
									isPluginUpdate = true; // dont replace (but maybe plugin did)
									result = false; // stop crawling
								}
							}
						}
						if ( result ) {
							if ( result = this._checkAttributes ( newnode, oldnode )) {
								if ( this.hasSoftSiblings && this._hasSoftChildren ( newnode ) && this._hasSoftChildren ( oldnode )) {
									if ( this._validateSoftChildren ( newnode, oldnode )) {
										this._updateSoftChildren ( newnode, oldnode );
										isSoftUpdate = true; // dont replace
									}
									result = false; // stop crawling - but continue in _updateSoftChildren
								} else {
									result = newnode.childNodes.length == oldnode.childNodes.length;
								}
							}
						}
					}
					break;
				case Node.TEXT_NODE :
					/*
					 * Trimming is needed because serverside scripting      
					 * may spontaneously insert whitespace text. oh Lord.
					 */
					if ( newnode.data.trim () != oldnode.data.trim ()) {
						result = false;
					}
					break;
			}
		}
		
		// when in doubt, the default action is to simply replace...
		if ( result == false && !isSoftUpdate && !isPluginUpdate ) {
			if ( id != null && element != null ) {
				this.addUpdate ( 
					new ReplaceUpdate ( id, element )
				);
			}
		}
		return result;
	},
	
	/**
	 * Are attributes similar? If property hasSoftAttributes is on, this may result 
	 * in a "soft" update of element attributes (tree structure is not modified).
	 * @param {Element} newnode
	 * @param {Element} oldnode
	 * @return {boolean} When false, replace "hard" and stop iteration.
	 */
	_checkAttributes : function ( newnode, oldnode ) {
		
		var result = true;
		var changed = false;
		
		var atts1 = newnode.attributes;
		var atts2 = oldnode.attributes;
		
		if ( atts1.length != atts2.length ) {
			changed = true;
		} else {
			changed = !Array.every ( atts1, function ( att1, i ) {
				var att2 = atts2.item ( i );
				return att1.nodeName == att2.nodeName && att1.nodeValue == att2.nodeValue;
			});
		}
		if ( changed ) {
			var newid = newnode.getAttribute ( "id" );
			var oldid = oldnode.getAttribute ( "id" );	
			if ( this.hasSoftAttributes && newid != null && newid == oldid ) {
				this.addUpdate ( 
					new AttributesUpdate ( oldid, newnode, oldnode )
				);
			} else {
				result = false; // addUpdate ReplaceUpdate!
			}
		}
	
		return result;
	},
	
	/**
	 * Are element children candidates for "soft" sibling updates?
	 * 1) All children must be of element nodetype (or whitespace textnodes).
	 * 2) All children must have an ID attribute specified.
	 * @param {Element} element
	 * @return {boolean}
	 */
	_hasSoftChildren : function ( element ) {
		
		var result = true;
		if ( element.hasChildNodes ()) {
			result = Array.every ( element.childNodes, function ( node ) {
				var res = true;
				switch ( node.nodeType ) {
					case Node.TEXT_NODE :
						res = !/[^\t\n\r ]/.test ( node.nodeValue );
						break;
					case Node.ELEMENT_NODE :
						res = node.getAttribute ( "id" ) != null;
						break;
				}
				return res;
			});
		}
		return result;
	},
	
	/**
	 * "Soft" siblings can be INSERTED and DELETED. Changing the ordinal position of  
	 * existing elements is NOT supported, since this is destructive the "hard" way 
	 * (moving eg. an iframe using DOM method insertBefore would reload the iframe). 
	 * This method will verify that new elements retain their relative positioning. 
	 * @param {Element} newnode
	 * @param {Element} oldnode
	 * @return {boolean}
	 */
	_validateSoftChildren : function ( newnode, oldnode ) {
		
		var result = true ;
		var prevold = -1;
		var prevnew = -1;
		var newindex = -1;
		
		var news = this._toMap ( newnode.childNodes, true );
		var olds = this._toMap ( oldnode.childNodes, true );
		
		for ( var id in olds ) {
			if ( result ) {
				var oldindex = olds [ id ];
				result = oldindex >= prevold;
				if ( news [ id ] != null ) {
					newindex = news [ id ];
					result = newindex >= prevnew;
				}
			}
			prevold = oldindex;
			if ( newindex >-1 ) {
				prevnew = newindex;
			}
		}
		
		return result;
	},
	
	/**
	 * @param {Element} newnode
	 * @param {Element} oldnode
	 * @return {boolean}
	 */
	_updateSoftChildren : function ( newnode, oldnode ) {
		
		var news = this._toMap ( newnode.childNodes );
		var olds = this._toMap ( oldnode.childNodes );
		
		for ( var id in olds ) {
			if ( news [ id ] == null ) {
				this.addUpdate (
					new SiblingUpdate ( Update.TYPE_REMOVE, id, null, null ) 
				);
			} else {
				this._crawl ( news [ id ], olds [ id ]); // crawling continued here!
			}
		}
		var previd = null;
		for ( id in news ) {
			if ( olds [ id ] == null ) {
				var xmlelement = news [ id ];
				if ( previd == null ) { // TODO: refactor this tedious fork
					var parentid = oldnode.getAttribute ( "id" );
					this.addUpdate (
						new SiblingUpdate ( Update.TYPE_INSERT, parentid, xmlelement, true ) 
					);
				} else {
					this.addUpdate (
						new SiblingUpdate ( Update.TYPE_INSERT, previd, xmlelement, false ) 
					);
				}
			}
			previd = id;
		}
	},
	
	/**
	 * Add update.
	 * @param {Update} update
	 */
	addUpdate : function ( update ) {
		
		this._updates.push ( update );
		if ( update instanceof ReplaceUpdate ) {
			this._replaced [ update.id ] = true;
		}
	},
	
	/**
	 * @param {Element} element
	 * @param {Element} oldelement
	 * @return {object}
	 */
	_getPlugin : function ( element, oldelement ) {
		
		var result = null;
		this.plugins.every ( function ( plugin ) {
			if ( plugin.handleElement ( element, oldelement )) {
				result = plugin;
			}
			return result == null;
		});
		return result;
	},
	
	/**
	 * Convert an nodelist into an ID-to-element or ID-to-index hashmap.
	 * @param {NodeList<Node>} nodes
	 * @return {object<String><Element>}
	 */
	_toMap : function ( nodes, isIndex ) {
		
		var result = {};
		Array.forEach ( nodes, function ( node, index ) {
			if ( node.nodeType == Node.ELEMENT_NODE ) {
				result [ node.getAttribute ( "id" )] = isIndex ? index : node;
			}
		});
		return result;
	},
	
	/**
	 * Harvest form elements.
	 * @param {HTMLFormElement} form
	 * @return {string}
	 */
	_getPost : function ( form ) {
		
		var result = new String ( "" );
		
		if ( form != null ) {
			var last = "";
			Array.forEach ( form.elements, function ( element ) {
				
				var name = element.name;
				var value = encodeURIComponent ( element.value );
				
				switch ( element.type ) {
						
					case "button" :
					case "submit" :
						var active = UpdateAssistant.getActiveElement ();
						if ( element == active && name!= "" ) {
							result += name + "=" + value + "&";
						}
						break;
						
					case "radio":
						if ( element.checked ) {
							result += name + "=" + value + "&";
						}
						break;
						
					case "checkbox":
						if ( element.checked ) {
							if ( element.name == last ) {
								if ( result.lastIndexOf ( "&" ) == result.length - 1 ) {
									result = result.substr ( 0, result.length - 1 );
								}
								result += "," + value;
							}
							else {
								result += name + "=" + element.value;
							}
							last = name;
							result += "&"; 
						}
						break;
						
					case "text":
					case "hidden":
					case "password":
					case "textarea":
					case "select-one" :
						result += name + "=" + value + "&";
						break;
				}
			});
		}
		
		return result.substr ( 0, result.length - 1 );
	},
	
	/**
	 * Post form data and parse document response.
	 * @param {HTMLFormElement} form
	 */
	_postRequest : function ( form ) {
		
		// collect post data
		var method = form.method != "" ? form.method : "get";
		var action = form.action != "" ? form.action : window.location.toString ();
		var format = this._getPost ( form );
		
		if ( method == "get" ) {
			if ( action.indexOf ( "?" ) >-1 ) {
				action = action + "&" + format;
			} else {
				action + "?" + format;
			}
		}
		
		// invoke request
		var _this = this;
		var request = UpdateAssistant.getXMLHttpRequest ( method, action, this );
		if ( method == "post" ) {
			request.setRequestHeader ( "Content-Type", "application/x-www-form-urlencoded" );
		}
		
		request.send ( method == "post" ? format : null );
	},
	
	/**
	 * ASP.NET requires viewstate and eventvalidation to be updated on each  
	 * page update, even though they may not be placed inside an updatezone.
	 * @param {Document} dom  
	 * @param {string} id
	 */
	_fixdotnet : function ( dom, id ) {
		
		var input = document.getElementById ( id );
		if ( input != null ) {
			var nextinput = UpdateAssistant.getElementById ( dom, id );
			if ( nextinput != null ) {
				var value = nextinput.getAttribute ( "value" );
				if ( value !== input.value ) {
					input.value = value;
				}
			}
		}
	},
	
	/** 
	 * Debug something. Does nothing by default, but while developing 
	 * you can yield an alert by flipping the isDebugging property.
	 * @param {string} out
	 */
	debug : function ( out ) {
		
		if ( this.isDebugging ) {
			alert ( "UpdateManager dysfunction. \n\n" + out );
		}
	},
	
	/** 
	 * Debug something that went wrong. You can tap into  
	 * the dispatched DOM event in order to handle the error.
	 * @param {string} out
	 */
	error : function ( out ) {

		this.errorsmessage = out;
		UpdateAssistant.dispatchEvent ( document.documentElement, UpdateManager.EVENT_ERRORUPDATE );
		this.debug ( out );
	},
	
	/**
	 * Append update info to the "summary" property.  
	 * @param {string} string This should be a one-liner.
	 */
	report : function ( string ) {
		
		this.summary += string + "\n";
	}
};

/*
 * The single working instance is declared here. Notice no _underscore!
 */
var UpdateManager = new _UpdateManager ();

/*
 * ----------------------------------------------------------------------------
 * "THE BEER-WARE LICENSE" (Revised):
 * Composite.NET wrote this file. As long as you retain this notice 
 * you can do whatever you want with this stuff. If we meet some day, 
 * and you think this stuff is worth it, you can buy us a beer in return.
 * ----------------------------------------------------------------------------
 */

/**
 * This fellow has nifty utility functions that may come in handy for the UpdateManager.  
 * This has been coded as a newable class to maximize visibility in your JS-aware IDE, 
 * but there should in fact be only one instance running: It is declared near the end 
 * of this file (scroll down) and accessed through instance variable "UpdateAssistant".
 */
function _UpdateAssistant () {
	
	var instance = null;
	if ( !window.UpdateAssistant ) {
		this._construct ();
		instance = this;
	}
	return instance;
}

_UpdateAssistant.prototype = {
	
	/**
	 * XML serializer.
	 * @type {XMLSerializer}
	 */
	_serializer : 
		window.XMLSerializer != null ? 
		new XMLSerializer () : 
		null,
	
	/**
	 * DOM parser.
	 * @type {DOMParser}
	 */
	_parser : 
		window.DOMParser != null ? 
		new DOMParser () : 
		null,
		
	/**
	 * Used to emulating document.activeElement for non-supporting browsers. 
	 * @type {Element}
	 */
	_activeElement : null,
		
	/**
	 * Constructor action. Tuning the DOM and JS engines while 
	 * patching sketchy WebKit implementation of activeElement. 
	 */
	_construct : function () {
		
		// DOM Node interface
		if ( !window.Node ) {
			window.Node = { ELEMENT_NODE : 1, TEXT_NODE : 3, DOCUMENT_NODE : 9 };
		}
		
		// Array.every
		if ( !Array.every ) {
			Array.every = function ( array, fun ) {
				var result = true;
				var len = array.length >>> 0;
				if ( typeof fun != "function" ) {
					throw new TypeError ();
				} else {
					var thisp = arguments [ 2 ];
					for ( var i = 0; i < len; i++ ) {
						if ( typeof array [ i ] != "undefined" ) {
							if ( !fun.call ( thisp, array [ i ], i, array )) {
								result = false;
								break;
							}
						}
					}
				}
				return result;
			};
		}
		
		// Array.prototype.every
		if ( !Array.prototype.every ) {
			Array.prototype.every = function ( fun ) {
				var thisp = arguments [ 1 ];
				return Array.every ( this, fun, thisp );
			}; 
		}
		
		// Array.forEeach
		if ( !Array.forEach ) {
			Array.forEach = function ( array, fun ) {
				var len = array.length >>> 0;
				if ( typeof fun != "function" ) {
					throw new TypeError ();
				} else {
					var thisp = arguments [ 2 ];
					for ( var i = 0; i < len; i++ ) {
						if ( typeof array [ i ] != "undefined" ) {
							fun.call ( thisp, array [ i ], i, array );
						}
					}
				}
			};
		}
		
		// Array.prototype.forEeach
		if ( !Array.prototype.forEach ) {
			Array.prototype.forEach = function ( fun ) {
				var thisp = arguments [ 1 ];
				Array.forEach ( this, fun, thisp );
			}; 
		}
		
		// String.prototype.trip
		if ( !String.prototype.trim ) {
			String.prototype.trim = function () {
				return this.replace ( /^\s*/, "" ).replace ( /\s*$/, "" );
			};
		}
		
		// tracking active element for current Webkit and old Firefox versions. 
		// mousedown is needed becuase WebKit buttons are bugged and do not focus.
		if ( document.addEventListener != null ) {
			document.addEventListener ( "focus", this, false );
			document.addEventListener ( "blur", this, false );
			document.addEventListener ( "mousedown", this, false );
		}
	},
	
	/**
	 * Tracking and hacking the active element; retrieved using method getActiveElement.
	 * @param {Event} e
	 */
	handleEvent : function ( e ) {
		
		switch ( e.type ) {
			case "focus" :
			case "mousedown" :
				this._activeElement = e.target;
				break;
			case "blur" :
				if ( this._activeElement == e.target ) {
					this._activeElement = null;
				}
				break;
		}
	},
	
	/**
	 * Build a XMLHttpRequest.
	 * TODO: This is used in multiple scenarios, but hacked to fit one in particular.
	 * @param {String} method
	 * @param {String} target
	 * @param {object} handler
	 * @return {XMLHttpRequest}
	 */
	getXMLHttpRequest : function ( method, target, handler ) {
		
		var request = window.XMLHttpRequest ? new XMLHttpRequest () : new ActiveXObject ( "Msxml2.XMLHTTP.3.0" );
		
		if ( request != null ) {
			request.open ( method, target, ( handler != null ? true : false ));	
			if ( handler != null ) {
				function action () {
					if ( request.readyState == 4 ) {
						var text = request.responseText;
						UpdateManager.pendingResponse = text;	
						var dom = UpdateAssistant.parse ( text );
						if ( dom != null ) {
							handler.handleResponse ( dom );
						}
					}
				}
				/*
				 * TODO: Does IE9 beta entere first case? 
				 * And if yes - does this work?
				 */
				if ( request.addEventListener != null ) {
					request.addEventListener ( "readystatechange", {
						handleEvent : function () {
							action ();
						}
					}, false );
				} else {
					request.onreadystatechange = action;
				}
			}
		}
		return request;
	},
	
	/**
	 * Dispatch bubbling DOM event. Note that IE does not accept  
	 * document nodes or window objects as targets for the event.
	 * @param {Element} element
	 * @param {String} name
	 * @return {boolean} Returns false if event was canceled
	 */
	dispatchEvent : function ( element, name ) {
		
		var result = true;
		if ( element.fireEvent != null ) {
			result = element.fireEvent ( "on" + name );
		} else {
			var event = document.createEvent ( "UIEvents" );
			event.initEvent ( name, true, true );
			result = element.dispatchEvent ( event );
		}
		return result;
	},
	
	/**
	 * Locate update zones in given document context.
	 * @param {Document} dom
	 * @return {Array<Element>}
	 */
	getUpdateZones : function ( dom ) {
		
		var xpath = "//*[@id and contains(@class,'updatezone')]";
		var result = []; 
		var search = null;
		var element = null;
		
		if ( window.XPathResult != null ) {
			var type = XPathResult.ORDERED_NODE_ITERATOR_TYPE;
			search = dom.evaluate ( xpath, dom, null, type, null );
			while (( element = search.iterateNext ()) != null ) {
				result.push ( element );
			}
		} else {
			search = dom.documentElement.selectNodes ( xpath );
			Array.forEach ( search, function ( element ) {
				result.push ( element );
			});
		}
		return result;
	},
	
	/**
	 * Get element by ID in given document context.
	 * @param {Document} dom
	 * @param {String} id
	 * @return {Element}
	 */
	getElementById : function ( dom, id ) {
		
		var xpath = "//*[@id='" + id + "']";
		var search = null;
		var result = null;
		
		if ( window.XPathResult != null ) {
			var type = XPathResult.FIRST_ORDERED_NODE_TYPE;
			search = dom.evaluate ( xpath, dom, null, type, null );
			result = search.singleNodeValue;
		} else {
			result = dom.documentElement.selectNodes ( xpath )[ 0 ];
		}
		return result;
	},
	
	/**
	 * Collect all id attributes used in a document so that  
	 * we can check for multiple occurances of the same id. 
	 * @param {Document} dom
	 * @return {Array<String>}
	 */
	_getIds : function ( dom ) {
		
		var xpath = "//*[@id]";
		var search = null;
		var result = [];
		
		if ( window.XPathResult != null ) {
			var type = XPathResult.ORDERED_NODE_ITERATOR_TYPE;
			search = dom.evaluate ( xpath, dom, null, type, null );
			while (( element = search.iterateNext ()) != null ) {
				result.push ( element.getAttribute ( "id" ));
			}
		} else {
			search = dom.documentElement.selectNodes ( xpath );
			Array.forEach ( search, function ( element ) {
				result.push ( element.getAttribute ( "id" ));
			});
		}
		return result;
	},
	
	/**
	 * Transform an "abstract" XML DOM element into a HTML element. 
	 * Method document.importNode can not be used in Firefox, it 
	 * will break stuff such as the document.forms object.
	 * @param {Element} element
	 */
	toHTMLElement : function ( element ) {
		
		var markup = this.serialize ( element );
		var temp = document.createElement ( "temp" );
		temp.innerHTML = markup;
		return temp.firstChild;
	},
	
	/**
	 * Patching a bug or questionable feature in Webkit where document   
	 * activeElement is only supported for input and textarea elements. 
	 * bugs.webkit.org/show_bug.cgi?id=28630 
	 * bugs.webkit.org/show_bug.cgi?id=22261
	 * @return {Element}
	 */
	getActiveElement : function () {
		
		var result = document.activeElement;
		if ( result == null || result == document.body ) {
			result = this._activeElement; 
		}
		return result;
	},
	
	/**
	 * Serialize DOM intro XML string.
	 * @param {Element} element
	 * @return {String}
	 */
	serialize : function ( element ) {
		
		/*
		 * Note to C1 developers: This method gets the  
		 * overwrite treatment in DocumentUpdatePlugin.js!
		 */
		var result = null;
		if ( this._serializer != null ) {
			result = this._serializer.serializeToString ( element );
		} else {
			result = element.xml;
		}
		return result;
	},
	
	/**
	 * This is never used by the UpdateManager itself, but plugins may 
	 * use this service to see if any two XML elements are different.
	 * @param {Element} newelement
	 * @param {Element} oldelement
	 * @return {boolean}
	 */
	hasDifferences : function ( newelement, oldelement ) {
		
		var s1 = null;
		var s2 = null;
		if ( this._serializer != null ) {
			s1 = this._serializer.serializeToString ( newelement );
			s2 = this._serializer.serializeToString ( oldelement );
		} else {
			s1 = newelement.xml;
			s2 = oldelement.xml;
		}
		return s1 != s2;
	},
	
	/**
	 * Parse XML string into DOM document.
	 * @param {String} markup
	 * @return {Document}
	 */
	parse : function ( markup ) {
	
		var result = null;
		if ( this._parser != null ) {
			result = this._parser.parseFromString ( markup, "text/xml" );
		} else {
			result = new ActiveXObject ( "Msxml2.DOMDocument.3.0" );
			result.setProperty ( "SelectionLanguage", "XPath" );
			result.loadXML ( markup );
		}
		return this._validate ( result );
	},
	
	/**
	 * Validate document and return it. UpdateManager.isDebugging can be  
	 * set to true in order to get notified about these possible errors:  
	 * 1) The XHTML is not well-formed
	 * 2) There are multiple elements with the same id
	 * @param {Document} dom
	 * @return {Document}
	 */
	_validate : function ( dom ) {
		
		var out = null;
		if ( dom.parseError != null && dom.parseError.errorCode != 0 ) {
			out = dom.parseError.reason;
		} else {
			var error = dom.getElementsByTagName ( "parsererror" ).item ( 0 );
			if ( error != null ) {
				out = error.textContent.
					replace ( /\^/g, "" ).
					replace ( /\-/g, "" );
			}
		}
		if ( out == null ) {
			var has = {}, ids = this._getIds ( dom );
			ids.every ( function ( id ) {
				var result = !has [ id ];
				has [ id ] = true;
				if ( !result ) {
					out = "Element \"" + id + "\" encountered twice.";
				}
				return result;
			});
		}
		if ( out != null ) {
			UpdateManager.error ( out );
			dom = null;
		}
		return dom;
	}
};

/*
 * The single working instance is declared here!
 */
var UpdateAssistant = new _UpdateAssistant ();

/*
 * ----------------------------------------------------------------------------
 * "THE BEER-WARE LICENSE" (Revised):
 * Composite.NET wrote this file. As long as you retain this notice 
 * you can do whatever you want with this stuff. If we meet some day, 
 * and you think this stuff is worth it, you can buy us a beer in return.
 * ----------------------------------------------------------------------------
 */

/* 
 * A plugin may be registered like this - note the optional compact syntax: 
 * 
 * UpdateManager.plugins.push ({
 * 		handleElement : function ( element ) { return true; },
 * 		updateElement : function ( element ) { return false; }
 * });
 */

/**
 * Handle input and textarea elements (with an ID attribute specified). 
 * The plugin is registered with the UpdateManager in the end of this file. 
 */
function UpdatePlugin () {
		
	/**
	 * Handle element? Return true to invoke method updateElement below.
	 * @param {Element} element Remember, this is an XML element, not HTML
	 * @param {Element} oldelement
	 * @return {boolean} 
	 */
	this.handleElement = function ( element, oldelement ) {
		
		var result = false;
		
		switch ( element.nodeName.toLowerCase ()) {
			
			case "input" :
			case "textarea" :
				
				/*
				 * By default, we handle any input element with a given ID. 
				 * Special input IDs are better left to the UpdateManager.
				 * We have ASP.NET hardcoded into this stuff, so you may 
				 * choose to adapt the setup to any preferred framework.
				 */
				switch ( element.getAttribute ( "id" )) {
					case "__EVENTTARGET" :
					case "__EVENTARGUMENT" :
					case "__VIEWSTATE" :
					case "__EVENTVALIDATION" :
						result = false;
						break;
				}
				break;
		}
		return result;
	};
	
	/**
	 * Update element. Return true if the UpdateManager should stop 
	 * crawling the DOM subtree in search for further updates.
	 * @param {Element} element
	 * @param {Element} oldelement
	 * @return {boolean} True to stop crawling
	 */
	this.updateElement = function ( element, oldelement ) {
		
		/*
		 * Compare the server XML response to the actual HTML input 
		 * field values on page. If the server sends another value, 
		 * we assume that it REALLY wants to update fields values.
		 */
		var id = element.getAttribute ( "id" );
		var input = document.getElementById ( id );
		if ( input != null ) {
			var value = null;
			switch ( input.nodeName.toLowerCase ()) {
				case "input" :
					value = element.getAttribute ( "value" );
					break;
				case "textarea" :
					value = element.textContent ? element.textContent : element.text;
					break;
			}
			
			/*
			 * Fallback value.
			 */
			if ( value == null ) {
				value = "";
			}
			
			/*
			 * TODO: Other attributes could have been  
			 * updated, they are now skipped completely!!!
			 */
			if ( value != input.value ) {
				input.value = value; 
				UpdateManager.report ( "Property [value] updated on field \"" + id  + "\"" );
			}
		}
		
		/*
		 * Return true to stop crawling (no need for input and textarea). 
		 * False will come in handy if you choose to do a ReplaceUpdate...
		 */
		return true;
	};
};

/**
 * Register plugin.
 */
UpdateManager.plugins.push ( new UpdatePlugin ());


/*
 * ----------------------------------------------------------------------------
 * "THE BEER-WARE LICENSE" (Revised):
 * Composite.NET wrote this file. As long as you retain this notice 
 * you can do whatever you want with this stuff. If we meet some day, 
 * and you think this stuff is worth it, you can buy us a beer in return.
 * ----------------------------------------------------------------------------
 */

/**
 * Default replacement update with which a section of the  
 * DOM subtree is simply replaced with something new. 
 * {@see ReplaceUpdate}
 * @type {String}
 */
Update.TYPE_REPLACE = "replace";

/**
 * Optional attribute update. Using this, elements may have their 
 * attributes updated without replacing the element DOM branch. 
 * The element must have a id attribute specified for this to work. 
 * {@see UpdateManager#hasSoftAttributes}
 * {@see AttributesUpdate}
 * @type {String}
 */
Update.TYPE_ATTRIBUTES = "attributes";

/**
 * Optional removal update: Removes a child without replacing the parent. 
 * Child siblings must all be elements and they must all have an id specified.
 * {@see UpdateManager#hasSoftSiblings}
 * {@see SiblingUpdate}
 * @type {String}
 */
Update.TYPE_REMOVE = "remove";

/**
 * Optional insertion update: Inserts a child without replacing the parent.
 * Child siblings must all be elements and they must all have an id specified.
 * {@see UpdateManager#hasSoftSiblings}
 * {@see SiblingUpdate}
 * @type {String}
 */
Update.TYPE_INSERT = "insert";

/**
 * This event is dispatched before an update. Event target depends on update type: 
 *   "replace" - event target is about to be deleted.
 *   "attributes" - event target is going to have attributes updated.
 *   "remove" - event target is about to be deleted.
 *   "insert" - event target is the PARENT node of an expected child.
 * @see {Update#_beforeUpdate}
 * @type {String}
 */
Update.EVENT_BEFOREUPDATE = "beforeupdate";

/**
 * This event is dispatched after an update. Event target depends on update type:
 *   "replace" - event target was just inserted.
 *   "attributes" - event target just had some attributes updated.
 *   "remove" - event target is the PARENT node of a deleted child.
 *   "insert" - event target was just inserted. 
 * @see {Update#_afterUpdate}
 * @type {String}
 */
Update.EVENT_AFTERUPDATE  = "afterupdate";

/**
 * The action is all about the subclasses.
 * @see {ReplaceUpdate}
 * @see {AttributesUpdate}
 * @see {SiblingUpdate}
 */
function Update () {
	
	return this;
}

Update.prototype = {
	
	/**
	 * Update type.
	 * @type {String}
	 */
	type : null,
	
	/**
	 * Identifies each unique Update instance.
	 * @see {UpdateManager#getUpdate}
	 * @type {String}
	 */
	key : null,
	
	/**
	 * Id of the current page element that is about to be updated.
	 * @type {String}
	 */
	id : null,
	
	/**
	 * The (XML) element used to replace or otherwise update the current element. 
	 * @type {Element}
	 */
	element : null,
	
	/**
	 * The update method performs the actual update. Count on methods  
	 * _beforeUpdate and _afterUpdate to be invoked at this pount.
	 */
	update : function () {},

	/**
	 * Better not keep references to any DOM element around here.
	 */
	dispose : function () {
		
		this.element = null;
	},
	
	/**
	 * When something changed, dispatch pre-update event. 
	 * The __updateType expando property can be used to act on this. 
	 * @param {Element} element
	 * @return {boolean}
	 */
	_beforeUpdate : function ( element ) {
		
		var result = true;
		if ( element != null ) {
			element.__updateType = this.type;
			result = UpdateAssistant.dispatchEvent ( element, Update.EVENT_BEFOREUPDATE );
		}
		return result;
	},
	
	/**
	 * When something changed, dispatch post-update event. 
	 * The __updateType expando property can be used to act on this.
	 * @param {Element} element
	 * @return {boolean}
	 */
	_afterUpdate : function ( element ) {
		
		var result = true;
		if ( element != null ) {
			element.__updateType = this.type;
			result = UpdateAssistant.dispatchEvent ( element, Update.EVENT_AFTERUPDATE );
		}
		return result;
	}
};

/*
 * ----------------------------------------------------------------------------
 * "THE BEER-WARE LICENSE" (Revised):
 * Composite.NET wrote this file. As long as you retain this notice 
 * you can do whatever you want with this stuff. If we meet some day, 
 * and you think this stuff is worth it, you can buy us a beer in return.
 * ----------------------------------------------------------------------------
 */

ReplaceUpdate.prototype = new Update ();
ReplaceUpdate.superclass = Update.prototype;

/**
 * Simple update.
 * @param {String} id
 * @param {Element} element
 */
function ReplaceUpdate ( id, element ) {
	
	this.type = Update.TYPE_REPLACE;
	this.id = id;
	this.element = element;
	return this;
}

/**
 * Replace current element with new element.
 */
ReplaceUpdate.prototype.update = function () {
	
	var target, container, update = UpdateAssistant.toHTMLElement ( this.element );
	
	if (( target = document.getElementById ( this.id )) != null ) {
		if (( container = target.parentNode ) != null ) {
			if ( this._beforeUpdate ( target )) {
				container.replaceChild ( update, target );	
				this._afterUpdate ( update );
			}
		}
	} else {
		UpdateManager.error ( "Element null point: " + this.id );
	}
};

/**
 * @param {Element} element
 * @return {boolean}
 */
ReplaceUpdate.prototype._afterUpdate = function ( element ) {
	
	var result = ReplaceUpdate.superclass._afterUpdate.call ( this, element );
	UpdateManager.report ( "Replaced element id=\"" + this.id + "\"" );
	if ( element.nodeName == "form" || element.getElementsByTagName ( "form" ).item ( 0 ) != null ) {
		UpdateManager.setupForms ();
	}
	return result;
}

/*
 * ----------------------------------------------------------------------------
 * "THE BEER-WARE LICENSE" (Revised):
 * Composite.NET wrote this file. As long as you retain this notice 
 * you can do whatever you want with this stuff. If we meet some day, 
 * and you think this stuff is worth it, you can buy us a beer in return.
 * ----------------------------------------------------------------------------
 */

SiblingUpdate.prototype = new Update ();
SiblingUpdate.superclass = Update.prototype;

/**
 * Sibling update.
 * @param {String} type
 * @param {String} id
 * @param {Element} element
 * @return
 */
function SiblingUpdate ( type, id, element, isFirst ) {
	
	this.type = type;
	this.id = id;
	this.element = element;
	this.isFirst = isFirst;
	return this;
}

/**
 * Update by either inserting or removing an element.
 */
SiblingUpdate.prototype.update = function () {
		
	var element = document.getElementById ( this.id );
	
	switch ( this.type ) {
		case Update.TYPE_REMOVE :
			this._remove ( element );
			break;		
		case Update.TYPE_INSERT :
			this._insert ( this.element, element );
			break;
	}
};

/**
 * Remove element.
 * @param {Element} element
 * @return
 */
SiblingUpdate.prototype._remove = function ( element ) {
	
	var parent = element.parentNode;
	if ( parent != null ) {
		if ( this._beforeUpdate ( element )) {
			parent.removeChild ( element );
			this._afterUpdate ( parent );
		}
	}
};

/**
 * Insert new element after existing element.
 * @param {Element} element The new (XML) element
 * @param {Element} otherelement An existing (HTML) element
 * @return
 */
SiblingUpdate.prototype._insert = function ( element, otherelement ) {
	
	var update = UpdateAssistant.toHTMLElement ( element );
	
	if ( this.isFirst ) {
		var parent = otherelement;
		if ( parent != null ) {
			if ( this._beforeUpdate ( parent )) {
				parent.insertBefore ( update, parent.firstChild );
				this._afterUpdate ( update );
			}
		}
	} else {
		var parent = otherelement.parentNode;
		if ( parent != null ) {
			if ( this._beforeUpdate ( parent )) {
				parent.insertBefore ( update, otherelement.nextSibling );
				this._afterUpdate ( update );
			}
		}
	}
};

/**
 * @param {Element} element
 */
SiblingUpdate.prototype._beforeUpdate = function ( element ) {
	
	var result = SiblingUpdate.superclass._beforeUpdate.call ( this, element );
	if ( this.type == Update.TYPE_REMOVE ) {
		UpdateManager.report ( "Removed element id=\"" + element.id + "\"" );
	}
	return result;
};

/**
 * @param {Element} element
 */
SiblingUpdate.prototype._afterUpdate = function ( element ) {
	
	var result = true;
	if ( element != null ) {
		result = SiblingUpdate.superclass._afterUpdate.call ( this, element );
		if ( this.type == Update.TYPE_INSERT ) {
			UpdateManager.report ( "Inserted element id=\"" + element.id + "\"" );
			if ( element.nodeName == "form" || element.getElementsByTagName ( "form" ).item ( 0 ) != null ) {
				UpdateManager.setupForms ();
			}
		}
	}
	return result;
};

/*
 * ----------------------------------------------------------------------------
 * "THE BEER-WARE LICENSE" (Revised):
 * Composite.NET wrote this file. As long as you retain this notice 
 * you can do whatever you want with this stuff. If we meet some day, 
 * and you think this stuff is worth it, you can buy us a beer in return.
 * ----------------------------------------------------------------------------
 */

AttributesUpdate.prototype = new Update ();
AttributesUpdate.superclass = Update.prototype;

/**
 * @type {Element}  
 */
AttributesUpdate.prototype.currentElement = null;

/**
 * Remember: The before and after element MUST have same id for this to work.
 * @param {String} type
 * @param {String} id
 * @param {Element} element
 * @return
 */
function AttributesUpdate ( id, element, oldelement ) {
	
	this.type = type = Update.TYPE_ATTRIBUTES;
	this.id = id;
	this.element = element;
	this.currentElement = oldelement;
	this._summary = [];
	return this;
}

/**
 * Update attributes.
 */
AttributesUpdate.prototype.update = function () {
	
	var element = document.getElementById ( this.id );
	if ( this._beforeUpdate ( element )) {
		this._updateAttributes ( element );
		this._afterUpdate ( element );
	}
};

/**
 * Performs the actual attribute synchronization.
 */
AttributesUpdate.prototype._updateAttributes = function ( element ) {
	
	// add and update attributes
	Array.forEach ( this.element.attributes, function ( newatt ) {
		var oldatt = this.currentElement.getAttribute ( newatt.nodeName );
		if ( oldatt == null || oldatt != newatt.nodeValue ) {
			this._setAttribute ( element, newatt.nodeName, newatt.nodeValue );
			this._summary.push ( "@" + newatt.nodeName );
		}
	}, this );
	
	// delete attributes
	Array.forEach ( this.currentElement.attributes, function ( oldatt ) {
		if ( this.element.getAttribute ( oldatt.nodeName ) == null ) {
			this._setAttribute ( element, oldatt.nodeName, null );
			this._summary.push ( "@" + oldatt.nodeName );
		}
	}, this );
};

/**
 * Set element attribute. For Internet Explorer, this may not be as simple as it sounds. 
 * @param {Element} element
 * @param {String} name
 * @param {String} value
 * @return
 */
AttributesUpdate.prototype._setAttribute = function ( element, name, value ) {
	
	
	if ( element == null ) {
		// id_FlowUI$Document$DocumentBody$TabPanels_lazybindingactivated2
		alert ( this.id + ": " + document.getElementById ( this.id )+ "\n\n" + name + "=" + value )
		SystemLogger.getLogger ( "AttributesUpdate" ).fine ( document.body.innerHTML )
	}
	
	
	var isDel = ( value == null );
	
	if ( isDel ) {
		element.removeAttribute ( name );
	} else {
		element.setAttribute ( name, value );
	}
	
	if ( document.all != null ) { // TODO: Think of more properties on the IE handicap list?
		if ( isDel ) {
			value = "";
		}
		switch ( name.toLowerCase ()) {
			
			/*
			 * Since matching IDs is a prerequisite for this to   
			 * happen, we don't need to hack support for ID updates.
			 */
			
			case "class" :
				element.className = value;
				break;
			case "disabled" :
				element.disabled = !isDel;
				break;
			case "checked" :
				element.checked = !isDel;
				break;
			case "readonly" :
				element.readOnly = !isDel;
				break;
		}
	}
};

/**
 * @overloads {Update#_afterUpdate}
 * @param {Element} element
 */
AttributesUpdate.prototype._afterUpdate = function ( element ) {
	
	AttributesUpdate.superclass._afterUpdate.call ( this, element );
	UpdateManager.report ( "Attributes updated on element id=\"" + this.id + "\": " + this._summary.toString ());
}

/**
 * Better not keep a reference to any DOM element around here.
 * @overloads {Update#dispose}
 */
AttributesUpdate.prototype.dispose = function () {
	
	Update.prototype.dispose.call ( this );
	this.currentElement = null;
};

/*
 * Pseudoimplement DOM2 Node interface.
 */
if ( !window.Node ) {
	window.Node = {
		ELEMENT_NODE				: 1,
		ATTRIBUTE_NODE				: 2,
		TEXT_NODE					: 3,
		CDATA_SECTION_NODE			: 4,
		ENTITY_REFERENCE_NODE		: 5,
		ENTITY_NODE					: 6,
		PROCESSING_INSTRUCTION_NODE	: 7,
		COMMENT_NODE				: 8,
		DOCUMENT_NODE				: 9,
		DOCUMENT_TYPE_NODE			: 10,
		DOCUMENT_FRAGMENT_NODE		: 11,
		NOTATION_NODE				: 12
	};
}

/*
 * Clone Java Swing KeyEvent interface.
 * TODO: investigate ALT and INSERT.
 */
window.KeyEventCodes = {
	
	VK_BACK						: 8,
	VK_TAB						: 9,
	VK_ENTER					: 13,
	VK_SHIFT					: 16,
	VK_CONTROL					: 17,
	VK_ALT						: null,
	VK_ESCAPE					: 27,
	VK_SPACE					: 32,
	VK_PAGE_UP					: 33,
	VK_PAGE_DOWN				: 34,
	VK_END						: 35,
	VK_HOME						: 36,
	VK_LEFT						: 37,
	VK_UP						: 38,
	VK_RIGHT					: 39,
	VK_DOWN						: 40,
	VK_INSERT					: null,
	VK_DELETE					: 127,
	VK_PLUS						: 187,
	VK_MINUS					: 189,
	VK_NUMPLUS					: 107,
	VK_NUMMINUS					: 109,
	VK_F1						: 112
};

/**
 * Global pointer to the root application window object. 
 * Please don't use too many of these global variables! 
 * @type {DOMDocumentView>
 */
if ( window == top ) {
	window.app = this;
} else {
	window.app = top.app;
}

/**
 * All bindings with a specified ID will be mapped here. 
 * @see {Binding#_updateBindingMap}
 * @type {HashMap<string><Binding>
 */
window.bindingMap = {};

/** 
 * @see {Application#framework}
 * @type {StandardEventHandler}
 */
window.standardEventHandler = null;

/*
 * Localize top level objects. From this point on, top level 
 * objects may be addressed without the "top" notation. This  
 * requires that the object is named identically to the file 
 * that loads it (Java convention). See ScriptLoaderControl.
 */
if ( window != window.top ) {
	
	top.Application.declareTopLocal ( window );
}

/*
 * Uncomment this to hunt down stray alerts.
 * 
new function () {
	var oldalert = window.alert;
	window.alert = function ( string ) {
		SystemLogger.getLogger ( "window.alert" ).debug ( string );
		oldalert ( string );
		SystemDebug.stack ( arguments );
	}
}
*/

/**
 * Accessed through instance variable "WindowManager" declared below.
 */
function _WindowManager () {
	
	this._construct ( KeyMaster.getUniqueKey ());
}

_WindowManager.prototype = {
		
	/*
	 * TODO: These are not really constants any more.
	 */
	WINDOW_LOADED_BROADCAST		: null,
	WINDOW_UNLOADED_BROADCAST	: null,
	WINDOW_EVALUATED_BROADCAST	: null,
	WINDOW_RESIZED_BROADCAST 	: null,
	
	/**
	 * @type {boolean}
	 */
	isWindowLoaded : false,
	
	_logger						: SystemLogger.getLogger ( "WindowManager [" + document.title + "]" ),
	_ondomstatements 			: new List (),
	_onloadstatements 			: new List (),
	_onresizestatements 		: new List (),
	
	_currentDimensions			: null,
	_newDimensions				: null,
	_broadcastTimeout			: null,
	_isHorizontalResize 		: false,
	_isVerticalResize 			: false,
	_broadcastTimeout			: null,
	
	/**
	 * Using unique key to compute various other keys.
	 * @param {string} string
	 * @return {string} 
	 */
	_compute : function ( string, key ) {
	
		return string.replace ( "${windowkey}", document.location + ":" + key );
	},
	
	/**
	 * Constructor action.
	 */
	_construct : function ( key ) {
		
		/*
		 * Define broadcast "constants".
		 */
		this.WINDOW_LOADED_BROADCAST	= this._compute ( BroadcastMessages.$WINKEY_LOADED, key );
		this.WINDOW_UNLOADED_BROADCAST	= this._compute ( BroadcastMessages.$WINKEY_UNLOADED, key );
		this.WINDOW_EVALUATED_BROADCAST	= this._compute ( BroadcastMessages.$WINKEY_EVALUATED, key );
		this.WINDOW_RESIZED_BROADCAST 	= this._compute ( BroadcastMessages.$WINKEY_RESIZED, key );
		
		/*
		 * Action on load and unload.
		 */
		DOMEvents.addEventListener ( window, DOMEvents.DOM, this );
		DOMEvents.addEventListener ( window, DOMEvents.LOAD, this );
		DOMEvents.addEventListener ( window, DOMEvents.UNLOAD, this );
	},
	
	/**
	 * Implements {IEventListener}
	 * @param {Event} e
	 */
	handleEvent : function ( e ) {
	
		switch ( e.type ) {
			
			case DOMEvents.DOM :
				this.onDOMContentLoaded ();
				break;
		
			case DOMEvents.LOAD :
				
				/*
				 * Can this happen twice? 
				 * Maybe descendant frames loading?
				 */
				if ( !this.isWindowLoaded ) {
					
					this.isWindowLoaded = true;
					
					/*
					 * Intercepted by DocumentManager. Register and attach Bindings.
					 */
					EventBroadcaster.broadcast ( this.WINDOW_LOADED_BROADCAST, this );
					
					while ( this._onloadstatements.hasNext ()) {
						this._onloadstatements.getNext ().fireOnLoad ();
					}
					
					/*
					 * Setup resize and unload events.
					 */
					this._currentDimensions = this.getWindowDimensions ();
					DOMEvents.addEventListener ( window, DOMEvents.RESIZE, this );
					EventBroadcaster.broadcast ( this.WINDOW_EVALUATED_BROADCAST, this );
					DOMEvents.removeEventListener ( window, DOMEvents.LOAD, this );
					DOMEvents.stopPropagation ( e );
				}
				break;
				
			case DOMEvents.RESIZE :
			
				/*
				 * Handling the top browser window will consume the mousedown event.
				 * Let's fire a global broadcast to close open menus and stuff.
				 */
				if ( window == top ) {
					EventBroadcaster.broadcast ( BroadcastMessages.MOUSEEVENT_MOUSEDOWN, document.body );
				}
				
				/*
				 * These statements will be executed RIGHT NOW. As of Firefox 3.6, 
				 * this implies that both browsers will fire them a million times 
				 * while resizing.
				 */
				this._onresizestatements.reset ();
				while ( this._onresizestatements.hasNext ()) {
					this._onresizestatements.getNext ().fireOnResize ();
				}
				
				/*
				 * EventBroadcasts are executed after a short timeout. 
				 * The timeout cancels itself on each resize event. 
				 * This will make sure that onresize methods aren't 
				 * executed a million times when user resizes window.
				 */
				this._newDimensions = WindowManager.getWindowDimensions ();
				var isHorizontalResize = this._newDimensions.w != this._currentDimensions.w;
				var isVerticalResize = this._newDimensions.h != this._currentDimensions.h;
				
				if ( isHorizontalResize || isVerticalResize ) {
					if ( this._broadcastTimeout != null ) {
						clearTimeout ( this._broadcastTimeout );
						this._broadcastTimeout = null;
					}
					var self = this;
					this._broadcastTimeout = setTimeout ( function () { 
						self._broadcastResizeEvent ();
					}, 250 );
				}
				break;
				
			case DOMEvents.UNLOAD :
			
				/*
				 * Currently not intercepted by nothing.
				 */
				EventBroadcaster.broadcast ( this.WINDOW_UNLOADED_BROADCAST );
				break;
		}
	},
	
	/**
	 * Broadcast resize event globally. 
	 */
	_broadcastResizeEvent : function () {
		
		clearTimeout ( this._broadcastTimeout );
		this._broadcastTimeout = null;
		EventBroadcaster.broadcast ( this.WINDOW_RESIZED_BROADCAST );
		this._currentDimensions = this._newDimensions;
	},
	
	/**
	 * Add DOMContentLoaded observer.
	 * @param {IDOMHandler} onDomHandler
	 */
	fireOnDOM : function ( onDomHandler ) {
		
		if ( Interfaces.isImplemented ( IDOMHandler, onDomHandler, true )) {
			this._ondomstatements.add ( onDomHandler );
		}
	},
	
	/**
	 * Add onload observer.
	 * @param {ILoadHandler} onLoadHandler
	 */
	fireOnLoad : function ( onLoadHandler ) {
		
		if ( Interfaces.isImplemented ( ILoadHandler, onLoadHandler, true )) {
			this._onloadstatements.add ( onLoadHandler );
		}
	},
	
	/**
	 * Add onresize observer.
	 * @param {IResizeHandler} onResizeHandler
	 */
	fireOnResize : function ( onResizeHandler ) {
		
		if ( Interfaces.isImplemented ( IResizeHandler, onResizeHandler, true )) {
			this._onresizestatements.add ( onResizeHandler );
		}
	},
	
	/**
	 * Note that in IE, this method will be invoked by the WindowAsssitant.
	 * TODO: Will IE9 support DOMContentLoaded event?
	 */
	onDOMContentLoaded : function () {
		
		while ( this._ondomstatements.hasNext ()) {
			this._ondomstatements.getNext ().fireOnDOM ();
		}
	},
	
	/**
	 * @return {Dimension}
	 */
	getWindowDimensions : function () {
	
		return new Dimension (
			Client.isMozilla ? window.innerWidth : document.body.clientWidth,
			Client.isMozilla ? window.innerHeight : document.body.clientHeight
		);
	},
	
	/*
	 * In Mozilla strict error parsing mode, eval must be performed locally  
	 * not to fire a warning. You cannot invoke "anotherWindow.eval(xxx)" ...
	 * http://groups.google.com/group/jquery-en/browse_thread/thread/9e6ed95bce10e2a4
	 * bug #359159 
	 */
	evaluate : function ( string ) {
		return eval ( string );
	}
}

/**
 * The instance that does it.
 * @type {_WindowManager}
 */
var WindowManager = new _WindowManager ();

/**
 * Assist the WindowManager in evaluation of the DOMContentLoaded event in  
 * Internet Explorer. This script is loaded with "defer" attribute, you see.
 */
new function WindowAssistant () {
	
	/*
	 * TODO: Will IE9 support DOMContentLoaded event?
	 */
	if ( Client.isExplorer ) {
		WindowManager.onDOMContentLoaded ();
	}
};


/**
 * Referencing the window object now loading inside the app frame.
 * This get registered as soon as the file "app.aspx" gets loaded.
 * @type {DOMDocumentView}
 */
top.app = null;

/*
TODO: timeout - scope
TODO: lists -scope
TODO: maps -scope
TODO: window.rootBInding / window.pageBinding
*/

/**
 * @class
 * Don't instantiate this class manually. Access through 
 * instance variable "Application" declared below. This 
 * instance should be considered a singleton class.
 */
function _Application () {
	
	this._construct ();
}

_Application.prototype = {
	
	// PUBLIC ..........................................................
	
	/** 
	 * Identifies this management console instance on the server. 
	 * There is a fair chance that no two users get the same ID.
	 * @type {string} 
	 */
	CONSOLE_ID : KeyMaster.getUniqueKey (),
	
	/**
	 * Timeout in milliseconds before we proclaim a global application blur event.
	 * @type {number}
	 */
	_TIMEOUT_LOSTFOCUS : 250,
	
	/** 
	 * @type {SystemLogger} 
	 */
	logger : SystemLogger.getLogger ( "Application" ),
	
	/** 
	 * @type {SystemTimer} 
	 */
	timer : SystemTimer.getTimer ( "Application" ),
	
	/**
	 * Set by ScriptLoaderControl.
	 * @type {boolean}
	 */
	isDeveloperMode : false,
	
	/**
	 * Set by ScriptLoaderControl.
	 * @type {boolean}
	 */
	isLocalHost : false,
	
	/**
	 * Set by ScriptLoaderControl.
	 * @type {boolean}
	 */
	hasExternalConnection : false,
	
	/**
	 * Flipped on login and logout.
	 * @type {boolean}
	 */
	isLoggedIn : false,
	
	/**
	 * Flipped on logout (only).
	 * @type {boolean}
	 */
	isLoggedOut : false,
	
	/** 
	 * @type {boolean} 
	 */
	isLocked : false,
	
	/** 
	 * @type {boolean} 
	 */
	hasStartPage : true,
	
	/**
	 * Flipped when certain critical errors are encountered.
	 * TODO: Is this used?
	 */
	isMalFunctional : false,

	/**
	 * Flipped when the stage is initialized.
	 * @type {boolean} 
	 */
 	isOperational : false,
 	
 	/**
	 * Flipped when top window is closed or reloaded.
	 * @type {boolean} 
	 */
 	isShuttingDown : false,
 	
 	/**
 	 * Indicates that the server was shut down (add-on upgrade or something).
 	 * @type {boolean} 
 	 */
 	isOffLine : false,
 	
 	/**
 	 * True when any window has the focus. To check if NO window has focus, 
 	 * ie the C1 Console has lost focus, better use property "isBlurred". 
 	 * @type {boolean}
 	 */
 	isFocused : true,
 	
 	/**
 	 * True when NO window has had focus for some milliseconds. This will 
 	 * trigger a broadcast of message BroadcastMessages.APPLIATION_BLURRED. 
 	 * Be advised, however, that this setup is highly dysfunctional in IE.
 	 * @type {boolean}
 	 */
 	isBlurred : false,
 	
 	
 	// PRIVATE ..........................................................
 	
	/**
	 * @type {boolean}
	 */
	_isMousePositionTracking : false,
	
	/**
	 * @type {Point}
	 */
	_mousePosition : null,
	
	/**
	 * @type {Point}
	 */
	_cursorStartPoint : null,
	
	/**
	 * @type {boolean}
	 */
	_isDragging : false,
	
	/**
	 * @type {boolean}
	 */
	_isShutDownAllowed : true,
	
	/**
	 * Counting lockers.
	 * @type {int}
	 */
	_lockers : 0,
	
	/**
	 * Used for debug when locking gets stuck.
 	 * @type {HashMap<object><boolean>}
 	 */
 	_lockthings : {},
	
	/**
	 * @type {boolean}
	 */
	_isRegistered : null,
	
	/**
	 * The most recently activated binding.
	 * @type {IActivatable}
	 * @see {DockBinding}
	 * @see {DialogBinding}
	 */
	_activeBinding : null,
	
	/**
	 * Bookkeeping the chronology of activated bindings. Whenever 
	 * a binding looses activation status, this will help us select 
	 * the most appropriate binding to activate next.
	 * @type {List}
	 */
	_activatedBindings : new List (),
	
	/**
	 * Bookkeeping list of dirty tabs.
	 * @type {Map<string><DockTabBinding>}
	 */
	_dirtyTabs : new Map (),
	
	/**
	 * EXPLAIN HERE!
	 */
	_topLevelClasses : typeof topLevelClassNames != "undefined" ? 
			new List ( topLevelClassNames ) : null,
	
		
	// METHODS ..........................................................	
		
	/**
	 * Construct.
	 */
	_construct : function () {
			
		/*
		 * Executed first.
		 */
		EventBroadcaster.subscribe ( WindowManager.WINDOW_EVALUATED_BROADCAST, {
			handleBroadcast : function () {
				try {
					Application.initialize ();
				} catch ( exception ) {
					SystemDebug.stack ( arguments );
					throw ( exception );
				}
			}
		});
		
		/*
		 * Executed on startup if log is open; otherwise called when log opens. 
		 * This cannot be placed in the "SystemLogger.js" because of script 
		 * loading dependancies in the file.
		 * @see {SystemLogPageBinding#onBindingRegister}
		 */
		EventBroadcaster.subscribe ( BroadcastMessages.SYSTEMLOG_OPENED, {
			handleBroadcast : function ( broadcast, outputwindow ) {
				SystemLogger.unsuspend ( outputwindow );
			}
		});
		
		/*
		 * Executed when the systemlog wiew closes.
		 * @see {SystemLogPageBinding#onBindingDispose}
		 */
		EventBroadcaster.subscribe ( BroadcastMessages.SYSTEMLOG_CLOSED, {
			handleBroadcast : function () {
				SystemLogger.suspend ();
			}
		});
		
		/*
		 * Executed last - when the stage is ready and login performed. 
		 * A short timeout prevents an occasional layout bug in Explorer.
		 */
		EventBroadcaster.subscribe ( BroadcastMessages.STAGE_INITIALIZED, {
			handleBroadcast : function () {
				
				/*
				 * Launching system developer panels.
				 */
				if ( Application.isDeveloperMode ) {
					StageBinding.handleViewPresentation ( "Composite.Management.SystemLog" );
					StageBinding.handleViewPresentation ( "Composite.Management.Developer" );
				}
				
				setTimeout ( function () {
					try {
						ProgressBarBinding.notch ( 4 );
						Application.isOperational = true;
						EventBroadcaster.broadcast ( BroadcastMessages.APPLICATION_OPERATIONAL );
					} catch ( exception ) {
						alert ( "Application operational NOT" );
						throw ( exception );
					}
				}, PageBinding.TIMEOUT );
			}
		});
		
		/*
		 * Setup ESCAPE to act as a panic button to close 
		 * the mastercover when a server error occured.
		 */
		EventBroadcaster.subscribe ( BroadcastMessages.KEY_ESCAPE, {
			handleBroadcast : function () {
				if ( Application.isLocked ) {
					Application.unlock ( Application, true );
				}
			}
		});
		
		/**
		 * Flag server offline status.
		 * Probably broadcasted by a {@link SOAPRequest}.
		 * The "Working" cover screen is handled by {@link MessageQueue}
		 */
		EventBroadcaster.subscribe ( BroadcastMessages.SERVER_OFFLINE, {
			handleBroadcast : function () {
				Application.isOffLine = true;
			}
		});
		
		/*
		 * Flag server online status.
		 * Probably broadcasted by a {@link SOAPRequest}
		 */
		EventBroadcaster.subscribe ( BroadcastMessages.SERVER_ONLINE, {
			handleBroadcast : function () {
				Application.isOffLine = false;
			}
		});
		
		/*
		 * Index dirty tab. Enable "save all"  
		 * when first tab is registered dirty.
		 */
		EventBroadcaster.subscribe ( BroadcastMessages.DOCKTAB_DIRTY, {
			handleBroadcast : function ( broadcast, arg ) {
				var list = Application._dirtyTabs;
				list.set ( arg.key, arg );
				if ( list.countEntries () == 1 ) {
					var broadcaster = top.app.bindingMap.broadcasterHasDirtyTabs;
					broadcaster.enable ();
				}
			}
		});
		
		/*
		 * Un-index dirty tab.
		 */
		EventBroadcaster.subscribe ( BroadcastMessages.DOCKTAB_CLEAN, {
			handleBroadcast : function ( broadcast, arg ) {
				var list = Application._dirtyTabs;
				list.del ( arg.key );
				if ( list.countEntries () == 0 ) {
					var broadcaster = top.app.bindingMap.broadcasterHasDirtyTabs;
					broadcaster.disable ();
				}
			}
		});
	},
	
	/**
	 * Identifies.
	 */
	toString : function  () {
		
		return "[Application]";
	},
		
	/**
	 * Login initializes webservices.
	 * @see {KickStart}
	 */
	login : function () {
		
		this.isLoggedIn = true;
		
		ConfigurationService		= WebServiceProxy.createProxy ( Constants.URL_WSDL_CONFIGURATION );
		ConsoleMessageQueueService	= WebServiceProxy.createProxy ( Constants.URL_WSDL_MESSAGEQUEUE );
		EditorConfigurationService 	= WebServiceProxy.createProxy ( Constants.URL_WSDL_EDITORCONFIG );
		FlowControllerService 		= WebServiceProxy.createProxy ( Constants.URL_WSDL_FLOWCONTROLLER );
		StringService				= WebServiceProxy.createProxy ( Constants.URL_WSDL_STRINGSERVICE );
		TreeService					= WebServiceProxy.createProxy ( Constants.URL_WSDL_TREESERVICE );
		SecurityService				= WebServiceProxy.createProxy ( Constants.URL_WSDL_SECURITYSERVICE );
		XhtmlTransformationsService	= WebServiceProxy.createProxy ( Constants.URL_WSDL_XHTMLTRANSFORM );
		LocalizationService			= WebServiceProxy.createProxy ( Constants.URL_WSDL_LOCALIZATION );
		SourceValidationService		= WebServiceProxy.createProxy ( Constants.URL_WSDL_SOURCEVALIDATION );
		MarkupFormatService			= WebServiceProxy.createProxy ( Constants.URL_WSDL_MARKUPFORMAT );
		PageService					= WebServiceProxy.createProxy ( Constants.URL_WSDL_PAGESERVICE );
		
		ProgressBarBinding.notch ( 4 );

		EventBroadcaster.broadcast ( BroadcastMessages.APPLICATION_LOGIN );
	},
	
	/**
	 * Log out. Notice that LogoutService currently returns true no matter what...
	 * @return {boolean}
	 */
	logout : function () {
		
		var result = false;
		if ( this.isLoggedIn ) {
			this.isLoggedIn = false;
			this.isLoggedOut = true;
			result = LoginService.Logout ( true );
			if ( !result ) {
				alert ( "Logout failed." );
			}
		}
		return result;
	},
	
	/**
	 * Blocking all interaction with the application interface. 
	 * We count all lockers so that we know when to unlock. 
	 * We also require a reference to the entity that caused the 
	 * lock. This may help in debugging stuck locks. 
	 * @param {object} Whatever invoked the lock.
	 */
	lock : function ( object ) {
		
		if ( object != null ) {
			this._lockthings [ object ] = true;
			if ( top.bindingMap.mastercover != null ) {
				if ( this._lockers >= 0 ) {
					this._lockers ++;					
					if ( this._lockers == 1 ) {
						this.isLocked = true;
						top.bindingMap.mastercover.show ();
						if ( top.app != null && top.app.bindingMap.throbber != null ) {
							top.app.bindingMap.throbber.play ();
						}
					}
				}
			}
		} else {
			throw "Application: No locker specified.";
		}
	},
	
	/**
	 * Unblocking interaction when all lockers are ready.
	 * @param {object} object Whatever invoked the unlock.
	 * @param @optional {boolean} isForcedUnlock
	 */
	unlock : function ( object, isForcedUnlock ) {

		if ( object != null ) {
			delete this._lockthings [ object ];
			if ( top.bindingMap.mastercover != null ) {
				if ( isForcedUnlock || this._lockers > 0 ) {
					if ( isForcedUnlock ) {
						var out = "Unlocked by " + new String ( object )+ "\n";
						for ( var locker in this._lockthings ) {
							out += "Locked by " + new String ( locker ) + ". ";
						}
						this.logger.debug ( out );
						this._lockers = 0;
					} else {
						this._lockers --;
					}
					if ( this._lockers == 0 ) {
						this.isLocked = false;
						top.bindingMap.mastercover.hide ();
						if ( top.app != null && top.app.bindingMap.throbber != null ) {
							setTimeout ( function () {
								top.app.bindingMap.throbber.stop ();
							}, 250 );
						}
					}
				}
			}
		} else {
			throw "Application: No unlocker specified.";
		}
	},
	
	hasLock : function ( locker ) {
		
		return this._lockthings [ locker ] == true;
	},
	
	/**	 
	 * Bookkeeping activated bindings so that an active-status 
	 * "undo" history can be maintained.
	 * @param {IActivatable} binding
	 */
	activate : function ( binding ) {
		
		var lastBinding = this._activeBinding;
		this._activeBinding = binding;
		this._activatedBindings.add ( binding );
		if ( lastBinding && lastBinding.isActive ) {
			lastBinding.deActivate ();
		}
	},
	
	/**
	 * If the currently activated binding get's deactivated, select the last  
	 * activated binding for activation. This defaults to the explorer dock.
	 * @param {IActivatable} binding
	 */
	deActivate : function ( binding ) {
		
		var nextBinding = null;
		var bestBinding = null;
		
		if ( binding == this._activeBinding ) { 
			while ( !bestBinding && this._activatedBindings.hasEntries ()) {
				nextBinding = this._activatedBindings.extractLast ();
				if ( nextBinding != binding && nextBinding.isActivatable ) {
					bestBinding = nextBinding;
				}
			}
			if ( !bestBinding ) {
				bestBinding = app.bindingMap.explorerdock;
			}
			bestBinding.activate ();
		}
	},
	
	/**
	 * Tracking global focused status. NOTE that you cannot trust these things in IE. 
	 * Specifically because IE may decide to declare a blur event (one one object) 
	 * AFTER the focus event (of another object). You should in fact never trust IE.
	 * @param isFocused
	 */
	focused : function ( isFocused ) {
		
		this.isFocused = isFocused;
		
		if ( isFocused ) {
			if ( this.isBlurred ) {
				this.isBlurred = false;
				EventBroadcaster.broadcast ( BroadcastMessages.APPLICATION_FOCUSED );
			}
		} else {
			setTimeout ( function () {
				if ( !Application.isFocused ) {
					Application.isBlurred = true;
					EventBroadcaster.broadcast ( BroadcastMessages.APPLICATION_BLURRED );
				}
			}, Application._TIMEOUT_LOSTFOCUS )
		}
	},
	
	/**
	 * Initialize.
	 */
	initialize : function () {
		
		/*
		 * Setup shutdown stuff
		 * TODO: make beforeunloadd stuff work reliably in both engines!
		 */
		DOMEvents.addEventListener ( top, DOMEvents.UNLOAD, {
			handleEvent : function ( e ) {
				EventBroadcaster.broadcast ( BroadcastMessages.APPLICATION_ONSHUTDOWN );
				EventBroadcaster.broadcast ( BroadcastMessages.APPLICATION_SHUTDOWN );
				if ( !Application.isShuttingDown ) { // this may be set by quit method already
					Application.isShuttingDown = true;
					if ( FlowControllerService != null ) {
						FlowControllerService.ReleaseAllConsoleResources ( Application.CONSOLE_ID ); 
					}
				}
				if ( this.isLoggedIn && !Application.isDeveloperMode ) {
					Application.logout ();
				}

			}
		});
		
		/*
		DOMEvents.addEventListener ( top, DOMEvents.BLUR, {
			handleEvent : function ( e ) {
				Application.logger.debug ( Math.random ())
			}
		});
		*/
		
		/*
		top.onblur = function () {
			Application.logger.debug ( Math.random ())
		}
		*/
		
		// broadcast startup
		EventBroadcaster.broadcast ( 
			BroadcastMessages.APPLICATION_STARTUP 
		);
	},
	
	/**
	 * Cancel shutdown. Although we can't really 
	 * cancel the shutdown, so don't use this.
	 */
	cancelShutDown : function () {
		
		this._isShutDownAllowed = false;
	},
	
	/**
	 * Setup standard framework mouseeventlisteners.
	 * Intercepting mousedown, mousemove, mouseup, keydown, keyup.
	 * @param {DOMDocument} doc
	 */
	framework : function ( doc ) {
		
		var win = DOMUtil.getParentWindow ( doc );
		if ( win != null ) {
			if ( !win.standardEventHandler ) {
				win.standardEventHandler = new StandardEventHandler ( doc );
			} else {
				// throw "StandardEventHandler added twice!";
				// TODO: investigate why editor-documents fall in this trap!
			}
		}
	},
	
	/**
	 * Normalize input and textarea elements.
	 * @param {DOMDocument} doc
	 */
	normalize : function ( doc ) {
	
		/*
		if ( !this.heyho ) {
			
			this.heyho = setInterval ( function () {
				Application.logger.debug ( StandardEventHandler.isBackAllowed );
			}, 3000 );
		}
		
		var win = DOMUtil.getParentWindow ( doc );
		if ( win != null ) {
			if ( !win.standardEventHandlerFixer ) {
				win.standardEventHandlerFixer = new StandardEventHandlerFixer ( doc );
			}
		}
		*/
	},
	
	/**
	 * @implements {IActionListener}
	 * @param {Action} action
	 */
	handleAction : function ( action ) {
		
		switch ( action.type ) {
			case Application.REFRESH :
				this.refresh ();
				break;
		}
	},
	
	/**
	 * Declare top level application classes as local variables in another window.
	 * This way, authors can address eg. the SystemLogger as such instead of top.SystemLogger
	 * Only the classes from the "top" folder are included (exluding "page" folder classes).
	 * Note that this is only relevant for developermode!
	 * @param {DocumentView} win
	 */
	declareTopLocal : function ( win ) {
		
		/*
		 * TODO: SCRIPLOADERCONTROL!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		 */
		var TOP_SCRIPTS = Resolver.resolve ( "/scripts/source/top/" );
		
		/*
		 * Please observe that we follow the Java convention of naming  
		 * any code file according to the single class it contains!
		 */
		if ( this._topLevelClasses == null ) {
			this._topLevelClasses = new List ();
			var self = this;
			new List (
				DOMUtil.getElementsByTagName ( document, "script" )
			).each ( function ( script ) {
				var src = script.src;
				if ( src.indexOf ( TOP_SCRIPTS ) >-1 ) {
					var name = src.substring ( 
						src.lastIndexOf ( "/" ) + 1,
						src.lastIndexOf ( ".js" )
					);
					self._topLevelClasses.add ( name );
				}
			});
		}
		this._topLevelClasses.each ( function ( name ) {
			if ( window [ name ] != null ) {
				win [ name ] = window [ name ];
			}
		});
	},
	
	/** 
	 * TODO: Explain this method.
	 * @param {MouseEvent} e
	 * @return {boolean}
	 */
	trackMousePosition : function ( e ) {
	
		var isTracking = false;
		if ( this._isMousePositionTracking ) {
			isTracking = true;
			if ( Client.isExplorer && e.button != 1 ) {
				isTracking = false;
			}
			if ( isTracking ) {
				this._mousePosition = DOMUtil.getUniversalMousePosition ( e );
			}
		}
		return isTracking;
	},
	
	
	// MOUSE TRACKING ............................................................
	
	/**
	 * Enable mouse position tracking.
	 * @param {MouseEvent} e
	 */
	enableMousePositionTracking : function ( e ) {
	
		if ( e ) {
			this._isMousePositionTracking = true;
			this._mousePosition = DOMUtil.getUniversalMousePosition ( e );
		} else {
			throw new Error ( 
				"Application: MouseEvent undefined." 
			);
		}
	},
	
	/**
	 * Disable mouse position tracking.
	 */
	disableMousePositionTracking : function () {
	
		this._isMousePositionTracking = false;
		this._mouseposition = null;
	},
	
	/**
	 * Get mouse position.
	 * @return {Point}
	 */
	getMousePosition : function () {
	
		return this._mousePosition;
	},
	
	
	// DRAG AND DROP ............................................................
	
	/**
	 * Drag start.
	 * @implements {IDragHandler}
	 * @param {Point} point
	 */
	onDragStart : function ( point ) {
		
		var binding = BindingDragger.draggedBinding;
		
		
		if ( Interfaces.isImplemented ( IDraggable, binding, true ) == true ) {
			if ( !this._isDragging ) {
				app.bindingMap.dragdropcursor.setImage (
					binding.getImage ()
				);
				this._cursorStartPoint = point;
				app.bindingMap.dragdropcursor.setPosition ( 
					this._cursorStartPoint 
				);
				CursorBinding.fadeIn ( app.bindingMap.dragdropcursor );
				if ( binding.showDrag ) {
					binding.showDrag ();
				}
				EventBroadcaster.broadcast ( 
					BroadcastMessages.TYPEDRAG_START,
					binding.dragType
				);
				this._isDragging = true;
			}
		}
	},
	
	/**
	 * Dragging.
	 * @implements {IDragHandler}
	 * @param {Point} diff
	 */
	onDrag : function ( diff ) {
		
		if ( this._isDragging ) {
			var point = new Point (
				this._cursorStartPoint.x + diff.x,
				this._cursorStartPoint.y + diff.y
			);
			app.bindingMap.dragdropcursor.setPosition ( 
				point 
			);
		}
	},
	
	/**
	 * Drag stop.
	 * @implements {IDragHandler}
	 * @param {Point} diff
	 */
	onDragStop : function ( diff ) {
	
		if ( this._isDragging ) {
			
			var binding = BindingDragger.draggedBinding; 
			
			if ( binding.hideDrag ) {
				binding.hideDrag ();
			}
			
			EventBroadcaster.broadcast ( 
				BroadcastMessages.TYPEDRAG_STOP,
				binding.dragType
			)
			
			this._isDragging = false;
			
			binding = BindingAcceptor.acceptingBinding;
			
			/*
			 * Accept dragged binding.
			 */
			if ( binding != null ) {
				if ( Interfaces.isImplemented ( IAcceptable, binding, true ) == true ) {
					binding.accept ( 
						BindingDragger.draggedBinding
					);
				} else {
					throw new Error ( "Application: IAcceptable not implemented " + binding );
				}
				BindingAcceptor.acceptingBinding = null;
				CursorBinding.fadeOut ( app.bindingMap.dragdropcursor );
			
			/*
			 * Reject dragged binding.
			 */
			} else {
				
				app.bindingMap.dragdropcursor.hide ();
				
				/*
				if ( app.bindingMap.dragdropcursor.getOpacity () == 1 ) {
					var cursorEndPoint = new Point ( 
						this._cursorStartPoint.x + diff.x,
						this._cursorStartPoint.y + diff.y
					);
					CursorBinding.moveOut ( 
						app.bindingMap.dragdropcursor,
						this._cursorEndPoint,
						this._cursorStartPoint
					);
				} else {
					app.bindingMap.dragdropcursor.hide ();
				}
				*/
			}
		}
	},
	
	
	// SHORTCUTS .................................................................
	
	/**
	 * Reloading application window [control+R]. 
	 * See the KeySetBinding in file "index.aspx".
	 * @param {boolean} isForcedReload
	 */
	reload : function ( isForcedReload ) {
		
		/*
		 * When developermode in Prism, this will clear the file cache.
		 */
		if ( this.isDeveloperMode || isForcedReload ) {
			if ( this.isDeveloperMode && Client.isPrism ) {
				Prism.clearCache ();
			}
			Application.lock ( Application );
			setTimeout ( function () {
				top.window.location.reload ( true );
			}, 0 );
		} else {
			if ( Application.isOperational ) {
				Dialog.question ( 
					StringBundle.getString ( "ui", "Website.Application.DialogReload.Title" ), 
					StringBundle.getString ( "ui", "Website.Application.DialogReload.Text" ),
					Dialog.BUTTONS_ACCEPT_CANCEL, 
					{
						handleDialogResponse : function ( response ) {
							if ( response == Dialog.RESPONSE_ACCEPT ) {
								Application.reload ( true );
							}
						}
					}
				);
			} else {
				Application.reload ( true );
			}
		}
	},
	
	/** 
	 * Quit application. This will automatically log off. When 
	 * running in developermode, closing or reloading the main  
	 * browserwindow will *not* log off unless we call this method!
	 */
	quit : function () {
		
		/*
		 * Note that Prism cannot actually close the window (because it 
		 * is the main browser window), but at least we can hide the interface. 
		 */
		Application.isShuttingDown = true;
		if ( FlowControllerService != null ) {
			FlowControllerService.ReleaseAllConsoleResources ( Application.CONSOLE_ID );
		}
		if ( this.logout ()) {
			top.close ();
			top.bindingMap.logoutcover.show ();
		}
	},
	
	/**
	 * Has dirty tabs?
	 * @return {boolean}
	 */
	hasDirtyDockTabs : function () {
		
		return this._dirtyTabs.countEntries () > 0;
	},
	
	/**
	 * Get dirty tabs.
	 * @return {List<string><DockTabBinding>}
	 */
	getDirtyDockTabsTabs : function () {
		
		return this._dirtyTabs;
	}
}

/**
 * The instance that does it.
 * @type {_Application}
 */
var Application = new _Application ();

/**
 * @class
 */
function _Installation () {
	
	EventBroadcaster.subscribe ( BroadcastMessages.APPLICATION_KICKSTART, this ); 
}

_Installation.prototype = {

    /**
    * Robot readable build version "1.2.3505.18361".
    * @type {string}
    */
    versionString: null,

    /**
    * Human readable product version "Composite C1 1.2 SP2".
    * @type {string}
    */
    versionPrettyString: null,

    /**
    * @type {string}
    */
    installationID: null,

    /**
    * Constructor action: Get installation info.
    * @return {_Installation}
    */
    handleBroadcast: function (broadcast) {

        switch (broadcast) {
            case BroadcastMessages.APPLICATION_KICKSTART:
                var list = new List(InstallationService.GetInstallationInfo(true));
                list.each(function (entry) {
                    switch (entry.Key) {
                        case "ProductVersion":
                            this.versionString = entry.Value;
                            break;
                        case "ProductTitle":
                            this.versionPrettyString = entry.Value;
                            break;
                        case "InstallationId":
                            this.installationID = entry.Value;
                            break;
                    }
                }, this);
                break;
        }
    }
};

/*
 * Here we go.
 */
var Installation = new _Installation ();

/**
 * @class
 * Broadcasting keys globally. This class is closely connected to the 
 * KeyGroupBinding going on in the root application file "top.aspx".
 */
function _Keyboard () {}

_Keyboard.prototype = {
	
	/**
	 * @type {SystemLogger}
	 */
	_logger : SystemLogger.getLogger ( "Keyboard" ),
	
	/** 
	 * @type {boolean}
	 */
	isShiftPressed : false,
	
	/** 
	 * @type {boolean}
	 */
	isControlPressed : false,
	
	/**
	 * Enter key pressed.
	 */
	keyEnter : function () {
		
		EventBroadcaster.broadcast ( BroadcastMessages.KEY_ENTER );
	},
	
	/**
	 * Escape key pressed.
	 */
	keyEscape : function () {
		
		EventBroadcaster.broadcast ( BroadcastMessages.KEY_ESCAPE );
	},
	
	/**
	 * Space key pressed.
	 */
	keySpace : function () {
		
		EventBroadcaster.broadcast ( BroadcastMessages.KEY_SPACE );
	},
	
	/**
	 * Shift key pressed. Another broadcast is 
	 * transmitted when the shift key is released.
	 * @see {Keyboard#keyUp} 
	 */
	keyShift : function () {
		
		this.isShiftPressed = true;
		EventBroadcaster.broadcast ( BroadcastMessages.KEY_SHIFT_DOWN );
	},
	
	/**
	 * Control key pressed. Another broadcast is 
	 * transmitted when the control key is released.
	 * @see {Keyboard#keyUp}
	 */
	keyControl : function () {
		
		this.isControlPressed = true;	
		EventBroadcaster.broadcast ( BroadcastMessages.KEY_CONTROL_DOWN );
	},
	
	/**
	 * Arrow key pressed.
	 */
	keyArrow : function ( key ) {
		
		EventBroadcaster.broadcast ( BroadcastMessages.KEY_ARROW, key );
	},
	
	/**
	 * Arrow key pressed.
	 */
	keyAlt : function () {
		
		EventBroadcaster.broadcast ( BroadcastMessages.KEY_ALT );
	},
	
	/**
	 * Tab key pressed.
	 */
	keyTab : function () {
		
		EventBroadcaster.broadcast ( BroadcastMessages.KEY_TAB );
	},
	
	/**
	 * Special broadcast whenever the shift or control key is released. 
	 * This method is invoked by the local {@link DocumentManager}.
	 * @param {KeyEvent} e
	 */
	keyUp : function ( e ) {
		
		if ( this.isShiftPressed && e.keyCode == window.KeyEventCodes.VK_SHIFT ) {
			this.isShiftPressed = false;
			EventBroadcaster.broadcast ( BroadcastMessages.KEY_SHIFT_UP );
		} else if ( this.isControlPressed && e.keyCode == window.KeyEventCodes.VK_CONTROL ) {
			this.isControlPressed = false;
			EventBroadcaster.broadcast ( BroadcastMessages.KEY_CONTROL_UP );
		}
	}
}

/**
 * The instance that does it.
 */
var Keyboard = new _Keyboard ();

/**
 * @class
 */
function _Audio () {
	this._construct ();
}

_Audio.prototype = {
	
	SPLASH : "${root}/audio/splash.mp3",
	LOGIN : "${root}/audio/login.mp3",
	FATAL : "${root}/audio/fatal.mp3",
	
	/** 
 	 * @type {SystemLogger}
 	 */
 	_logger : SystemLogger.getLogger ( "Audio" ),
 	
 	 /**
 	 * This would be the Flash object tag.
 	 * @type {DOMElement}
 	 */
 	_audio : null,
 	
 	/**
 	 * @type {boolean}
 	 */
 	isInitialized : false,
 	
 	/**
 	 * @type {boolean}
 	 */
 	isEnabled : false,
 	
 	/**
 	 * Construct.
 	 */
 	_construct : function () {
		
		/*
		 * If no Flash is installed, initialize when kikstart is fired.
		 * @see {KickStart}
		 */
		if ( !Client.hasFlash ) {
			EventBroadcaster.subscribe ( BroadcastMessages.APPLICATION_KICKSTART, {
				handleBroadcast : function () {
					Audio.initialize ( null );
				}
			});
		}
	},
 	
 	/**
	 * @param {DOMElement} flashElement
	 */
	initialize : function ( flashElement ) {
		
		if ( !this.isInitialized ) {
			this.isInitialized = true;
			if ( flashElement ) {
	 			this._audio = flashElement;
	 			this.isEnabled = true;
	 		}
	 		EventBroadcaster.broadcast ( 
	 			BroadcastMessages.AUDIO_INITIALIZED 
	 		);
	 	}
 	},
 	
 	
	
	/**
	 * Play sound from url.
	 * @param {string} url
	 * @return {boolean}
	 */
	play : function ( url ) {
		
		var result = false;
		if ( this.isEnabled && Preferences.getPref ( "audio" )) {
			this._audio.fromURL ( 
				Resolver.resolve ( url )
			);
			result = true;
		}
		return result;
	}
}
var Audio = new _Audio ();

/**
 * @class
 * @see {Options}
 */
window.Preferences = new function () {
	
	var logger = SystemLogger.getLogger ( "Preferences" );
	
	/*
	 * Preferrably using defined constants to avoid spelling mistakes.
	 */
	this.AUDIO = "audio";
	this.LOGIN = "login";
	
	/* 
	 * Default preferences.
	 */
	var preferences = {
		"audio" : true,
		"login" : true
	};
	
	/* 
	 * Fetch preferences on startup.
	 */
	EventBroadcaster.subscribe ( BroadcastMessages.LOCALSTORE_INITIALIZED, {
		handleBroadcast : function () {
			if ( LocalStore.isEnabled ) {
				var store = LocalStore.getProperty ( LocalStore.PREFERENCES );
				if ( store ) {
					for ( var key in store ) { // "overloading" not replacing!
						preferences [ key ] = store [ key ];
					}
					debug ( true );
				} else {
					debug ( false );
				}
			} else {
				debug ( false );
			}
		}
	});
	
	/* 
	 * Store preferences on shutdown.
	 */
	EventBroadcaster.subscribe ( BroadcastMessages.APPLICATION_SHUTDOWN, {
		handleBroadcast : function () {
			if ( LocalStore.isEnabled ) {
				LocalStore.setProperty ( 
					LocalStore.PREFERENCES,
					preferences
				);
			}
		}
	});
	
	/**
	 * Get preference.
	 * @param {string} key
	 * @return {object}
	 */
	this.getPref = function ( key ) {
		
		var result = null;
		if ( key ) {
			result = preferences [ key ];
		} else {
			throw "No such preference.";
		}
		return result;
	}
	
	/**
	 * Set preference.
	 * @param {string} key
	 * @param {object} value
	 */
	this.setPref = function ( key, value ) {
		
		if ( key ) {
			preferences [ key ] = value;
		} else {
			throw "No such preference.";
		}
	}
	
	/**
	 * Logging preferences on startup.
	 * @param {boolean} hasStoredPreferences 
	 */
	function debug ( hasStoredPreferences ) {
		
		var output = hasStoredPreferences ? 
			"Persisted preferences" : 
			"No persisted preferences. Using defaults";
			
		output += ":\n";
		for ( var key in preferences ) {
			var pref = preferences [ key ];
			output += "\n\t" + 
				key + ": " + 
				pref + " [" + 
				typeof pref + "]";
		}
		logger.fine ( output );
	}
}

/**
 * @class
 * This is the public interface for persistance management.
 * Don't instantiate this class manually. Access through 
 * instance variable "Persistance" declared below. This 
 * instance should be considered a singleton class.
 */
function _Persistance () {}
_Persistance.prototype = {
		
	/**
	 * @type {SystemLogger}
	 */
	_logger : SystemLogger.getLogger ( "Persistance" ),	
	
	/**
	 * @type {HashMap<string><HashMap<string><string>>}
	 */
	_persistance : null,

	/**
	 * Flip to activate!
	 */
	_isEnabled : false,
	
	/**
	 * @type {boolean}
	 */
	isInitialized : false,
	
	/**
	 * @type {boolean}
	 */
	isEnabled : false,
		
	/**
	 * Get persisted property.
	 * @param {string} id
	 * @param {string} prop
	 * @return {string}
	 */
	getPersistedProperty : function ( id, prop ) {
		
		var result = null;
		if ( this.isInitialized == true ) {
			if ( this._persistance ) {
				var entry = this._persistance [ id ];
				if ( entry ) {
					result = entry [ prop ];
				}
			}
		} else {
			throw "Persistance not initialized!";
		}
		return result;
	},
	
	/**
	 * Set persisted property.
	 * @param {string} id
	 * @param {string} prop
	 * @param {string} value
	 */
	setPersistedProperty : function ( id, prop, value ) {
		
		if ( this.isInitialized == true ) {
			if ( this._persistance ) {
				if ( value != null ) {
					if ( !this._persistance [ id ]) {
						this._persistance [ id ] = {};
					}
					this._persistance [ id ][ prop ] = String ( value );
				} else {
					this._logger.error ( "Cannot persist " + prop + " with value: null" );
				}
			}
		} else {
			throw "Persistance not initialized!";
		}
	},
	
	/**
	 * Clear all persisted properties.
	 * TODO: Actually clear all persisted properties.
	 */
	clearAllPersistedProperties : function () {
		
		this._logger.debug ( "TODO: clearAllPersistedProperties" );
	},
	
	/**
	 * @implements {IBroadcastListener}
	 * @param {string} broadcast
	 */
	handleBroadcast : function ( broadcast ) {
		
		switch ( broadcast ) {
			case BroadcastMessages.APPLICATION_SHUTDOWN :
				var binding = top.bindingMap.persistance; 
				binding.persist ( this._persistance );
				break;
		}
	},
	
	/**
	 * Initialize. This is invoked by the {@link PersistanceBinding}.
	 * @param {HashMap<string><HashMap<string><string>>} map
	 */
	initialize : function () {
		
		/*
		 * Fetching persistance from PersistanceBinding.
		 */
		if ( !this.isInitialized ) {
			this.isInitialized = true;
			if ( this._isEnabled == true ) {
				var binding = top.bindingMap.persistance;
				var map = binding.getPersistanceMap ();
				if ( map ) {
					this.isEnabled = true;
					this._persistance = map;
					EventBroadcaster.subscribe ( BroadcastMessages.APPLICATION_SHUTDOWN, this );
				}
			} else {
				this.isEnabled = false;
			}
			EventBroadcaster.broadcast ( BroadcastMessages.PERSISTANCE_INITIALIZED );
		}
	}
}

/**
 * The instance that does it.
 * @type {_Chrome}
 */
var Persistance = new _Persistance ();

/*
 * TEMP!
 */
var LocalStore = new function () {
	
	this.isInitialized = true;	
	this.isEnabled = false;
}

/**
 * Apparently this needs to adjusted on a system scope scale, although it 
 * simply get's switched whenever native keys are toggled for any document.
 */
StandardEventHandler.isBackAllowed = false;

/**
 * @param {DOMDocument} doc
 * @param {boolean} isMouseHandlerOnly Not currently used...
 */
function StandardEventHandler ( doc, isMouseHandlerOnly ) { 

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "StandardEventHandler [" + doc.title +"]" );
	
	/**
	 * @type {DOMDocument}
	 */
	this._contextDocument = doc;
	
	/**
	 * @type {DOMDocumentView}
	 */
	this._contextWindow = DOMUtil.getParentWindow ( doc );
	
	/**
	 * Don't set this property directly! Please use methods below. 
	 * @see {StandardEventHandler#enableNativeKeys}
	 * @see {StandardEventHandler#disableNativeKeys}
	 * @type {boolean}
	 */
	this.hasNativeKeys = false;
	
	/**
	 * @type {boolean}
	 */
	this._isAllowTabs = false;
	
	/**
	 * @type {boolean}
	 */
	this._isMouseHandlerOnly = isMouseHandlerOnly;
	
	/*
	 * Add listeners!
	 */
	this._addListeners ();
}

/*
 * Add listeners!
 */
StandardEventHandler.prototype._addListeners = function () {
	
	var doc = this._contextDocument;
	
	DOMEvents.addEventListener ( doc, DOMEvents.MOUSEDOWN, this );
	DOMEvents.addEventListener ( doc, DOMEvents.MOUSEUP, this );
	DOMEvents.addEventListener ( doc, DOMEvents.MOUSEMOVE, this );
	
	if ( !this._isMouseHandlerOnly ) {
		
		DOMEvents.addEventListener ( doc, DOMEvents.KEYDOWN, this );
		DOMEvents.addEventListener ( doc, DOMEvents.KEYUP, this );
		
		if ( this._contextWindow.WindowManager == null ) {
			if ( Client.isExplorer ) {
				DOMEvents.addEventListener ( doc, DOMEvents.FOCUSIN, this );
				DOMEvents.addEventListener ( doc, DOMEvents.FOCUSOUT, this );
			} else {
				if ( this._contextDocument.designMode != "on" ) {
					DOMEvents.addEventListener ( doc, DOMEvents.FOCUS, this, true );
					DOMEvents.addEventListener ( doc, DOMEvents.BLUR, this, true );
				}
			}
		}
		
		/*
		 * Setup global focus listeners.
		 * TODO: Make reliable for IE!
		 * @see {Application#focused}
		 */
		var handler = {
			handleEvent : function ( e ){
				switch ( e.type ) {
					case DOMEvents.BLUR :
						Application.focused ( false );
						break;
					case DOMEvents.FOCUS :
						Application.focused ( true );
						break;
				}
			}
		}
		
		DOMEvents.addEventListener ( this._contextWindow, DOMEvents.BLUR, handler );
		DOMEvents.addEventListener ( this._contextWindow, DOMEvents.FOCUS, handler );
	}
	
	/*
	 * Supress CTRL+S (TODO: handle this elsewhere!)
	 */
	if ( Client.isMozilla ) {
		doc.addEventListener ( DOMEvents.KEYDOWN, {
			handleEvent : function ( e ) {
				var s = 83;
				if ( e.ctrlKey && e.keyCode == s ) {
					e.preventDefault ();
				}
			}
		}, true );
	}
}

/** 
 * @implements {IEventListener}
 * @param {MouseEvent} e
 */
StandardEventHandler.prototype.handleEvent = function ( e ) {
		
	switch ( e.type ) {
		case DOMEvents.MOUSEDOWN :
			this._handleMouseDown ( e );
			break;
		case DOMEvents.MOUSEUP :
			this._handleMouseUp ( e );
			break;
		case DOMEvents.MOUSEMOVE :
			this._handleMouseMove ( e );
			break;
		case DOMEvents.KEYDOWN :
			this._handleKeyDown ( e );
			break;
		case DOMEvents.KEYUP :
			this._handleKeyUp ( e );
			break;
		case DOMEvents.FOCUS :
		case DOMEvents.BLUR :
		case DOMEvents.FOCUSIN :
		case DOMEvents.FOCUSOUT :
			this._handleFocus ( e );
			break;
	}
}

/**
 * Broadcast mousedown globally. For framework pages, locate nearest binding 
 * instance to make it dispatch the "bindingactivated" action. This action is 
 * probably consumed by nearest containing {@link DockBinding}.
 * @param {MouseEvent} e
 */
StandardEventHandler.prototype._handleMouseDown = function ( e ) {
	
	Application.trackMousePosition ( e );
	EventBroadcaster.broadcast ( BroadcastMessages.MOUSEEVENT_MOUSEDOWN, e );
	
	/*
	 * Only left mouse button will activate and migrate.
	 */
	if ( e.button != ButtonStateManager.RIGHT_BUTTON ) {
		
		var node = DOMEvents.getTarget ( e );
		while ( node ) {
			switch ( node.nodeType ) {
				case Node.ELEMENT_NODE :
					var binding = UserInterface.getBinding ( node );
					if ( binding != null ) {
						binding.dispatchAction ( 
							Binding.ACTION_ACTIVATED 
						);
					}
					node = binding ? false : node.parentNode;
					break;
				case Node.DOCUMENT_NODE :
					node = DOMUtil.getParentWindow ( node ).frameElement;
					break;
			}
		}
	}
}
	
/*
 * Broadcast mouseup globally.
 * @param {MouseEvent} e
 */
StandardEventHandler.prototype._handleMouseUp = function ( e ) {
	
	Application.trackMousePosition ( e );
	EventBroadcaster.broadcast ( BroadcastMessages.MOUSEEVENT_MOUSEUP, e );
}
	
/**
 * Broadcast mousemove globally *only* while mousetracking.
 * TODO: Broadcast mouseup if button is not pressed!
 * @param {MouseEvent} e
 */
StandardEventHandler.prototype._handleMouseMove = function ( e ) {
	
	try {
		
		var isTracking = Application.trackMousePosition ( e );
		if ( isTracking ) {
			EventBroadcaster.broadcast ( BroadcastMessages.MOUSEEVENT_MOUSEMOVE, e );
		}
		
		/*
		 * IE may spontaneously believe that no window has focus. If the   
		 * mousemove event is registered, this is not obviously not the case. 
		 * Therefore we can safely FOCUS our window, kicking IE back on track. 
		 * This fixes a bug where the backspace key stopped working.
		 */
		if ( Client.isExplorer && false ) {
			
			if ( Application.isBlurred ) {
				
				var doc = this._contextDocument;
				var win = this._contextWindow;
				
				/*
				 * The contentEditable document MUST be activated by a 
				 * mousedown WHEN another window has the focus. That's 
				 * why we focus the parent window in this case.
				 */
				if ( doc.body.contentEditable == "true" ) {
					win = DOMUtil.getParentWindow ( win.frameElement );
				}
				win.focus ();
			}
		}
		
	} catch ( exception ) { // don't want to throw errors continually onmousemove
		DOMEvents.removeEventListener ( 
			this._contextDocument, 
			DOMEvents.MOUSEMOVE, 
			this
		);
		throw ( exception );
	}
}

/**
 * @param {KeyEvent} e
 */
StandardEventHandler.prototype._handleKeyDown = function ( e, isTabHandled ) {

	/*
	 * This should only happen in the currently active window, 
	 * but the keypress should still be propagated for KeyBinding.
	 */
	if ( e.keyCode == KeyEventCodes.VK_TAB ) {
		if ( !this._isAllowTabs ) {
			if ( !isTabHandled ) {
				this._handleTab ( e );
				DOMEvents.preventDefault ( e );
			}
		} else {
			if ( e.shiftKey || e.ctrlKey ) {
				DOMEvents.preventDefault ( e );
			}
		}
		isTabHandled = true;
	}
	
	/*
	 * Prevent standard browser page navigation keys. Theorectically, the check 
	 * for shift and controls keys should *not* be performed. For some unknown 
	 * reason, however, pressing these keys will switch the value of hasNativeKeys...
	 * TODO: Investigate why!
	 */
	if ( !this.hasNativeKeys && !e.shiftKey && !e.ctrlKey ) {
		switch ( e.keyCode ) {
			case KeyEventCodes.VK_UP :
			case KeyEventCodes.VK_DOWN :
			case KeyEventCodes.VK_LEFT :
			case KeyEventCodes.VK_RIGHT :
			case KeyEventCodes.VK_SPACE :
			case KeyEventCodes.VK_PAGE_UP :
			case KeyEventCodes.VK_PAGE_DOWN :
				DOMEvents.preventDefault ( e );
			 	break;
		} 
	}
	
	if ( e.keyCode == KeyEventCodes.VK_BACK ) {
		if ( !StandardEventHandler.isBackAllowed ) {
			DOMEvents.preventDefault ( e );
		}
	}
	
	var isHandled = KeySetBinding.handleKey ( this._contextDocument, e );
	if ( !isHandled ) {
		switch ( e.keyCode ) {
			case KeyEventCodes.VK_PAGE_UP :
			case KeyEventCodes.VK_PAGE_DOWN :
				/*
				 * Strangely, these keys may stop working in this._contextWindow, 
				 * even while allowed, when an ANCESTOR frame preventDefaults them.
				 */
				break;
			default :
				var frame = this._contextWindow.frameElement;
				if ( frame != null ) {
					var parent = DOMUtil.getParentWindow ( frame );
					if ( parent.standardEventHandler != null ) {
						parent.standardEventHandler._handleKeyDown ( e, isTabHandled );
					}
				}
				break;
		}
	}
}

/**
 * TAB is handled especial.
 * @param {KeyEvent} e
 */
StandardEventHandler.prototype._handleTab = function ( e ) {
	
	if ( !this._isAllowTabs ) {
		if ( !e.ctrlKey ) {
			if ( e.shiftKey ) {
				FocusBinding.navigatePrevious ();
			} else {
				FocusBinding.navigateNext ();
			}
		}
	}
}

/**
 * Handle focus and blur.
 * @param {Event} e
 */
StandardEventHandler.prototype._handleFocus = function ( e ) {
	
	var isFocus = false;
	var target = DOMEvents.getTarget ( e );
	var name = target.nodeName.toLowerCase ();
	
	switch ( name ) {	
		case "input" :
		case "textarea" :
		case "select" :
			isFocus = ( e.type == DOMEvents.FOCUS || e.type == DOMEvents.FOCUSIN );
			if ( name == "input" || name == "textarea" ) {
				StandardEventHandler.isBackAllowed = isFocus;
			}
			if ( isFocus ) {
				if ( !this.hasNativeKeys ) {
					this.enableNativeKeys ();
				}
			} else {
				if ( this.hasNativeKeys ) {
					this.disableNativeKeys ();
				}
			}
			break;
	}
}

/**
 * @param {KeyEvent} e
 */
StandardEventHandler.prototype._handleKeyUp = function ( e ) {
	
	/*
	 * Simply broadcast the keyup event globally 
	 * via the {@link Keyboard} singleton.
	 */
	Keyboard.keyUp ( e );
}

/**
 * Enable native keys. 
 * @param {boolean} isAllowTabs Relevant for editors
 */
StandardEventHandler.prototype.enableNativeKeys = function ( isAllowTabs ) {
	
	this._isAllowTabs = ( isAllowTabs == true ? true : false );
	
	/* Timeout hack prevents open dialogs from closing when  
	 * a SelectBoxBinding changes selection. Also, it allows  
	 * one control to disable keys *before* another enables it.
	 */
	var self = this;
	top.setTimeout ( function () {
		self.hasNativeKeys = true;
		StandardEventHandler.isBackAllowed = true;
	}, 0 );
}
	
/**
 * Disable native keys. This will always dissalow tabs.
 */
StandardEventHandler.prototype.disableNativeKeys = function () {

	this._isAllowTabs = false;
	this.hasNativeKeys = false;
	StandardEventHandler.isBackAllowed = false;
}

/**
 * To avoid spelling mistakes, always use predefined constants  
 * (eg. TreeNodeBinding.ONFOCUS) when specifying the actions
 * "type" parameter. This method doublechecks that the predefined 
 * constant is actually predefined.
 * @param {string} type
 */
Action.isValid = function ( type ) {

	return typeof type != Types.UNDEFINED;
}

/**
 * @class
 * @param {Binding} target
 * @param {string} type
 */
function Action ( target, type ) {
	
	/** 
	 * @type {Binding} 
	 */
	this.target	= target;
	
	/** 
	 * @type {string} 
	 */
	this.type = type;
	
	/** 
	 * @type {Binding} 
	 */
	this.listener = null;
	
	/** 
	 * @type {boolean} 
	 */
	this.isConsumed = false;
	
	/** 
	 * @type {boolean} 
	 */
	this.isCancelled = false;
}

/**
 * A Binding can call this method to prevent ancestor 
 * Bindings from dealing with the Action.
 */
Action.prototype.consume = function () {

	this.isConsumed = true;
}

/**
 * A Binding can call this method to cancel the action associated to 
 * an event dispatch. But only if the dispatcher handles this scenario! 
 * Actually it's just a flag, you decide what for. 
 */
Action.prototype.cancel = function () {

	this.isCancelled = true;
}

/**
 * This fellow should exceed the most popular 
 * CSS transitions time used around stylesheets. 
 * In fact it has nothing to do with stuff below.
 * @type {int}
 */
Animation.DEFAULT_TIME = parseInt ( 250 );

/**
 * Presents a simple animation interface. When instantiated, user can modify properties interval, 
 * iterator, modifier and endcount to control the animation. User should alsoe override methods 
 * onstart, onstep and onstop before calling the <code>play</code> method. In the example below, 
 * we define animation properties in an optional constructor object. Note that only 
 * some properties are explicitely defined while others are left to default values.
 * <pre>
 *     var animation = new Animation ({
 *         modifier : 5,
 *         onstart : function () {
 *             foo.x = 0;
 *         },
 *         onstep : function ( i ) {
 *             foo.x += 10;
 *         }
 *     }).play ();
 * </pre>
 *
 * @param @optional {object} initializer Quickly configures animation properties.
 * @constructor
 */
function Animation ( initializer ) {

	/** 
	 * uniquely identify this animation. 
	 * @ignore
	 */
	this.id = KeyMaster.getUniqueKey ();
	
	/** 
	 * Iteration interval in milliseconds 
	 * @type {int} 
	 */
	this.interval = 25;
	
	/** 
	 * Iterator starting value 
	 * @type {number} 
	 */
	this.iterator =  0;
	
	/** 
	 * Iterator increment value
	 * @type {number} 
	 */
	this.modifier =  1;
	
	/** 
	 * Iterator end value (animation will stop here) 
	 * @type {number}
	 */
	this.endcount = 90;
	
	// if an animation initializer was specified,
	// apply initializer properties.
	for ( var property in initializer ) {
		this [ property ] = initializer [ property ];
	}
}

/**
 * Starts the animation.
 */
Animation.prototype.play = function () {

	// start playing
	if ( !this.isPlaying ) {
		var self = this;
		this._nextframe = function () {
			window [ this.id ] = setTimeout ( 
				function () {
					self.play ();
				}
			, this.interval );
		}
		this.onstart ( this.iterator );
		this._nextframe ();
		this.isPlaying = true;
	}
	
	// stop playing
	else if ( this.modifier > 0 ? this.iterator >= this.endcount : this.iterator <= this.endcount ) {
		this.stop ();
	}
	
	// play it again
	else {
		var it1 = this.iterator;
		var it2 = this.onstep ( this.iterator );
		if ( it2 && it2 != it1 ) {
			this.iterator = it2;
		} else {
			this.iterator += this.modifier;
		}
		this._nextframe ();
	}
}

/**
 * Stops the animation (not to be confused with "onstop").
 * TODO: perhaps we should clear the timeout around here?
 */
Animation.prototype.stop = function () {
	
	this.onstop ( this.iterator );
	this.isPlaying = false;
}

/**
 * (User should overwrite this method) Action to take when starting animation.
 * @param {number} iterator
 * @return {number} nextIterator
 */
Animation.prototype.onstart = function ( iterator ) {};

/**
 * (User should overwrite this method) Action to take on each animation sequence. 
 * The iterator value is provided as method argument. Optionally, user can overwrite 
 * the animation iterator by making these methods return a number; if a return value 
 * is specified, this value will be used as argument for next iteration.
 * @param {number} iterator
 * @return {number} nextIterator
 */
Animation.prototype.onstep = function ( iterator ) {};

/** 
 * (User should overwrite this method) Action to take when stopping animation
 * @param {number} iterator
 * @return {number} nextIterator
 */
Animation.prototype.onstop = function ( iterator ) {};

/**
 * Compare two points.
 * @param {Point} p1
 * @param {Point} p2
 * @return {boolean}
 */
Point.isEqual = function ( p1, p2 ) {
	
	var result = false;
	if ( p1 && p2 ) {
		result = ( p1.x == p2.x ) && ( p1.y == p2.y );
	}
	return result;
}

/**
 * @class
 * @param {int} x
 * @param {int} y
 */
function Point ( x, y ) {

	this.x = x;
	this.y = y;
}

Point.prototype = {
	
	/**
	 * X position.
	 * @type {int}
	 */
	x : 0,
	
	/**
	 * Y position.
	 * @type {int}
	 */
	y : 0
}

/**
 * Compare two dimensions.
 * @param {Dimension} dim1
 * @param {Dimension} dim2
 * @return {boolean}
 */
Dimension.isEqual = function ( dim1, dim2 ) {
	
	var result = false;
	if ( dim1 && dim2 ) {
		result = ( dim1.w == dim2.w ) && ( dim1.h == dim2.h );
	}
	return result;
}

/**
 * @class
 * @param {int} w
 * @param {int} h
 */
function Dimension ( w, h ) {

	this.w = w;
	this.h = h;
}

Dimension.prototype = {
	
	/**
	 * Width.
	 * @type {int}
	 */
	w : 0,
	
	/**
	 * Height.
	 * @type {int}
	 */
	h : 0
}

/**
 * @class
 * @param {int} x
 * @param {int} y
 * @param {int} w
 * @param {int} h
 */
function Geometry ( x, y, w, h ) {

	this.x = x;
	this.y = y;
	this.w = w;
	this.h = h;
}

/**
 * @type {Binding}
 */
BindingAcceptor.acceptingBinding = null;

/** 
 * @param {Binding} binding
 */
function BindingAcceptor ( binding ) {

	/** 
	 * @type {SystemLogger} 
	 */
	this.logger = SystemLogger.getLogger ( "BindingDragger" );

	/** 
	 * @type {Binding} 
	 */
	this._binding = binding;	
	
	/**
	 * @type {HashMap<string><boolean>}
	 */
	this._acceptedList = {};
	
	/**
	 * @type {boolean}
	 */
	this._isAccepting = false;
	
	/**
	 * @type {CursorBinding}
	 */
	this._corsor = null;
	
	/* 
	 * Initialize.
	 */
	this._initialize ();
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Initialize.
 */
BindingAcceptor.prototype._initialize = function () {
	
	EventBroadcaster.subscribe ( BroadcastMessages.TYPEDRAG_START, this );
	EventBroadcaster.subscribe ( BroadcastMessages.TYPEDRAG_STOP, this );
	
	if ( this._binding.dragAccept ) {
	
		EventBroadcaster.subscribe ( BroadcastMessages.TYPEDRAG_PAUSE, this );
	
		var types = new List ( 
			this._binding.dragAccept.split ( " " )
		);
		while ( types.hasNext ()) {
			var type = types.getNext ();
			this._acceptedList [ type ] = true;
		}
	}
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
BindingAcceptor.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	var type = arg;
	
	try {
	
	switch ( broadcast ) {
	
		case BroadcastMessages.TYPEDRAG_START :
			if ( this._cursor == null ) {
				this._cursor = app.bindingMap.dragdropcursor;
			}
			this._binding.addEventListener ( DOMEvents.MOUSEENTER, this );
			this._binding.addEventListener ( DOMEvents.MOUSELEAVE, this );
			if ( this.isAccepting ( type )) {
				this._isAccepting = true;
				this._startAccepting ();
			}
			break;
			
		case BroadcastMessages.TYPEDRAG_STOP :
			this._binding.removeEventListener ( DOMEvents.MOUSEENTER, this );
			this._binding.removeEventListener ( DOMEvents.MOUSELEAVE, this );
			if ( this.isAccepting ( type )) {
				this._isAccepting = false;
				this._stopAccepting ();
			}
			break;
			
		case BroadcastMessages.TYPEDRAG_PAUSE :	
			if ( this.isAccepting ( type )) {
				this._pauseAccepting ();
			}
			break;
	}
	
	} catch ( exception ) {
		this.logger.debug ( exception );
	}
}

/**
 * Is accepting type?
 * @param {string} type
 * @return {boolean}
 */
BindingAcceptor.prototype.isAccepting = function ( type ) {
	
	return Types.isDefined ( this._acceptedList [ type ]);
}

/**
 * Start accepting binding.
 */
BindingAcceptor.prototype._startAccepting = function () {
	
	if ( Types.isFunction ( this._binding.showGeneralAcceptance )) {
		this._binding.showGeneralAcceptance ();
	}
}

/**
 * Pause accepting binding.
 */
BindingAcceptor.prototype._pauseAccepting = function () { 
	
	/*
	if ( this._binding.hideGeneralAcceptance ) {
 		this._binding.hideGeneralAcceptance ();
 	}
 	*/
 	if ( this._binding.hideAcceptance ) {
		this._binding.hideAcceptance ();
	}
	
	this._cursor.hideAcceptance ();
	BindingAcceptor.acceptingBinding = null;
}
 
/**
 * Stop accepting binding.
 */
BindingAcceptor.prototype._stopAccepting = function () { 
	
	if ( this._binding.hideGeneralAcceptance ) {
 		this._binding.hideGeneralAcceptance ();
 	}
 	if ( this._binding.hideAcceptance ) {
		this._binding.hideAcceptance ();
	}
}

/**
 * Implements DOM2 EventListener.
 * @param {MouseEvent} e 
 */
BindingAcceptor.prototype.handleEvent = function ( e ) {

	switch ( e.type ) {
	
		case DOMEvents.MOUSEENTER :
		case DOMEvents.MOUSEOVER :
			if ( this._isAccepting ) {
				if ( BindingAcceptor.acceptingBinding != this._binding ) {
					BindingAcceptor.acceptingBinding = this._binding;
					this._cursor.showAcceptance ();
					if ( Types.isFunction ( this._binding.showAcceptance )) {
						this._binding.showAcceptance ();
					}
				}
			} else {
				EventBroadcaster.broadcast ( BroadcastMessages.TYPEDRAG_PAUSE );
				DOMEvents.stopPropagation ( e );
			}
			break;
			
		case DOMEvents.MOUSELEAVE :
		case DOMEvents.MOUSEOUT :
			if ( this._isAccepting ) {
				BindingAcceptor.acceptingBinding = null;
				this._cursor.hideAcceptance ();
				if ( Types.isFunction ( this._binding.hideAcceptance )) {
					this._binding.hideAcceptance ();
				}
			} else {
				DOMEvents.stopPropagation ( e );
			}
			break;
	}
	
	DOMEvents.stopPropagation ( e );
}

/**
 * Dispose (on binding dispose).
 */
BindingAcceptor.prototype.dispose = function () {
	
	EventBroadcaster.unsubscribe ( BroadcastMessages.TYPEDRAG_START, this );
	EventBroadcaster.unsubscribe ( BroadcastMessages.TYPEDRAG_STOP, this );
}

/**
 * @class
 * Presents a simpliefied API for dealing with a bindings size and position on stage.
 * @param {Binding} binding 
 */
function BindingBoxObject ( binding ) {
	
	/**
	 * @type {DOMElement} 
	 */
	this._domElement = binding.getBindingElement ();
}

/**
 * Get relative to top window.
 * @return {Point} 
 */
BindingBoxObject.prototype.getUniversalPosition = function () {

	return DOMUtil.getUniversalPosition ( this._domElement );
}

/**
 * Get position relative to containing window.
 * @return {Point} 
 */
BindingBoxObject.prototype.getGlobalPosition = function () {

	return DOMUtil.getGlobalPosition ( this._domElement );
}

/**
 * Get position relative to nearest positioned ancestor.
 * @return {Point} 
 */
BindingBoxObject.prototype.getLocalPosition = function () {

	return DOMUtil.getLocalPosition ( this._domElement );
}

/**
 * @return {Dimension} 
 */
BindingBoxObject.prototype.getDimension = function () {

	/*
	return new Dimension (
		 this._domElement.offsetWidth,
		 this._domElement.offsetHeight
	);
	*/
	
	var rect = this._domElement.getBoundingClientRect ();
	return new Dimension (
		 rect.right - rect.left,
		 rect.bottom - rect.top
	);
}

/**
 * Dispose.
 */
BindingBoxObject.prototype.dispose = function () {
	
	this._domElement = null;
}

/**
 * True while dragging. Certain GUI components should 
 * modify their behavior dependant on this property.
 * @type {boolean}
 */
BindingDragger.isDragging = false;

/**
 * @type {Binding}
 */
BindingDragger.draggedBinding = null;

/**
 * @type {BindingDragger}
 */
BindingDragger.bindingDragger = null;

/**
 * @class
 * The main point with this class is to not register a 
 * default method "handleEvent" to all Binding instances.
 * @param {Binding} binding
 */
function BindingDragger ( binding ) {

	/** @type {SystemLogger} */
	this.logger = SystemLogger.getLogger ( "BindingDragger" );

	/** @type {Binding} */
	this.binding = binding;
	
	/** @type {boolean} */
	this.isDragReady = false;
	
	/** @type {boolean} */
	this.isDragging = false;
	
	/** @type {Point} */
	this.startPoint = null;
	
	/** @type {MouseEvent} */
	this.currentEvent = null
}

/**
* Implements DOM2 EventListener.
* @param {MouseEvent} e
*/
BindingDragger.prototype.handleEvent = function ( e ) {
	
	if ( e.type == DOMEvents.MOUSEUP ) {
		this.isDragReady = false;
	}
	else if ( !BindingDragger.isDragging ) {
		switch ( e.type ) {
			case DOMEvents.MOUSEDOWN :
				if ( !DOMEvents.isRightButton ( e )) {
					this.isDragReady = true;
					DOMEvents.preventDefault ( e ); // kills FF3 image dragging
				}
				break;
			case DOMEvents.MOUSEMOVE :
				if ( this.isDragReady == true ) {
					this.binding.dispatchAction ( 
						Binding.ACTION_DRAG 
					);
					if ( this.handler ) {
						this.onDragStart ( e );
					}
					this.isDragReady = false;
				}
				break;
		}
	}
}

BindingDragger.prototype.registerHandler = function ( handler ) {
	
	if ( Interfaces.isImplemented ( IDragHandler, handler ) == true ) {
		this.handler = handler;
	} else {
		throw new Error ( 
			"BindingDragger: Interface IDraghandler not implemented." 
		);
	}
}

/**
 * @param {MouseEvent} e
 */
BindingDragger.prototype.onDragStart = function ( e ) {
	
	if ( !this.isDragging ) {
		
		Application.enableMousePositionTracking ( e );
		this.startPoint = Application.getMousePosition ();
		this.isDragging = true;
		BindingDragger.isDragging = true;
		BindingDragger.draggedBinding = this.binding;
		this.handler.onDragStart ( this.startPoint );
		
		EventBroadcaster.subscribe ( BroadcastMessages.MOUSEEVENT_MOUSEMOVE, this );
		EventBroadcaster.subscribe ( BroadcastMessages.MOUSEEVENT_MOUSEUP, this );
	}
}

/**
 * @param {MouseEvent} e
 */
BindingDragger.prototype.onDrag = function ( e ) {

	if ( this.isDragging == true ) {
		var isLeftButtonPressed = e.button == ( e.target ? 0 : 1 );
		if ( isLeftButtonPressed ) {
			this.handler.onDrag ( this.getDiff ());
		} else {
			this.onDragStop ( e );
		}
	}
}

/**
 * @param {MouseEvent} e
 */
BindingDragger.prototype.onDragStop = function ( e ) {

	if ( this.isDragging == true ) {
		
		Application.disableMousePositionTracking ();
		this.handler.onDragStop ( this.getDiff ());
		this.isDragging = false;
		BindingDragger.isDragging = false;
		BindingDragger.draggedBinding = null;
		
		EventBroadcaster.unsubscribe ( BroadcastMessages.MOUSEEVENT_MOUSEMOVE, this );
		EventBroadcaster.unsubscribe ( BroadcastMessages.MOUSEEVENT_MOUSEUP, this );
	}
}

/**
 * @param {MouseEvent} e
 * @return {Point}
 */
BindingDragger.prototype.getDiff = function () {

	var point = Application.getMousePosition ();
	var dx = point.x - this.startPoint.x;
	var dy = point.y - this.startPoint.y;
	return new Point ( dx, dy );
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} e In this case, an instance of DOM MouseEvent
 */
BindingDragger.prototype.handleBroadcast = function ( broadcast, e ) {
	
	switch ( broadcast ) {
		case BroadcastMessages.MOUSEEVENT_MOUSEMOVE :
			this.onDrag ( e );
			break;
		case BroadcastMessages.MOUSEEVENT_MOUSEUP :
			this.onDragStop ( e );
			break;
	}
}

/**
 * Dispose.
 */
BindingDragger.prototype.dispose = function () {
	
	this.binding = null;
}

BindingParser.XML = "<div xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:ui=\"http://www.w3.org/1999/xhtml\">${markup}</div>";

/**
 * @class
 * Parses markup into elements with all bindings preregistered.
 * @param {DOMDocument} ownerDocument
 */
function BindingParser ( ownerDocument ) {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "BindingParser" );
	
	/**
	 * @type {DOMDocument}
	 */
	this._ownerDocument = ownerDocument;
	
	/**
	 * @type {DOMElement}
	 */
	this._rootElement = null;
}

/**
 * Since incoming markup may not be placed in a single root element, 
 * this method returns a list of elements. Normally you would   
 * return a DOMDocumentFragment, but IE doesn't handle those. Notice 
 * that we return a list of elements, not bindings.
 * @param {string} markup
 * @return {List<DOMElement>}
 */
BindingParser.prototype.parseFromString = function ( markup ) {
	
	var result = new List ();
	var xml = BindingParser.XML.replace ( "${markup}", markup );
	var doc = XMLParser.parse ( markup );
	
	if ( doc ) {
		var solidroot = DOMUtil.createElementNS ( 
			Constants.NS_XHTML, 
			"div", 
			this._ownerDocument 
		);
		this._iterate ( doc.documentElement, solidroot );
		var node = solidroot.firstChild;
		while ( node ) {
			if ( node.nodeType == Node.ELEMENT_NODE ) {
				result.add ( node );
			}
			node = node.nextSibling;
		}
	}
	return result;
}

/**
 * Iterate an "abstract" DOM document and produce a solid XHTML nodetree.
 * @param {DOMNode} abstract
 * @param {DOMElement} collector
 */
BindingParser.prototype._iterate = function ( abstractnode, collector ) {
	
	var solidnode = null;

	switch ( abstractnode.nodeType ) {
		case Node.ELEMENT_NODE :
			solidnode = this._cloneElement ( abstractnode );
			UserInterface.registerBinding ( solidnode );
			break;
		case Node.TEXT_NODE :		
			solidnode = this._ownerDocument.createTextNode ( abstractnode.nodeValue );
			break;
	}
	if ( solidnode ) {
		collector.appendChild ( solidnode );
	}
	if ( solidnode && abstractnode.hasChildNodes ()) { // SOLIDNODE?
		var child = abstractnode.firstChild;
		while ( child ) {
			this._iterate ( child, solidnode );
			child = child.nextSibling;
		}
	}
};

/**
 * Clone element and attributes from "abstract" node and return a solid XHTML node.
 * @param {DOMElement} abstractnode
 * @return {DOMElement}
 */
BindingParser.prototype._cloneElement = function ( abstractnode ) {
	
	/*
	 * Notice that null namespaces gets converted to XHTML because of Atlas fugup.
	 */
	var solidnode = DOMUtil.createElementNS (
		abstractnode.namespaceURI ? abstractnode.namespaceURI : Constants.NS_XHTML, 
		abstractnode.nodeName, 
		this._ownerDocument 
	);
	var i = 0;
	while ( i < abstractnode.attributes.length ) {
		var attr = abstractnode.attributes.item ( i++ );
		solidnode.setAttribute ( attr.nodeName, String ( attr.nodeValue ));
	}
	return solidnode;
}

/**
 * Register binding if applicable.
 * @param {DOMElement} abstractnode
 * @param {DOMElement} solidnode
 *
BindingParser.prototype._registerBinding = function ( abstractnode, solidnode ) {
	
	UserInterface.registerBinding ( solidnode );
	if ( abstractnode.prefix && abstractnode.prefix == "ui" ) {
		var name = DOMUtil.getLocalName ( abstractnode );
		var impl = null;
		if ( abstractnode.getAttribute ( "binding" ) != null ) {
			impl = eval ( abstractnode.getAttribute ( "binding" ));
		} else {
			impl = BindingParser.map [ name ];
		}
		if ( impl ) {
			UserInterface.registerBinding ( solidnode, impl );
		}
	}
}
*/

/**
 * @type {BindingSerializer}
 */
BindingSerializer.activeInstance = null;

/**
 * @type {string}
 */
BindingSerializer.KEYPOINTER = "bindingserializerkeypointer";

/**
 * @type {boolean}
 */
BindingSerializer.includeShadowTreeBindings = false;

/**
 * This filter function is intended for the {@link ElementIterator}.
 * It's not elegant. But at least we get to use the ElementIterator! 
 * TODO: REFACTOR now that extra arguments are provided to the filter!
 * @param {DOMElement} element
 */
BindingSerializer.filter = function ( element ) {

	var keyPointer = null;
	var wasBindingSerializeable = false;
	var parentKeyPointer = element.parentNode.getAttribute ( BindingSerializer.KEYPOINTER );

	if ( UserInterface.hasBinding ( element )) {
		var binding = UserInterface.getBinding ( element );
		wasBindingSerializeable = BindingSerializer.activeInstance.indexBinding ( binding );
		if ( wasBindingSerializeable ) {
			keyPointer = binding.key;
			element.setAttribute ( BindingSerializer.KEYPOINTER, keyPointer ) 
		}
	}
	keyPointer = keyPointer ? keyPointer : parentKeyPointer;
	var children = new List ( element.childNodes );
	children.each ( function ( child ) {
		if ( child.nodeType == Node.ELEMENT_NODE ) {
			child.setAttribute ( BindingSerializer.KEYPOINTER, keyPointer ) 
		}
	});
	if ( wasBindingSerializeable ) {
		BindingSerializer.activeInstance.append ( keyPointer, parentKeyPointer );
	}
}

/**
 * @class
 */
function BindingSerializer () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "BindingSerializer" );

	/**
	 * @type {DOMDocument}
	 */
	this._dom = DOMUtil.getDOMDocument ();
	
	/*
	 * TEMP!
	 */
	alert ( "BindingSerializer: Convert to Crawler!" );
	
	/**
	 * @type {HashMap<string><DOMElement>}
	 */
	this._pointers = [];
}

BindingSerializer.prototype.serializeBinding = function ( binding, includeShadowTreeBindings ) {

	BindingSerializer.includeShadowTreeBindings = includeShadowTreeBindings ? true : false;
	BindingSerializer.activeInstance = this;
	binding.bindingWindow.ElementIterator.iterate ( 
		binding.bindingElement, 
		BindingSerializer.filter
	);
	return DOMSerializer.serialize ( this._dom, true );
}

BindingSerializer.prototype.indexBinding = function ( binding ) {

	var wasBindingSerialized = false;
 	var properties = binding.serialize ();
	
	if ( properties != false ) {
		
		/*
		 * The filter queries this return value.
		 */
		wasBindingSerialized = true;
		
		/*
		 * create a new element in the serialization 
		 * document and index it with a pointer key.
		 */
		var nodeName = "ui:" + DOMUtil.getLocalName ( binding.bindingElement );
		var element = DOMUtil.createElementNS ( Constants.NS_UI, nodeName, this._dom );
		this._pointers [ binding.key ] = element;
		
		/*
		 * Assign binding properties.
		 */
		for ( var prop in properties ) {
			if ( properties [ prop ] != null ) {
				element.setAttribute ( prop, String ( properties [ prop ]));
			}
		}	
	}
	return wasBindingSerialized;
}

/**
 * @param {string} keyPointer
 * @param {string} parentKeyPointer
 */
BindingSerializer.prototype.append = function ( keyPointer, parentKeyPointer ) {
	
	var childNode = this._pointers [ keyPointer ];	
	var parentNode = parentKeyPointer ? this._pointers [ parentKeyPointer ] : this._dom;
	parentNode.appendChild ( childNode );	
}


/**
 * Button image handling have been separated out so that we 
 * can hardcode-declare it for certain types of buttons.
 * @param {object} object Any type of object with four special properties.
 */
function ImageProfile ( object ) {
	
	this._default		= object.image;
	this._hover 		= object.imageHover;
	this._active		= object.imageActive;
	this._disabled		= object.imageDisabled;
}

/**
 * Get default image.
 * @return {string}
 */
ImageProfile.prototype.getDefaultImage = function () {

	return this._default;
}

/**
 * Set default image.
 * @param {string} image
 */
ImageProfile.prototype.setDefaultImage = function ( image ) {
	
	this._default = image;
}

/**
 * Get hover image.
 * @return {string}
 */
ImageProfile.prototype.getHoverImage = function () {

	return this._hover;
}

/**
 * Set default image.
 * @param {string} image
 */
ImageProfile.prototype.setHoverImage = function ( image ) {
	
	this._hover = image;
}

/**
 * Get active image.
 * @return {string}
 */
ImageProfile.prototype.getActiveImage = function () {

	return this._active;
}

/**
 * Set active image.
 * @param {string} image
 */
ImageProfile.prototype.setActiveImage = function ( image ) {
	
	this._active = image;
}

/**
 * Get disabled image.
 * @return {string}
 */
ImageProfile.prototype.getDisabledImage = function () {

	return this._disabled;
}

/**
 * Set disabled image.
 * @param {string} image
 */
ImageProfile.prototype.setDisabledImage = function ( image ) {
	
	this._disabled = image;
}

/**
 * @class
 * Locating bindings.
 */
function _BindingFinder () {}

_BindingFinder.prototype = {
	
	/**
	 * Get descendant bindings by nodename.
	 * @param {Binding} source
	 * @param {string} nodeName
 	 * @param {boolean} isChildrenOnly If set to true, return only children (not all descendants).
 	 * @return {List<Binding>}
	 */
	getDescendantBindingsByLocalName : function ( source, nodeName, isChildrenOnly ) {
	
		var result = null;
		if ( source.isAttached ) {
			result = new List ();
			var elements = isChildrenOnly ?
				 source.getChildElementsByLocalName ( nodeName ) : 
				 source.getDescendantElementsByLocalName ( nodeName );
			elements.each ( function ( element ) {
				var binding = UserInterface.getBinding ( element );
				if ( binding ) {
					result.add ( binding );
				}
			});
		} else {
			var ouch = "Could not resolve descendants of unattached binding " + source.toString (); 
			if ( Application.isDeveloperMode ) {
				throw ouch;
			}
		}
		return result;
	},
	
	/**
	 * Get ancestor binding by type.
	 * @param {Class} impl
	 * @param {boolean} isTraverse If set to true, cross iframe boundaries.
 	 * @return {Binding}
	 */
	getAncestorBindingByType : function ( source, impl, isTraverse ) {
		
		var result = null;
		var node = source.bindingElement;
		while ( !result && node ) {
			node = node.parentNode;
			if ( UserInterface.hasBinding ( node )) {
				var binding = UserInterface.getBinding ( node );
				if ( binding instanceof impl ) {
					result = binding;
				}
			} else if ( isTraverse && node.nodeType == Node.DOCUMENT_NODE ) {
				var win = DOMUtil.getParentWindow ( node );
				if ( win != null ) {
					node = win.frameElement;
				} else {
					SystemDebug.stack ( arguments );
					break;
				}
			}
		}
		return result;
	},
	
	/**
	 * Get ancestor binding by nodename.
	 * @param {Binding} source
	 * @param {string} nodename
	 * @param {boolean} isTraverse If set to true, cross iframe boundaries.
	 * @return {Binding}
	 */
	getAncestorBindingByLocalName : function ( source, nodeName, isTraverse ) {
	
		var result = null;
		if ( nodeName == "*" ) {
			var node = source.bindingElement;
			while ( !result && ( node = node.parentNode ) != null ) {
				if ( UserInterface.hasBinding ( node )) {
					result = UserInterface.getBinding ( node );
				}
			}
		} else {
			result = UserInterface.getBinding ( 
				DOMUtil.getAncestorByLocalName ( nodeName, source.bindingElement, isTraverse )
			);
		}
		return result;
	},
	
	/**
	 * Get child elements by nodename.
	 * @param {Binding} source
	 * @param {string} nodeName
	 * @return {List<DOMElement>}
	 */
	getChildElementsByLocalName : function ( source, nodeName ) {
		
		var result = new List ();
		var children = new List ( source.bindingElement.childNodes );
		children.each ( function ( child ) {
			if ( child.nodeType == Node.ELEMENT_NODE ) {
				if ( nodeName == "*" || DOMUtil.getLocalName ( child ) == nodeName ) {
					result.add ( child );
				}
			}
		});
		return result;
	},
	
	/**
	 * Get the FIRST child binding of a specified type.
	 * @param {Binding} source
	 * @param {Class} impl
	 * @return {Binding}
	 */
	getChildBindingByType : function ( source, impl ) {
	
		var result = null;
		source.getChildElementsByLocalName ( "*" ).each ( 
			function ( child ) {
				var binding = UserInterface.getBinding ( child );
				if ( binding != null && binding instanceof impl ) {
					result = binding;
					return false;
				} else {
					return true;
				}
			}
		);
		return result;
	},
	
	/**
	 * Get the FIRST decendant binding of a specified type.
	 * TODO: Merge with getChildBindingByType. 
	 * @param {Binding} source
	 * @param {Class} impl
	 * @return {Binding}
	 */
	getDescendantBindingByType : function ( source, impl ) {
		
		var result = null;
		source.getDescendantElementsByLocalName ( "*" ).each ( 
			function ( child ) {
				var binding = UserInterface.getBinding ( child );
				if ( binding != null && binding instanceof impl ) {
					result = binding;
					return false;
				} else {
					return true;
				}
			}
		);
		return result;
	},
	
	/**
	 * Get ALL decendant binding of a specified type. 
	 * @param {Binding} source
	 * @param {Class} impl
	 * @return {List<Binding>}
	 */
	getDescendantBindingsByType : function ( source, impl ) {
		
		var result = new List ();
		source.getDescendantElementsByLocalName ( "*" ).each ( 
			function ( descendant ) {
				var binding = UserInterface.getBinding ( descendant );
				if ( binding != null && binding instanceof impl ) {
					result.add ( binding );
				}
				return true;
			}
		);
		return result;
	},
	
	/**
	 * Get next binding by name.
	 * @param {Binding} binding
	 * @param {string} name
	 * @return {Binding}
	 */
	getNextBindingByLocalName : function ( binding, name ) {
		
		var result = null;
		var element = binding.bindingElement;
		while (( element = DOMUtil.getNextElementSibling ( element )) != null && DOMUtil.getLocalName ( element ) != name ) {}
		if ( element != null ) {
			result = UserInterface.getBinding ( element );
		}
		return result;
	},
	
	/**
	 * Get previous binding by name.
	 * @param {Binding} binding
	 * @param {string} name
	 * @return {Binding}
	 */
	getPreviousBindingByLocalName : function ( binding, name ) {
		
		var result = null;
		var element = binding.bindingElement;
		while (( element = DOMUtil.getPreviousElementSibling ( element )) != null && DOMUtil.getLocalName ( element ) != name ) {}
		if ( element != null ) {
			result = UserInterface.getBinding ( element );
		}
		return result;
	}
};

/**
 * The instance that does it.
 * @type {_BindingFinder}
 */
var BindingFinder = new _BindingFinder ();

NodeCrawler.NORMAL = 1;
NodeCrawler.SKIP_NODE = 2;
NodeCrawler.SKIP_CHILDREN = 4;
NodeCrawler.STOP_CRAWLING = 8;

NodeCrawler.TYPE_DESCENDING = "descending";
NodeCrawler.TYPE_ASCENDING = "ascending";

/**
 * @class
 * The NodeCrawler will climb up and down the DOM tree.
 */
function NodeCrawler () {
	
	this._construct ();
	return this;
}

NodeCrawler.prototype = {
	
	/**
	 * @type {SystemLogger}
	 */
	logger: SystemLogger.getLogger ( "NodeCrawler" ),
		
	/**
	 * Type (defaults to descending).
	 * @type {string}
	 */
	type : NodeCrawler.TYPE_DESCENDING,
	
	/**
	 * The current node.
	 * @type {DOMElement}
	 */
	currentNode : null,
	
	/**
	 * The previous node.
	 * @type {DOMElement}
	 */
	previousNode : null,
	
	/**
	 * @type {DOMDocument}
	 */
	contextDocument : null,
	
	/**
	 * Filter list. Note that the filter list is not inherited to 
	 * subclasses, ie. all NodeCrawlers start with an empty list.
	 * @type {List<function>
	 */
	_filters : null,
	
	/**
	 * This will allow us to subclass safely. 
	 */
	_construct : function () {
		
		this.currentNode = null,
		this.previousNode = null;
		this.nextNode = null;
		this._filters = new List ();
		this.type = NodeCrawler.TYPE_DESCENDING;
	},
	
	/**
	 * Add node filter.
	 * @param {function} filter
	 */
	addFilter : function ( filter ) {
	
		this._filters.add ( filter );
	},
	
	/**
	 * Remove node filter.
	 * TODO: Test this method.
	 * @param {function} filter
	 */
	removeFilter : function ( filter ) {
		
		var index = -1;
		this._filters.each ( function ( fil ) {
			index ++;
			var result = true;
			if ( fil == filter ) {
				result = false;
			}
			return result;
		});
		if ( index >-1 ) {
			this._filters.del ( index );
		}
	},
	
	/**
	 * Apply functions to a given node. Return type info:
	 * 
	 * SKIP_NODE and STOP_CRAWLING will discontinue both 
	 * filter execution and DOM traversal immediately.
	 * 
	 * SKIP_CHILDREN will not stop the filter execution  
	 * chain, it only affects the DOM traversal on next 
	 * iteration of the _crawl method. Note that this  
	 * may itself be modified by a later function in the 
	 * filter chaing (by setting the response to NORMAL).
	 * 
	 * @param {DOMNode} node
	 * @return
	 */
	_applyFilters : function ( node, arg ) {
		
		var returnable = null;
		var stop = NodeCrawler.STOP_CRAWLING;
		var skip = NodeCrawler.SKIP_NODE;
		var block = NodeCrawler.SKIP_CHILDREN;
		
		this._filters.reset ();
		var isContinue = true;
		
		while ( this._filters.hasNext () && isContinue == true ) {
			var filter = this._filters.getNext ();
			//var res = filter ( node, arg );
			var res = filter.call ( this, node, arg );
			if ( res != null ) {
				returnable = res;
				switch ( res ) {
					case stop :
					case skip :
					case skip + block :
						isContinue = false;
						break;
				}
			}
		}
		return returnable;
	},
	
	/**
	 * Start crawling.
	 * @param {DOMElement} element
	 * @param {object} arg
	 */
	crawl : function ( element, arg ) {
		
		this.contextDocument = element.ownerDocument;
		this.onCrawlStart ();
		
		/*
		 * TODO: Does ascending crawler evaluates first node twice?
		 */
		var isAscending = this.type == NodeCrawler.TYPE_ASCENDING;
		var returnable = this._applyFilters ( element, arg );
		
		/*
		 * Where to crawl next? Special setup when start crawling.
		 */
		if ( returnable != NodeCrawler.STOP_CRAWLING ) {
			if ( isAscending && returnable == NodeCrawler.SKIP_CHILDREN ) {
				// stop here!
			} else {
				var next = null;
				if ( this.nextNode != null ) {
					next = this.nextNode;
					this.nextNode = null;
				} else {
					next = isAscending ? element.parentNode : element;
				}
				this._crawl ( next, arg );
			}
		}
		
		this.onCrawlStop ();
	},
	
	/**
	 * Invoked when crawl is instantiated. Doing nothing  
	 * by default, this is for subclasses to overwrite.
	 */
	onCrawlStart : function () {},
	
	/**
	 * Invoked when crawl is terminated. Doing nothing  
	 * by default, this is for subclasses to overwrite.
	 */
	onCrawlStop : function () {},
	
	/**
	 * @param {DOMElement} element
	 * @param {object} arg
	 * @return {String}
	 */
	_crawl : function ( element, arg ) {
		
		var returnable = null;
		switch ( this.type ) {
			case NodeCrawler.TYPE_DESCENDING :
				returnable = this._crawlDescending ( element, arg );
				break;
			case NodeCrawler.TYPE_ASCENDING :
				returnable = this._crawlAscending ( element, arg );
				break;
		}
		return returnable;
	},
	
	/**
	 * Crawl descending.
	 * @param {DOMElement} element
	 * @param {object} arg
	 * @param {boolean} isInternal
	 * @return {String}
	 */
	_crawlDescending : function ( element, arg ) {
		
		var skip = NodeCrawler.SKIP_NODE;
		var block = NodeCrawler.SKIP_CHILDREN;
		var stop = NodeCrawler.STOP_CRAWLING;
		
		var returnable = null;
		
		if ( element.hasChildNodes ()) {
			
			var node = element.firstChild;
			while ( node != null && returnable != stop ) {
				
				this.currentNode = node;
				returnable = this._applyFilters ( node, arg );
				
				switch ( returnable ) {
					case stop :
					case block :
					case skip + block :
						break;
					default :
						if ( node.nodeType == Node.ELEMENT_NODE ) {
							if ( this.nextNode == null ) {
								var res = this._crawl ( node, arg ); 
								if ( res == stop ) {
									returnable = stop;
									break;
								}
							}
						}
						if ( returnable != stop && returnable != skip ) {
							this.previousNode = node; // .... move this up? Think about it...
						}
						break;
				}
				if ( returnable != stop ) {
					node = this.nextNode ? this.nextNode : node.nextSibling;
					this.nextNode = null;
				}
			}
		}
		
		return returnable;
	},
	
	/**
	 * Crawl ascending.
	 * @param {DOMElement} element.
	 * @param {object} arg
	 * @return {String}
	 */
	_crawlAscending : function ( element, arg ) {
		
		var returnable = null;
		var skip = NodeCrawler.SKIP_CHILDREN;
		var stop = NodeCrawler.STOP_CRAWLING;
		
		if ( element != null ) {
			this.currentNode = element;
			returnable = this._applyFilters ( element, arg );
			if ( returnable != stop ) {
				var next = this.nextNode ? this.nextNode : element.parentNode;
				this.nextNode = null;
				if ( next && next.nodeType != Node.DOCUMENT_NODE ) {
					this.previousNode = element;
					returnable = this._crawl ( next, arg );
				}
			}
		} else {
			returnable = stop;
		}
		return returnable;
	}
}

/**
 * Dispose crawler. The benefit of this has not been documented, 
 * but leaking closures may be hiding in the filters...
 */
NodeCrawler.prototype.dispose = function () {
	
	this._filters.dispose ();
	for ( var property in this ) {
		this [ property ] = null;
	}
}

ElementCrawler.prototype = new NodeCrawler;
ElementCrawler.prototype.constructor = ElementCrawler;
ElementCrawler.superclass = NodeCrawler.prototype;

/**
 * @class
 * The ElementCrawler sees only element nodes.
 */
function ElementCrawler () {

	this._construct ();
	return this;
}

/**
 * Filter all but Element nodes.
 * @overloads {NodeCrawler#_construct} 
 */
ElementCrawler.prototype._construct = function () {
	
	ElementCrawler.superclass._construct.call ( this );
	
	this.addFilter ( function ( node, arg ) {
		var result = null;
		if ( node.nodeType != Node.ELEMENT_NODE ) {
			result = NodeCrawler.SKIP_NODE;
		}
		return result;
	});
}

BindingCrawler.prototype = new ElementCrawler;
BindingCrawler.prototype.constructor = BindingCrawler;
BindingCrawler.superclass = ElementCrawler.prototype;

/**
 * @class
 * The ElementCrawler sees only elements with Bindings attached.
 */
function BindingCrawler () {
	
	this._construct ();
	return this;
}

/**
 * * Filter all but Binding elements.
 * @overloads {ElementCrawler#_construct} 
 */
BindingCrawler.prototype._construct = function () {
	
	BindingCrawler.superclass._construct.call ( this );
	
	this.addFilter ( function ( element, arg ) {
		var result = null;
		if ( !UserInterface.hasBinding ( element )) {
			result = NodeCrawler.SKIP_NODE;
		}
		return result;
	});
}

Crawler.prototype = new BindingCrawler;
Crawler.prototype.constructor = Crawler;
Crawler.superclass = BindingCrawler.prototype;

/**
 * @class
 * The Crawler will climb all binding elements and 
 * invoke a method on the associated Binding.
 */
function Crawler () {
	
	/**
	 * The binding may recognize the intent of 
	 * the crawler by addressing the id property.
	 * @type {string}
	 */ 
	this.id = null;

	/**
	 * The binding may control the bindings behavior - eg skip, 
	 * stop or skip children - by modifying this property. We 
	 * do it like this because a response type on the method 
	 * <code>handleCrawler</code> would surely get lost in 
	 * method overloading...
	 * @type {string}
	 */
	this.response = null;
	
	/*
	 * Construct.
	 */
	this._construct ();
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Fires the method <code>handleCrawler</code> an any waiting binding. 
 * @overloads {BindingCrawler#_construct} 
 */
Crawler.prototype._construct = function () {
	
	Crawler.superclass._construct.call ( this );
	
	this.response = null;

	var self = this;
	this.addFilter ( function ( element, arg ) {
		var result = null;
		var binding = UserInterface.getBinding ( element );
		if ( Interfaces.isImplemented ( ICrawlerHandler, binding ) == true ) {
			self.response = null;
			binding.handleCrawler ( self );
			result = self.response;		
		}
		return result;
	});
}

FlexBoxCrawler.prototype = new Crawler;
FlexBoxCrawler.prototype.constructor = FlexBoxCrawler;
FlexBoxCrawler.superclass = Crawler.prototype;

FlexBoxCrawler.ID = "flexboxcrawler";
FlexBoxCrawler.MODE_FORCE = "force";
FlexBoxCrawler.MODE_NORMAL = "normal";

/**
 * @class
 * Crawler handles recursive flex.
 * @see {Binding#reflex}
 * @see {FlexBoxBinding.reflex}
 */
function FlexBoxCrawler () {
	
	/**
	 * Identifies the crawler.
	 * @type {string}
	 */
	this.id = FlexBoxCrawler.ID;
	
	/**
	 * Switching Crawler agressiveness.
	 * @type {string}
	 */
	this.mode = FlexBoxCrawler.MODE_NORMAL;
	
	/**
	 * This binding who instantiated the reflex action.
	 * @type {Binding}
	 */
	this.startBinding = null;
	
	/*
	 * Construction time again.
	 */
	this._construct ();
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * @overloads {Crawler#_construct} 
 */
FlexBoxCrawler.prototype._construct = function () {
	
	FlexBoxCrawler.superclass._construct.call ( this );

	var self = this;
	
	this.addFilter ( function ( element, list ) {
		
		var result = null;
		var binding = UserInterface.getBinding ( element );
		
		if ( Interfaces.isImplemented ( IFlexible, binding ) == true ) {
			
			/*
			 * Note that we don't check the value of property 
			 * isFlexible. That's because the flex method 
			 * may be used for other purposes than flexboxing.
			 */
			switch ( self.mode ) {		
				case FlexBoxCrawler.MODE_FORCE :
					list.add ( binding );
					break;
					
				case FlexBoxCrawler.MODE_NORMAL :
					if ( binding.isFlexSuspended == true ) {
						result = NodeCrawler.SKIP_CHILDREN;
					} else {
						list.add ( binding );
					}
					break;
			}
		}
		
		return result;
	});
}

FocusCrawler.prototype = new Crawler;
FocusCrawler.prototype.constructor = FocusCrawler;
FocusCrawler.superclass = Crawler.prototype;

FocusCrawler.ID = "focuscrawler";

FocusCrawler.MODE_INDEX = "index";
FocusCrawler.MODE_FOCUS = "focus";
FocusCrawler.MODE_BLUR = "blur";

/**
 * This crawler handles focus and blur.
 * @class
 */
function FocusCrawler () {
	 
	this.id = FocusCrawler.ID;
	this._construct ();
	return this;
}

/**
 * @overloads {Crawler#_construct} 
 */
FocusCrawler.prototype._construct = function () {
	
	FocusCrawler.superclass._construct.call ( this );
	
	this.addFilter ( function ( element, list ) {
		
		var result = null;
		var binding = UserInterface.getBinding ( element );
		
		if ( binding.isAttached == true ) {
			if ( Interfaces.isImplemented ( IFocusable, binding ) == true ) {
				if ( binding.isFocusable && binding.isVisible ) {
					switch ( this.mode ) {
						
						case FocusCrawler.MODE_INDEX :	
							list.add ( binding );
							break;
							
						case FocusCrawler.MODE_FOCUS :
							if ( !binding.isFocused ) {
								binding.focus ();
							}
							result = NodeCrawler.STOP_CRAWLING;
							break;
	
						case FocusCrawler.MODE_BLUR :
							if ( binding.isFocused == true ) {
								binding.blur ();
								result = NodeCrawler.STOP_CRAWLING;
							}
							break;
					}
				}
			}
		}
		//self._string += binding.toString () + ": " + result + "\n";
		
		return result;
	});
}

/*
FocusCrawler.prototype.onCrawlStart = function (){
	
	this._string = this.mode + "\n\n";
}

FocusCrawler.prototype.onCrawlStop = function (){
	
	this.logger.debug ( this._string );
}
*/

FitnessCrawler.prototype = new Crawler;
FitnessCrawler.prototype.constructor = FitnessCrawler;
FitnessCrawler.superclass = Crawler.prototype;

FitnessCrawler.ID = "fitnesscrawler";
FitnessCrawler.MODE_BRUTAL = "brutal fitness";
FitnessCrawler.MODE_TRAINING = "train fitness";

/**
 * This crawler handles focus and blur.
 * @class
 */
function FitnessCrawler () {
	 
	this.id = FitnessCrawler.ID;
	this.mode = FitnessCrawler.MODE_TRAINING; 
	this._construct ();
	return this;
}

/**
 * @overloads {Crawler#_construct} 
 */
FitnessCrawler.prototype._construct = function () {
	
	FitnessCrawler.superclass._construct.call ( this );
	
	this.addFilter ( function ( element, list ) {
		
		var result = null;
		var binding = UserInterface.getBinding ( element );
		
		if ( !binding.isVisible ) {
			result = NodeCrawler.SKIP_NODE + NodeCrawler.SKIP_CHILDREN; 
		}
		
		return result;
	});
	
	/*
	 * Collecting unfit members.
	 */
	this.addFilter ( function ( element, list ) {
		
		var result = null;
		var binding = UserInterface.getBinding ( element );
		
		if ( binding.isAttached ) {
			if ( Interfaces.isImplemented ( IFit, binding )) {
				if ( !binding.isFit || this.mode == FitnessCrawler.MODE_BRUTAL ) {
					list.add ( binding );
				}
			}
		}
		return null;
	});
};

/**
 * Integrate the UpdateManager framework with the amazing world of Bindings.
 * Accessed through instance variable "DocumentManager" declared below.
 */
function _DocumentUpdatePlugin () {
	
	if ( window.UpdateManager != null ) {
		UpdateManager.plugins.push ( this );
		this._setup ();
	}
}

_DocumentUpdatePlugin.prototype = {
		
	/**
	 * Identification.
	 * @return {String}
	 */
	toString : function () {
		
		return "[DocumentUpdatePlugin]";
	},
	
	/**
	 * @type {SystemLogger}
	 */
	_logger : SystemLogger.getLogger ( "DocumentUpdatePlugin [" + document.title + "]" ),
	
	/**
	 * True while UpdateManager is in action.
	 * @type {boolean}
	 */
	_isUpdating : false,
	
	/**
	 * Used to delegate element updates of type "attribute" to the associated binding. 
	 * In other words, let the binding know that the elements attributes were updated. 
	 * Remember that this must be wired up using the bindings "propertyMethodMap" thingy.
	 * @type {Map<String><String>}
	 */
	_attributesbuffer : null,
	
	/**
	 * Instead of attaching bindings on sight - when new elements are inserted - we 
	 * collect elements in a buffer and attach bindings them in the final phase. 
	 * This way, newly attached bindings may be fully aware of document structure. 
	 * Note: Updated attributes are evaluated "on sight", should this be changed?
	 * @type {List<Element>}
	 */
	_elementsbuffer : null,
	
	/**
	 * Debug DOM before and after? This throws out a pretty 
	 * verbose log statement, so let's not keep it enabled.
	 */
	isDebugging : Application.isDeveloperMode, // Application.isDeveloperMode
	
	/**
	 * Store before-DOM serialization here so that we   
	 * may debug before and after in a single output.
	 * @type {String}
	 */
	_oldDOM : null,
	
	/**
	 * Refocus last focused binding after replace.
	 * @type {String}
	 */
	_focusID : null,
		
	/**
	 * UpdateManager configuration and modification.
	 */
	_setup : function () {
	
		/*
		 * Prepare UpdatManager for hard work.
		 */
		UpdateManager.isDebugging = Application.isDeveloperMode;
		UpdateManager.hasSoftAttributes = true;
		UpdateManager.hasSoftSiblings = true;
		
		/*
		 * Setup update listeners and handle potential errors.
		 */
		DOMEvents.addEventListener ( document, DOMEvents.BEFOREUPDATE, this );
		DOMEvents.addEventListener ( document, DOMEvents.AFTERUPDATE, this );
		DOMEvents.addEventListener ( document, DOMEvents.ERRORUPDATE, this );
		DOMEvents.addEventListener ( window, DOMEvents.UNLOAD, this );
		
		/*
		 * This evil hackery fixes the glitch where a the Gecko serializer 
		 * would mess up the prefixes on HTML and UI elements. Since these 
		 * elements reside in the same namespace, Gecko is perfectly 
		 * entitled to do so. Unfortunately, it is also perfectly entitled  
		 * to ignore the evil hack presented below, but it does seem to work.
		 * TODO: Verify this after https://bugzilla.mozilla.org/show_bug.cgi?id=368437
		 */
		if ( Client.isMozilla ) {
			UpdateAssistant.serialize = function ( element ) {
				element = element.cloneNode ( true ); // don't modify UpdateManager.currentDOM!
				element.setAttributeNS ( Constants.NS_NS, "xmlns", Constants.NS_XHTML );
				element.setAttributeNS ( Constants.NS_NS, "xmlns:ui", Constants.NS_UI );
				return this._serializer.serializeToString ( element );
			};
		}
	
	},
	
	/**
	 * @implements {IEventListener}
	 * @param {Event} e
	 */
	handleEvent : function ( e ) {
		
		var target = DOMEvents.getTarget ( e );
		
		switch ( e.type ) {
		
			case DOMEvents.BEFOREUPDATE :
				this._beforeUpdate ( target );
				break;
				
			case DOMEvents.AFTERUPDATE :
				this._afterUpdate ( target );
				break;
				
			case DOMEvents.ERRORUPDATE :
				this._errorUpdate ();
				break;
				
			case DOMEvents.UNLOAD :
				if ( Application.hasLock ( this )) {
					Application.unlock ( this );
				}
				break;
		}
	},
	
	/**
	 * Invoked before an update AND before any updates. 
	 * @param {Element} target 
	 */
	_beforeUpdate : function ( target ) {
		
		var isBeginUpdate = ( target == document.documentElement );
		
		if ( isBeginUpdate ) {
			
			this._elementsbuffer = new List ();
			
			this._isUpdating = true;
			Application.lock ( this ); // TODO: doesn't work in IE
			
			// notify containing page 
			// TODO: nice method to locate the page!
			var root = UserInterface.getBinding ( document.body );
			if ( root != null ) {
				var page = root.getDescendantBindingByType ( PageBinding );
				if ( page != null ) {
					page.onBeforeUpdates ();
				}
			}
			
			var binding = FocusBinding.focusedBinding;
			if ( binding != null ) {
				this._focusID = binding.getID ();
			}
			
			if ( this.isDebugging ) {
				this._oldDOM = DOMSerializer.serialize ( UpdateManager.currentDOM, true );
			}
			
		} else {
			
			switch ( target.__updateType ) {
				case Update.TYPE_REPLACE :
				case Update.TYPE_REMOVE :
					DocumentManager.detachBindings ( target );
					break;
				case Update.TYPE_ATTRIBUTES :
					this._backupattributes ( target, false );
					break;
			}
		}
	},
	
	/**
	 * Invoked after an update AND after all updates. 
	 * @param {Element} target 
	 */
	_afterUpdate : function ( target ) {
		
		var isFinishedUpdate = ( target == document.documentElement );
		
		if ( isFinishedUpdate ) {
			 			
			/*
			 * Register and attach new bindings.
			 */
			var buffer = this._elementsbuffer;
			
			if ( buffer.hasEntries ()) {
				buffer.each ( function ( element ) {
					DocumentManager.attachBindings ( element );
				});
			}
			
			/*
			 * Unlock UI.
			 */
			this._isUpdating = false;
			Application.unlock ( this );
			
			// notify containing page 
			// TODO: nice method to locate the page!
			var root = UserInterface.getBinding ( document.body );
			if ( root != null ) {
				var page = root.getDescendantBindingByType ( PageBinding );
				if ( page != null ) {
					page.onAfterUpdates ();
				}
			}
			
			var binding = FocusBinding.focusedBinding;
			if ( binding == null ) {
				var element = document.getElementById ( this._focusID );
				if ( element != null ) {
					var binding = UserInterface.getBinding ( element );
					if ( binding != null ) {
						binding.focus ();
					}
				}
			}
			this._focusID = null;
			
			// debug before and after DOM
			if ( UpdateManager.summary != "" ) {
				if ( this.isDebugging ) {
					var newDOM = DOMSerializer.serialize ( UpdateManager.currentDOM, true );
					var debug = "NEW DOM: " + document.title + "\n\n" + newDOM + "\n\n";
					debug += "OLD DOM: " + document.title + "\n\n" + this._oldDOM;
					this._logger.debug ( debug );
					this._oldDOM = null;
				}
				this._logger.fine ( UpdateManager.summary );
			}
			
		} else {
			
			switch ( target.__updateType ) {
				case Update.TYPE_REPLACE :
				case Update.TYPE_INSERT :
					// DocumentManager.attachBindings ( target );
					this._elementsbuffer.add ( target );
					break;
				case Update.TYPE_ATTRIBUTES :
					this._backupattributes ( target, true );
					break;
			}
			
			/*
			 * Dispatch updated status from nearest Binding.
			 * TODO: Stamp the __updateType for any reason?
			 */
			switch ( target.id ) {
				
				case "__VIEWSTATE" :
				case "__EVENTTARGET" :
				case "__EVENTARGUMENT" :
				case "__EVENTVALIDATION" :
				case "__LASTFOCUS" :
				case "__REQUEST" :
				case "__RESPONSE" :
				case "__CONSOLEID" :
					break;
					
				default :
					
					/*
					 * Note that the Binding.ACTION_UPDATED action is not   
					 * always targetted at the binding that got updated; 
					 * but it will let a dialog know that layout was changed...
					 */
					var binding = UserInterface.getBinding ( target );
					while ( binding == null && target != null ) {
						binding = UserInterface.getBinding ( target );
						target = target.parentNode;
					}
					if ( binding != null ) {
						binding.dispatchAction ( Binding.ACTION_UPDATED );
					}
					break;
			}
		}
	},
	
	/**
	 * Update error!
	 */
	_errorUpdate : function () {
		
		Application.unlock ( this );
		var cry = "UpdateManager dysfunction:\n\n" + UpdateManager.errorsmessage;
		this._logger.error ( cry + "\n\n" + UpdateManager.pendingResponse );
		if ( Application.isDeveloperMode ) {
			alert ( cry );
		}
	},
	
	/**
	 * Backup attributes for comparison with updated attributes.
	 * @param {Element} element
	 * @param {boolean} isRestore
	 */
	_backupattributes : function ( element, isRestore ) {
		
		var binding = UserInterface.getBinding ( element );
		if ( binding != null ) {
			
			if ( isRestore ) {
				
				var buffer = this._attributesbuffer;
				var map = new Map (); 
				
				buffer.each ( function ( name, old ) {
					var now = element.getAttribute ( name );
					if ( now != null ) {
						if ( now != old ) {
							map.set ( name, Types.castFromString ( now ));
						}
					} else {
						map.set ( name, null );
					}
				});
				new List ( element.attributes ).each ( function ( att ) {
					if ( att.specified ) {
						if ( !buffer.has ( att.nodeName )) {
							map.set ( att.nodeName, Types.castFromString ( att.nodeValue ));
						}
					}
				});
				map.each ( function ( name, value ) {
					var method = binding.propertyMethodMap [ name ];
					if ( method != null ) {
						method.call ( binding, value );
					}
				});
				
			} else {
				
				var map = new Map ();
				new List ( element.attributes ).each ( function ( att ) {
					if ( att.specified ) {
						map.set ( att.nodeName, att.nodeValue );
					}
				});
				this._attributesbuffer = map;
			}
		}
	},
	
	
	// UPDATEPLUGIN METHODS ..............................................
	
	/**
	 * Handle element?
	 * @implements {IUpdateHandler}
	 * @param {Element} newelement
	 * @param {Element} oldelement
	 * @return {boolean}
	 */
	handleElement : function ( newelement, oldelement ) {
		
		// since we know that the element has a specied ID...
		var binding = window.bindingMap [ newelement.getAttribute ( "id" )];
		if ( binding != null ) {
			return binding.handleElement ( newelement, oldelement );
		}
	},
	
	/**
	 * Update element.
	 *	@implements {IUpdateHandler}
	 * @param {Element} newelement
	 * @param {Element} oldelement
	 * @return {boolean}
	 */
	updateElement : function ( newelement, oldelement ) {
		
		var binding = window.bindingMap [ newelement.getAttribute ( "id" )];
		if ( binding != null ) {
			return binding.updateElement ( newelement, oldelement );
		}
	}
}

/**
 * The instance that does it.
 * @type {_DocumentUpdatePlugin}
 */
var DocumentUpdatePlugin = new _DocumentUpdatePlugin ();

DocumentCrawler.prototype = new ElementCrawler;
DocumentCrawler.prototype.constructor = DocumentCrawler;
DocumentCrawler.superclass = ElementCrawler.prototype;

DocumentCrawler.ID = "documentcrawler";
DocumentCrawler.MODE_REGISTER = "register";
DocumentCrawler.MODE_ATTACH = "attach";
DocumentCrawler.MODE_DETACH = "detach";

/**
 * @class
 * This be the crawler that attaches and detaches bindings. When a binding has 
 * the DocumentCrawler.ID included in it's "crawlerFilters" property, it means 
 * that the binding is not supposed to have descendant bindings (or that the  
 * binding will handle descendant bindings registration and attachment itself).
 */
function DocumentCrawler () {
	
	this.mode = DocumentCrawler.MODE_REGISTER;
	this.id = DocumentCrawler.ID;
	this._construct ();
	return this;
}

/**
 * @overloads {Crawler#_construct} 
 */
DocumentCrawler.prototype._construct = function () {
	
	DocumentCrawler.superclass._construct.call ( this );
	
	var self = this;
	this.addFilter ( function ( element, list ) {
		
		var binding = UserInterface.getBinding ( element );
		var result = null;
		
		switch ( self.mode ) {
			
			case DocumentCrawler.MODE_REGISTER :
				if ( binding == null ) {
					UserInterface.registerBinding ( element );
				}
				break;
				
			case DocumentCrawler.MODE_ATTACH :
				if ( binding != null ) {
					if ( !binding.isAttached ) {
						list.add ( binding );
					}
					if ( binding.isLazy == true ) {
						result = NodeCrawler.SKIP_CHILDREN;
					}
				}
				break;
				
			case DocumentCrawler.MODE_DETACH :
				if ( binding != null ) {
					list.add ( binding );
				}
				break;
		}
		return result;
	});
}

/**
 * Accessed through instance variable "DocumentManager" declared below.
 */
function _DocumentManager () {
	
	this._construct ();
}

_DocumentManager.prototype = {
	
	_logger	: SystemLogger.getLogger ( "DocumentManager [" + document.title + "]" ),
	_maxIndex : -1, // MOVE THIS!
	
	/**
	 * Exposes special binding associations for the {@link UserInterface}.
	 * @type {UserInterfaceMapping} 
	 */
	customUserInterfaceMapping : null,
	
	/**
	 * Determines whether or not document text is selectable.
	 * @type {boolean}
	 */
	isDocumentSelectable : false,
	
	/**
	 * Determines whether or not to display the browsers own contextmenu on rightclick.
	 * Note that the contextmenu will *not* be disabled for textareas and inputfields.
	 * @type {boolean}
	 */
	hasNativeContextMenu : false,
	
	/**
	 * Constructor action.
	 */
	_construct : function () {
	
		/*
		 * Setup standard framework event listeners.
		 * Intercepting mousedown, mousemov, mouseup, keydown, keyup.
		 */
		Application.framework ( document );
		
		/*
		 * Initializing when window is fully loaded.
		 * 1) Setup textcontent selection.
		 * 2) Setup contextmenu handling
		 * 3) Resolve custom bindings
		 * 4) Resolve lazy bindings
		 * 5) Attach bindings.
		 */
		EventBroadcaster.subscribe ( WindowManager.WINDOW_LOADED_BROADCAST, this );
		
		/*
		 * For explorer, disable audible clicks when navigating dummy hypertext links.
		 */
		if ( Client.isExplorer ) {
			DOMEvents.addEventListener ( document, DOMEvents.CLICK, this );
		}
		
	},
	
	/**
	 * @implements {IBroadcastListener}
	 * @param {String} broadcast
	 * @param {Object} arg
	 */
	handleBroadcast : function ( broadcast, arg ) {
		
		if ( !this.isDocumentSelectable ) {
			this._makeDocumentUnselectable ();
		}
		if ( !this.hasNativeContextMenu ) {
			DOMEvents.addEventListener ( document, DOMEvents.CONTEXTMENU, this );
		}
		if ( !Application.isMalFunctional ) {
			this._resolveCustomBindingMappings ();
			this.attachBindings ( document.documentElement);
		}
	},
	
	/**
	 * @implements {IEventListener}
	 * @param {Event} e
	 */
	handleEvent : function ( e ) {
		
		var target = DOMEvents.getTarget ( e );
		
		switch ( e.type ) {
				
			case DOMEvents.SELECTSTART :
			case DOMEvents.CONTEXTMENU :
				if ( !this._isTextInputElement ( target )) {
					DOMEvents.preventDefault ( e );
				}
				break;

			case DOMEvents.CLICK :
				if ( Client.isExplorer ) {
					if ( target.href && target.href.indexOf ( Constants.DUMMY_LINK ) >-1 ) {
						DOMEvents.preventDefault ( e );
					}
				}
				break;
		}
	},
	
	
	/** 
	 * Resolve custom bindingmappings scoped for this window. 
	 * This is done here, not in a ordinary Binding, because 
	 * we need this stuff to be evaluated max pronto up front.
	 */
	_resolveCustomBindingMappings : function () {
		
		var bindingset = DOMUtil.getElementsByTagName ( document.documentElement, "bindingmappingset" ).item ( 0 );
		if ( bindingset != null ) {
			var map = {};
			var mappings = DOMUtil.getElementsByTagName ( bindingset, "bindingmapping" );
			new List ( mappings ).each (
				function ( mapping ) {
					var element = mapping.getAttribute ( "element" );
					var binding = mapping.getAttribute ( "binding" );
					map [ element ] = eval ( binding );
				}
			);
			this.setCustomUserInterfaceMapping (
				new UserInterfaceMapping ( map )
			);
		}
	},
	
	/**
	 * Register custom bindingmapping. This will merge with any previously registerd mapping.
	 * @param {UserInterfaceMapping} mapping
	 */
	setCustomUserInterfaceMapping : function ( mapping ) {
		
		if ( this.customUserInterfaceMapping == null ) {
			this.customUserInterfaceMapping = mapping;
		} else {
			this.customUserInterfaceMapping.merge ( mapping );
		}
	},
	
	/**
	 * Register bindings on and within a given container.
	 * @param {DOMElement} element
	 */
	_registerBindings : function ( element ) {
		
		var crawler = new DocumentCrawler ();
		crawler.mode = DocumentCrawler.MODE_REGISTER;
		crawler.crawl ( element );
		crawler.dispose ();
	},
	
	/**
	 * Attach bindings on and within a given container.
	 * @param {DOMElement} container
	 */
	_attachBindings : function ( container ) {
		
		var crawler = new DocumentCrawler ();
		crawler.mode = DocumentCrawler.MODE_ATTACH;
		
		var list = new List ();
		crawler.crawl ( container, list );
		
		/*
		 * Because bindings may modify DOM structure upon 
		 * attachment (confusing the crawler), we collect them 
		 * all in a list before we invoke the onBindingAttach.
		 */
		var wasDataBinding = false;
		while ( list.hasNext ()) {
			var binding = list.getNext ();
			if ( !binding.isAttached ) {
				binding.onBindingAttach ();
				if ( !binding.memberDependencies ) {
					binding.onBindingInitialize ();
				}
				if ( Interfaces.isImplemented ( IData, binding )) {
					wasDataBinding = true;
				}
			}
		}
		
		/*
		 * TODO: NOT ON DISPOSE PAGE!
		 * Update the focus list. Technically, the binding itself 
		 * should dispatch this (root may be located to high in the tree), 
		 * but this will stress up on bulk attachment via UpdateManager.  
		 */
		if ( wasDataBinding ) {
			var root = UserInterface.getBinding ( document.body );
			if ( root != null ) {
				setTimeout ( function () {
					if ( Binding.exists ( root )) {
						root.dispatchAction ( FocusBinding.ACTION_UPDATE );
					}
				}, 250 );
			}
		}
		
		crawler.dispose ();
		list.dispose ();
	},

	/** 
	 * Attach bindings on and within a given element.
	 * @param {DOMElement} element
	 * @param {boolean} isTiming
	 */
	attachBindings : function ( element ) {
		
		this._registerBindings ( element );
		this._attachBindings ( element );
	},

	/** 
	 * Detach bindings within and on a given element.
	 * @param {DOMElement} element
	 * @param {boolean} isElemnentSafe If true, only element descendants will detach.
	 */
	detachBindings : function ( element, isElementSafe ) {
	
		var crawler = new DocumentCrawler ();
		crawler.mode = DocumentCrawler.MODE_DETACH;
		
		var list = new List ();
		crawler.crawl ( element, list );
		
		/*
		 * Preserve binding on container element?
		 */
		if ( isElementSafe == true ) {
			list.extractFirst ();
		}
		
		/*
		 * Reverse collection, disposing bindings from deepest position in DOM tree.
		 * This way, bindings will still have access to parent bindings when disposed. 
		 * Please not that we only nuke the Binding objects here, not the DOMElements, 
		 * as designated by the boolean argument passed to Binding#dispose.
		 */
		var wasDataBinding = false;
		list.reverse ().each ( function ( binding ) {
			if ( Interfaces.isImplemented ( IData, binding )) {
				wasDataBinding = true;
			}
			binding.dispose ( true );
		});
		
		/*
		 * TODO: NOT ON DISPOSE PAGE!
		 * Update the focus list. Technically, the binding itself 
		 * should dispatch this (root may be located to high in the tree), 
		 * but this will stress up on bulk detachment via UpdateManager.  
		 */
		if ( wasDataBinding ) {
			var root = UserInterface.getBinding ( document.body );
			if ( root != null ) {
				setTimeout ( function () {
					if ( Binding.exists ( root )) {
						root.dispatchAction ( FocusBinding.ACTION_UPDATE );
					}
				}, 250 );
			}
		}
		
		/*
		 * Cleanup.
		 */
		crawler.dispose ();
		list.dispose ();
	},
	
	/**
	 * Detach all bindings in document. Invoked when disposing the containing WindowBinding. 
	 * Local instances of WindowBinding will detach their bindings recursively, chain reaction.
	 * @see {WindowBinding#onBindingDispose}
	 */
	detachAllBindings : function () {
		
		this.detachBindings ( document.documentElement);
	},
	
	/**
	 * Scann all z-index values and compute a new, highest value. 
	 * Elements are actually only scanned when first called;
	 * henceforth the value is simply incremented.
	 * TODO: deprecate?
	 * @return {int}
	 */
	computeMaxIndex : function () {
		
		if ( this._maxIndex == -1 ) {
			this._maxIndex = DOMUtil.getMaxIndex ( document );
		}
		return this._maxIndex ++;
	},
	
	/**
	 * Test whether or not an element is an interactive text input field.
	 * TODO: optimize
	 * @param {DOMElement} element
	 * @return {boolean}
	 */
	_isTextInputElement : function ( element ) {
	
		return ( /textarea|input/.test ( 
			DOMUtil.getLocalName ( element )
		));
	},
	
	/*
	 * Prevent non-relevant GUI elements from being selected with the mouse.
	 */
	_makeDocumentUnselectable : function () {
	
		if ( Client.isExplorer ) {
			
			DOMEvents.addEventListener ( document, DOMEvents.SELECTSTART, this );
			
		} else {
			// Ideally, we would say: document.body.style.MozUserSelect = "none";
			// But if we disable user-selection on root element, a bug 
			// prevents descendant nodes from being selected (bug 203291).
			// Instead, all ui:label elements have been made unselectable via CSS.
		}
	}
}

/**
 * The instance that does it.
 * @type {_DocumentManager}
 */
var DocumentManager = new _DocumentManager ();

/**
 * Accessed through instance variable "WindowManager" declared below.
 */
function _DataManager () {}
_DataManager.prototype = {
	
	/**
	 * Flip to enable Ajax style postback and update.
	 * @type {boolean}
	 */
	isPostBackFun : false,
	
	/**
	 * @type {SystemLogger}
	 */
	_logger : SystemLogger.getLogger ( "DataManager [" + document.title + "]" ),
	
	/**
	 * @type {HashMap<string><IData>}
	 */
	_dataBindings : {},
	
	/**
	 * This dirty flag will be falsed by a "persist" or "save" postMessage. 
	 * If true, something was changed in this document since last postMessage.
	 * @see {PageBinding#postMessage}  
	 * @type {boolean}
	 */
	isDirty : false,
	
	/**
	 * Make binding AND DataManager dirty. 
	 * 1) The binding will remain dirty until "save" is successful (note success!) 
	 * 2) DataManager is dirty until a "save" or "persist" postMessage is attempted. 
	 * @param {DataBinding} binding
	 * @return {boolen} True if the binding switched to dirty
	 */
	dirty : function ( binding ) {
		
		this.isDirty = true;
		
		var result = false;
		if ( binding != null && !binding.isDirty ) {	
			binding.isDirty = true;
			binding.dispatchAction ( Binding.ACTION_DIRTY );
			result = true;
		}
		
		return result;
	},
	
	/**
	 * Make binding clean.
	 * @param {DataBinding} binding
	 */
	clean : function ( binding ) {
		
		if ( binding.isDirty ) {
			binding.isDirty = false;
		}
	},
	
	/**
	 * Register DataBinding. Remember that this will only happen 
	 * automatically if and when the DataBinding has a name property.
	 * @param {string} name
	 * @param {DataBinding} binding
	 */
	registerDataBinding : function ( name, binding ) {
		
		if ( Interfaces.isImplemented ( IData, binding, true )) {
			if ( this._dataBindings [ name ] != null ) {
				throw "no proper support for checkbox multiple values! " + name ;
			} else {
				this._dataBindings [ name ] = binding;
			}
		} else {
			throw "Invalid DataBinding: " + binding;
		}
	},
	
	/**
	 * Unregister DataBinding.
	 * @param {string} name
	 */
	unRegisterDataBinding : function ( name ) {
		
		if ( this._dataBindings [ name ] != null ) {
			delete this._dataBindings [ name ];
		}
	},
	
	/**
	 * Get DataBinding by name.
	 * @return {DataBinding}
	 */
	getDataBinding : function ( name ) {
		
		var result = null;
		if ( this._dataBindings [ name ] != null ) {
			result = this._dataBindings [ name ];
		}
		return result;
	},
	
	/**
	 * Get list of all DataBindings - possibly even from descendant windows.
	 * @param {boolean} isTraverse
	 * @return {List<DataBinding>}
	 */
	getAllDataBindings : function ( isTraverse ) {
		
		var list = new List ();
		for ( var name in this._dataBindings ) {
			var binding = this._dataBindings [ name ];
			list.add ( binding );
			if ( isTraverse && binding instanceof WindowBinding ) {
				var manager = binding.getContentWindow ().DataManager;
				if ( manager != null ) {
					list.merge ( manager.getAllDataBindings ());
				}
			}
		}
		return list;
	},
	
	/**
	 * Has DataBindings?
	 * @return {boolean}
	 */
	hasDataBindings : function () {
		
		var result = false;
		for ( var name in this._dataBindings ) {
			result = true;
			break;
		}
		return result;
	},
	
	/**
	 * Populate DataBindings.
	 * @param {DataBindingMap} map
	 */
	populateDataBindings : function ( map ) {
		
		if ( map instanceof DataBindingMap ) {
			map.each ( function ( name, value ) {
				var dataBinding = this._dataBindings [ name ];
				if ( dataBinding != null ) {
					switch ( map.type ) {
						case DataBindingMap.TYPE_RESULT :
							try {
								dataBinding.setResult ( value );
							} catch ( exception ) {
								if ( Application.isDeveloperMode ) {
									alert ( dataBinding );
								}
								throw exception;
							}
							break;
						case DataBindingMap.TYPE_VALUE :
							throw "Not implemented!";
					}
				}
			});
		}
	},
	
	/**
	 * Collect all DataBinding values in a single name-value hashmap.
	 * @return {HashMap<string><string>}
	 */
	getDataBindingValueMap : function () {
		
		var result = new DataBindingMap ();
		result.type = DataBindingMap.TYPE_VALUE;
		
		for ( var name in this._dataBindings ) {
			var dataBinding = this._dataBindings [ name ];
			if ( dataBinding instanceof DataDialogBinding ) {
				throw "DataDialogBinding valuemap not supported!";
			}
			result [ name ] = dataBinding.getValue ();
		}
		return result;
	},
	
	/**
	 * Collect and combine all DataBinding results in a single DataBindingMap.
	 * Notice that we call the getResult method instead of getValue. The "value"
	 * is for the serverside while the "result" is automatically typecasted 
	 * for clientside handling and/or can be set to complex objects.
	 * @return {DataBindingMap} 
	 */
	getDataBindingResultMap : function () {
		
		var result = new DataBindingMap ();
		result.type = DataBindingMap.TYPE_RESULT;
		
		for ( var name in this._dataBindings ) {
			var binding = this._dataBindings [ name ];
			var res = binding.getResult ();
			if ( res instanceof DataBindingMap ) {
				res.each ( function ( name, value ) {
					result.set ( name, value );
				});
			} else {
				result.set ( name, res );
			}
		}
		return result;
	},
	
	/**
	 * Harvest form elements to produce a humongous querystring. This will collect  
	 * all form elements, not just those produced by the DataBinding manifest method.
	 */
	getPostBackString : function () {
		
		var result = "";
		var form = document.forms [ 0 ];
		
		if ( form != null ) {
			var lastname = "";
			new List ( form.elements ).each ( function ( element ) {
				
				var name = element.name;
				var value = encodeURIComponent ( element.value );
				
				switch ( element.type ) {
					
					case "text":
					case "hidden":
					case "password":
					case "textarea":
					case "select-one" :
						result += name + "=" + value + "&";
						break;
						
					case "submit" :
						if ( document.activeElement == element ) { // or what?
							result += name + "=" + value + "&";
						}
						break;
						
					case "radio":
						if ( element.checked ) {
							result += name + "=" + value + "&";
						}
						break;
						
					case "checkbox":
						if ( element.checked ) {
							if ( element.name == lastname ) {
								if ( result.lastIndexOf ( "&" ) == result.length - 1 ) {
									result = result.substr ( 0, result.length - 1 );
								}
								result += "," + value;
							}
							else {
								result += name + "=" + element.value;
							}
							lastname = name;
							result += "&";
						}
						break;
						
				}
			});
		}
		
		return result.substr ( 0, result.length - 1 ); // trailing "&"
	}
}

/**
 * The instance that does it.
 * @type {_DataManager}
 */
var DataManager = new _DataManager ();

/**
 * @class
 * This can retrieve all sorts of stuff located in the root "templates" folder. 
 * Stuff can be retrieved as either pure text, DOMDocuments and DOMElements.
 */
function _Templates () {}

_Templates.prototype = {
	
	/**
	 * @type {SystemLogger}
	 */
	_logger : SystemLogger.getLogger ( "Templates" ),
	
	/**
	 * @type {HashMap<string><object>}
	 */
	_cache : {},
	
	/**
	 * @type {int}
	 */
	_mode : null,
	
	/**
	 * @type {object}
	 */
	_modes : {
		MODE_PLAINTEXT		: 0,
		MODE_DOCUMENT		: 1,
		MODE_ELEMENT		: 2,
		MODE_DOCUMENTTEXT	: 3,
		MODE_ELEMENTTEXT	: 4
	},
	
	/**
	 * Get template as DOMDocument.
	 * @param {string} name
	 * @return {DOMDocument}
	 */
	getTemplateDocument : function ( name ) {
	
		this._mode = this._modes.MODE_DOCUMENT;
		return this._getIt ( name );
	},
	
	/**
	 * Get template as DOMElement.
	 * @param {string} name
	 * @return {DOMElement}
	 */
	getTemplateElement : function ( name ) {
	
		this._mode = this._modes.MODE_ELEMENT;
		return this._getIt ( name );
	},
	
	/**
	 * Get template as serialized DOMDocument.
	 * @param {string} name
	 * @return {string}
	 */
	getTemplateDocumentText : function ( name ) {
	
		this._mode = this._modes.MODE_DOCUMENTTEXT;
		return this._getIt ( name );
	},
	
	/**
	 * Get template as serialized DOMElement.
	 * @param {string} name
	 * @return {string}
	 */
	getTemplateElementText : function ( name ) {
	
		this._mode = this._modes.MODE_ELEMENTTEXT;
		return this._getIt ( name );
	},
	
	/**
	 * Superhacked method to fetch multiple "root" 
	 * nodes in textual form. The document structure 
	 * must take the form of an XHTML document...
	 * @param {string} name
	 * @return {string}
	 */
	getTemplateBodyText : function ( name ) {
		
		var tmp = this.getTemplateDocumentText ( name );
		tmp = tmp.split ( "<body>" )[ 1 ].split ( "</body>" )[ 0 ];
		return tmp;
	},
	
	/**
	 * Get template as plain text. This can read non-welformed templates.
	 * @param {string} name
	 * @return {string}
	 */
	getPlainText : function ( name ) {
	
		this._mode = this._modes.MODE_PLAINTEXT;
		return this._getIt ( name );
	},
	
	/**
	 * @param {string} name
	 * @return {object}
	 * @ignore
	 */ 
	_getIt : function ( name ) {
	
		var result = null;
		var entry = null;
		var isFresh = false;
		
		if ( !this._cache [ name ]) {
			
			isFresh = true;
			
			var uri = Constants.TEMPLATESROOT + "/" + name;
			var request = DOMUtil.getXMLHTTPRequest ();
			request.open ( "get", uri,  false );
			request.setRequestHeader ( "Content-Type", "text/xml; charset=UTF-8" );
			request.send ( null );
			
			switch ( this._mode ) {	
				case this._modes.MODE_PLAINTEXT :
					entry = request.responseText;
					break;
				default :
					entry = request.responseXML;
					break;
			}
			if ( entry == null ) {
				throw new Error ( "Templates: Could not read template. Malformed XML?" );
			} else {
				this._cache [ name ] = entry;
			}
		}
		
		entry = this._cache [ name ];
		
		switch ( this._mode ) {
			case this._modes.MODE_PLAINTEXT :
				result = entry;
				break;
			case this._modes.MODE_DOCUMENT :
				result = DOMUtil.cloneNode ( entry, true );
				break;
			case this._modes.MODE_ELEMENT :
				result = DOMUtil.cloneNode ( entry.documentElement, true );
				break;
			case this._modes.MODE_DOCUMENTTEXT :
				result = DOMSerializer.serialize ( entry, true );
				break;
			case this._modes.MODE_ELEMENTTEXT :
				result = DOMSerializer.serialize ( entry.documentElement, true );
				break;
		}
		
		/**
		 * Debug output for developers.
		 */
		if ( isFresh && Application.isDeveloperMode ) {
			this._logger.fine ( new String ( "Import \"" + name + "\":\n\n" + result ));
		}
		
		return result;
	}
}

/**
 * The instance that does it.
 */
var Templates = new _Templates ();

/** 
 * Actually just a simple configuration which can be 
 * used to construct a real {@link ClickButtonBinding}.
 * @param {object} obj Optional constructor object
 */
function DialogButton ( obj ) {

	/**
     * The button label.
	 * @type {string}
	 */
	this.label = null;
	
	/**
     * The button image.
	 * @type {string}
	 */
	this.image = null;
	
	/**
	 * The button response. This can be anything object; although usually a string.
	 * @type {object}
	 */
	this.response = null;
	
	/**
	 * Always focusable!
	 * @type {boolean}
	 */
	this.isFocusable = true;
	
	/**
	 * Is default button?
	 * @type {boolean}
	 */
	this.isDefault = false;
	
	/**
	 * Is focused?
	 * @type {boolean}
	 */
	this.isFocused = false;

	/*
	 * Initialize values from constructor
	 */
	if ( obj ) {
		for ( var prop in obj ) {
			if ( typeof this [ prop ] != "undefined" ) {
				this [ prop ] = obj [ prop ];
			} 
		}
	}
}

/**
 * @class
 */
function _Dialog () {
	
	this._construct ();
}

_Dialog.prototype = {
	
	/**
	 * @type {SystemLogger}
	 */
	_logger : SystemLogger.getLogger ( "Dialog" ),
	
	/*
	 * Standard dialogs are loaded from here.
	 */
	_URL_STANDARDDIALOG : "${root}/content/dialogs/standard/standard.aspx",
	
	/*
	 * Two basic types of dialogs.
	 */
	MODAL : "modal",
	NON_MODAL : "nonmodal",
	
	/*
	 * Some URL constants for common dialogs.
	 */
	URL_TREESELECTOR 	: "${root}/content/dialogs/treeselector/treeselector.aspx",
	URL_TREESEARCH 		: "${root}/content/dialogs/treesearch/treeSearchForm.aspx",
	URL_IMAGESELECTOR 	: "${root}/content/dialogs/treeselector/special/imageselector.aspx",
	URL_SERVICEFAULT 	: "${root}/content/dialogs/webservices/error.aspx",
	
	/*
	 * Some predefined button configurations
	 */
	BUTTONS_YES_NO_CANCEL 	: [ "yes:default", "no", "cancel" ],
	BUTTONS_ACCEPT_CANCEL 	: [ "accept:default", "cancel" ],
	BUTTONS_ACCEPT 			: [ "accept:default" ],
	
	/*
	 * Some predefined button response values
	 */
	RESPONSE_YES 		: "yes",
	RESPONSE_NO 		: "no",
	RESPONSE_ACCEPT 	: "accept",
	RESPONSE_CANCEL 	: "cancel",
	RESPONSE_DEFAULT	: "default",
	
	/*
	 * Some predefined standard dialog types
	 */
	_TYPE_WARNING 	: "warning",
	_TYPE_MESSAGE	: "message",
	_TYPE_ERROR 	: "error",
	_TYPE_QUESTION 	: "question",
	
	/*
	 * Hm. If these are defined by code, maybe the 
	 * dialog vignette should be expelled from CSS?
	 */
	_dialogImages : {
	
		"warning" 	: "${icon:warning}",
		"message" 	: "${icon:message}",
		"error" 	: "${icon:error}",
		"question" 	: "${icon:question}"
	},
	 
	/**
	 * Construction builds dialog buttons. 
	 */
	_construct : function () {
		
		this._dialogButtons = {
		
			"yes" 		: new DialogButton ({ label : "Yes", 	response : this.RESPONSE_YES }),
			"no" 		: new DialogButton ({ label : "No", 	response : this.RESPONSE_NO }),
			"accept" 	: new DialogButton ({ label : "OK", 	response : this.RESPONSE_ACCEPT }),
			"cancel" 	: new DialogButton ({ label : "Cancel", response : this.RESPONSE_CANCEL })
		}
	},
	
	/**
	 * Invoke dialog by URL.
	 * @param {string} url
	 * @param {IDialogResponseHandler} handler
	 * @param {object} argument
	 * @return {DialogViewDefinition}
	 */
	invoke : function  ( url, handler, argument ) {
			
		this._logger.error ( "Not implemented" );
	},
	
	/**
	 * Invoke modal dialog by URL.
	 * @param {string} url
	 * @param {IDialogResponseHandler} handler
	 * @param {object} argument
	 * @return {DialogViewDefinition}
	 */
	invokeModal : function ( url, handler, argument ) {
		
		var definition = new DialogViewDefinition ({
			handle 		: KeyMaster.getUniqueKey (),
			position	: Dialog.MODAL,
			url 		: url,
			handler		: handler,
			argument	: argument
		});
		
		StageBinding.presentViewDefinition ( definition );
		return definition;
	},

	/**
	 * Invoke dialog by definition. 
	 * @param {DialogViewDefinition} definition
	 * @return {DialogViewDefinition}
	 */
	invokeDefinition : function  ( definition ) {
		
		if ( definition instanceof DialogViewDefinition ) {
			StageBinding.presentViewDefinition ( definition );	
		}
		return definition;
	},
		
	/**
	 * Invoke question dialog.
	 * @param {string} title
	 * @param {string} text
	 * @param {array<DialogButton>} buttons
	 * @param {IDialogResponseHandler} handler
	 */
	question : function ( title, text, buttons, handler ) {
		
		if ( !buttons ) {
			buttons = this.BUTTONS_ACCEPT_CANCEL;
		}
		this._standardDialog ( this._TYPE_QUESTION, title, text, buttons, handler );
	},
	
	/**
	 * Invoke message dialog.
	 * @param {string} title
	 * @param {string} text
	 * @param {array<DialogButton>} buttons
	 * @param {IDialogResponseHandler} handler
	 */
	message : function ( title, text, buttons, handler ) {
		
		if ( !buttons ) {
			buttons = this.BUTTONS_ACCEPT;
		}
		this._standardDialog ( this._TYPE_MESSAGE, title, text, buttons, handler );
	},
	
	/**
	 * Invoke error dialog.
	 * @param {string} title
	 * @param {string} text
	 * @param {array<DialogButton>} buttons Defaults to Accept button.
	 * @param {IDialogResponseHandler} handler
	 */
	error : function ( title, text, buttons, handler ) {
		
		if ( !buttons ) {
			buttons = this.BUTTONS_ACCEPT;
		}
		this._standardDialog ( this._TYPE_ERROR, title, text, buttons, handler );
	},
	
	/**
	 * Invoke warning dialog.
	 * @param {string} title
	 * @param {string} text
	 * @param {array<DialogButton>} buttons
	 * @param {IDialogResponseHandler} handler
	 */
	warning :  function ( title, text, buttons, handler ) {
		
		if ( !buttons ) {
			buttons = this.BUTTONS_ACCEPT;
		}
		this._standardDialog ( this._TYPE_WARNING, title, text, buttons, handler );
	},
	
	/**
	 * TODO: example on how to invoke with custom buttons.
	 * @param {string} type
	 * @param {string} title
	 * @param {string} text
	 * @param {array<DialogButton>} buttons
	 * @param {IDialogResponseHandler} handler
	 * @ignore
	 */
	_standardDialog : function ( type, title, text, buttons, handler ) {
		
		var buttonList = null;
		
		if ( !buttons ) {
			buttonList = new List ( 
				Dialog.BUTTONS_ACCEPT
			);
		} else {
			buttonList = new List ();
			new List ( buttons ).each ( 
				function ( entry ) {
					var config = null;
					switch ( typeof entry ) {
						case "object" :
							config = entry;
							break;
						case "string" :
							var isDefault = false;
							if ( entry.indexOf ( ":" ) >-1 ) {
								entry = entry.split ( ":" )[ 0 ];
								isDefault = true;
							}
							config = Dialog._dialogButtons [ entry ];
							if ( isDefault ) {
								config.isDefault = true;
							}
							break;
					}
					buttonList.add ( config );
				}
			);
		}
		
		var argument = {
			title	: title,
			text	: text,
			type	: type,
			image	: this._dialogImages [ type ],
			buttons : buttonList
		}
		
		var definition = new DialogViewDefinition ({
			handle 		: "standarddialog:" + type,
			position	: Dialog.MODAL,
			url 		: this._URL_STANDARDDIALOG,
			handler		: handler,
			argument	: argument
		})
		
		StageBinding.presentViewDefinition ( definition );
	}
}
 
/**
 * The instance that does it.
 */
var Dialog = new _Dialog ();

/**
 * @class
 * Simply because we need to wrap some code up in short method   
 * names that can be accessed easily in inline markup.
 */
function _Commands () {
	
	this._construct ();
}

/**
 * Code.
 */
_Commands.prototype = {
	
	_URL_ABOUTDIALOG : "${root}/content/dialogs/about/about.aspx",
	_URL_PREFERENCES : "${root}/content/dialogs/preferences/preferences.aspx",
	
	/**
	 * Construct.
	 */
	_construct : function () {
		
		var self = this;
		EventBroadcaster.subscribe ( BroadcastMessages.SAVE_ALL, {
			handleBroadcast : function ( broadcast, arg ) {
				self.saveAll ( arg );
			}
		})
	},

	/**
	 * Opens the About dialog.
	 */
	about : function () {
		
		this._dialog ( this._URL_ABOUTDIALOG );
	},
	
	/**
	 * Opens the Preferences dialog.
	 */
	preferences : function () {
		
		this._dialog ( this._URL_PREFERENCES );
	},
	
	/**
	 * Taking care to fadeout menus before opening dialogs, otherwise   
	 * fading may be jaggy. But what if nobody was using a menu?...
	 */
	_dialog : function ( url ) {
		
		if ( Client.hasTransitions ) {
			setTimeout ( function () {
				Dialog.invokeModal ( url );
			}, Animation.DEFAULT_TIME );
		} else {
			Dialog.invokeModal ( url );
		}
	},
	
	/**
	 * Close current editor. This broadcast is intercepted by the DockTabBinding. 
	 */
	close : function () {
		
		EventBroadcaster.broadcast ( BroadcastMessages.CLOSE_CURRENT );
	},
	
	/**
	 * Close all (editors). 
	 */
	closeAll : function () {
		
		this.saveAll ( true );
	},
	
	/**
	 * Save current editor [CTRL+S].  This broadcast is intercepted by the DockTabBinding.
	 */
	save : function () {
		
		EventBroadcaster.broadcast ( BroadcastMessages.SAVE_CURRENT );
	},
	
	/**
	 * Save all dirty tabs (in all perspectives), prompting a list.
	 * @param {boolean} isCloseAll
	 */
	saveAll : function ( isCloseAll ) {
		
		/*
		 * Invoke dialog and collect 
		 * selected tabs in a list.
		 */
		var self = this;
		var docktabs = Application.getDirtyDockTabsTabs ();
		if ( docktabs.hasEntries ()) {
			Dialog.invokeModal ( "${root}/content/dialogs/save/saveall.aspx", {
				handleDialogResponse : function ( response, result ) {
					switch ( response ) {
						case Dialog.RESPONSE_ACCEPT :
							self._handleSaveAllResult ( result, isCloseAll );
							break;
						case Dialog.RESPONSE_CANCEL :
							/*
							 * Needed for language-change scenario...
							 */
							EventBroadcaster.broadcast ( BroadcastMessages.SAVE_ALL_DONE );
							break;
					}
				}
			}, docktabs );
		} else if ( isCloseAll ){
			EventBroadcaster.broadcast ( BroadcastMessages.CLOSE_ALL );
		}
	},
	
	/**
	 * Handle result from "save all" dialog.
	 * @param {DataBindingResultMap} result
	 * @param {boolean} isCloseAll
	 * @return {boolean} True if something was dirty...
	 */
	_handleSaveAllResult : function ( result, isCloseAll ) {
	
		var returnable = false;
		
		var list = new List ();
		result.each ( function ( name, tab ) {
			if ( tab != false ) {
				list.add ( tab );
			}
		});
		/*
		 * Save tabs from list.
		 */
		if ( list.hasEntries ()) {
			returnable = true;
			var count = list.getLength ();
			var handler = { 
				handleBroadcast : function ( broadcast, tab ) {
					if ( --count == 0 ) {
						EventBroadcaster.unsubscribe ( BroadcastMessages.DOCKTAB_CLEAN, this );
						EventBroadcaster.broadcast ( BroadcastMessages.SAVE_ALL_DONE );
						if ( isCloseAll ) {
							EventBroadcaster.broadcast ( BroadcastMessages.CLOSE_ALL );
						}
					}
				}
			}
			EventBroadcaster.subscribe ( BroadcastMessages.DOCKTAB_CLEAN, handler );
			list.each ( function ( tab ) {
				tab.saveContainedEditor ();
			});
		} else {
			/*
			 * Needed for language-change scenario...
			 */
			EventBroadcaster.broadcast ( BroadcastMessages.SAVE_ALL_DONE );
		}
		
		return returnable;
	},
	
	/**
	 * Flip display of the system log [control+shift+L]. If an error prevented 
	 * the system from starting normally, you'll be happy to know that the log 
	 * is still able to open in a regular browser window.
	 */
	systemLog : function () {
		
		if ( Application.isOperational ) {
			StageBinding.handleViewPresentation ( "Composite.Management.SystemLog" );
		} else {
			var win = window.open ( Constants.APPROOT + "/content/views/dev/systemlog/systemlogoutput.html" );
			win.onload = function () {
				EventBroadcaster.broadcast ( BroadcastMessages.SYSTEMLOG_OPENED, this );
			}
		}
	},
	
	/**
	 * Launch the Help view.
	 */
	help : function () {
		
		var handle = "Composite.Management.Help";
		if ( !StageBinding.isViewOpen ( handle )) {
			StageBinding.handleViewPresentation ( handle );
		}
	}
}

/**
 * The instance that does it.
 */
var Commands = new _Commands ();

/**
 * @class
 * Allows basic communication between C1 and the Prism host. 
 * The Composite C1 extension must be installed in Prism.
 * Don't instantiate this class manually. Access through 
 * instance variable "Prism" declared below. This 
 * instance should be considered a singleton class.
 */
function _Prism () {}
_Prism.prototype = {
		
	/**
	 * @type {SystemLogger}
	 */
	_logger : SystemLogger.getLogger ( "Prism" ),
	
	/**
	 * This will clear the cache (in Prism only).
	 */
	clearCache : function () {
	
		this._logger.fine ( "Clearing the cache" );
		this._dispatchToPrism ( "contenttochrome-clearcache" );
	},
	
	/**
	 * This will disable forced cache in Prism. Forced. 
	 * cache is a setup were files are NEVER checked 
	 * for newer versions on server unless expired.
	 */
	disableCache : function () {
		
		this._logger.fine ( "Disabling cache" );
		this._dispatchToPrism ( "contenttochrome-cache-disable" );
	},
	
	/**
	 * This will enable forced cache in Prism (see note above).
	 */
	enableCache : function () {
		
		this._logger.fine ( "Enabling cache" );
		this._dispatchToPrism ( "contenttochrome-cache-enable" );
	},
	
	/**
	 * Dispatch event to Prism host.
	 * @param {string} type
	 */
	_dispatchToPrism : function ( type ) {
		
		if ( Client.isPrism ) {
			var event = document.createEvent ( "Events" );
			event.initEvent ( type, true, true );
			window.dispatchEvent ( event );
		} else {
			this._logger.warn ( "Prism methods should only be invoked in Prism! (" + type + ")" );
		}
	}
}

/**
 * The instance that does it.
 * @type {_Chrome}
 */
var Prism = new _Prism ();

/**
 * @type {string}
 */
ViewDefinition.DEFAULT_URL = "${root}/blank.aspx";

/**
 * Clone a ViewDefinition, assigning a new handle.
 * @param {String} handle
 * @param {String} newhandle
 * @return {ViewDefinition}
 */
ViewDefinition.clone = function ( handle, newhandle ) {
	
	var result = null;
	var proto = ViewDefinitions [ handle ];
	
	if ( proto.isMutable ) {
		
		var impl = null;
		if ( proto instanceof DialogViewDefinition ) {
			impl = DialogViewDefinition;
		} else {
			impl = HostedViewDefinition;
		}
		if ( newhandle != null && impl != null ) {
			var def = new impl ();
			for ( var prop in proto ) {
				def [ prop ] = proto [ prop ];
			}
			def.handle = newhandle;
			result = def;
		} else {
			throw "Cannot clone without newhandle";
		}
	} else {
		throw "Cannot clone non-mutable definition";
	}
	return result;
}

/**
 * @class
 * Don't construct this fellow manually, please subclass first.
 */
function ViewDefinition () {}

ViewDefinition.prototype = {
	
	/**
	 * The URL to display.
	 * @type {string}
	 */
	url : ViewDefinition.DEFAULT_URL,
	
	/**
	 * Served to PageBinding.
	 * @see {PageBinding#setPageArgument}
	 * @type {object}
	 */
	argument : null,
	
	/**
	 * Backend handle (ElementKey).
	 * @type {string}
	 */
	handle : null,
	
	/**
	 * May associate the definition to a tree item.
	 * @type {string}
	 */
	entityToken : null,
	
	/**
	 * Backend flowhandle.
	 * @type {string}
	 */
	flowHandle : null,
	
	/**
	 * The label.
	 * @type {string}
	 */
	label : null,
	
	/**
	 * The image URL.
	 * @type {string}
	 */
	image : null,
	
	/**
	 * The tooltip.
	 * @type {string}
	 */
	toolTip : null
}

SystemViewDefinition.prototype = new ViewDefinition;
SystemViewDefinition.prototype.constructor = SystemViewDefinition;
SystemViewDefinition.superclass = ViewDefinition.prototype;
SystemViewDefinition.DEFAULT_URL = "${root}/content/views/systemview/systemview.aspx";

/**
 * @class
 * @param {SystemNode} node
 */
function SystemViewDefinition ( node ) {
	
	/**
	 * Unique for system viewdefinitions.
	 * @type {SystemNode}
	 */
	this.node = node;
	
	/**
	 * Served for the {@link SystemPageBinding}.
	 * @overwrites {ViewDefinition#argument}
	 * @type {SystemNode}
	 */
	this.argument = node;
	
	/**
	 * All systemviews start with the same URL. The content is later
	 * generated on basis of the the SystemNode supplied in constructor.
	 * @overwrites {ViewDefinition#url}
	 * @type {string}	 
	 */
	this.url = SystemViewDefinition.DEFAULT_URL;
	
	/**
	 * @type {string}
	 */
	this.handle	= node.getHandle ();
	
	/**
	 * @type {string}
	 */
	this.label = node.getLabel ();
	
	/** 
	 * TODO: are we using this?
	 * @type {string}
	 */
	this.image = node.getImageProfile ().getDefaultImage ();
	
	/**
	 * @type {string}
	 */
	this.toolTip = node.getToolTip ();
}

HostedViewDefinition.prototype = new ViewDefinition;
HostedViewDefinition.prototype.constructor = HostedViewDefinition;
HostedViewDefinition.superclass = ViewDefinition.prototype;
HostedViewDefinition.POSTBACK_URL = "${root}/postback.aspx";

/**
 * @class 
 * @param {object} arg Constructor argument properties maps directly into class properties.
 */
function HostedViewDefinition ( arg ) {
	
	/**
	 * The dock default position.
	 * @type {object}
	 */
	this.position = DockBinding.MAIN;
	
	/**
	 * Associates the View to a given perspective. This property matches 
	 * the "TagValue" property of the ClientElement objects sent from server.
	 * @type {string}
	 */
	this.perspective = null;
	
	/**
	 * @overwrites {ViewDefinition#entityToken}
	 * @type {string}
	 */
	this.entityToken = null;
	
	/**
	 * @overwrites {ViewDefinition#label}
	 * @type {string}
	 */
	this.label = null;
	
	/**
	 * @overwrites {ViewDefinition#image}
	 * @type {string}
	 */
	this.image = null;
	
	/*
	 * Initialize all of the above from argument.
	 */
	if ( arg ) {
		for ( var prop in arg ) {
			if ( this [ prop ] || this.prop == null ) {
				this [ prop ] = arg [ prop ];
				if ( this.url ) {
					this.url = Resolver.resolve ( this.url );
				}
			} else {
				throw "Property not recognized: " + prop;
			}
		}
	}
}

DialogViewDefinition.prototype = new ViewDefinition;
DialogViewDefinition.prototype.constructor = HostedViewDefinition;
DialogViewDefinition.superclass = ViewDefinition.prototype;

/**
 * @class 
 * @param {object} arg Constructor argument properties maps directly into class properties.
 */
function DialogViewDefinition ( arg ) {
	
	/**
	 * Don't confuse with "handle".
	 * @type {IDialogResponseHandler}
	 */
	this.handler = null;
	
	/**
	 * The dialog default position.
	 * @type {object}
	 */
	this.position = Dialog.MODAL;
	
	/**
	 * @overwrites {ViewDefinition#label}
	 * @type {string}
	 */
	this.label = null; //DockTabBinding.LABEL_TABLOADING;
	
	/**
	 * @overwrites {ViewDefinition#image}
	 * @type {string}
	 */
	this.image = null; // DockTabBinding.IMG_TABLOADING;
	
	/**
	 * @type {int}
	 */
	this.width = null;
	
	/**
	 * @type {int}
	 */
	this.height = null;
	
	/*
	 * Initialize all of the above from argument.
	 */
	if ( arg ) {
		for ( var prop in arg ) {
			if ( this [ prop ] || this.prop == null ) {
				this [ prop ] = arg [ prop ];
				if ( this.url ) {
					this.url = Resolver.resolve ( this.url );
				}
				if ( this.handler ) {
					if ( !Interfaces.isImplemented ( IDialogResponseHandler, this.handler )) {
						throw "IDialogResponseHandler not implemented";
					}
				}
			} else {
				throw "Property not recognized: " + prop;
			}
		}
	}
}

/*
 * Note that all bindings meddle with the constructor property thusly.
 */
Binding.prototype.constructor = Binding;

/*
 * Attribute names reserved for NET server postback.
 */
Binding.CALLBACKID = "callbackid"; // __EVENTTARGET
Binding.CALLBACKARG = "callbackarg"; // __EVENTARGUMENT

/*
 * Special classname to clear the float using CSS hacks. 
 * These are added dynamically, although it is not the 
 * best way to performance-optimize Internet Explorer.
 * @see "base.css"
 */
Binding.CLASSNAME_CLEARFLOAT = "clearfloatelement";
Binding.CLASSNAME_FOCUSED = "focused";

/*
 * Standard timeout in milliseconds before a lazy binding 
 * wakes up properly. This prevents jumping layouts. The 
 * binding may define a different timeout if desired.
 * @see {Binding#wakeUp}
 */
Binding.SNOOZE = Client.isMozilla == true ? 125: 250;

/*
 * Actions common to all Bindings.
 */
Binding.ACTION_DRAG = "bindingdrag";
Binding.ACTION_DROP = "bindingdrop";
Binding.ACTION_DIRTY = "bindingdirty";
Binding.ACTION_VALID = "bindingvalid";
Binding.ACTION_UPDATED = "bindingupdated";
Binding.ACTION_INVALID = "bindinginvalid";
Binding.ACTION_RESIZED = "bindingresized";
Binding.ACTION_FOCUSED = "bindingfocused";
Binding.ACTION_BLURRED = "bindingblurred";
Binding.ACTION_ATTACHED = "bindingattached";
Binding.ACTION_DETACHED = "bindingdetached";
Binding.ACTION_DISPOSED = "bindingdisposed";
Binding.ACTION_MOVETOTOP = "bindingmovetotop";
Binding.ACTION_ACTIVATED = "bindingactivated";
Binding.ACTION_REGISTERED = "bindingregistered";
Binding.ACTION_MOVEDONTOP = "bindingmovedontop";
Binding.ACTION_INITIALIZED = "bindinginitialized";
Binding.ACTION_FORCE_REFLEX = "bindingforcereflex";
Binding.ACTION_POSITIONCHANGED = "bindingpositionchanged";
Binding.ACTION_DIMENSIONCHANGED = "bindingdimensionchanged";
Binding.ACTION_VISIBILITYCHANGED = "bindingvisibilitychanged";

/**
 * Abstract method "placeholder" function. Indicates  
 * that subclasses should overwrite the particular method.
 * @type {function}
 */
Binding.ABSTRACT_METHOD = function () {
	
	SystemDebug.stack ( arguments );
	throw ( this.toString () + " abstract method not implemented" );
}

/**
 * Evaluate inline script (declared in markup) in binding context.
 * @param {String} script
 * @param {Binding} binding
 * @return {object}
 */
Binding.evaluate = function ( script, binding ) {
	
	var result = null;
	var manager = binding.bindingWindow.WindowManager;
	if ( manager != null ) {
		var statement = Binding.parseScriptStatement ( script, binding.key );
		result = manager.evaluate ( statement );
	}
	return result;
}

/**
 * Due to differences in the implementation of "eval" in different browsers, it may be 
 * nescessary to replace the "this" keyword in a script string with a global pointer. 
 * This is needed for all versions of IE and for Firefox starting from version 3.7
 * TODO: Doesn't handle string "alert(this)" !!!
 * @see {ButtonBinding}
 * @see {TreeNodeBinding}
 * @param {String} script
 * @param {String} key
 */
Binding.parseScriptStatement = function ( script, key ) {
	
	if ( script != null && key != null ) {
		var replacement = "UserInterface.getBindingByKey ( \"" + key + "\" )";
		script = script.replace ( /(\W|^)this(,| +|\)|;)/g, replacement );
		script = script.replace ( /(\W|^)this(\.)/g, replacement + "." );
	}
	return script;
}

/**
 * Nowadays, with Dot Net Ajax and what, you can never 
 * be sure that your Binding hasn't been spirited away behind 
 * your back. This method will verify the integrity of your 
 * binding before you attempt to invoke it's methods. 
 * @param {Binding} binding 
 * @return {boolean}
 */
Binding.exists = function ( binding ) {
	
	var result = false;
	try {
		if ( binding && binding.bindingElement && binding.bindingElement.nodeType && binding.isDisposed == false ) {
			result = true;
		}
	} catch ( accessDeniedException ) {
		result = false;
	} finally {
		return result;
	}
}

/**
 * Destroy binding. Somewhat overdestructively in order to patch memory leaks.
 * Note that the DOM element is not removed, only the binding gets nuked.
 * @param {Binding} binding
 */
Binding.destroy = function ( binding ) {
	
	if ( !binding.isDisposed ) {
		
		if ( binding.acceptor != null ) {
			binding.acceptor.dispose ();
		}
		if ( binding.dragger != null ) {
			binding.disableDragging ();
		}
		if ( binding.boxObject != null ) {
			binding.boxObject.dispose ();
		}
		if ( binding._domEventHandlers != null ) {
			DOMEvents.cleanupEventListeners ( binding );
		}
		for ( var branch in binding.shadowTree ) {
			var entry = binding.shadowTree [ branch ];
			if ( entry instanceof Binding && Binding.exists ( entry )) {
				entry.dispose ( true );
			}
			binding.shadowTree [ branch ] = null;
		}
		binding.isDisposed = true;
		binding = null;
	}
}

/**
 * Inject the binding with a hidden field so that the ASP.NET server may recognize it.
 * The binding may access the field as "this.shadowTree.dotnetinput" to mofify its value. 
 * Note this: The ID attribute is for the client while the callbackid is for the server.
 * @param {Binding} binding
 * @param {String} value
 * @returns
 */
Binding.dotnetify = function ( binding, value ) {

	var callbackid = binding.getCallBackID ();
	
	if ( callbackid != null ) {
		var input = DOMUtil.createElementNS ( Constants.NS_XHTML, "input", binding.bindingDocument );
		input.type = "hidden";
		input.id = callbackid;
		input.name = callbackid;
		input.value = value != null ? value : "";
		binding.bindingElement.appendChild ( input );
		binding.shadowTree.dotnetinput = input;
	} else {
		throw binding.toString () + ": Missing callback ID";
	}
}

/**
 * Build image profile. 
 * @param {Binding} binding
 */
Binding.imageProfile = function ( binding ) {
	
	var image = binding.getProperty ( "image" );
	var imageHover = binding.getProperty ( "image-hover" );
	var imageActive = binding.getProperty ( "image-active" );
	var imageDisabled = binding.getProperty ( "image-disabled" );
	
	/*
	 * Note that we don't overwrite properties 
	 * that were already assigned programatically.
	 */
	if ( binding.imageProfile == null ) {
		if ( binding.image == null && image != null ) {
			binding.image = image;
		}
		if ( binding.imageHover == null && imageHover != null ) {
			binding.imageHover = image;
		}
		if ( binding.imageActive == null && imageActive != null ) {
			binding.imageActive = imageActive;
		}
		if ( binding.imageDisabled == null && imageDisabled != null ) {
			binding.imageDisabled = imageDisabled;
		}
		if ( binding.image || binding.imageHover || binding.imageActive || binding.imageDisabled ) {
			binding.imageProfile = new ImageProfile ( binding );
		}
	}
};

// BINDING CLASS ..................................................................

/**
 * @class
 * The <code>Binding</code> is the base class for all objects 
 * that control UI namespaced DOM elements on the rendering canvas.
 * @implements {IEventListener}
 * @implements {IActionListener}
 * @implements {IBroadcastListener}
 */
function Binding () {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "binding" );
	
	/**
	 * This property is set by {@link UserInterface} when the binding 
	 * is registered. The bound element is assigned a DOM attribute 
	 * "key" with a corresponding value.
	 * @type {string}
	 */
	this.key = null;

	/**
	 * The DOM element wrapped by the Binding. 
	 * @type {DOMElement}
	 */
	this.bindingElement	= null;
	
	/** 
	 * The ownerDocument of the bound element. 
	 * @type {DOMDocument}
	 */
	this.bindingDocument = null;
	
	/**
	 * The parent window of the bound element. 
	 * @type {DocumentView}
	 */
	this.bindingWindow = null;
	
	/**
	 * Pointers to DOMElements generated by the Binding. 
	 * @type {HashMap<string><DOMElement>}
	 */
	this.shadowTree = null;
	
	/** 
	 * A collection of actionlisteners.
	 * @type {HashMap<string><array>}
	 * @private 
	 */
	this.actionListeners = null;
	
	/**
	 * @type {PopupBinding}
	 * @private
	 */
	this.contextMenuBinding = null;
	
	/**
	 * Switched to true when the bindings <code>onBindingRegister</code> method executes.
	 * @type {boolean}
	 */
	this.isRegistered = false;
	
	/**
	 * Switched to true when the bindings <code>onBindingAttach</code> method executes.
	 * @type {boolean}
	 */
	this.isAttached = false;
	
	/**
	 * Switched to true when the bindings <code>onBindingInitialize</code> method executes.
	 * @type {boolean}
	 */
	this.isInitialized = false;
	
	/**
	 * Switched to true when the bindings <code>onBindingDispose</code> method executes 
	 * (although technically the switch is performed elsewhere).
	 * @see {Binding#dispose} 
	 * @type {boolean}
	 */
	this.isDisposed = false;
	
	/**
	 * If set to true, the binding element will dispatch a special action on drag gesture.
	 * @type {boolean}
	 */
	this.isDraggable = false;
	
	/**
	 * This one handles dragging action.
	 * @type {Dragger}
	 */
	this.dragger = null;
	
	/**
	 * Determines whether or not the binding should be serialized. Please note that 
	 * this property is automatically set by the {@link Binding#serialize} method.
	 * Don't set this property! To make the binding unserializable, instead set 
	 * the returnvalue to false in the {@link Binding#serialize} method.
	 */
	this.isShadowBinding = false;
	
	/**
	 * This depends on...
	 * @type {HashMap<string><boolean>}
	 */
	this.memberDependencies = null;
	
	/**
	 * Depends on this...
	 * @type {HashMap<string><Binding>}
	 */
	this.dependentBindings = null;
	
	/** 
	 * This maps binding DOM properties to binding methods. When the property 
	 * is modified, the method will be invoked with the property value as an 
	 * argument. To avoid an excessive amount of mutation event listeners, 
	 * you *must* change the property using the setProperty method. This property   
	 * should be specified when you wire the binding to a {@link BroadcasterBinding}
	 * @type {HashMap<string><function>}
	 */
	this.propertyMethodMap = null;
	
	/**
	 * If set to true, this binding may still dispatch an {@link Action} but 
	 * it will not relay events dispatched by any descendant binding.
	 * @type {boolean}
	 */
	this.isBlockingActions = false;
	
	/**
	 * @type {boolean}
	 */
	this.isVisible = true;
	
	/**
	 * Presents a simpliefied API for dealing with this bindings size and position on stage.
	 * @type {BindingBoxObject}
	 */
	this.boxObject = null;
	
	/**
	 * Identifies the type of this binding while dragging.
	 * @see {Binding#dragAccept}
	 * @type {string}
	 */
	this.dragType = null;
	
	/**
	 * Whitespace-separated list of draggable types to accept.
	 * @see {Binding#dragType}
	 * @type {string}
	 */
	this.dragAccept = null;
	
	/**
	 * If set to true, this binding will not accept any dragged bindings.
	 * @type {boolean}
	 */
	this.dragReject = false;
	
	/**
	 * Handles binding acceptance end rejection while dragging.
	 * @type {BindingAcceptor}
	 */
	this.acceptor = null;

	/**
	 * Flags lazy attachment.
	 * @type {boolean}
	 */
	this.isLazy = false;
	
	/**
	 * The property "persistance" must be markup up as a whitespace 
	 * separated list of persisted properties. Internally we use a hashmap.
	 * @type {HashMap<string><string>}
	 */
	this._persist = null;
	
	/**
	 * True if DOM content was expanded server side.
	 * @type {boolean}
	 */
	this.isBindingBuild = false;
	
	/**
	 * Used to cleanup activationaware bindings.
	 * @type {boolean}
	 */
	this._hasActivationAwareness = false;
	
	/**
	 * While flexing, minimize the amount of DOM iterations by flipping this.
	 * @see {FlexBoxCrawler}
	 * @type {boolean}
	 */
	this.isFlexSuspended = false;
	
	/**
	 * Blocking crawler progression by matching the crawler ID with a list.   
	 * This way, bindings may fasttrack simple rejection of common crawlers. 
	 * Advanced handling of crawlers should be done with method handleCrawler.
	 * Note that the crawler filter property is null untill subclass constructs it.
	 * @type {List<string>}
	 */
	this.crawlerFilters = null;
	
	/**
	 * EventBroadcaster subscriptions.
	 * @type {Map<string><boolean>}
	 */
	this._subscriptions = null;
}

/**
 * Identifies binding.
 */
Binding.prototype.toString = function () {

	return "[Binding]";
}

/**
 * Register binding. Must only be invoked by the DocumentManager.
 */
Binding.prototype.onBindingRegister = function () {

	if ( !this.isRegistered ) {
		
		this.bindingElement			= UserInterface.getElement ( this );
		this.bindingDocument 		= this.bindingElement.ownerDocument;
		this.bindingWindow			= DOMUtil.getParentWindow ( this.bindingDocument );
		this.shadowTree 			= {};
		this.actionListeners		= {};
		this.propertyMethodMap		= {};
		this.isRegistered 			= true;
		this._subscriptions			= new Map ();
		
		var id = this.bindingElement.id;
		if ( id != "" && id.slice ( 0, 2 ) == "ID" && this.bindingWindow.isServersideExpand ) {
			this.isBindingBuild = true; // This is not used and should be done elsehow anyway...
		}
		
		this._updateBindingMap ( true );
		if ( this.getProperty ( "lazy" )) {
			this.isLazy = true;
		}
	}
}

/**
 * Attach binding. Must only be invoked by the DocumentManager or via the attach method.
 */
Binding.prototype.onBindingAttach = function () {

	if ( !this.isAttached ) {
		if ( !this.bindingElement.parentNode ) {
			alert ( this + " onBindingAttach: Binding must be positioned in document structure before attachment can be invoked." );
		} else {
			this.boxObject = new BindingBoxObject ( this );
			this._initializeBindingPersistanceFeatures ();
			this._initializeBindingGeneralFeatures ();
			this._initializeBindingDragAndDropFeatures ();
			this._updateBindingMap ( true );
			this.isAttached = true;
		}
	}
}

/**
 * Initialize binding. Must only be invoked by the DocumentManager or via the attach method.
 */
Binding.prototype.onBindingInitialize = function () {
	
	/*
	 * When overloading, place your code here!!!!
	 */ 
	
	if ( this.dependentBindings != null ) {
		for ( var key in this.dependentBindings ) {
			var dependentBinding = this.dependentBindings [ key ];
			dependentBinding.onMemberInitialize ( this );
		}
	}
	
	/*
	 * Flag initialized status.
	 */
	this.isInitialized = true;
}

/**
 * Evaluated when a dependent members onBindingInitialize method is invoked.
 * @param {Binding} binding
 */
Binding.prototype.onMemberInitialize = function ( binding ) {

	/*
	 * When overloading, place your code here!!!!
	 */

	if ( binding ) {
		this.memberDependencies [ binding.key ] = true;
		var isReady = true;
		for ( var key in this.memberDependencies ) {
			if ( this.memberDependencies [ key ] == false ) {
				isReady = false;
				break;
			}
		}
		if ( isReady ) {
			this.onBindingInitialize ();
		}
	} else {
		throw new Error ( this + " onMemberInitialize: Expected argument." );
	}
}

/**
 * Invokes onBindingAttach and onBindingInitialize; then returns the binding.
 * @return {Binding}
 */
Binding.prototype.attach = function () {
	
	if ( !this.isAttached ) {
		this.onBindingAttach ();
		if ( this.memberDependencies == null ) {
			this.onBindingInitialize ();
		}
	}
	return this;
}

/**
 * Recursivley attach this and any descendant binding not already attached. 
 */
Binding.prototype.attachRecursive = function () {

	this.bindingWindow.DocumentManager.attachBindings ( this.bindingElement );
}

/**
 * Recursivley dispose all descendant bindings, possibly even this binding.
 * Please note this will not destroy the associated DOMElements!
 * @param {boolean} isDetachMyself If set to true, dispose this binding.
 */
Binding.prototype.detachRecursive = function ( isDetachMyself ) {
	
	if ( isDetachMyself == null ) {
		isDetachMyself = false;
	}
	this.bindingWindow.DocumentManager.detachBindings ( 
		this.bindingElement, !isDetachMyself 
	);
}

/**
 * Add single member.
 * @param {Binding} binding
 * @return {Binding}
 */
Binding.prototype.addMember = function ( binding ) {
	
	if ( !this.isAttached ) {
		throw "Cannot add members to unattached binding";
	} else if ( !binding.isInitialized ){
		if ( !this.memberDependencies ) {
			this.memberDependencies = {};
		}
		this.memberDependencies [ binding.key ] = false;
		binding.registerDependentBinding ( this );
	}
	return binding;
}

/**
 * Add list of members.
 * @param {List} bindings
 * @return {List}
 */
Binding.prototype.addMembers = function ( bindings ) {
	
	while ( bindings.hasNext ()) {
		var binding = bindings.getNext ();
		if ( !binding.isInitialized ) {
			this.addMember ( binding );
		}
	}
	return bindings;
}

/**
 * Register dependant binding.
 * @param {Binding} binding
 */
Binding.prototype.registerDependentBinding = function ( binding ) {
	
	if ( !this.dependentBindings ) {
		this.dependentBindings = {};
	}
	this.dependentBindings [ binding.key ] = binding;
}

/**
 * Initialize persistance.
 */
Binding.prototype._initializeBindingPersistanceFeatures = function () {
	
	var persist = this.getProperty ( "persist" );
	
	if ( persist && Persistance.isEnabled ) {
		var id = this.bindingElement.id;
		if ( !KeyMaster.hasKey ( id )) {
			this._persist = {};
			var props = new List ( persist.split ( " " ));
			while ( props.hasNext ()) {
				var prop = props.getNext ();
				var value = Persistance.getPersistedProperty ( id, prop );
				if ( value != null ) {
					this._persist [ prop ] = value;
					this.setProperty ( prop, value );
				} else {
					value = this.getProperty ( prop );
					// alert ( this.toString() + " " + id + " " + prop +":" + value );
					if ( value != null ) {
						this._persist [ prop ] = value;
					}
				}
			};
		} else {
			throw "Persistable bindings must have a specified ID.";
		}
	}
}

/**
 * Intitialize general features.
 */
Binding.prototype._initializeBindingGeneralFeatures = function () {

	var disabled 			= this.getProperty 	( "disabled" );
	var contextmenu 		= this.getProperty 	( "contextmenu" );				
	var observes 			= this.getProperty 	( "observes" );
	var onattach 			= this.getProperty 	( "onattach" );
	var hidden				= this.getProperty 	( "hidden" );
	var isBlocking 			= this.getProperty 	( "blockactionevents" );
	
	if ( hidden == true && this.isVisible == true ) {
		this.hide ();
	}
	if ( disabled && this.logger != null ) {
		this.logger.error ( "The 'disabled' property has been renamed 'isdisbaled'" );
	}
	if ( contextmenu ) {
		this.setContextMenu ( contextmenu );
	}
	if ( observes ) {
		this.observe ( 
			this.getBindingForArgument ( observes )
		);
	}
	if ( isBlocking == true ) {
		this.isBlockingActions = true;
	}
	if ( this.isActivationAware == true ) {
		var root = UserInterface.getBinding ( this.bindingDocument.body );
		root.makeActivationAware ( this );
		this._hasActivationAwareness = true;
	}
	if ( onattach != null ) {
		Binding.evaluate ( onattach, this );
	}
	
	// TODO: investigate why explorer apparently stops evaluating statements at this point!
}

/**
 * Intitialize drag and drop features. Notice that a dragtype 
 * implies that the binding is draggable unless specifically 
 * stated otherwise (draggable property set to false).
 * TODO: This may not be a good idea regarding persistance!
 * TODO: require draggable set to true!
 */
Binding.prototype._initializeBindingDragAndDropFeatures = function () {

	var isDraggable = this.getProperty 	( "draggable" );
	var dragtype	= this.getProperty 	( "dragtype" );
	var dragaccept	= this.getProperty 	( "dragaccept" );
	var dragreject	= this.getProperty 	( "dragreject" );
	
	if ( isDraggable != null ) {
		this.isDraggable = isDraggable; // but see below...
	}
	if ( dragtype != null ) {
		this.dragType = dragtype;
		if ( isDraggable != false ) {
			this.isDraggable = true; // dragtype enables drag, unless explicitely denied.
		}
	}
	if ( dragaccept != null ){ 
		this.dragAccept = dragaccept;
	}
	if ( dragreject	!= null ) {
		this.dragReject = dragreject;
	}

	/*
	 * Setup drag type stuff.
	 */
	if ( this.isDraggable ) {
		this.enableDragging ();
	}
	if ( this.dragger != null && this.dragType != null ) {
		this.dragger.registerHandler ( 
			Application 
		);
	}
	
	/*
	 * Note that we construct a BindingAcceptor even for rejecting bindings!
	 */
	if ( this.dragAccept != null && this.dragReject == true ) {
		throw new Error ( "Binding cannot both accept and reject " + this );
	} else if ( this.dragAccept != null || this.dragReject != null ) {
		this.acceptor = new BindingAcceptor ( this );
	}
}

/**
 * Update bindingMap (see WindowManager). Notice that this method gets invoked 
 * from both onBindingRegister, onBindingAttach and onBindingDispose methods.
 * @param {boolean} isRegistration
 */
Binding.prototype._updateBindingMap = function ( isRegistration ) {
	
	try {
		if ( this.bindingWindow ) {
		
			var id = this.bindingElement.id;
			var map = this.bindingWindow.bindingMap;
			var registered = null;
		
			if ( isRegistration ) {
				registered = map [ id ];
				if ( registered != null && registered != this ) {
					var cry = this.toString () + " duplicate binding ID: " + id;
					this.logger.error ( cry );
					if ( Application.isDeveloperMode ) {
						throw ( cry );
					}
				} else {
					map [ id ] = this;
				}
			} else {
				registered = map [ id ];
				if ( registered != null && registered == this ) {
					delete map [ id ];
				}
			}
		} else {
			var fault = new String ( "Binding#_updateBindingMap odd dysfunction: " + this.toString () + ": " + isRegistration );
			if ( Application.isDeveloperMode == true ) {
				alert ( fault );
			} else {
				this.logger.error ( fault );
			}
		}
	} catch ( exception ) {
		this.logger.error ( exception );
	}
}

/**
 * Handle DOM event. To eliminate doubts when subclassing, 
 * all bindings have been fitted with this method to overload.
 * @implements {IEventListener}
 * @param {Event} e
 */
Binding.prototype.handleEvent = function ( e ) {};

/**
 * Handle Action. To eliminate doubts when subclassing, 
 * all bindings have been fitted with this method to overload.
 * @implements {IActionListener}
 * @param {Action} action 
 */
Binding.prototype.handleAction = function ( action ) {};

/**
 * Handle broadcast. To eliminate doubts when subclassing, 
 * all bindings have been fitted with this method to overload.
 * @see {EventBroadcaster}
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object] arg 
 */
Binding.prototype.handleBroadcast = function ( broadcast, arg ) {};

/**
 * Handle element update?
 * @implements {IUpdateHandler}
 * @param {Element} element
 * @returns {boolean} Return true to trigger method handleElement.
 */
Binding.prototype.handleElement = function ( element ) {
	
	return false;
}

/**
 * Update element. And stop crawling DOM subtree?
 * @implements {IUpdateHandler}
 * @param {Element} element
 * @returns {boolean} Return true to stop crawling.
 */
Binding.prototype.updateElement = function ( element ) {
	
	return false;
}

/**
 * This utility function allows you to address a binding instance using 
 * a number of argument types. If you provide an element or a binding 
 * there's no trick to it. But if you provide a string it will either resolve 
 * to the id of an element in the current document context OR be evaluated  
 * as a javascript call which can retrieve a binding from somewhere in the  
 * application hierarchy.
 * @param {object} arg
 */
Binding.prototype.getBindingForArgument = function ( arg ) {
	
	var result = null;

	switch ( typeof arg ) {
		case "object" : // the result was assigned using javascript
			result = arg;
			break;
		case "string" : // the result was declared in inline markup
		
			// fetch binding by simple id in current document scope
			result = this.bindingDocument.getElementById ( arg );
			
			// or evaluate the attribute as some kind of javascript
			if ( result == null ) {
				result = Binding.evaluate ( arg, this );
			}
			break;
	}
	
	// at this point, the result can be either a DOMElement or a Binding.
	if ( result != null && result.nodeType != null ) {
		result = UserInterface.getBinding ( result );
	}
	return result;
}

/**
 * Serialize binding. Returns a hashmap of properties to be included in the 
 * serialization result tree. Return false to prevent binding entirely from 
 * appearing in the result tree (anonymously generated shadow content).
 * @return {HashMap<string><object>} well - could also return null or false!
 */
Binding.prototype.serialize = function () {

	/*
	 * All properties of this object will be translated  
	 * to attributes on the serialized result element.
	 */
	var result = {};
	
	/**
	 * Always include non-autogenerated id attribute.
	 */
	var id = this.bindingElement.id;
	if ( id && id != this.key ) {
		result.id = id;
	}
	
	var binding = this.getProperty ( "binding" );
	if ( binding ) {
		result.binding = binding;
	}
	
	/**
	 * Check shadowBinding status.
	 */
	if ( !BindingSerializer.includeShadowTreeBindings ) {
		var ancestorBinding = this.getAncestorBindingByLocalName ( "*" );
		if ( ancestorBinding ) {
			if ( ancestorBinding.isShadowBinding ) {
				this.isShadowBinding = true;
				result = false;
			} else {
				var tree = ancestorBinding.shadowTree;
				for ( var key in tree ) {
					var entry = tree [ key ];
					if ( entry == this ) {
						this.isShadowBinding = true;
						result = false;
					}
				}
			}
		}
	}
	return result;
}

/**
 * @param {boolean} includeShadowTreeBindings
 * @return {string}
 */
Binding.prototype.serializeToString = function ( includeShadowTreeBindings ) {
	
	var result = null;
	if ( this.isAttached ) {
		result = new BindingSerializer ().serializeBinding ( this, includeShadowTreeBindings );
	} else {
		throw "cannot serialize unattached binding";
	}
	return result;
}

/**
 * Generate binding subtree from string input.
 * TODO: RUN VIA MASTERFILTER.XSL?
 * @param {string} string
 */
Binding.prototype.subTreeFromString = function ( markup ) {

	this.detachRecursive ();
	this.bindingElement.innerHTML = markup;
	this.attachRecursive ();
}

/**
 * Get bound element attribute. The attribute value (in DOM always a string) is 
 * analyzed  and converted to an appropriate js primitive of type number, 
 * string or boolean, making it simpler to work with in a scripting environment. 
 * @param {string} attname
 */
Binding.prototype.getProperty = function ( attname ) {
	
	var value = this.bindingElement.getAttribute ( attname );
	if ( value ) {
		value = Types.castFromString ( value );
	}
	return value;
}

/**
 * Set bound element attribute. The value is converted to a string. 
 * If set to a null value, the property will be removed. By specifying 
 * the propertyMethodMap, this method can automatically invoke a specified 
 * method on the binding using the formatted value as an argument. This setup 
 * was engineered specifically to support the {@link BroadcasterBinding}.
 * @param {string} attname The name of the attribute
 * @param {object} value The attribute value.
 */
Binding.prototype.setProperty = function ( prop, value ) {
	
	if ( value != null ) {
	
		// DOM attributes are always stored as strings
		value = value.toString ();
		
		/*
		 * Dont't do anything unless the property is actually changed.
		 * This will prevent recursive calls to methods which in turn 
		 * modifies the properties of the binding.
		 */
		if ( String ( this.bindingElement.getAttribute ( prop )) != value ) {
			
			this.bindingElement.setAttribute ( prop, value );
			if ( this.isAttached == true ) {
				
				/*
				 * Handle persistance.
				 */
				if ( Persistance.isEnabled && value != null ) {
					if ( this._persist != null && this._persist [ prop ]) {
						this._persist [ prop ] = value;
						Persistance.setPersistedProperty ( 
							this.bindingElement.id, 
							prop, 
							value 
						);
					}
				}
				
				/*
				 * Handle "setters" (methods invoked when setting the property).
				 */
				var method = this.propertyMethodMap [ prop ];
				if ( method ) {
					method.call ( this, this.getProperty ( prop ));
				}
			}
		}
	} else {
		this.deleteProperty ( prop );
	}
}

/**
 * Remove bound element attribute.
 * @param {string} prop The name of the attribute
 */
Binding.prototype.deleteProperty = function ( prop ) {
	
	this.bindingElement.removeAttribute ( prop );
}

/**
 * Get the ID of the associated element.
 * @return {string}
 */
Binding.prototype.getID = function () {
	
	return this.bindingElement.id;
}

/**
 * Attach CSS classname to bound element.
 * @param {string} classname
 */
Binding.prototype.attachClassName = function ( classname ) {
	
	CSSUtil.attachClassName ( this.bindingElement, classname );
}

/**
 * Detach CSS classname from bound element.
 * @param {string} classname
 */
Binding.prototype.detachClassName = function ( classname ) {
	
	CSSUtil.detachClassName ( this.bindingElement, classname );
}

/**
 * Check bound element classname.
 * @param {string} classname
 * @return {boolean}
 */
Binding.prototype.hasClassName = function ( classname ) {
	
	return CSSUtil.hasClassName ( this.bindingElement, classname );
}

/**
 * Add Action listener, not to be confused with real DOM events.
 * @param {string} type The event type should match (TODO: setup certain event types to match?)
 * @param {IActionListener} listener An object implementing {IActionListener} - optional.
 */
Binding.prototype.addActionListener = function ( type, listener ) {

	listener = listener != null ? listener : this;

	if ( Action.isValid ( type )) {
		if ( Interfaces.isImplemented ( IActionListener, listener )) {
			if ( !this.actionListeners [ type ]) {
				this.actionListeners [ type ] = [];
			}
			this.actionListeners [ type ].push ( listener );
		} else throw new Error ( 
			"Could not add action-event listener. Method handleAction not implemented." 
		);
	} else {
		alert ( this + "\nCould not add undefined Action (" + listener + ")" );
	}
}

/**
 * Remove action listener
 * @param {string} type
 * @param {IActionListener} unListener
 */
Binding.prototype.removeActionListener = function ( type, unListener ) {

	unListener = unListener ? unListener : this;

	if ( Action.isValid ( type )) {
		var listeners = this.actionListeners [ type ];	
		if ( listeners ) {
			var i = 0, listener;
			while (( listener = listeners [ i ]) != null ) {
				if ( listener == unListener ) {
					listeners.splice ( i, 1 );
					break;
				}
				i++;
			}
		}
	}
}

/**
 * Add DOM event listener, not to be confused with Action listeners,
 * to this bindingElement. If handler argument is omitted, the handler 
 * defaults to the binding itself.
 * @param {string} type
 * @param {IEventListener} handler Optional. 
 */
Binding.prototype.addEventListener = function ( type, handler ) {
	
	handler = handler ? handler : this;
	DOMEvents.addEventListener ( this.bindingElement, type, handler );
	
}

/**
 * Remove DOM event listener from this bindingElement.
 * @param {string} type
 * @param {IEventListener} handler Optional.
 */
Binding.prototype.removeEventListener = function ( type, handler ) {
	
	handler = handler ? handler : this;
	DOMEvents.removeEventListener ( this.bindingElement, type, handler );
	
}

/**
 * Subscribe EventBroadcaster transmission.
 * @param {string} broadcast
 */
Binding.prototype.subscribe = function ( broadcast ) {
	
	if ( !this.hasSubscription ( broadcast )) {
		this._subscriptions.set ( broadcast, true );
		EventBroadcaster.subscribe ( broadcast, this );
	} else {
		this.logger.error ( "Dubplicate subscription aborted:" + broadcast );
	}
}

/**
 * Unsubscribe EventBroadcaster transmission.
 * @param {string} broadcast
 */
Binding.prototype.unsubscribe = function ( broadcast ) {
	
	if ( this.hasSubscription ( broadcast )) {
		this._subscriptions.del ( broadcast );
		EventBroadcaster.unsubscribe ( broadcast, this );
	}
}

/**
 * Has EventBroadcaster subscription?
 * @return {boolean}
 */
Binding.prototype.hasSubscription = function ( broadcast ) {
	
	return this._subscriptions.has ( broadcast );
}

/**
 * Observe broadcaster.
 * @param {BroadcasterBinding} broadcaster
 * @param {string} properties
 */
Binding.prototype.observe = function ( broadcaster, properties ) {
	
	broadcaster.addObserver ( this, properties );
}

/**
 * Unobserve broadcaster.
 * @param {BroadcasterBinding} broadcaster
 * @param {string} properties
 */
Binding.prototype.unObserve = function ( broadcaster, properties ) {
	
	broadcaster.removeObserver ( this, properties );
}

/**
 * Setup the contextmenu. For binding to handle contextmenu 
 * selection, it should implement the handleAction method.
 * @param {object} arg
 */
Binding.prototype.setContextMenu = function ( arg ) {
	
	this.contextMenuBinding = this.getBindingForArgument ( arg );
	
	if ( this.contextMenuBinding ) {
		
		var self = this;
		var menu = this.contextMenuBinding;
		
		this.addEventListener ( DOMEvents.CONTEXTMENU, {
			handleEvent : function ( e ) {
				if ( Interfaces.isImplemented ( IActionListener, self ) == true ) {
					var actionHandler = {
						handleAction : function () {
							menu.removeActionListener ( MenuItemBinding.ACTION_COMMAND, self );
							menu.removeActionListener ( PopupBinding.ACTION_HIDE, actionHandler );
						}
					}
					menu.addActionListener ( MenuItemBinding.ACTION_COMMAND, self );
					menu.addActionListener ( PopupBinding.ACTION_HIDE, actionHandler );
				}
				menu.snapToMouse ( e );
			}
		});
		
	} else {
		throw "No such contextmenu: " + arg;
	}
	
}

/**
 * @return {PopupBinding}
 */
Binding.prototype.getContextMenu = function () {
	
	return this.contextMenuBinding;
}

/**
 * Dispatch event, triggering actionlisteners associated to event type. 
 * The event "bubbles up" to parent Bindings in a DOM-like way.
 * @param {object} arg This can be either a string or an {@link Action}.
 * @return {Action}
 */
Binding.prototype.dispatchAction = function ( arg ) {

	var action = null;
	var result = null;
	var isMyAction = false;

	/*
	 * Are we dispatching a new event or relaying a descendant event?
	 */
	if ( arg instanceof Action ) {
		action = arg;
	} else if ( Action.isValid ( arg )) {
		action = new Action ( this, arg );
		isMyAction = true;
	}

	/*
	 * Pass event to relevant listeners; then migrate the event to containing binding.
	 */
	if ( action != null && Action.isValid ( action.type ) == true ) {
		if ( action.isConsumed == true ) {
			result = action;
		} else {
			var listeners = this.actionListeners [ action.type ];
			if ( listeners != null ) {
				action.listener = this;
				var i = 0, listener;
				while (( listener = listeners [ i++ ]) != null ) {
					if ( listener && listener.handleAction ) {
						listener.handleAction ( action );
					}
				}
			}
			 
			/*
			 * Migrate action? 
			 */
			var isMigrate = true;
			
			/*
			 * Note that selected actions are allowed to bypass the  
			 * action block system, notably the "activated" action.
			 * The postback action was added to please the 
			 * wysiwygeditor (template update selector).
			 */
			if ( this.isBlockingActions == true ) {
				switch ( action.type ) {
					case Binding.ACTION_FOCUSED : // EXPERIMENTAL!
					case Binding.ACTION_BLURRED : // EXPERIMENTAL!
					case Binding.ACTION_ACTIVATED :
					case Binding.ACTION_FORCE_REFLEX :
					case DockTabBinding.ACTION_UPDATE_VISUAL :
					case PageBinding.ACTION_DOPOSTBACK :
						break;
					default :
						if ( !isMyAction ) {
							isMigrate = false;
						}
						break;		
				}
			}
			
			if ( isMigrate ) {
				result = this.migrateAction ( action );
			} else {
				result = action;
			}
		}
	}
	return result;
}

/**
 * Migrate action to ancestor binding.
 * @param {Action} action
 * @return {Action}
 */
Binding.prototype.migrateAction = function ( action ) {
	
	var binding	= null;
	var result 	= null;
	var node 	= this.getMigrationParent ();
	
	if ( node ) {
		while ( node && !binding && node.nodeType != Node.DOCUMENT_NODE ) {
			binding = UserInterface.getBinding ( node );
			node = node.parentNode;
		}
		if ( binding ) {
			result = binding.dispatchAction ( action );
		} else {
			result = action;
		}
	}
	return result;
}

/**
 * Invoke the flex method (if specified) on this binding and all descendant bindings.
 * @param @optional {boolean} isForce
 */
Binding.prototype.reflex = function ( isForce ) {
	
	if ( Application.isOperational == true ) {
		FlexBoxBinding.reflex ( this, isForce );
	}
}

/**
 * Note that the {@link RootBinding} overwrites this method 
 * in order to migrate the event across iframe boundaries.
 * @return {DOMElement}
 */
Binding.prototype.getMigrationParent = function () {

	var result = null;
	if ( true ) { // Binding.exists ( this )
		try {
			var parent = this.bindingElement.parentNode;
			if ( parent != null ) {
				result = parent;
			}
		} catch ( wtfException ) { // Explorer may collapse any day now - especially around here
			this.logger.error ( "Binding#getMigrationParent exception" );
			SystemDebug.stack ( arguments );
			result = null;
		}
	}
	return result;
}

/**
 * @param {Binding} binding
 * @return {Binding}
 */
Binding.prototype.add = function ( binding ) {

	if ( binding.bindingDocument == this.bindingDocument ) {
		this.bindingElement.appendChild ( 
			binding.bindingElement 
		);
	} else {
		throw "Could not add " + binding.toString () + " of different document origin.";
	}
	return binding;
}

/**
 * @param {Binding} binding
 * @return {Binding}
 */
Binding.prototype.addFirst = function ( binding ) {

	if ( binding.bindingDocument == this.bindingDocument ) {
		this.bindingElement.insertBefore ( 
			binding.bindingElement, 
			this.bindingElement.firstChild 
		);
	} else {
		throw "Could not add " + binding.toString () + " of different document origin.";
	}
	return binding;
}

/**
 * Get ancestor binding by nodename.
 * @param {boolean} isTraverse If set to true, crossing iframe boundaries.
 * @return {Binding}
 */
Binding.prototype.getAncestorBindingByLocalName = function ( nodeName, isTraverse ) {
	
	return BindingFinder.getAncestorBindingByLocalName ( this, nodeName, isTraverse );
}

/**
 * Get ancestor binding by implementation type.
 * @param {Class} impl
 * @param {boolean} isTraverse If set to true, crossing iframe boundaries.
 * @return {Binding}
 */
Binding.prototype.getAncestorBindingByType = function ( impl, isTraverse ) {
	
	return BindingFinder.getAncestorBindingByType ( this, impl, isTraverse );
}

/**
 * Get first child binding of a specified type.
 * @param {Class} impl
 * @return {Binding}
 */
Binding.prototype.getChildBindingByType = function ( impl ) {
	
	return BindingFinder.getChildBindingByType ( this, impl );
}

/**
 * Get child elements by localname.
 * @param {string} nodeName
 * @return {List<DOMElement>}
 */
Binding.prototype.getChildElementsByLocalName = function ( nodeName ) {
	
	return BindingFinder.getChildElementsByLocalName ( this, nodeName );
}
/**
 * Get first child element by localname.
 * @param {string} nodeName
 * @return {DOMElement}
 */
Binding.prototype.getChildElementByLocalName = function ( nodeName ) {

	return this.getChildElementsByLocalName ( nodeName ).getFirst ();
}

/**
 * Get descendant elements by localname.
 * @param {string} nodeName
 * @return {List<Binding>}
 */
Binding.prototype.getDescendantElementsByLocalName = function ( nodeName ) {
	
	return new List ( 
		DOMUtil.getElementsByTagName ( this.bindingElement, nodeName ) 
	);
}

/**
 * Get multiple child bindings by localname.
 * @param {string} nodeName
 * @return {List<Binding>}
 */
Binding.prototype.getChildBindingsByLocalName = function ( nodeName ) {

	return this.getDescendantBindingsByLocalName ( nodeName, true );
}

/**
 * Get first child binding by localname.
 * @param {string} nodeName
 * @return {Binding}
 */
Binding.prototype.getChildBindingByLocalName = function ( nodeName ) {

	return this.getChildBindingsByLocalName ( nodeName ).getFirst ();
}

/**
 * Get descendant bindings by localname.
 * @param {string} nodeName
 * @param {boolean} isChildrenOnly If set to true, return only direct children bindings.
 * @return {List<Binding>}
 */
Binding.prototype.getDescendantBindingsByLocalName = function ( nodeName, isChildrenOnly ) {
	
	return BindingFinder.getDescendantBindingsByLocalName ( this, nodeName, isChildrenOnly );
}

/**
 * Get first descendant binding by localname.
 * TODO: optimize for speed by not collecting all first?
 * @param {string} nodeName
 * @return {Binding}
 */
Binding.prototype.getDescendantBindingByLocalName = function ( nodeName ) {
	
	return this.getDescendantBindingsByLocalName ( nodeName, false ).getFirst ();
}

/**
 * Get ALL descendant binding of a specified type.
 * @param {Class} impl
 * @return {List<Binding>}
 */
Binding.prototype.getDescendantBindingsByType = function ( impl ) {
	
	return BindingFinder.getDescendantBindingsByType ( this, impl );
}

/**
 * Get FIRST descendant binding of a specified type.
 * @param {Class} impl
 * @return {Binding}
 */
Binding.prototype.getDescendantBindingByType = function ( impl ) {
	
	return BindingFinder.getDescendantBindingByType ( this, impl );
}

/**
 * Get next binding by localname.
 * @param {string} nodeName
 * @return {Binding}
 */
Binding.prototype.getNextBindingByLocalName = function ( nodeName ) {
	
	return BindingFinder.getNextBindingByLocalName ( this, nodeName );
};

/**
 * Get next binding by localname.
 * @param {string} nodeName
 * @return {Binding}
 */
Binding.prototype.getPreviousBindingByLocalName = function ( nodeName ) {
	
	return BindingFinder.getPreviousBindingByLocalName ( this, nodeName );
};

/**
 * Because of a seriously weird bug in Explorer, this may be 
 * the preferred way to obtain a handle on the bound element. 
 * @return {DOMElement} 
 */
Binding.prototype.getBindingElement = function () {

	return this.bindingDocument.getElementById ( this.bindingElement.id );
}

/**
 * Get the ordinal position of a Binding within it's container (skipping textnodes). 
 * @param {DOMElement} element
 * @param {boolean} isSimilar If set to true, count only similar bindings.
 * @return {int}
 */
Binding.prototype.getOrdinalPosition = function ( isSimilar ) {

	return DOMUtil.getOrdinalPosition ( this.bindingElement, isSimilar );
}

/**
 * Is first child of container?
 * @param {boolean} isSimilar If set to true, count only similar bindings.
 * @return {boolean}
 */
Binding.prototype.isFirstBinding = function ( isSimilar ) {

	return ( this.getOrdinalPosition ( isSimilar ) == 0 );
}
	
/**
 * Is last child of container?
 * @param {boolean} isSimilar If set to true, count only similar bindings.
 * @return {boolean}
 */
Binding.prototype.isLastBinding = function ( isSimilar ) {

	return DOMUtil.isLastElement ( this.bindingElement, isSimilar );	
}

/**
 * Has callback ID? If true, the server is probably watching this Binding.
 * @return {boolean}
 */
Binding.prototype.hasCallBackID = function () {
	
	return this.getProperty ( Binding.CALLBACKID ) != null;
}

/**
 * Get callback ID. On server postback, this will be transmitted as parameter __EVENTTARGET.
 * @return {String}
 */
Binding.prototype.getCallBackID = function () {
	
	return this.getProperty ( Binding.CALLBACKID );
}

/**
 * Set callback ID.
 * @param {String} id
 */
Binding.prototype.setCallBackID = function ( id ) {
	
	this.setProperty ( Binding.CALLBACKID, id );
}

/**
 * Has callback argument?
 * @return {boolean}
 */
Binding.prototype.hasCallBackArg = function () {
	
	return this.getCallBackArg () != null;
}

/**
 * Get callback argument. On server postback, this will be transmitted as parameter __EVENTARGUMENT.
 * @return {String}
 */
Binding.prototype.getCallBackArg = function () {
	
	return this.getProperty ( Binding.CALLBACKARG );
}

/**
 * Set callback argument.
 * @param {String} argument
 */
Binding.prototype.setCallBackArg = function ( string ) {
	
	this.setProperty ( Binding.CALLBACKARG, string );
}

/**
 * Removes the bindingElement from stage and nulls all Binding properties, 
 * freeing delicious memory. Recursively destroys bindings withind DOM subtree.
 * @param {boolean} isDerivedDisposal
 */
Binding.prototype.dispose = function ( isDerivedDisposal ) {
	
	if ( !this.isDisposed ) {
	
		if ( !isDerivedDisposal ) {
	
			/*
			 * Destroy Binding objects recursively, starting from 
			 * the deepest position in descendant DOM structure.
			 * The DocumentManager will invoke this method again, 
			 * this time with the method argument set to true.
			 */
			this.bindingWindow.DocumentManager.detachBindings ( this.bindingElement );
		
			/*
			 * If this is the first Binding being disposed, remove bindingElement from DOM.
			 * We need to use getElementById here because explorer gets it fugged.
			 */
			var bindingElement = this.bindingDocument.getElementById ( this.bindingElement.id );
			if ( bindingElement ) {
				if ( Client.isExplorer ) {
					bindingElement.outerHTML = ""; // removeChild will memoryleak explorer (!)
				} else {
					bindingElement.parentNode.removeChild ( bindingElement );
				}
			}
			
		} else {
			
			/*
			 * Unregister EventBroadcaster subscriptions.
			 */
			if ( this._subscriptions.hasEntries ()) {
				var self = this;
				var list = new List ();
				this._subscriptions.each ( function ( broadcast ) {
					list.add ( broadcast );
				});
				list.each ( function ( broadcast ) {
					self.unsubscribe ( broadcast );
				});
			}
			
			/*
			 * Note that even on the first disposed binding, the DocumentManager re-invokes 
			 * this method with an argument value of true, triggering the onBindingDispose. 
			 */
			this.onBindingDispose ();
			
			/*
			 * This will attempt to kill the binding for good. 
			 * Currently, though, it doesn't release memory!
			 */
			UserInterface.unRegisterBinding ( this );
		}
	}
	
	// Note that the property "isDisposed" is finally set
	// to true around the static method Binding.destroy...
}

/**
 * Place your cleanup code around here.
 */
Binding.prototype.onBindingDispose = function () {
	
	/**
	 * Cleanup activation awareness. 
	 */
	if ( this._hasActivationAwareness ) {
		var root = UserInterface.getBinding ( this.bindingDocument.body );
		root.makeActivationAware ( this, false );
		this._hasActivationAwareness = false;
	}
	
	/**
	 * Delete from window scope bindingMap.
	 */
	this._updateBindingMap ( false );
}

/**
 * Enable dragging.
 */
Binding.prototype.enableDragging = function () {
	
	if ( this.dragger == null ) {
		this.dragger = new BindingDragger ( this );
		this.addEventListener ( DOMEvents.MOUSEDOWN, this.dragger );
		this.addEventListener ( DOMEvents.MOUSEMOVE, this.dragger );
		this.addEventListener ( DOMEvents.MOUSEUP, this.dragger );
	}
	this.isDraggable = true;
}

/**
 * Disable dragging.
 */
Binding.prototype.disableDragging = function () {

	if ( this.dragger != null ) {	
		this.removeEventListener ( DOMEvents.MOUSEDOWN, this.dragger );
		this.removeEventListener ( DOMEvents.MOUSEMOVE, this.dragger );
		this.removeEventListener ( DOMEvents.MOUSEUP, this.dragger );
		this.dragger.dispose ();
		this.dragger = null;
	}
	this.isDraggable = false;
}

/**
 * Show.
 */ 
Binding.prototype.show = function () {
	
	if ( !this.isVisible ) {
		this.bindingElement.style.display = "block";
		this.setProperty ( "hidden", true );
		this.isVisible = true;
	}
}

/**
 * Hide.
 */
Binding.prototype.hide = function () {
	
	if ( this.isVisible == true ) {
		this.bindingElement.style.display = "none";
		this.deleteProperty ( "hidden" );
		this.isVisible = false;
	}
}

/**
 * Wake up lazy binding (and perform the action provided as argument).
 * @param @optional {string} action The action to take when awoke.
 */
Binding.prototype.wakeUp = function ( action, timeout ) {
	
	timeout = timeout ? timeout : Binding.SNOOZE;
	
	if ( this.isLazy == true ) {
		
		this.deleteProperty ( "lazy" );
		this.isLazy = false;
		Application.lock ( this );
		
		/*
		 * Force new indexation of focusable elements.
		 */
		this.dispatchAction ( FocusBinding.ACTION_UPDATE );
		
		/*
		 * Timeout fixes freezing sensation.
		 */
		var self = this;
		setTimeout ( function () {
			self.attachRecursive ();
			setTimeout ( function () {
				if ( action !== undefined ) {
					self [ action ] ();
				}
				// Update any related LazyBindingDataBinding so that the server knows we are awake.
				LazyBindingBinding.wakeUp ( self );
				Application.unlock ( self );
				/*
				setTimeout ( function () {
					Application.focused ( true );
				},  Application._TIMEOUT_LOSTFOCUS * 2 );
				*/
			}, timeout ); // explorer cannot flex unless we timeout here - look into this!
		}, 0 );
	}
}

/**
 * Handle crawler. 
 * @implements {ICrawlerHandler}
 * @param {Crawler} crawler
 */
Binding.prototype.handleCrawler = function ( crawler ) {
	
	/*
	 * Lazy bindings will accept the DocumentCrawler   
	 * for purposes of binding registration only. 
	 */
	if ( crawler.response == null && this.isLazy == true ) {
		if ( crawler.id == DocumentCrawler.ID && crawler.mode == DocumentCrawler.MODE_REGISTER ) {
			crawler.response = NodeCrawler.NORMAL;
		} else {
			crawler.response = NodeCrawler.SKIP_CHILDREN;
		}
	}
	
	/*
	 * Search binding crawler filters.
	 */
	if ( crawler.response == null && this.crawlerFilters != null ) {
		if ( this.crawlerFilters.has ( crawler.id )) {
			crawler.response = NodeCrawler.SKIP_CHILDREN;
		}
	}
	
	/*
	 * These common crawlers should no iterate into hidden bindings.
	 */
	if ( crawler.response == null ) {
		switch ( crawler.id ) {	
			case FlexBoxCrawler.ID :
			case FocusCrawler.ID :
				if ( !this.isVisible ) {
					crawler.response = NodeCrawler.SKIP_CHILDREN;
				}
				break;
		}
	}
}

/**
 * Binding factory.
 * @param {DOMDocument} ownerDocument
 * @return {Binding}
 */
Binding.newInstance = function ( ownerDocument ) {
	
	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:binding", ownerDocument );
	return UserInterface.registerBinding ( element, Binding );
}

DataBinding.prototype = new Binding;
DataBinding.prototype.constructor = DataBinding;
DataBinding.superclass = Binding.prototype;

DataBinding.AUTOGENERATED = "autogenerateddatabindingname";

DataBinding.TYPE_NUMBER = "number";
DataBinding.TYPE_INTEGER = "integer";
DataBinding.TYPE_STRING = "string";

DataBinding.CLASSNAME_INVALID = "invalid";
DataBinding.CLASSNAME_WARNING = "warning";
DataBinding.CLASSNAME_FOCUSED = "focused";
DataBinding.CLASSNAME_DISABLED = "disabled";


/**
 * Populating expressions when user logs in.
 * Becuase they may be language dependant.
 */
EventBroadcaster.subscribe ( BroadcastMessages.APPLICATION_LOGIN, {
	handleBroadcast : function () {
		var expressions = new List ( ConfigurationService.GetValidatingRegularExpressions ( "dummy" ));
		expressions.each ( function ( entry ) {
			DataBinding.expressions [ entry.Key ] = new RegExp ( entry.Value );
		});
	}
});


/**
 * Regular expressions used for validating. Populated 
 * by ConfigurationService on login (see abowe).
 * @type {HashMap<string><RegExp>}
 */
DataBinding.expressions = {
	
	// populated by server - just to illustrate the structure...
	
	/*
	"number" 	: /^[0-9]+(\,[0-9]+)?$/,
	"integer" 	: /^[0-9]+$/,
	"currency" 	: /^[0-9]{1,3}(\.[0-9]{3})*(\,[0-9]{1,2})?$/,
	"email"		: /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,})+$/,
	"string"	: /[a-å]|[A-Å]|[0-9]/
	"url"		: /^/|://|mailto:|javascript:/
	*/
}

/**
 * Warnings. This is written *inside* the control, not in a balloon. Not all DataBindings 
 * may support warnings; only bindings that rely on direct keyboard input.
 * @see {DataInputBinding}
 * @see {TextBoxBinding} 
 * TODO: Move to ConfigurationService?
 */
DataBinding.warnings = {
	
	"required" 	                : "Required",
	"number" 	                : "Numbers only",
	"integer" 	                : "Integers only",
	"programmingidentifier"     : "Invalid identifier",
	"programmingnamespace"      : "Invalid namespace",
	"url"						: "Invalid URL",
	"minlength"					: "${count} characters minimum",
	"maxlength"					: "${count} characters maximum",
	"currency"					: "Invalid notation",
	"email"						: "Invalid e-mail",
	"guid"						: "Invalid GUID"
}

/**
 * Errors (balloons texts). All DataBindings support errors. 
 * Remember that error presentation is handled by the FieldBinding.
 * @see {FieldBinding#handleAction} 
 * TODO: Move to ConfigurationService?
 */
DataBinding.errors = {
	
	"programmingidentifier"     : "An identifier must not contain spaces or special characters. Only characters a-z, A-Z and 0-9 are allowed. An identifier must begin with a letter (not a number).",
	"programmingnamespace"      : "A namespace must take the form Example.Name.Space where only characters a-z, A-Z, 0-9 and dots (.) are allowed. Each part of the namespace must begin with a letter (not a number).",
	"url"						: "A valid URL must begin with a forward slash, designating the site root, or an URL scheme name such as http://. Simpliefied addresses such as www.example.com cannot be resolved reliably by the browser. Relative URLs are not supported."
}

/**
 * Retrieve the string label of the FieldDescBinding hosting any given binding.
 * @param {Binding} binding 
 * @return {string}
 */
DataBinding.getAssociatedLabel = function ( binding ) {
	
	var result = null;
	var field = binding.getAncestorBindingByLocalName ( "field" );
	
	if ( field && field instanceof FieldBinding ) {
		var desc = field.getDescendantBindingByLocalName ( "fielddesc" );
		if ( desc && desc instanceof FieldDescBinding ) {
			result = desc.getLabel ();
		}
	}
	return result;
}

/**
 * @class
 * This is sort of an abstract class. The real stuff goes on in subclasses.
 * @implements {IData}
 */
function DataBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DataBinding" );
	
	/**
	 * @type {string}
	 */
	this._name = null;
	
	/**
	 * @type {boolean}
	 */
	this.isDirty = false;
	
	/**
	 * @implements {IData}
	 * @type {boolean}
	 */
	this.isFocusable = true;
	
	/**
	 * @implements {IData}
	 * @type {boolean}
	 */
	this.isFocused = false;
	
	/**
	 * The errortext associated, popularly known as balloons. 
	 * Remember that errors may also be injected by the server 
	 * in a special UpdatePanelBinding.
	 * @type {string} 
	 */
	this.error = null;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
DataBinding.prototype.toString = function () {

	return "[DataBinding]";
}

/**
 * Register binding with DocumentManager.
 * @overloads {Binding#onBindingRegister}
 */
DataBinding.prototype.onBindingRegister = function () {

	DataBinding.superclass.onBindingRegister.call ( this );
	this.propertyMethodMap [ "isdisabled" ] = this.setDisabled; // HIGHLY QUESTIONABLE!
	
	/*
	 * Register name (backendish concept) with DataManager.
	 */
	var name = this._name ? this._name : this.getProperty ( "name" );
	if ( name == null ) {
		name = DataBinding.AUTOGENERATED + KeyMaster.getUniqueKey ();
	}
 	this.setName ( name );
}

/**
 * Associate an error (balloon) to this bindings invalid state?
 * @overloads {Binding#onBindingAttach}
 */
DataBinding.prototype.onBindingAttach = function () {
	
	DataBinding.superclass.onBindingAttach.call ( this );
 	if ( this.getProperty ( "error" )) {
	 	this.error = this.getProperty ( "error" );
	}
}

/**
 * Unregister binding with the window-scope {@link DataManager}.
 * @overloads {Binding#onBindingDispose}
 */
DataBinding.prototype.onBindingDispose = function () {
	
	DataBinding.superclass.onBindingDispose.call ( this );
	
	if ( this.isFocused == true ) {
		this.blur ();
	}
	
	var dataManager = this.bindingWindow.DataManager;
	dataManager.unRegisterDataBinding ( this._name );
}

/**
 * Set name. The DataBinding is registered with the window-scope  
 * {@link DocumentManager} for easy retrieval in other contexts.
 * @param {string} name
 */
DataBinding.prototype.setName = function ( name ) {
	
	var dataManager = this.bindingWindow.DataManager;

	if ( dataManager.getDataBinding ( name )) {
		dataManager.unRegisterDataBinding ( name );
	}
	dataManager.registerDataBinding ( name, this );
	this.setProperty ( "name", name );
	this._name = name;
}

/**
 * Get name.
 * @implements {IData}
 * @return {string}
 */
DataBinding.prototype.getName = function () {
	
	return this._name;
}

/**
 * Focus.
 * @implements {IData}
 */
DataBinding.prototype.focus = function () {
	
	if ( this.isFocusable && !this.isFocused ) {
		this.isFocused = true;
		this.dispatchAction ( Binding.ACTION_FOCUSED );
		this.attachClassName ( DataBinding.CLASSNAME_FOCUSED );
	}
};

/**
 * Blur.
 * @implements {IData}
 */
DataBinding.prototype.blur = function () {
	
	if ( this.isFocused ) {
		this.isFocused = false;
		this.dispatchAction ( Binding.ACTION_BLURRED );
		this.detachClassName ( DataBinding.CLASSNAME_FOCUSED );
	}
};

/**
 * Pollute dirty flag.
 */
DataBinding.prototype.dirty = function () {
	
	this.bindingWindow.DataManager.dirty ( this );
};

/**
 * Clear dirty flag.
 */
DataBinding.prototype.clean = function () {
	
	this.bindingWindow.DataManager.clean ( this );
};

// ABSTRACT METHODS ............................................................

/**
 * Validate.
 * @implements {IData}
 * @return {boolean}
 */
DataBinding.prototype.validate = Binding.ABSTRACT_METHOD;

/**
 * Manifest. This will write form elements into page DOM 
 * so that the server recieves something on form submit.
 * @implements {IData}
 */
DataBinding.prototype.manifest = Binding.ABSTRACT_METHOD;

/**
 * Get value. This is intended for serversice processing.
 * @implements {IData}
 * @return {string}
 */
DataBinding.prototype.getValue = Binding.ABSTRACT_METHOD;

/**
 * Set value.
 * @implements {IData}
 * @param {string} value
 */
DataBinding.prototype.setValue = Binding.ABSTRACT_METHOD;

/**
 * Get result. This is intended for clientside processing.
 * @implements {IData}
 * @return {object}
 */
DataBinding.prototype.getResult = Binding.ABSTRACT_METHOD;

/**
 * Set result.
 * @implements {IData}
 * @param {object} value
 */
DataBinding.prototype.setResult = Binding.ABSTRACT_METHOD;


RootBinding.prototype = new Binding;
RootBinding.prototype.constructor = RootBinding;
RootBinding.superclass = Binding.prototype;

/*
 * These actions get dispatched simultaniously on document 
 * initialization. They have been split into three so that hosted  
 * bindings get hook into different "phases" for fine-tuning. 
 * They all get consumed by first ancestor {@link ViewBinding}. 
 * TODO: Refactor > consume by WindowBinding.
 */
RootBinding.ACTION_PHASE_1 = "root init phase 1";
RootBinding.ACTION_PHASE_2 = "root init phase 2";
RootBinding.ACTION_PHASE_3 = "root init phase 3";

/*
 * Bindings can hook into these to know when the nearest ancestor 
 * DockBinding or StageDialogBinding has been changed activation. 
 * They both get consumed by first ancestor {@link WindowBinding}. 
 * Alternatively, see method {RootBinding#makeActivationAware}.
 */
RootBinding.ACTION_ACTIVATED = "root activated";
RootBinding.ACTION_DEACTIVATED = "root deactivated";

/**
 * @class
 * This binds to the BODY tag!
 */
function RootBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "RootBinding" );
	 
	/**
	 * The root is always activation-aware ANYWAY!
	 * TODO: normalize this scenario!
	 * @implements {IActivationAware}
	 * @type {boolean}
	 */
	this.isActivationAware = false;
	
	/**
	 * @implements {IActivationAware}
	 * @type {boolean}
	 */
	this.isActivated = false;
	
	/**
	 * List of activation-aware bindings.
	 * @type {List<IAcivationAware>}
	 */
	this._activationawares = null;
	
	/*
	 * Returnable
	 */
	return this;
}

/**
 * Identifies binding.
 */
RootBinding.prototype.toString = function () {

	return "[RootBinding]";
}

/**
 * Setup to make sure that any freshly loaded window 
 * is always flexed up from the root element.
 * @overloads {Binding#onBindingRegister}.
 */
RootBinding.prototype.onBindingRegister = function () {
	
	RootBinding.superclass.onBindingRegister.call ( this );
	
	this.logger = SystemLogger.getLogger ( this.bindingDocument.title.toString ());
	
	if ( this.bindingWindow.WindowManager ) {
		this.subscribe ( this.bindingWindow.WindowManager.WINDOW_EVALUATED_BROADCAST );
	}
	
	/*
	 * Make activation aware.
	 */
	this._activationawares = new List ();
	this.isActivated = false;
	this._setupActivationAwareness ( true );
}

/**
 * @overloads {Binding#onBindingDispose}
 */
RootBinding.prototype.onBindingDispose = function () {
	
	RootBinding.superclass.onBindingDispose.call ( this );
	this._setupActivationAwareness ( false );
	EventBroadcaster.unsubscribe ( 
		this.bindingWindow.WindowManager.WINDOW_EVALUATED_BROADCAST,
		this
	);
}

/**
 * On window load, dispatch three actions. If one binding is  
 * required to do something before another binding, just let  
 * them hook into different phases around here.  
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
RootBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	RootBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	var onloadBroadcast = this.bindingWindow.WindowManager.WINDOW_EVALUATED_BROADCAST;
	
	switch ( broadcast ) {
		case onloadBroadcast :
			
			/*
			 * Dispatch phases.
			 */
			this.dispatchAction ( RootBinding.ACTION_PHASE_1 );
			this.dispatchAction ( RootBinding.ACTION_PHASE_2 );
			this.dispatchAction ( RootBinding.ACTION_PHASE_3 );
			this.unsubscribe ( onloadBroadcast );
			break;
	}
}

/**
 * Invoked when the nearest containing 
 * {@link IActivatable} gets activated.
 * TODO: Disable during startup?
 * @implements {IActivationAware}
 */
RootBinding.prototype.onActivate = function () {
	
	this._onActivationChanged ( true );
}

/**
 * Invoked when the nearest containing 
 * {@link IActivatable} gets deactivated.
 * TODO: Disable during startup?
 * @implements {IActivationAware}
 */
RootBinding.prototype.onDeactivate = function () {
	
	this._onActivationChanged ( false );
}

/**
 * Handle activation change.
 * @param {boolean} isActivated
 * @return
 */
RootBinding.prototype._onActivationChanged = function ( isActivated ) {
	
	var action = isActivated ? RootBinding.ACTION_ACTIVATED : RootBinding.ACTION_DEACTIVATED;
	
	if ( isActivated != this.isActivated ) {
		
		this.isActivated = isActivated;
		this.dispatchAction ( action );
		var waste = new List ();
		var self = this;
		
		/*
		 * Bindings will cleanup themselves on disposal, 
		 * but other objects may forget to unregister 
		 * from the awareness list. We do a basic cleanup.
		 */
		this._activationawares.each ( function ( aware ) {
			if ( aware.isActivationAware ) {
				try {
					if ( isActivated ) {
						if ( !aware.isActivated ) {
							aware.onActivate ();
						}
					} else {
						if ( aware.isActivated ) {
							aware.onDeactivate ();
						}
					}
				} catch ( exception ) {
					self.logger.error ( exception );
					waste.add ( aware );
				}
			}
		});
		
		/*
		 * Cleanup waste from awareness list.
		 */
		waste.each ( function ( aware ) {
			this._activationawares.del ( aware );
		});
		waste.dispose ();
		
	} else {
		var error = "Activation dysfunction: " + this.bindingDocument.title;
		if ( Application.isDeveloperMode == true ) {
			// alert ( error ); 
			this.logger.error ( error );
		} else {
			this.logger.error ( error );
		}
	}
}

/**
 * Add or remove binding to be poked when activation changes.
 * @param {IActivationAware} binding
 * @param @optional {boolean} isAware
 */
RootBinding.prototype.makeActivationAware = function ( binding, isAware ) {
	
	if ( Interfaces.isImplemented ( IActivationAware, binding, true ) == true ) {
		if ( isAware == false ) {
			this._activationawares.del ( binding );
		} else {
			this._activationawares.add ( binding );
			if ( this.isActivated == true ) {		
				binding.onActivate ();
			}
		}
	} else {
		if ( Application.isDeveloperMode == true ) {
			alert ( "RootBinding: IActivationAware not implemented (" + binding + ")");
		}
	}
}

/**
 * Add and remove activation awareness (on register and dispose).
 * @param {boolean} isSetup
 */
RootBinding.prototype._setupActivationAwareness = function ( isSetup ) {

	var frame = this.getMigrationParent ();
	if ( frame != null ) {
		var root = frame.ownerDocument.body;
		var binding = UserInterface.getBinding ( root );
		if ( binding != null ) {
			binding.makeActivationAware ( this, isSetup );
		}
	}
}

/**
 * Relay ascending crawle to containing document.
 * @implements {ICrawlerHandler}
 * @param {Crawler} crawler
 */
RootBinding.prototype.handleCrawler = function ( crawler ) {
	
	RootBinding.superclass.handleCrawler.call ( this, crawler );
	
	if ( crawler.type == NodeCrawler.TYPE_ASCENDING ) {
		crawler.nextNode = this.bindingWindow.frameElement;
	}
}

/**
 * Migrate the action to "nearest" binding in ancestor document.
 * @overwrites {Binding#getMigrationParent}.
 */
RootBinding.prototype.getMigrationParent = function () {

	var result = null;
	if ( this.bindingWindow.parent ) {
		result = this.bindingWindow.frameElement;
	}
	return result;
}

MatrixBinding.prototype= new Binding;
MatrixBinding.prototype.constructor = MatrixBinding;
MatrixBinding.superclass = Binding.prototype;

MatrixBinding.CLASSNAME_MANIFESTER = "matrixbindingmanifester";

MatrixBinding.CENTER	= "c";
MatrixBinding.NORTH 	= "n";
MatrixBinding.SOUTH 	= "s";
MatrixBinding.EAST 		= "e";
MatrixBinding.WEST 		= "w";
MatrixBinding.NORTHEAST	= "ne";
MatrixBinding.NORTHWEST	= "nw";
MatrixBinding.SOUTHEAST	= "se";
MatrixBinding.SOUTHWEST	= "sw";

/**
 * @type {string}
 */
MatrixBinding.markup = null;

/**
 * @class
 */
function MatrixBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "MatrixBinding" );
	
	/**
	 * Subclass can overwrite this property to disable matrix building.
	 * @type {boolean}
	 */
	this.hasMatrix = true;
	
	/**
	 * The matrix template. Locates a file in the "templates" folder.
	 * @type {string}
	 */
	this.template = "matrixbindingelement.xml";
	
	/**
	 * We'll be generating of lot of matrixes, so we won't index the table unless required.
	 * @type {boolean}
	 */
	this._isTableIndexed = false;
	
	/*
	 * Returnable
	 */
	return this;
}

/**
 * Identifies binding.
 */
MatrixBinding.prototype.toString = function () {

	return "[MatrixBinding]";
}

/**
 *
 */
MatrixBinding.prototype.onBindingAttach = function () {

	MatrixBinding.superclass.onBindingAttach.call ( this );
	
	if ( this.hasMatrix ) {
		if ( this.bindingElement.hasChildNodes ()) {
			throw new Error ( "MatrixBinding: No support for childnodes!" );
		} else {
			this.bindingElement.innerHTML = Templates.getTemplateElementText ( 
				this.template 
			);
			this.shadowTree.table = this.bindingElement.firstChild;
		}
	}
}

/**
 * Indexing table cells.
 */
MatrixBinding.prototype._indexTable = function () {

	var cells = new List ( 
		DOMUtil.getElementsByTagName ( this.bindingElement, "td" )
	);
	while ( cells.hasNext ()) {
		var cell = cells.getNext ();
		this.shadowTree [ cell.className ] = cell;	
	}
}

/**
 * @overwrites {Binding#add} to make sure 
 * that added content is placed in matrix center.
 * @param {Binding} binding
 * @return {Binding}
 */
MatrixBinding.prototype.add = function ( binding ) {

	var returnable = null;
	if ( this.hasMatrix ) {
		if ( !this._isTableIndexed ) {
			this._indexTable ();
		}
		this.shadowTree [ MatrixBinding.CENTER ].appendChild ( binding.bindingElement );
		returnable = binding;
	} else {
		returnable = MatrixBinding.superclass.add.call ( this, binding );
	}
	return returnable;
}

/**
 * @overwrites {Binding#addFirst} to make sure 
 * that added content is placed in matrix center.
 * @param {Binding} binding
 * @return {Binding}
 */
MatrixBinding.prototype.addFirst = function ( binding ) {

	var returnable = null;
	if ( this.hasMatrix ) {
		if ( !this._isTableIndexed ) {
			this._indexTable ();
		}
		var centerCell = this.shadowTree [ MatrixBinding.CENTER ];
		centerCell.insertBefore ( binding.bindingElement, centerCell.firstChild );
		returnable = binding;
	} else {
		returnable = MatrixBinding.superclass.addFirst.call ( this, binding );
	}
	return binding;
}

/**
 * Both browsers have trouble rendering the table unless at least one cell has 
 * content. This can be fixed by setting a border, but we don't want one of those.
 * In most cases - eg buttons and tabs - the matrix has content and this can be skipped.
 */
MatrixBinding.prototype.manifest = function () {
	
	if ( !this._isTableIndexed ) {
		this._indexTable ();
	}
	var div = this.bindingDocument.createElement ( "div" );
	div.appendChild ( this.bindingDocument.createTextNode ( "!" ));
	div.className = MatrixBinding.CLASSNAME_MANIFESTER;
	this.shadowTree [ MatrixBinding.CENTER ].appendChild ( div );
}

/**
 * MYBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {MYBinding}
 */
MatrixBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:matrix", ownerDocument );
	return UserInterface.registerBinding ( element, MatrixBinding );
}

FlexBoxBinding.prototype= new Binding;
FlexBoxBinding.prototype.constructor = FlexBoxBinding;
FlexBoxBinding.superclass = Binding.prototype;

FlexBoxBinding.CLASSNAME = "flexboxelement";

FlexBoxBinding.TIMEOUT = 250;

/**
 * In case the reflex chain should invoke a new call to reflex, a clever timeout 
 * system has been established to prevent multiple simultanious flex iterators. 
 * It works by switching the isFlexSuspended property on bindings. The timeout can 
 * be supressed by passing a boolean value of true to the method. This can be desired, 
 * but should be avoided since it adds a computational overhead that threatens Explorer. 
 * Notice that reflex invokation is disabled during startup since the stage is hidden anyway.
 * @param {Binding} startBinding
 * @param @optional {boolean} isForce
 */
FlexBoxBinding.reflex = function ( startBinding, isForce ) {
	
	/*
	 * Collect flexible bindings in a list.  
	 * Skip bindings with suspended flex.
	 */
	var list = new List ();
	var crawler = new FlexBoxCrawler ();
	crawler.mode = isForce ? FlexBoxCrawler.MODE_FORCE : FlexBoxCrawler.MODE_NORMAL;
	crawler.startBinding = startBinding;
	crawler.crawl ( startBinding.bindingElement, list );
	
	/*
	 * Flex each binding in list, briefly suspending flexibility 
	 * (the binding may still flex in case the isForce param is true). 
	 * Note that the crawler SKIPS bindings with suspended flex.
	 */
	list.each ( function ( binding ) {
		binding.flex ();
	});
	
	/*
	 * This is ultra lame. But so is Internet Explorer. Note that 
	 * we don't respect the significance of suspended flex here,  
	 * We simply flex again. The longer the timeout, the better  
	 * the odds of IE computing an exact layout calculation...
	 */
	if ( Client.isExplorer ) {
		setTimeout ( function () {
			list.each ( function ( binding ) {
				if ( Binding.exists ( binding )) {
					binding.flex ();
				}
			});
		}, 0.5 * FlexBoxBinding.TIMEOUT );
	}
	
	/*
	 * Reset binding flexibility after a short timeout.
	 */
	setTimeout ( function () {
		list.each ( function ( binding ) {
			if ( Binding.exists ( binding )) {
				binding.isFlexSuspended = false;
			}
		});
		list.dispose ();
	}, FlexBoxBinding.TIMEOUT );
		
	/*
	 * Creepy crawlers.
	 */
	crawler.dispose ();
}

/**
 * @class
 */
function FlexBoxBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "FlexBoxBinding" );
	
	/**
	 * This flag is switched off and and later switched back on by the binding 
	 * that started the iteration. This will prevent multiple flex invokations 
	 * with much computational stress but no visible effect.
	 * @see {Binding#reflex}
	 * @type {boolean}
	 */
	this.isFlexSuspended = false;
	
	/**
	 * Enable flexbox behavior.
	 * @type {boolean}
	 */
	this.isFlexible = true;
	
	/**
	 * @type {boolean}
	 */
	this.isFit = true; 
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
FlexBoxBinding.prototype.toString = function () {

	return "[FlexBoxBinding]";
}

/**
 * @overloads {Binding#onBindingRegister}
 */
FlexBoxBinding.prototype.onBindingRegister = function () {

	FlexBoxBinding.superclass.onBindingRegister.call ( this );
	
	/*
	 * Note that you can disable flex  
	 * by twisting this property.
	 */
	if ( this.getProperty ( "flex" ) == false ) {
		this.isFlexible = false;
	}
	
	/*
	 * Attaching class names has a huge impact on Explorer, 
	 * so there's no need to stress it right now. However, 
	 * Mozilla renders the ExplorerBinding tree wrong unless 
	 * we do it now. Luckily, classnames won't bother Mozilla. 
	 */
	if ( Client.isMozilla ) {
		if ( this.isFlexible ) {
			this.attachClassName ( FlexBoxBinding.CLASSNAME );
		}
	}
}

/**
 * @overloads {Binding#onBindingAttach}
 */
FlexBoxBinding.prototype.onBindingAttach = function () {
	
	FlexBoxBinding.superclass.onBindingAttach.call ( this );
	
	/*
	 * For use with the fitness program. This allows dialogs 
	 * to expand in order to show content without scrollbars.
	 */
	this.addActionListener ( Binding.ACTION_UPDATED );
	
	/*
	 * This has been dealyed for performance reasons.
	 * See note in method onBindingRegister...
	 */
	if ( Client.isExplorer ) {
		if ( this.isFlexible ) {
			this.attachClassName ( FlexBoxBinding.CLASSNAME );
		}
	}
}

/**
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
FlexBoxBinding.prototype.handleAction = function ( action ) {
	
	FlexBoxBinding.superclass.handleAction.call ( this, action );
	
	switch ( action.type ) {
		case Binding.ACTION_UPDATED :
			this.isFit = false;
			break;
	}
}

/**
 * Get combined span of sibling elements.
 * @param @optional {boolean} isHorizontal
 */
FlexBoxBinding.prototype._getSiblingsSpan = function ( isHorizontal ) {
	
	var result = 0;
	var children = new List ( this.bindingElement.parentNode.childNodes );
	
	while ( children.hasNext ()) {
		var child = children.getNext ();
		if ( child.nodeType == Node.ELEMENT_NODE && child != this.bindingElement ) {
			if ( !this._isOutOfFlow ( child )) {
				var rect = child.getBoundingClientRect ();
				if ( isHorizontal ) {
					height += ( rect.right - rect.left );
				} else {
					result += ( rect.bottom - rect.top );
				}
			}			
		}
	};
	return result;
}

/**
 * Not counting absolutely positioned or floated elements.
 * @param {DOMElement} element
 * @return {boolean}
 * @private
 */
FlexBoxBinding.prototype._isOutOfFlow = function ( element ) {

	var position = CSSComputer.getPosition ( element );
	var cssfloat = CSSComputer.getFloat ( element );
	return ( position == "absolute" || cssfloat != "none" ? true : false );
}

/**
 * Compute height.
 */
FlexBoxBinding.prototype._getCalculatedHeight = function () {

	var parent	= this.bindingElement.parentNode;
	var rect = parent.getBoundingClientRect ();
	var result = rect.bottom - rect.top;
	var padding	= CSSComputer.getPadding ( parent );
	var border	= CSSComputer.getBorder ( parent );
	
	result -= ( padding.top + padding.bottom );
	result -= ( border.top + border.bottom );

	return result;
}

/**
 * Compute width. This is not currently in use.
 */
FlexBoxBinding.prototype._getCalculatedWidth = function () {

	var parent	= this.bindingElement.parentNode;
	var rect = parent.getBoundingClientRect ();
	var result = rect.right - rect.left;
	var padding	= CSSComputer.getPadding ( parent );
	var border	= CSSComputer.getBorder ( parent );
	
	result -= ( padding.left + padding.right );
	result -= ( border.left + border.right );

	return result;
}

/**
 * Set flex behavior.
 */
FlexBoxBinding.prototype.setFlexibility = function ( isFlexible ) {
	
	if ( isFlexible != this.isFlexible ) {
		if ( isFlexible ) {
			this.attachClassName ( FlexBoxBinding.CLASSNAME );
			this.deleteProperty ( "flex" );
		} else {
			this.detachClassName ( FlexBoxBinding.CLASSNAME );
			this.setProperty ( "flex", false );
		}
		this.isFlexible = isFlexible;
	}
}

/**
 * Performs the actual flexing. Note that  
 * isFlexSuspended is not accounted for here.
 * @implements {IFlexible}
 */
FlexBoxBinding.prototype.flex = function ( ) {
	
	if ( Binding.exists ( this )) {
		if ( this.isFlexible == true ) {
			var height = this._getSiblingsSpan ();
			height = this._getCalculatedHeight () - height;
			if ( !isNaN ( height ) && height >= 0 ) {
				if ( height != this.bindingElement.offsetHeight ) {
					this.bindingElement.style.height = String ( height ) + "px";
				}
			}
		}
	}
}
	
/**
 * Expand flexbox vertically to eclose it's content. 
 * Should only be invoked by the {@link StageDialogBinding}
 * @param {boolean} isForce
 * @implements {IFit}
 */
FlexBoxBinding.prototype.fit = function ( isForce ) {

	if ( !this.isFit || isForce ) {
		
		var height = 0;
		
		new List ( this.bindingElement.childNodes ).each ( 
			function ( child ) {
				if ( child.nodeType == Node.ELEMENT_NODE ) {
					if ( !this._isOutOfFlow ( child )) {
						var rect = child.getBoundingClientRect ();
						height += ( rect.bottom - rect.top );
					}
				}
			}
		, this );
		// if ( height > this._getFitnessHeight ()) { // check disabled!
			this._setFitnessHeight ( height );
		// }
		this.isFit = true;
	}
}

/**
 * Hardwired for method fit. 
 * @return {int} 
 *
FlexBoxBinding.prototype._getFitnessHeight = function () {
	
	var padding	= CSSComputer.getPadding ( this.bindingElement );
	var border	= CSSComputer.getBorder ( this.bindingElement );
	var height = this.bindingElement.offsetHeight;
	
	height += padding.top + padding.bottom;
	height += border.top + border.bottom;
	
	return height;
}
*/

/**
 * Hardwired for method fit. 
 * Note the {@link DialogPageBodyBinding} overwrites this!
 * @param {int} height
 */
FlexBoxBinding.prototype._setFitnessHeight = function ( height ) {
	
	var padding	= CSSComputer.getPadding ( this.bindingElement );
	var border	= CSSComputer.getBorder ( this.bindingElement );
	
	height += padding.top + padding.bottom;
	height += border.top + border.bottom;
	
	this.bindingElement.style.height = height + "px";
}


ScrollBoxBinding.prototype = new FlexBoxBinding;
ScrollBoxBinding.prototype.constructor = ScrollBoxBinding;
ScrollBoxBinding.superclass = FlexBoxBinding.prototype;

function ScrollBoxBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ScrollBoxBinding" );
}

/**
 * Identifies binding.
 */
ScrollBoxBinding.prototype.toString = function () {

	return "[ScrollBoxBinding]";
}

/**
 * @overloads {MatrixBinding#onBindintRegister}
 */
ScrollBoxBinding.prototype.onBindingRegister = function () {
	
	ScrollBoxBinding.superclass.onBindingRegister.call ( this );
	this.addActionListener ( BalloonBinding.ACTION_INITIALIZE );
	// this._isFit = this.getProperty ( "fit" ) == true;
}

/**
 * Register as environment for balloons.
 * @implements {IActionListener}
 * @overloads {FlexBoxBinding#handleAction}
 * @param {Action} action
 */
ScrollBoxBinding.prototype.handleAction = function ( action ) {
	
	ScrollBoxBinding.superclass.handleAction.call ( this, action );
	
	/*
	 * Balloon tricks a go go.
	 */
	switch ( action.type ) {
		case BalloonBinding.ACTION_INITIALIZE :
			action.consume ();
			break;
	}
}

/**
 * Pathces a glitch where scrollboxes would otherwise resort to visible scrollbars. 
 * @param {int} height
 *
ScrollBoxBinding.prototype._setFitnessHeight = function ( height ) {
	
	/*
	 * TODO: Figure out where these extra pixels are coming from!
	 *
	ScrollBoxBinding.superclass._setFitnessHeight.call ( this, height + 5 );
}
*/

/**
 * Set scrollbox position.
 * @param {Point} point
 */
ScrollBoxBinding.prototype.setPosition = function ( point ) {
	
	this.bindingElement.scrollLeft = point.x;
	this.bindingElement.scrollTop = point.y;
}

/**
 * Get scrollbox position.
 * @return {Point}
 */
ScrollBoxBinding.prototype.getPosition = function () {
	
	return new Point (
		this.bindingElement.scrollLeft,
		this.bindingElement.scrollTop
	);	
}

LabelBinding.prototype = new Binding;
LabelBinding.prototype.constructor = LabelBinding;
LabelBinding.superclass = Binding.prototype;

/*
 * Can be used to indicate that a dialog window will 
 * open. Looks more elegant than three regular dots.
 */
LabelBinding.DIALOG_INDECATOR_SUFFIX = String.fromCharCode ( 8230 ); // "…".charCodeAt ( 0 );
LabelBinding.DEFAULT_IMAGE = "${root}/images/blank.png";
LabelBinding.EXPLORER_IMAGE_FILTER = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${url}',sizingMethod='crop');"
LabelBinding.CLASSNAME_TEXTOVERFLOW = "textoverflow";
LabelBinding.CLASSNAME_GRAYTEXT = "graytext";
LabelBinding.CLASSNAME_FLIPPED = "flipped";

/**
 * @class
 */
function LabelBinding () {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "LabelBinding" );
	
	/**
	 * @type {boolean}
	 */
	this.hasImage = false;
	
	/**
	 * @type {boolean}
	 */
	this.hasLabel = false;

	/**
	 * Image and text position reversed?
	 * @type {boolean}
	 */
	this.isFlipped = false;
	
	/**
	 * Block common crawlers.
	 * @overwrites {Binding#crawlerFilters}
	 * @type {List<string>}
	 */
	this.crawlerFilters	= new List ([ DocumentCrawler.ID, FlexBoxCrawler.ID, FocusCrawler.ID ]);
	
	/*
	 * Returnable.
	 */
	return this;
}

/** 
 * Identifies binding.
 */
LabelBinding.prototype.toString = function () {

	return "[LabelBinding]";
}


/** 
 * Can't remember why we need to build DOM content in the registration phase...
 * @overloads {Binding#onBindingRegister}
 */
LabelBinding.prototype.onBindingRegister = function () {
	
	LabelBinding.superclass.onBindingRegister.call ( this );
	
	if ( this.isBindingBuild ) {
		this.shadowTree.labelBody = this._getBuildElement ( "labelbody" );
	} else {
		this.shadowTree.labelBody = DOMUtil.createElementNS ( 
			Constants.NS_UI, "ui:labelbody", this.bindingDocument 
		);
		this.bindingElement.appendChild ( this.shadowTree.labelBody );
	}
}

/** 
 * @overloads {Binding#onBindingAttach}
 */
LabelBinding.prototype.onBindingAttach = function () {
	
	LabelBinding.superclass.onBindingAttach.call ( this );
	
	if ( this.isBindingBuild ) {
		var element = this._getBuildElement ( "labeltext" );
		if ( element ) {
			this.shadowTree.labelText = element;
			this.shadowTree.text = element.firstChild;
			this.hasLabel = true;
		}
	} else {
		
		var label = this.getProperty ( "label" );
		var image = this.getProperty ( "image" );
		var tooltip = this.getProperty ( "tooltip" );
		
		if ( label ) {
			this.setLabel ( label, false );
		}
		if ( image ) {
			this.setImage ( image, false );
		}
		if ( tooltip ) {
			this.setToolTip ( tooltip );
		}
		this.buildClassName ();
	}
}

/**
 * @param {string} label
 * @param {boolean} isNotBuildingClassName Set to true for faster screen update.
 */
LabelBinding.prototype.setLabel = function ( label, isNotBuildingClassName ) {

	label = label ? label : "";
	
	if ( !this.hasLabel ) {
		this.buildLabel ();
	}
	this.shadowTree.text.data = Resolver.resolve ( label );
	this.setProperty ( "label", label );
	if ( !isNotBuildingClassName ) {
		this.buildClassName ();
	}
}

/**
 * @return {string}
 */
LabelBinding.prototype.getLabel = function () {

	return this.getProperty ( "label" );
}

/**
 * Set image.
 * @param {string} url Eh - this could be a boolean!
 * @param {boolean} isNotBuildingClassName Set to true for faster screen update.
 */
LabelBinding.prototype.setImage = function ( url, isNotBuildingClassName ) {
	
	if ( url != false ) {
		
		/*
		switch ( url ) {
			case "${icon:blank}" :
			case "${icon:accept}" :
				
				if ( this.getLabel () == "Default" && url == "${icon:accept}" ) {
					alert ( this );
					SystemDebug.stack ( arguments );
				}
				
				if ( this.bindingWindow.FieldsButtonDataBinding != null ) {
					alert ( this.getLabel () + ": " + url );
				}
			break;
		}
		*/
		
		url = url ? url : LabelBinding.DEFAULT_IMAGE;
		this.setAlphaTransparentBackdrop ( 
			Resolver.resolve ( url )
		);
		this.setProperty ( "image", url );
		this.hasImage = true;
		if ( !isNotBuildingClassName ) {
			this.buildClassName ();
		}
	} else {
		this.setAlphaTransparentBackdrop ( false );
		this.deleteProperty ( "image" );
		this.hasImage = false;
		this.buildClassName ();
	}
}

/**
 * Set image.
 * @param {string} url
 */
LabelBinding.prototype.setDefaultImage = function ( url ) {
	
	this.setImage ( LabelBinding.DEFAULT_IMAGE );
}

/**
 * Attaches a background-image to the labelbody 
 * element, supporting 24bit alphatransparency.
 * @param {string} url
 */
LabelBinding.prototype.setAlphaTransparentBackdrop = function ( url ) {
	
	if ( this.shadowTree.labelBody ) { // sometimes it glitches in moz...
		if ( url != false ) {
			url = Resolver.resolve ( url );
			if ( Client.isExplorer6 ) {
				this.shadowTree.labelBody.style.filter = LabelBinding.EXPLORER_IMAGE_FILTER.replace ( "${url}", url );
			} else {
				this.shadowTree.labelBody.style.backgroundImage = "url(" + url + ")";
			}
		} else {
			if ( Client.isExplorer6 ) {
				this.shadowTree.labelBody.style.filter = "none";
			} else {
				this.shadowTree.labelBody.style.backgroundImage = "none";
			}
		}
	}
}

/**
 * @return {string}
 */
LabelBinding.prototype.getImage = function () {

	return this.getProperty ( "image" );
}

/**
 * For some reason, setting tooltip on the label may not work reliably 
 * in Explorer. Always check the result if you use this method.
 * @param {string} tooltip
 */
LabelBinding.prototype.setToolTip = function ( tooltip ) {
	
	this.setProperty ( "tooltip", tooltip );
	
	/*
	 * Some guy keeps setting tooltips equal to the labels of things. 
	 * If a tooltip has nothing new to say, it's better not to show it,  
	 * since the tooltip may obscure the view while navigating trees etc. 
	 * TODO: fix that guy instead!
	 */
	if ( tooltip != this.getLabel ()) {
		this.setProperty ( "title", Resolver.resolve ( tooltip ));
	}
}

/**
 * @return {string}
 */
LabelBinding.prototype.getToolTip = function ( tooltip ) {

	return this.getProperty ( "tooltip" );
}

/**
 * Flip image and text position. This is not supported in IE6.
 * @param @optional {boolean} isFlipped.
 */
LabelBinding.prototype.flip = function ( isFlipped ) {
	
	isFlipped = isFlipped == null ? true : isFlipped; 
	var classname = LabelBinding.CLASSNAME_FLIPPED;
	
	if ( !Client.isExplorer6 ) {
		this.isFlipped = isFlipped;
		if ( isFlipped ) {
			this.attachClassName ( classname );
		} else {
			this.detachClassName ( classname );
		}
	}
}

/**
 * Build the various label elements: A "labelbody" element 
 * containing a "labeltext" element containing a textnode. 
 * These extra elements will come in handy for CSS purposes.
 */
LabelBinding.prototype.buildLabel = function () {
	
	if ( !this.hasLabel ) {
		this.shadowTree.labelText = DOMUtil.createElementNS ( 
			Constants.NS_UI, "ui:labeltext", this.bindingDocument 
		);
		this.shadowTree.text = this.bindingDocument.createTextNode ( "" );
		this.shadowTree.labelText.appendChild ( this.shadowTree.text );
		this.shadowTree.labelBody.appendChild ( this.shadowTree.labelText );
		this.hasLabel = true;
	}
}

/**
 * Builds the CSS classname, taking care to preserve externally applied classnames.
 */
LabelBinding.prototype.buildClassName = function () {
	
	if ( Client.isMozilla ) {
		//this._buildOverflowClassName (); TODO: VERY SLOW - ENABLE FOR SELECTORS ONLY!
	}
	
	var class1 = "textonly";
	var class2 = "imageonly";
	var class3 = "both";
	
	if ( this.hasLabel && this.hasImage ) {
		this.detachClassName ( class1 );	
		this.detachClassName ( class2 );	
		this.attachClassName ( class3 );
	} else if ( this.hasLabel ) {
		this.detachClassName ( class3 );	
		this.detachClassName ( class2 );	
		this.attachClassName ( class1 );
	} else if ( this.hasImage ) {
		this.detachClassName ( class3 );	
		this.detachClassName ( class1 );	
		this.attachClassName ( class2 );
	}
}

/**
 * This will help us emulate text-overflow: ellipsis in Mozilladrengen.
 */
LabelBinding.prototype._buildOverflowClassName = function () {
	
	if ( Client.isMozilla && this.isAttached && this.getLabel ()) {
		if ( this.isAttached && this.shadowTree.labelText ) {
			this.detachClassName ( LabelBinding.CLASSNAME_TEXTOVERFLOW );
			if ( this.shadowTree.labelText.offsetWidth > this.shadowTree.labelBody.offsetWidth ) {
				this.attachClassName ( LabelBinding.CLASSNAME_TEXTOVERFLOW );
			}
		}
	}
}

/**
 * LabelBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {ShadowBinding}
 */
LabelBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:labelbox", ownerDocument );
	return UserInterface.registerBinding ( element, LabelBinding );
}

TextBinding.prototype = new Binding;
TextBinding.prototype.constructor = TextBinding;
TextBinding.superclass = Binding.prototype;

/**
 * @class
 * Here's a weird binding that will replace itself with a text node!
 */
function TextBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "TextBinding" );
	
	/**
	 * Block common crawlers.
	 * @type {Map<string><boolean>}
	 * @overwrites {Binding#crawlerFilters}
	 */
	this.crawlerFilters	= new List ([ DocumentCrawler.ID, FlexBoxCrawler.ID, FocusCrawler.ID ]);
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
TextBinding.prototype.toString = function () {
	
	return "[TextBinding]";
}

/**
 * Observe how the binding gets disposed and replaced by a simple text node.
 * TODO: This is silly, just keep the element and add some text!
 * @overloads {Binding#onBindingAttach}
 */
TextBinding.prototype.onBindingAttach = function () {
	
	TextBinding.superclass.onBindingAttach.call ( this );
	
	var label = this.getProperty ( "label" );
	if ( !label ) {
		label = DOMUtil.getTextContent ( this.bindingElement );
	}
	var text = this.bindingDocument.createTextNode ( 
		Resolver.resolve ( label )
	);
	this.bindingElement.parentNode.replaceChild ( text, this.bindingElement );
	this.dispose ();
}

/**
 * You should invoke this method before the binding attaches 
 * (since attachment will effectively destroy the binding).
 */
TextBinding.prototype.setLabel = function ( label ) {
	
	this.setProperty ( "label", label );
}

/**
 * TextBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {TextBinding}
 */
TextBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:text", ownerDocument );
	return UserInterface.registerBinding ( element, TextBinding );
}

BroadcasterSetBinding.prototype = new Binding;
BroadcasterSetBinding.prototype.constructor = BroadcasterSetBinding;
BroadcasterSetBinding.superclass = Binding.prototype;

/**
 * @class
 * Why not have binding for this?
 */
function BroadcasterSetBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "BroadcasterSetBinding" );
}

/**
 * Identifies binding.
 */
BroadcasterSetBinding.prototype.toString = function () {

	return "[BroadcasterSetBinding]";
}

BroadcasterBinding.prototype = new Binding;
BroadcasterBinding.prototype.constructor = BroadcasterBinding;
BroadcasterBinding.superclass = Binding.prototype;

/**
 * @class
 * The broadcaster can mysteriously project its properties onto other bindings. 
 * By updating a single broadcaster, multiple other bindings will update. This 
 * setup is handled using the (other) bindings "observes" property.
 */
function BroadcasterBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "BroadcasterBinding" );
	
	/**
	 * @type {HashMap<string><List<Binding>>}
	 */
	this._observers = null;
}

/**
 * Identifies binding.
 */
BroadcasterBinding.prototype.toString = function () {

	return "[BroadcasterBinding]";
}

/**
 * @overloads {Binding#onBindingRegister}
 */
BroadcasterBinding.prototype.onBindingRegister = function () {

	BroadcasterBinding.superclass.onBindingRegister.call ( this );
	this.propertyMethodMap [ "isdisabled" ] = this.setDisabled;
	this._observers = new List ();
}

/**
 * All broadcaster property updates will be transmitted to observers. 
 * @overloads {Binding#setProperty}
 * @param {string} attname The name of the attribute
 * @param {object} value The attribute value.
 */
BroadcasterBinding.prototype.setProperty = function ( attname, value ) {
	
	BroadcasterBinding.superclass.setProperty.call ( this, attname, value );
	
	function update ( list ) {
		if ( list ) {
			list.each ( function ( binding ) {
				binding.setProperty ( attname, value );
			});
		}
	}
	if ( this._observers [ "*" ] != null ) {
		update ( this._observers [ "*" ]);
	}
	var observers = this._observers [ attname ];
	if ( observers ) {
		update ( observers );
	}
}

/**
 * All broadcaster property deletions will be mimicked by observers. 
 * @overloads {Binding#deleteProperty}
 * @param {string} attname The name of the attribute
 */
BroadcasterBinding.prototype.deleteProperty = function ( attname ) {
	
	BroadcasterBinding.superclass.deleteProperty.call ( this, attname );
	
	function update ( list ) {
		if ( list ) {
			list.each ( function ( binding ) {
				binding.deleteProperty ( attname );
			});
		}
	}
	if ( this._observers [ "*" ] != null ) {
		update ( this._observers [ "*" ]);
	}
	var observers = this._observers [ attname ];
	if ( observers ) {
		update ( observers );
	}
}

/**
 * Add observer binding.
 * @param {Binding} binding
 * @param {string} properties A whitespace-separated list of properties to watch
 */
BroadcasterBinding.prototype.addObserver = function ( binding, properties ) {
	
	properties = properties ? properties : "*";
	properties = new List ( properties.split ( " " ));
	
	while ( properties.hasNext ()) {
		var property = properties.getNext ();
		switch ( property ) {
			case "*" :
				this._setAllProperties ( binding );
				break;
			default :
				var value = this.getProperty ( property );
				binding.setProperty ( property, value );
				break;
		}
		if ( !this._observers [ property ]) {
			this._observers [ property ] = new List ();
		}
		this._observers [ property ].add ( binding );
	}
}

/**
 * Transmit all properties to specified binding.
 * @param {Binding} binding
 */
BroadcasterBinding.prototype._setAllProperties = function ( binding ) {
	
	var atts = new List ( this.bindingElement.attributes );
	while ( atts.hasNext ()) {
		var att = atts.getNext ();
		if ( att.specified ) {
			var property = att.nodeName;
			switch ( property ) {
				case "id" :
				case "key" :
					break;
				default :
					var value = this.getProperty ( property );
					binding.setProperty ( 
						property,
						value
					);
					break;
			}
		}
	}
}

/**
 * Remove observer binding.
 * TODO: Test this method!
 * @param {Binding} binding
 * @param {string} properties A whitespace-separated list of properties to watch
 */
BroadcasterBinding.prototype.removeObserver = function ( binding, properties ) {
	
	properties = properties ? properties : "*";
	properties = new List ( properties.split ( " " ));
	
	while ( properties.hasNext ()) {
		var list = this._observers [ properties.getNext ()];
		if ( list ) {
			while ( list.hasNext ()) {
				var entry = list.getNext ();
				if ( entry == binding ) {
					list.del ( entry );
				}
			}
		}
	}
}

/**
 * This method provides a prettified interface for 
 * updating the always popular disabled property. 
 */
BroadcasterBinding.prototype.disable = function () {
	
	this.setDisabled ( true );
}

/**
 * This method provides a prettified interface for 
 * updating the always popular disabled property. 
 */
BroadcasterBinding.prototype.enable = function () {
	
	this.setDisabled ( false );
}

/**
 * This method provides a prettified interface for 
 * updating the always popular disabled property. 
 * @param {boolean} isDisabled
 */
BroadcasterBinding.prototype.setDisabled = function ( isDisabled ) {
	
	this.setProperty ( "isdisabled", isDisabled );
}

/**
 * This method provides a prettified interface for 
 * checking the always popular disabled property. 
 * @return {boolean}
 */
BroadcasterBinding.prototype.isDisabled = function () {
	
	return this.getProperty ( "isdisabled" ) == true;
}

ButtonBinding.prototype = new MatrixBinding;
ButtonBinding.prototype.constructor = ButtonBinding;
ButtonBinding.superclass = MatrixBinding.prototype;

ButtonBinding.ACTION_COMMAND = "buttoncommand";
ButtonBinding.ACTION_RADIOBUTTON_ATTACHED = "radiobutton attached";

ButtonBinding.TYPE_CHECKBUTTON = "checkbox"; /* TODO: RENAME THIS TO CHECKBUTTON! */
ButtonBinding.TYPE_RADIOBUTTON = "radio";

ButtonBinding.CLASSNAME_FOCUSABLE = "focusable";
ButtonBinding.CLASSNAME_FOCUSED = "focused";
ButtonBinding.CLASSNAME_DEFAULT = "default";

/**
 * @class
 */
function ButtonBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ButtonBinding" );
	
	/**
	 * @type {boolean}
	 */
	this.isCheckButton = false;
	
	/**
	 * @type {boolean}
	 */
	this.isRadioButton = false;
	
	/**
	 * Flip this exotic property to invoke hover state onmouseover even when 
	 * a radiobutton or checkbutton is checked. No effect for normal buttons.
	 * @see {ButtonStateManager#handleEvent}
	 */
	this.isCheckBox = false;
	
	/**
	 * @type {boolean}
	 */
	this.isActive = false;
	
	/**
	 * @type {boolean}
	 */
	this.isChecked = false;
	
	/**
	 * @type {boolean}
	 */
	this.isDisabled = false;
	
	/**
	 * @implements {IFocusable}
	 * @type {boolean}
	 */
	this.isFocusable = false;
	
	/**
	 * When disabled, this will backup the value of isFocusable.
	 * @type {boolean}
	 */
	this._isFocusableButton = false;
	
	/**
	 * @implements {IFocusable}
	 * @type {boolean}
	 */
	this.isFocused = false;
	
	/**
	 * Relevant for focusable dialog buttons...
	 * @type {boolean}
	 */
	this.isDefault = false;
	
	/**
	 * @type {PopupBinding}
	 */
	this.popupBinding = null;
	
	/**
	 * @type {LabelBinding}
	 */
	this.labelBinding = null;
	
	/**
	 * @type {string}
	 */
	this.image = null;
	
	/**
	 * @type {string}
	 */
	this.imageHover = null;
	
	/**
	 * @type {string}
	 */
	this.imageActive = null;
	
	/**
	 * @type {string}
	 */
	this.imageDisabled = null;
	
	/**
	 * @type {ImageProfile}
	 */
	this.imageProfile = null;
	
	/**
	 * @type {ButtonStateManager}
	 */
	this._stateManager = null;
	
	/**
	 * Used in dialogs.
	 * @type {object} 
	 */
	this.response = null;
	
	/**
	 * @type {DOMElement}
	 */
	this.popupBindingTargetElement = null;
	
	/**
	 * Subclasses can owerwrite this to 
	 * dispatch an unique Action type.
	 */
	this.commandAction = ButtonBinding.ACTION_COMMAND;
	
	/**
	 * Image and text position reversed?
	 * @type {boolean}
	 */
	this.isFlipped = false;
	
	/**
	 * @implements {IData}
	 * @type {boolean}
	 */
	this.isDirty = false;
	
	/**
	 * Block common crawlers.
	 * @type {Map<string><boolean>}
	 * @overwrites {Binding#crawlerFilters}
	 */
	this.crawlerFilters	= new List ([ DocumentCrawler.ID, FlexBoxCrawler.ID, FocusCrawler.ID, FitnessCrawler.ID ]);
}

/**
 * Identifies binding.
 */
ButtonBinding.prototype.toString = function () {

	return "[ButtonBinding]";
}

/**
 * @overloads {MatrixBinding#onBindingRegister} 
 */
ButtonBinding.prototype.onBindingRegister = function () {

	ButtonBinding.superclass.onBindingRegister.call ( this );
	this.propertyMethodMap [ "isdisabled" ] = this.setDisabled;
}

/**
 * @overloads {MatrixBinding#onBindingAttach} 
 */
ButtonBinding.prototype.onBindingAttach = function () {

	ButtonBinding.superclass.onBindingAttach.call ( this );
	
	this.parseDOMProperties ();
	this.buildDOMContent ();
	
	if ( this.isRadioButton == true ) {
		this.dispatchAction ( ButtonBinding.ACTION_RADIOBUTTON_ATTACHED );
	}
}

/**
 * Cleanup button.
 * @overloads {Binding#onBindingDispose} 
 */
ButtonBinding.prototype.onBindingDispose = function () {
	
	ButtonBinding.superclass.onBindingDispose.call ( this );
	if ( this._stateManager != null ) {
		this._stateManager.dispose ();
		this._stateManager = null;
	}
}

/**
 * Parse DOM properties.
 */
ButtonBinding.prototype.parseDOMProperties = function () {

	Binding.imageProfile ( this );
	
	/*
	if ( !this.imageProfile ) {

		var image = this.getProperty ( "image" );
		var imageHover = this.getProperty ( "image-hover" );
		var imageActive = this.getProperty ( "image-active" );
		var imageDisabled = this.getProperty ( "image-disabled" );
		
		if ( !this.image && image ) {
			this.image = image;
		}
		if ( !this.imageHover && imageHover ) {
			this.imageHover = image;
		}
		if ( !this.imageActive && imageActive ) {
			this.imageActive = imageActive;
		}
		if ( !this.imageDisabled && imageDisabled ) {
			this.imageDisabled = imageDisabled;
		}
		this.imageProfile = new ImageProfile ( this );
	}
	*/
}

/**
 * Building DOM content.
 */
ButtonBinding.prototype.buildDOMContent = function () {

	var tree		= this.shadowTree;
	var width		= this.getProperty ( "width" );
	var label 		= this.getProperty ( "label" );
	var type		= this.getProperty ( "type" );
	var popup		= this.getProperty ( "popup" );
	var tooltip 	= this.getProperty ( "tooltip" );
	var disabled	= this.getProperty ( "isdisabled" );
	var response	= this.getProperty ( "response" );
	var oncommand	= this.getProperty ( "oncommand" );
	var value 		= this.getProperty ( "value" );
	var checked		= this.getProperty ( "ischecked" );
	var callbackid	= this.getProperty ( "callbackid" );
	var isFocusable	= this.getProperty ( "focusable" );
	var isFocused	= this.getProperty ( "focused" );
	var isDefault   = this.getProperty ( "default" );
	var url			= this.getProperty ( "url" );
	var isFlipped	= this.getProperty ( "flip" );

	/*
	 * Build the label.
	 */
	this.labelBinding = LabelBinding.newInstance ( this.bindingDocument );
	this.add ( this.labelBinding );
	this.labelBinding.attach ();
	this.shadowTree.labelBinding = this.labelBinding;
	if ( isFlipped ) {
		this.flip ( true );
	}
	
	/*
	 * Buld the rest.
	 */
	if ( !this._stateManager ) {
		this._stateManager = new ButtonStateManager ( this );
	}
	if ( this.imageProfile != null && this.imageProfile.getDefaultImage () != null ) {
		this.setImage ( this.imageProfile.getDefaultImage ());
	}
	if ( label != null ) {
		this.setLabel ( label );
	}
	if ( type != null ) {
		this.setType ( type );
	}
	if ( tooltip != null ) {
		this.setToolTip ( tooltip );
	}
	if ( width != null ) {
		this.setWidth ( width );
	}
	if ( popup != null ) {
		this.setPopup ( popup );
	} 
	if ( response != null ) {
		this.response = response;
	}
	if ( checked == true ) {
		if ( this.isCheckButton || this.isRadioButton ) {
			this.check ( true );
		}
	}
	if ( oncommand != null && this.oncommand == null ) {
		this.oncommand = function () {
			Binding.evaluate ( oncommand, this );
		};
	}
	if ( isFocusable || this.isFocusable ) {
		this._makeFocusable ();
		if ( isDefault || this.isDefault ) {
			this.isDefault = true;
		}
		if ( isFocused ) {
			this.focus ();
		}
	}
	if ( disabled == true ) {
		this.disable ();
	}
	if ( url != null ) {
		this.setURL ( url );
	}
	
	/*
	 * Setup ASP.NET callback.
	 */
	if ( callbackid != null ) {
		
		/*
		 * Register as DataBinding.
		 */
		this.bindingWindow.DataManager.registerDataBinding ( callbackid, this );
		
		/*
		 * Unless they have a value, buttons should not inject a hidden field.
		 * NOTE: The value must NOT be an empty string, since this is treated 
		 * as null for inscrutable historic reasons.
		 */
		if ( value != null ) {
			Binding.dotnetify ( this, value );
		}
		
		/*
		 * By default, callbackid will instantiate a postback  
		 * on button click while marking the binding dirty. 
		 * Note: It may be quite important for backend buttons 
		 * not to have an oncommand specified.
		 */
		if ( this.oncommand == null ) {
			this.oncommand = function () {
				this.dirty ();
				if ( this.getProperty ( "validate" ) == true ) {
					this.dispatchAction ( PageBinding.ACTION_DOVALIDATEDPOSTBACK );
				} else {
					this.dispatchAction ( PageBinding.ACTION_DOPOSTBACK );
				}
			};
		}
	}
}

/**
 * Make focusable.
 */
ButtonBinding.prototype._makeFocusable = function () {
 
	this.isFocusable = true;
	this.attachClassName ( ButtonBinding.CLASSNAME_FOCUSABLE );
	this._isFocusableButton = true;
}

/**
 * Set image.
 * @param {string} image
 */
ButtonBinding.prototype.setImage = function ( image ) {

	if ( this.isAttached ) {
		this.labelBinding.setImage ( image );
	}
	this.setProperty ( "image", image );
}

/**
 * Get image.
 * @return {string}
 */
ButtonBinding.prototype.getImage = function () {

	return this.getProperty ( "image" );
}


/**
 * Set label.
 * @param {string} label
 */
ButtonBinding.prototype.setLabel = function ( label ) {
	
	if ( this.isAttached ) {
		this.labelBinding.setLabel ( label );
	}
	this.setProperty ( "label", label );	
}

/** 
 * Get label.
 * @return {string}
 */
ButtonBinding.prototype.getLabel = function () {
	
	return this.getProperty ( "label" );
}


/**
 * This should probably only be set during initialization.
 * @param {string} type
 */
ButtonBinding.prototype.setType = function ( type ) {

	switch ( type ) {
		case ButtonBinding.TYPE_CHECKBUTTON :
			this.isCheckButton = true;
			break;
		case ButtonBinding.TYPE_RADIOBUTTON :
			this.isRadioButton = true;
			break;
	}
	this.setProperty ( "type", type );
}

/**
 * Set tooltip.
 * @param {string} type
 */
ButtonBinding.prototype.setToolTip = function ( tooltip ) {
	
	this.setProperty ( "tooltip", tooltip );
	if ( this.isAttached == true ) {
		this.setProperty ( "title", Resolver.resolve ( tooltip ));
	}
}

/** 
 * Get tooltip.
 * @return {string}
 */
ButtonBinding.prototype.getToolTip = function () {
	
	return this.getProperty ( "tooltip" );
}

/**
 * Set image profile. The button constructs a default imageprofile, 
 * so this should only be used in special cases.
 * @param {Class} imageProfileImplementation
 */
ButtonBinding.prototype.setImageProfile = function ( imageProfileImplementation ) {
	
	this.imageProfile = new imageProfileImplementation ( this );
}

/**
 * Note that this will convert the button to a checkboxbutton.
 * @param {object} arg This can be either a string or a {@link PopupBinding}.
 */
ButtonBinding.prototype.setPopup = function ( arg ) {

	this.popupBinding = this.getBindingForArgument ( arg );

	if ( this.popupBinding ) {
		this.setType ( ButtonBinding.TYPE_CHECKBUTTON );
		if ( !this.popupBindingTargetElement ) {
			this.popupBindingTargetElement = this.bindingElement;
		}
		var self = this;
		this.popupBinding.addActionListener ( PopupBinding.ACTION_HIDE, {
			handleAction : function () {
				if ( self.isChecked == true ) {
					self.uncheck ( true );
				}
			}
		});
	}
}

/**
 * This wil rig up the button to launch an URL in a new browserwindow when clicked.
 * This is *not* done by window.open. Instead, we place a simple link inside the button. 
 * This will trigger Prism to launch the default browser instead of a new Prism window.
 * @param {string} url
 */
ButtonBinding.prototype.setURL = function ( url ) {
	
	if ( this.isAttached == true ) {
		if ( !this.shadowTree.buttonurl ) {
			var a = this.bindingDocument.createElement ( "a" );
			a.className = "buttonurl";
			a.target = "_blank";
			this.shadowTree.buttonurl = a;
			this.bindingElement.appendChild ( a );
		}
		this.shadowTree.buttonurl.href = url;
	}
	this.setProperty ( "url", url );
}

/**
 * Get URL.
 * @return {string}
 */
ButtonBinding.prototype.getURL = function () {
	
	return this.getProperty ( "url" );
}

/**
 * Flip image and text position. This is not supported in IE6.
 * @param @optional {boolean} isFlipped.
 */
ButtonBinding.prototype.flip = function ( isFlipped ) {
	
	isFlipped = isFlipped == null ? true : isFlipped;
	this.isFlipped = isFlipped;
	this.setProperty ( "flip", isFlipped );
	if ( this.isAttached ) {
		this.labelBinding.flip ( isFlipped );
	}
}

/**
 * Fire command.
 */
ButtonBinding.prototype.fireCommand = function () {
	
	if ( !this.isDisabled ) {
		
		if ( this.oncommand != null ) {
			this.oncommand ();
		}
		this.dispatchAction ( this.commandAction );
		
		if ( this.popupBinding ) {
			if ( !this.isCheckButton || this.isChecked ) {
				this.popupBinding.snapTo ( this.popupBindingTargetElement );
				this.popupBinding.show ();
				this.popupBinding.grabKeyboard ();
			} else {
				this.popupBinding.hide ();
				this.popupBinding.releaseKeyboard ();
			}
		}
	}
}

/**
 * User may define this.
 */
ButtonBinding.prototype.oncommand = null;

/**
 * Invoke button action. Unlike the fireCommand method, this 
 * considers whether or not the button is a checkbox-button.
 */
ButtonBinding.prototype.invoke = function () {

	if ( !this.isCheckButton ) {
		this.fireCommand ();
	} else {
		if ( this.isChecked ) {
			this.uncheck ();
		} else {
			this.check ();
		}
	}
}

/**
 * Check button.
 * @param {boolean} isDisableCommand
 */
ButtonBinding.prototype.check = function ( isDisableCommand ) {
	
	if (( this.isCheckButton || this.isRadioButton ) && !this.isChecked ) {
		if ( this.isAttached == true ) {
			this._check ();
			if ( !isDisableCommand == true ) {
				this.fireCommand ();
			}
		}
		this.setProperty ( "ischecked", true );
	}
}

/**
 * Isolated so that ButtonStateManager may control these properties.
 * @param {boolean} isStateManager
 */
ButtonBinding.prototype._check = function ( isStateManager ) {

	this.isActive = true;
	this.isChecked = true;
	if ( !isStateManager ) {
		this._stateManager.invokeActiveState ();
	}
}

/**
 * Uncheck button.
 * @param {boolean} isDisableCommand
 */
ButtonBinding.prototype.uncheck = function ( isDisableCommand ) {

	if (( this.isCheckButton || this.isRadioButton ) && this.isChecked ) {
		if ( this.isAttached == true ) {
			this._uncheck ();
			if ( !isDisableCommand == true ) {
				this.fireCommand ();
			}
		}
		this.setProperty ( "ischecked", false );
	}
}

/**
 * Isolated so that ButtonStateManager may control these properties.
 * @param {boolean} isStateManager
 */
ButtonBinding.prototype._uncheck = function ( isStateManager ) {

	this.isActive = false;
	this.isChecked = false;
	if ( !isStateManager ) {
		this._stateManager.invokeNormalState ();
	}
}

/**
 * Check / uncheck button.
 * @param {boolean} isChecked
 * @param {boolean} isDisableCommand
 */
ButtonBinding.prototype.setChecked = function ( isChecked, isDisableCommand ) {
	
	if ( isChecked == null ) {
		isChecked == false;
	}
	
	if ( this.isCheckButton || this.isRadioButton ) {
		switch ( isChecked ) {
			case true :
				this.check ( isDisableCommand );
				break;
			case false :
				this.uncheck ( isDisableCommand );
				break;
		}
	}
}

/**
 * Set button disabled status.
 * @param {boolean} bool
 */
ButtonBinding.prototype.setDisabled = function ( bool ) {
	
	if ( bool == null ) { // for automated propertyMethodMap to function, see DocumentManager#_backupattributes
		bool = false;
	}
	
	this.isDisabled = bool;
	
	switch ( bool ) {
		case true :
			this.bindingElement.setAttribute ( "title", "" );
			this.setProperty ( "isdisabled", true );
			if ( this._stateManager != null ) {
				this._stateManager.invokeDisabledState ();
			}
			break;
		case false :
			this.deleteProperty ( "isdisabled" );
			var tooltip = this.getProperty ( "tooltip" );
			if ( tooltip ) {
				this.setToolTip ( tooltip );
			}
			if ( this._stateManager != null ) {
				this._stateManager.invokeNormalState ();
			}
			break;
	}
	
	if ( this._isFocusableButton == true ) {
		this.isFocusable = !this.isDisabled;
		this.dispatchAction ( FocusBinding.ACTION_UPDATE );
	}
}

/**
 * Disable button.
 */
ButtonBinding.prototype.disable = function () {

	this.setDisabled ( true );
}

/**
 * Enable button.
 */
ButtonBinding.prototype.enable = function () {

	this.setDisabled ( false );
}

/**
 * Focus.
 * @implements {IFocusable}
 */
ButtonBinding.prototype.focus = function () {
	
	if ( this.isFocusable && !this.isFocused ) {
		this.isFocused = true;
		FocusBinding.focusElement ( this.bindingElement );
		this.dispatchAction ( Binding.ACTION_FOCUSED );
	}
}

/**
 * Blur.
 * @implements {IFocusable}
 */
ButtonBinding.prototype.blur = function () {
	
	if ( this.isFocusable && this.isFocused ) {
		this.isFocused = false;
		this.dispatchAction ( Binding.ACTION_BLURRED );
	}
}

/**
 * Action on mouse down. Invoked by the ButtonStageManager.
 * @see {ButtonStateManager#handleEvent}
 */
ButtonBinding.prototype.onMouseDown = function () {

	EventBroadcaster.broadcast ( BroadcastMessages.MOUSEEVENT_MOUSEDOWN, this );
	this.dispatchAction ( Binding.ACTION_ACTIVATED );
}

/**
 * Action on mouse up.
 * @see {ButtonStateManager#handleEvent}
 */
ButtonBinding.prototype.onMouseUp = function () {

	EventBroadcaster.broadcast ( BroadcastMessages.MOUSEEVENT_MOUSEUP, this );
}

/**
 * Get width. Actually, get width of the labelbinding. Used for equalsizing buttons. 
 * Notice that this getter changes the layout, so we should ONLY use it for equalsizing!
 * @see {ToolBarBodyBinding#_enforceEqualSize}
 * @return {int}
 */
ButtonBinding.prototype.getEqualSizeWidth = function () {

	var result = null;
	if ( this.isAttached == true ) {
		this.labelBinding.bindingElement.style.marginLeft = "0";
		this.labelBinding.bindingElement.style.marginRight = "0";
		result = this.labelBinding.bindingElement.offsetWidth;
	} else {
		throw "ButtonBinding: getEqualSizeWidth failed for non-attached button.";
	}
	return result;
}

/**
 * Set width. Actually; in order to center labelbinding, this will 
 * be computed around and applied as margins on the label. This method 
 * should only be invoked while equalsizing buttons.
 * @see {ToolBarBodyBinding#_enforceEqualSize} 
 * @param {int} goal
 */
ButtonBinding.prototype.setEqualSizeWidth = function ( goal ) {
	
	if ( this.isAttached == true ) {
		var width = this.getEqualSizeWidth ();
		if ( goal > width ) {
			var diff = goal - width;
			var marg = Math.floor ( diff * 0.5 );
			this.labelBinding.bindingElement.style.marginLeft = marg + "px";
			this.labelBinding.bindingElement.style.marginRight = marg + "px";
		}
	}
}

/**
 * Get width.
 * @return {int} width
 */
ButtonBinding.prototype.getWidth = function () {
	
	var result = null;
	if ( this.isAttached == true ) {
	
		var padding = CSSComputer.getPadding ( this.bindingElement );
		var border = CSSComputer.getPadding ( this.bindingElement );
	
		result = this.shadowTree.c.offsetWidth + this.shadowTree.e.offsetWidth + this.shadowTree.w.offsetWidth;
		result = result + padding.left + padding.right;
		result = result + border.left + border.right;
		
	} else {
		throw "ButtonBinding: getWidth failed for non-attached button."
	}
	return result;
	
}

/**
 * Set width (technically by adjusting the width of the center tablecell).
 * @param {int} width
 */
ButtonBinding.prototype.setWidth = function ( width ) {
	
	if ( this.isAttached == true ) {
		
		var minus = this.shadowTree.e.offsetWidth + this.shadowTree.w.offsetWidth;
		var padding = CSSComputer.getPadding ( this.shadowTree.c );
		
		var center = width - minus;
		center = center - padding.left - padding.right;
		this.shadowTree.c.style.width = String ( center ) + "px";
		
		if ( this.getProperty ( "centered" )) { // only relevant on splash for now...
			this.labelBinding.bindingElement.style.marginLeft = String ( 0.5 * ( center - this.labelBinding.bindingElement.offsetWidth )) + "px";
		}
	}
	
	this.setProperty ( "width", width );
}

//IMPLEMENT IDATA..........................................

/**
 * Validate.
 * @return {boolean}
 */
ButtonBinding.prototype.validate = function () {
	
	return true; // hardcoded!
}

/**
 * Manifest. This will write form elements into page DOM 
 * so that the server recieves something on form submit.
 */
ButtonBinding.prototype.manifest = function () {}

/**
 * Pollute dirty flag.
 */
ButtonBinding.prototype.dirty = DataBinding.prototype.dirty;

/**
 * Clean dirty flag.
 */
ButtonBinding.prototype.clean = DataBinding.prototype.clean;

/**
 * Get name.
 * @return {string}
 */
ButtonBinding.prototype.getName = function () {}

/**
 * Get value. This is intended for serverside processing.
 * @return {string}
 */
ButtonBinding.prototype.getValue = function () {
	
	return this.shadowTree.dotnetinput.value;
}

/**
 * Set value.
 * @param {string} value
 */
ButtonBinding.prototype.setValue = function ( value ) {
	
	this.shadowTree.dotnetinput.value = value;
}

/**
 * Get result. This is intended for clientside processing.
 * @return {object}
 */
ButtonBinding.prototype.getResult = function () {
	
	return this.getValue ();
}

/**
 * Set result.
 * @see {DataManager#populateDataBindings}
 * @param {object} result
 */
ButtonBinding.prototype.setResult = function ( result ) {
	
	this.setValue ( result );
}

ButtonStateManager.STATE_NORMAL	= 0;
ButtonStateManager.STATE_HOVER	= 1;
ButtonStateManager.STATE_ACTIVE	= 2;
ButtonStateManager.RIGHT_BUTTON = 2;

/**
 * @class
 * Better externalize this complex stuff from the ButtonBinding.
 * @param {ButtonBinding} binding
 */
function ButtonStateManager ( binding ) {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ButtonStateManager" );
	
	/**
	 * @type {ButtonBinding}
	 */
	this.binding = binding;
	
	/**
	 * @type {ImageProfile}
	 */
	this.imageProfile = binding.imageProfile;

	/* 
	 * Assigning event listener.
	 */
	this.assignDOMEvents ( true );
}

/**
 * Assigning DOM event listeners.
 */
ButtonStateManager.prototype.assignDOMEvents = function ( isAssign ) {
	
	var action = isAssign ? "addEventListener" : "removeEventListener";
	
	this.binding [ action ] ( DOMEvents.MOUSEENTER, this );
	this.binding [ action ] ( DOMEvents.MOUSELEAVE, this );
	this.binding [ action ] ( DOMEvents.MOUSEDOWN, this );
	this.binding [ action ] ( DOMEvents.MOUSEUP, this );
}

/**
 * Cleanup.
 * @see {ButtonBinding#onBindingDispose}
 */
ButtonStateManager.prototype.dispose = function () {
	
	this.assignDOMEvents ( false );
	this.binding = null;
	this.imageProfile = null;
}

/** 
 * TODO: Split into multiple methods.
 * @mplements {IEventListener}.
 * @param {MouseEvent} e
 */
ButtonStateManager.prototype.handleEvent = function ( e ) {
	
	if ( Binding.exists ( this.binding ) && !this.binding.isDisabled && !BindingDragger.isDragging ) {
	
		var isCommand = false, state = null;
		
		if ( e.button == ButtonStateManager.RIGHT_BUTTON ) {
			 // do nothing - right clicks are handled by the contextmenu property
		}
		else if ( this.binding.isCheckBox ) {
			
			switch ( e.type ) {
				case DOMEvents.MOUSEENTER :
				case DOMEvents.MOUSEOVER :
					state = ButtonStateManager.STATE_HOVER; // image decision left to imageprofile!
					break;
				case DOMEvents.MOUSELEAVE :
				case DOMEvents.MOUSEOUT :
					state = this.binding.isChecked ? ButtonStateManager.STATE_ACTIVE : ButtonStateManager.STATE_NORMAL;
					break;
				case DOMEvents.MOUSEDOWN :
					state = ButtonStateManager.STATE_HOVER;
					break;
				case DOMEvents.MOUSEUP :
					this.binding.isChecked = !this.binding.isChecked;
					state = this.binding.isChecked ? ButtonStateManager.STATE_ACTIVE : ButtonStateManager.STATE_NORMAL;
					if ( state == ButtonStateManager.STATE_ACTIVE ) {
						this.binding._check ( true );
					} else {
						this.binding._uncheck ( true );
					}
					isCommand = true;
					break;
			}
		}
		else if ( this.binding.isCheckButton || this.binding.isRadioButton ) {
		
			switch ( e.type ) {
				case DOMEvents.MOUSEENTER :
				case DOMEvents.MOUSEOVER :
					if ( !this.binding.isChecked ) {
						state = ButtonStateManager.STATE_HOVER;
					}
					break;
				case DOMEvents.MOUSELEAVE :
				case DOMEvents.MOUSEOUT :
					if ( !this.binding.isChecked ) { // TODO: CHECK DESCENDANT TARGET!
						state = ButtonStateManager.STATE_NORMAL;
					}
					break;
				case DOMEvents.MOUSEDOWN :
					state = ButtonStateManager.STATE_ACTIVE;
					break;
				case DOMEvents.MOUSEUP :
					if ( this.binding.isCheckButton || !this.binding.isChecked ) {
						this.binding.isChecked = !this.binding.isChecked;
						state = this.binding.isChecked ? ButtonStateManager.STATE_ACTIVE : ButtonStateManager.STATE_NORMAL;
						if ( state == ButtonStateManager.STATE_ACTIVE ) {
							this.binding._check ( true );
						} else {
							this.binding._uncheck ( true );
						}
						isCommand = true;
					}
					break;
			}
		} else {
			switch ( e.type ) {
				case DOMEvents.MOUSEENTER :
				case DOMEvents.MOUSEOVER :
					state = ButtonStateManager.STATE_HOVER;
					break;
				case DOMEvents.MOUSELEAVE :
				case DOMEvents.MOUSEOUT :
					state = ButtonStateManager.STATE_NORMAL;
					break;
				case DOMEvents.MOUSEDOWN :
					state = ButtonStateManager.STATE_ACTIVE;
					break;
				case DOMEvents.MOUSEUP :
					state = ButtonStateManager.STATE_NORMAL;
					isCommand = true;
					break;
			}
		}
		switch ( state ) {
			case ButtonStateManager.STATE_NORMAL :
				this.invokeNormalState ();			
				break;
			case ButtonStateManager.STATE_HOVER :
				this.invokeHoverState ();
				break;
			case ButtonStateManager.STATE_ACTIVE :
				this.invokeActiveState ();
				break;
		}
		
		/*
		 * Please note that the button command is invoked here!
		 */
		if ( isCommand ) {
			this.binding.fireCommand ();
		}
		
		/*
		 * Check patches explorer in case fireCommand 
		 * closed the containing window.
		 */
		if ( Binding.exists ( this.binding ) == true ) {
		
			/*
			 * Consuming the event!
			 */
			DOMEvents.stopPropagation ( e );
			
			/*
			 * Broadcast mousedown and mouseup to close open popups and menupopups. 
			 * Notice that our binding is broadcasted as argument. This will prevent 
			 * popups associated to *our* binding from closing as soon as it opens. 
			 * The broadcast argument should really be a MouseEvent, so this is 
			 * really a terrible way to handle the popup display status problem. 
			 * UPDATE: we now use Bindings as arguments in other scenarios.
			 * @see {PopupBinding#handleBroadcast}
			 */
			switch ( e.type ) {
				case DOMEvents.MOUSEDOWN :
					this.binding.onMouseDown ();
					break;
				case DOMEvents.MOUSEUP :
					this.binding.onMouseUp ();
					break;
			}
		}
	}
}

/**
 * Invoke normal state.
 */
ButtonStateManager.prototype.invokeNormalState = function () {

	this.binding.detachClassName ( "hover" );
	this.binding.detachClassName ( "active" );
	this.binding.detachClassName ( "isdisabled" );
	
	if ( this.imageProfile ) {
		var url = this.imageProfile.getDefaultImage ();
		if ( url ) {
			this.binding.setImage ( url );
		}
	}
}

/**
 * Invoke hover state.
 */
ButtonStateManager.prototype.invokeHoverState = function () {

	this.binding.attachClassName ( "hover" );
	this.binding.detachClassName ( "active" );
	
	if ( this.imageProfile ) {
		var url = this.imageProfile.getHoverImage ();
		if ( url ) {
			this.binding.setImage ( url );
		}
	}
}

/**
 * Invoke active state.
 */
ButtonStateManager.prototype.invokeActiveState = function () {

	this.binding.attachClassName ( "active" );
	this.binding.detachClassName ( "hover" );
	
	if ( this.imageProfile ) {
		var url = this.imageProfile.getActiveImage ();
		if ( url ) {
			this.binding.setImage ( url );
		}
	}
}

/**
 * Invoke disabled state. This method gets invoked by the button.
 * @see {ButtonBinding#setDisabled}
 */
ButtonStateManager.prototype.invokeDisabledState = function () {

	this.binding.detachClassName ( "hover" );
	this.binding.detachClassName ( "active" );
	this.binding.attachClassName ( "isdisabled" );
	
	if ( this.imageProfile ) {
		var image = this.imageProfile.getDisabledImage ();
		if ( image ) {
			this.binding.setImage ( image );
		}
	}
}

ClickButtonBinding.prototype = new ButtonBinding;
ClickButtonBinding.prototype.constructor = ClickButtonBinding;
ClickButtonBinding.superclass = ButtonBinding.prototype;

/**
 * @class
 */
function ClickButtonBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ClickButtonBinding" );
}

/**
 * Identifies binding.
 */
ClickButtonBinding.prototype.toString = function () {

	return "[ClickButtonBinding]";
}

/**
 * ClickButtonBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {ClickButtonBinding}
 */
ClickButtonBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:clickbutton", ownerDocument );
	return UserInterface.registerBinding ( element, ClickButtonBinding );
}

RadioButtonBinding.prototype = new ButtonBinding;
RadioButtonBinding.prototype.constructor = RadioButtonBinding;
RadioButtonBinding.superclass = ButtonBinding.prototype;

RadioButtonBinding.IMG_DEFAULT 		= "${skin}/buttons/radiobutton-default.png";
RadioButtonBinding.IMG_HOVER 		= "${skin}/buttons/radiobutton-hover.png";
RadioButtonBinding.IMG_ACTIVE 		= "${skin}/buttons/radiobutton-active.png";
RadioButtonBinding.IMG_DISABLED 	= "${skin}/buttons/radiobutton-disabled.png";

/**
 * @class
 */
function RadioButtonBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "RadioButtonBinding" );
	
	/**
	 * @overwrites {ButtonBinding#isRadioButton}
	 * @type {boolean}
	 */
	this.isRadioButton = true;
	
	/**
	 * @overwrites {MatrixBinding#hasMatrix}
	 * @type {boolean}
	 */
	this.hasMatrix = false;
	
	/**
	 * @type {ImageProfile}
	 */
	this.imageProfile = new ImageProfile ({
		image			: RadioButtonBinding.IMG_DEFAULT,
		imageHover 		: RadioButtonBinding.IMG_HOVER,
		imageActive		: RadioButtonBinding.IMG_ACTIVE,
		imageDisabled	: RadioButtonBinding.IMG_DISABLED 
	});
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
RadioButtonBinding.prototype.toString = function () {

	return "[RadioButtonBinding]";
}

/**
 * RadioButtonBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {RadioButtonBinding}
 */
RadioButtonBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:radiobutton", ownerDocument );
	return UserInterface.registerBinding ( element, RadioButtonBinding );
}

CheckButtonBinding.prototype = new ButtonBinding;
CheckButtonBinding.prototype.constructor = CheckButtonBinding;
CheckButtonBinding.superclass = ButtonBinding.prototype;

/**
 * @class
 */
function CheckButtonBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "CheckButtonBinding" );
	
	/**
	 * @overwrites {ButtonBinding#isCheckButton}
	 * @type {boolean}
	 */
	this.isCheckButton = true;
	
	/**
	 * Invoke hover state onmouseover even when checked.
	 * @overwrites {ButtonBinding#isCheckBox}
	 * @type {boolean}
	 */
	this.isCheckBox = true;
	
	/**
	 * @overwrites {MatrixBinding#hasMatrix}
	 * @type {boolean}
	 */
	this.hasMatrix = false;
	
	/**
	 * @type {CheckButtonImageProfile}
	 */
	this.imageProfile = new CheckButtonImageProfile ( this );
}

/**
 * Identifies binding.
 */
CheckButtonBinding.prototype.toString = function () {

	return "[CheckButtonBinding]";
}

/**
 * CheckButtonBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {CheckButtonBinding}
 */
CheckButtonBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:checkbutton", ownerDocument );
	return UserInterface.registerBinding ( element, CheckButtonBinding );
}

CheckButtonImageProfile.IMG_DEFAULT 		= "${skin}/buttons/checkbutton-default.png";
CheckButtonImageProfile.IMG_HOVER 			= "${skin}/buttons/checkbutton-hover.png";
CheckButtonImageProfile.IMG_ACTIVE 			= "${skin}/buttons/checkbutton-active.png";
CheckButtonImageProfile.IMG_ACTIVE_HOVER 	= "${skin}/buttons/checkbutton-active-hover.png";
CheckButtonImageProfile.IMG_DISABLED 		= null;
CheckButtonImageProfile.IMG_DISABLED_ON 	= null;

/**
 * Checkbutton image profile.
 * @param {CheckButtonBinding} binding
 * @implements {IImageProfile}
 */
function CheckButtonImageProfile ( binding ) {
	
	this._binding = binding;
}

/**
 * Get default image.
 * @return {string}
 */
CheckButtonImageProfile.prototype.getDefaultImage = function () {

	return CheckButtonImageProfile.IMG_DEFAULT;
}

/**
 * Get hover image.
 * @return {string}
 */
CheckButtonImageProfile.prototype.getHoverImage = function () {

	return this._binding.isChecked ? 
		CheckButtonImageProfile.IMG_ACTIVE_HOVER :
		CheckButtonImageProfile.IMG_HOVER;
}

/**
 * Get active image.
 * @return {string}
 */
CheckButtonImageProfile.prototype.getActiveImage = function () {

	return CheckButtonImageProfile.IMG_ACTIVE;
}

/**
 * Get disabled image.
 * @return {string}
 */
CheckButtonImageProfile.prototype.getDisabledImage = function () {

	return this._binding.isChecked ? 
		CheckButtonImageProfile.IMG_DISABLED :
		CheckButtonImageProfile.IMG_DISABLED_ON;
}

ViewButtonBinding.prototype = new ButtonBinding;
ViewButtonBinding.prototype.constructor = ViewButtonBinding;
ViewButtonBinding.superclass = ButtonBinding.prototype;

/**
 * @class
 * This buttons has been hardwired to openening a view. There is no 
 * unique tagname involved, you simply specify the "binding" attribute.
 */
function ViewButtonBinding () {
	
	/*
	 * Returnable 
	 */
	return this;
}

/**
 * Identifies binding
 * @return {string}
 */
ViewButtonBinding.prototype.toString = function () {
	
	return "[ViewButtonBinding]";
}

/**
 * Open view when clicked.
 * @overwrites {ButtonBinding#oncommand}
 */
ViewButtonBinding.prototype.oncommand = function () {
	
	alert ( this );
}

ControlGroupBinding.prototype = new Binding;
ControlGroupBinding.prototype.constructor = ControlGroupBinding;
ControlGroupBinding.superclass = Binding.prototype;

/**
 * @class
 */
function ControlGroupBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ControlGroupBinding" );
	
	/**
	 * Block common crawlers.
	 * @type {Map<string><boolean>}
	 * @overwrites {Binding#crawlerFilters}
	 */
	this.crawlerFilters	= new List ([ FlexBoxCrawler.ID, FocusCrawler.ID ]);
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
ControlGroupBinding.prototype.toString = function () {

	return "[ControlGroupBinding]";
}

/**
 * Setup event listeners.
 */
ControlGroupBinding.prototype.onBindingAttach = function () {

	ControlGroupBinding.superclass.onBindingAttach.call ( this );
	this.assignDOMEvents ();
}

/**
 * Mouseevents should not be propagated to the titlebar when handling controls.
 * These listeners will take care of it.
 */
ControlGroupBinding.prototype.assignDOMEvents = function () {

	this.addEventListener ( DOMEvents.MOUSEDOWN );
	this.addEventListener ( DOMEvents.MOUSEUP );
}

/**
 * Activate. Forces a refresh on contained controls. This may 
 * update control image if containing ControlBoxBinding changed 
 * active state AND control isGhostable.
 */
ControlGroupBinding.prototype.onActivate = function () {
	
	var controls = this.getDescendantBindingsByLocalName ( "control" );
	controls.each ( function ( control ) {
		//if ( control.isGhostable ) {
			control.setControlType ( control.controlType );
		//}
	});
}

/**
 * Deactivate.
 */
ControlGroupBinding.prototype.onDeactivate = ControlGroupBinding.prototype.onActivate;

/**
 * Blocks event propagation.
 * @implements {IEventListener}
 * @overloads {Binding#handleEvent}
 * @param {MouseEvent} e
 */
ControlGroupBinding.prototype.handleEvent = function ( e ) {

	ControlGroupBinding.superclass.handleEvent.call ( this, e );
	
	DOMEvents.stopPropagation ( e );

	switch ( e.type ) {
		case DOMEvents.MOUSEDOWN :
			EventBroadcaster.broadcast ( BroadcastMessages.MOUSEEVENT_MOUSEDOWN, e );
			this.dispatchAction ( Binding.ACTION_ACTIVATED );
			break;
		case DOMEvents.MOUSEUP :
			EventBroadcaster.broadcast ( BroadcastMessages.MOUSEEVENT_MOUSEUP, e );
			break;
	}
}

/**
 * ControlGroupBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {ControlGroupBinding}
 */
ControlGroupBinding.newInstance = function ( ownerDocument ) {
	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:controlgroup", ownerDocument );
	return UserInterface.registerBinding ( element, ControlGroupBinding );
}

ControlBinding.prototype = new ButtonBinding;
ControlBinding.prototype.constructor = ControlBinding;
ControlBinding.superclass = ButtonBinding.prototype;

ControlBinding.ACTION_COMMAND		= "controlcommand";
ControlBinding.TYPE_MINIMIZE 		= "minimize";
ControlBinding.TYPE_MAXIMIZE 		= "maximize";
ControlBinding.TYPE_UNMAXIMIZE 		= "unmaximize";
ControlBinding.TYPE_UNMINIMIZE 		= "unminimize";
ControlBinding.TYPE_CLOSE 			= "close";

ControlBinding.TOOLTIP = {
	"minimize"		: "${string:Website.App.ToolTipMinimize}",
	"maximize" 		: "${string:Website.App.ToolTipMaximize}",
	"unmaximize" 	: "${string:Website.App.ToolTipUnMaximize}",
	"unminimize" 	: "${string:Website.App.ToolTipUnMinimize}",
	"close" 		: "${string:Website.App.ToolTipClose}"
};

/**
 * @class
 * The ControlBinding is a simple button-type binding  
 * specific for controlling panel behavior.
 */
function ControlBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ControlBinding" );
	
	/**
	 * Carefully named not to conflict with regular ButtonBinding type property.
	 * @type {string}
	 */
	this.controlType = null;
	
	/**
	 * Overwrites super property to dispatch an unique command type.
	 * @type {string}
	 */
	this.commandAction = ControlBinding.ACTION_COMMAND;
	
	/**
	 * @overwrites {ButtonBinding#imageProfile}
	 */
	this.imageProfile = true;
	
	/**
	 * @type {ControlBoxBinding}
	 */
	this.containingControlBoxBinding = null;
	
	/** 
	 * @type {boolean}
	 */
	this.isVisible = true;
	
	/**
	 * @type {boolean}
	 */
	this.isGhostable = false;
	
	/**
	 * Block common crawlers.
	 * @type {Map<string><boolean>}
	 * @overwrites {Binding#crawlerFilters}
	 */
	this.crawlerFilters	= new List ([ DocumentCrawler.ID, FlexBoxCrawler.ID, FocusCrawler.ID ]);
}

/**
 * Identifies binding.
 */
ControlBinding.prototype.toString = function () { 

	return "[ControlBinding]";
}

/**
 * Note that we assign a hardcoded image profile to the control instance. That's 
 * because IE6.0 cannot handle both alphatransparency and background positioning.
 */
ControlBinding.prototype.onBindingAttach = function () {
	
	this.controlType = this.getProperty ( "controltype" );
	this.setProperty ( "tooltip", ControlBinding.TOOLTIP [ this.controlType ]);
	
	if ( !this.isAttached ) {
		if ( this.controlType ) {
			this.containingControlBoxBinding = this.getAncestorBindingByType ( 
				ControlBoxBinding 
			);
			if ( this.containingControlBoxBinding ) {
				this.containingControlBoxBinding.addActionListener ( 
					ControlBoxBinding.ACTION_STATECHANGE, this 
				);
			}
			ControlBinding.superclass.onBindingAttach.call ( this );
			this.addEventListener ( DOMEvents.MOUSEDOWN );	
			this.setImage ( this.imageProfile.getDefaultImage ());
		} else {
			throw "ControlBinding: type not specified.";
		}
	}
}

/**
 * Makes it possible to close the controlbox without activating it.
 * @implements {IEventListener}
 * @overloads {Binding#handleEvent}
 * @param {MouseEvent} e
 */
ControlBinding.prototype.handleEvent = function ( e ) {

	ControlBinding.superclass.handleEvent.call ( this, e );
	
	switch ( e.type ) {
		case DOMEvents.MOUSEDOWN :
			DOMEvents.stopPropagation ( e );
			break;
	}
}

/**
 * Set control type. This changes whenever 
 * the control is handled.
 * @param {string} type
 */
ControlBinding.prototype.setControlType = function ( type ) {

	this.controlType = type;
	this.setProperty ( "controltype", type );
	this.setToolTip ( ControlBinding.TOOLTIP [ type ]);
	if ( this.isAttached ) {
		this.setImage ( 
			this.imageProfile.getDefaultImage ()
		);
	}
}

/**
 * Intercepts panel state change and updates control type accordingly.
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
ControlBinding.prototype.handleAction = function ( action ) {

	ControlBinding.superclass.handleAction.call ( this, action );
	
	switch ( action.type ) {
		case ControlBoxBinding.ACTION_STATECHANGE :
			this._handleStateChange ();
			break;
	}
}

/** 
 * Handle state change.
 */
ControlBinding.prototype._handleStateChange = function () {
	
	switch ( this.containingControlBoxBinding.getState ()) {
		case ControlBoxBinding.STATE_MAXIMIZED :
			if ( this.controlType == ControlBinding.TYPE_MAXIMIZE ) {
				this.setControlType ( ControlBinding.TYPE_UNMAXIMIZE );
			}
			if ( this.controlType == ControlBinding.TYPE_UNMINIMIZE ) {
				this.setControlType ( ControlBinding.TYPE_MINIMIZE );
			}
			break;
		case ControlBoxBinding.STATE_MINIMIZED :
			if ( this.controlType == ControlBinding.TYPE_MINIMIZE ) {
				this.setControlType ( ControlBinding.TYPE_UNMINIMIZE );
			}
			if ( this.controlType == ControlBinding.TYPE_UNMAXIMIZE ) {
				this.setControlType ( ControlBinding.TYPE_MAXIMIZE );
			}
			break;
		case ControlBoxBinding.STATE_NORMAL :
			if ( this.controlType == ControlBinding.TYPE_UNMAXIMIZE ) {
				this.setControlType ( ControlBinding.TYPE_MAXIMIZE );
			}
			if ( this.controlType == ControlBinding.TYPE_UNMINIMIZE ) {
				this.setControlType ( ControlBinding.TYPE_MINIMIZE );
			}
			break;
	}
}

/**
 * Unlike other bindings, handling the control should not 
 * activate docks or close open selectboxes and stuff. This 
 * method is invoked by the ButtonStageManager.
 * @see {ButtonStateManager#handleEvent}
 * @overwrites {Button#onMouseDown}
 */
ControlBinding.prototype.onMouseDown = function () {

	// do nothing
}

/**
 * No action on mouse up.
 * @see {ButtonStateManager#handleEvent}
 * @overwrites {Button#onMouseDown}
 */
ControlBinding.prototype.onMouseUp = function () {

	// do nothing
}

ControlImageProfile.IMAGE_MINIMIZE = null;
ControlImageProfile.IMAGE_MAXIMIZE = null;
ControlImageProfile.IMAGE_RESTORE = null; 
ControlImageProfile.IMAGE_CLOSE = null;

/**
 * Please subclass this in order to use!
 * @param {ControlBinding} binding
 */
function ControlImageProfile ( binding ) {
	
	this.binding = binding;
}

/**
 * @param {string} string
 * @return {string}
 * @private
 */
ControlImageProfile.prototype._getImage = function ( string ) {
	
	var result = null;

	switch ( this.binding.controlType ) {
		case ControlBinding.TYPE_MINIMIZE :
			result = this.constructor.IMAGE_MINIMIZE;
			break;
		case ControlBinding.TYPE_MAXIMIZE :
			result = this.constructor.IMAGE_MAXIMIZE;
			break;
		case ControlBinding.TYPE_UNMAXIMIZE :
		case ControlBinding.TYPE_UNMINIMIZE :
			result = this.constructor.IMAGE_RESTORE;
			break;
		case ControlBinding.TYPE_CLOSE :
			result = this.constructor.IMAGE_CLOSE;
			break;
	}
	
	return result.replace ( "${string}", string );
}

/**
 * Get default image. Unlike hover and active, this may depend on container state.
 * @return {string}
 */
ControlImageProfile.prototype.getDefaultImage = function () {

	var isActive = true;
	if ( this.binding.isGhostable && this.binding.containingControlBoxBinding ) {
		isActive = this.binding.containingControlBoxBinding.isActive ? true : false;
	}
	return isActive ? this._getImage ( "default" ) : this._getImage ( "ghosted" );
}

/**
 * Get hover image.
 * @return {string}
 */
ControlImageProfile.prototype.getHoverImage = function () {

	return this._getImage ( "hover" );
}

/**
 * Get active image.
 * @return {string}
 */
ControlImageProfile.prototype.getActiveImage = function () {

	return this._getImage ( "active" );
}

ControlBoxBinding.prototype = new FlexBoxBinding;
ControlBoxBinding.prototype.constructor = ControlBoxBinding;
ControlBoxBinding.superclass = FlexBoxBinding.prototype;

ControlBoxBinding.STATE_NORMAL			= "normal";
ControlBoxBinding.STATE_MAXIMIZED 		= "maximized";
ControlBoxBinding.STATE_MINIMIZED 		= "minimized";
ControlBoxBinding.ACTION_NORMALIZE 		= "controlbox normalizeaction";
ControlBoxBinding.ACTION_MAXIMIZE 		= "controlbox maximizeaction";
ControlBoxBinding.ACTION_MINIMIZE 		= "controlbox minimizeaction";
ControlBoxBinding.ACTION_STATECHANGE	= "controlbox statechangeacton";

/**
 * @class
 */
function ControlBoxBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ControlBoxBinding" );
	
	/**
	 * @type {boolean}
	 */
	this.isNormalized = true;
	
	/**
	 * @type {boolean}
	 */
	this.isMaximized = false;
	
	/**
	 * @type {boolean}
	 */
	this.isMinimized = false;
}

/**
 * Identifies binding.
 */
ControlBoxBinding.prototype.toString = function () {

	return "[ControlBoxBinding]";
}

/**
 * @overloads {FlexBoxBinding#onBindingRegister}
 */
ControlBoxBinding.prototype.onBindingAttach = function () {

	ControlBoxBinding.superclass.onBindingAttach.call ( this );
	this.addActionListener ( ControlBinding.ACTION_COMMAND, this );
	this.attachClassName ( ControlBoxBinding.STATE_NORMAL );
}

/**
 * @implements {IActionListener}
 * @overloads {FlexBoxBinding#handleAction}
 * @param {Action} action
 */
ControlBoxBinding.prototype.handleAction = function ( action ) {

	ControlBoxBinding.superclass.handleAction.call ( this, action );

	switch ( action.type ) {
		case ControlBinding.ACTION_COMMAND :
			var controlBinding = action.target;
			Application.lock ( this );
			var self = this;
			setTimeout ( function () {
				self.handleInvokedControl ( controlBinding );
				Application.unlock ( self );
			}, 0 );
			action.consume ();
			break;
	}
}

/**
 * Invoked when descendant controls fire.
 * @param {ControlBinding} control
 */
ControlBoxBinding.prototype.handleInvokedControl = function ( control ) {
	
	switch ( control.controlType ) {
		case ControlBinding.TYPE_MAXIMIZE :
			this.maximize ();
			break;
		case ControlBinding.TYPE_MINIMIZE :
			this.minimize ();
			break;
		case ControlBinding.TYPE_UNMAXIMIZE :
		case ControlBinding.TYPE_UNMINIMIZE :
			this.normalize ();
			break;
	}
}

/**
 * Minimize.
 */
ControlBoxBinding.prototype.maximize = function () {

	this.dispatchAction ( ControlBoxBinding.ACTION_MAXIMIZE );
	this.setState ( ControlBoxBinding.STATE_MAXIMIZED );
	this.isNormalized = false;
	this.isMaximized = true;
	this.isMinimized = false;
}

/**
 * Minimize.
 */
ControlBoxBinding.prototype.minimize = function () {

	this.dispatchAction ( ControlBoxBinding.ACTION_MINIMIZE );
	this.setState ( ControlBoxBinding.STATE_MINIMIZED );
	this.isNormalized = false;
	this.isMaximized = false;
	this.isMinimized = true;
}

/**
 * Normalize.
 */
ControlBoxBinding.prototype.normalize = function () {

	this.dispatchAction ( ControlBoxBinding.ACTION_NORMALIZE );
	this.setState ( ControlBoxBinding.STATE_NORMAL );
	this.isNormalized = true;
	this.isMaximized = false;
	this.isMinimized = false;
}

/**
 * Updates the value of the "state" property. This also sets a specific CSS classname.
 * @param {string} state
 */
ControlBoxBinding.prototype.setState = function ( state ) {
	
	// backup the old value
	var prestate = this.getState ();

	// assert the new value
	this.setProperty ( "state", state );
	
	// synchronize the CSS classname
	this.detachClassName ( prestate );
	this.attachClassName ( state );
	
	// dispatching common action for all state changes
	this.dispatchAction ( ControlBoxBinding.ACTION_STATECHANGE );
}

/**
 * @return {string}
 */
ControlBoxBinding.prototype.getState = function () {

	var result = this.getProperty ( "state" );
	if ( !result ) {
		result = ControlBoxBinding.STATE_NORMAL;
	}
	return result;
}

MenuContainerBinding.prototype = new Binding;
MenuContainerBinding.prototype.constructor = MenuContainerBinding;
MenuContainerBinding.superclass = Binding.prototype;

/**
 * @implements {IMenuContainer}
 */
function MenuContainerBinding () {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "MenuContainerBinding" );
	
	/**
	 * @type {boolean}
	 * @private
	 */
	this._isOpen = false;
	
	/**
	 * @type {MenuBinding} 
	 * @private
	 */
	this._openElement = null;
	
	/**
	 * @type {MenuContainerBinding}
	 * @private
	 */
	this.menuContainerBinding = null;
	
	/**
	 * @type {MenuPopupBinding}
	 * @private
	 */
	this.menuPopupBinding = null;
}

/**
 * Identifies binding.
 */
MenuContainerBinding.prototype.toString = function () {

	return "[MenuContainerBinding]";
}

/**
 * Is open?
 * @param {Binding} object TODO: update documentation around here!
 * @return {boolean}
 */
MenuContainerBinding.prototype.isOpen = function ( object ) {

	var result = null;
	if ( !object ) {
		result = this._isOpen;
	} else {
		result = ( object == this._openElement );
	}
	return result;
}

/**
 * @param {Binding} binding Ehm, this could actually also be a boolean value of false...
 */
MenuContainerBinding.prototype.setOpenElement = function ( binding ) {
	
	if ( binding ) {
		if ( this._openElement ) {
			this._openElement.hide ();
		}
		this._openElement = binding;
		this._isOpen = true;
	} else {
		this._openElement = null;
		this._isOpen = false;
	}
}

/**
 * Locating ancestor MenuContainerBinding.
 * @return {MenuContainerBinding}
 */
MenuContainerBinding.prototype.getMenuContainerBinding = function () {
	
	if ( !this.menuContainerBinding ) {
		this.menuContainerBinding = this.getAncestorBindingByType ( MenuContainerBinding );
	}
	return this.menuContainerBinding;
}

/**
 * Locating child MenuPopupBinding. Code allows for the menupopup to be replaced runtime.
 * @return {MenuPopupBinding}
 */
MenuContainerBinding.prototype.getMenuPopupBinding = function () {
	
	var menuPopup = this.getChildBindingByLocalName ( "menupopup" );
	if ( menuPopup && menuPopup != this.menuPopupBinding ) {
		this.menuPopupBinding = menuPopup;
		this.menuPopupBinding.addActionListener ( PopupBinding.ACTION_HIDE, this );
	}
	return this.menuPopupBinding;
}

/**
 * Show.
 * @overwrites {Binding#show}
 */
MenuContainerBinding.prototype.show = function () {
	
	var container = this.getMenuContainerBinding ();
	container.setOpenElement ( this );
	
	var popup = this.getMenuPopupBinding ();
	popup.snapTo ( this.bindingElement );
	popup.show ();
}

/**
 * Hide.
 * @overwrites {Binding#hide}
 */
MenuContainerBinding.prototype.hide = function () {
	
	this.reset ();
	this.getMenuPopupBinding ().hide ();
	if ( this._isOpen ) {
		this._openElement.hide ();
	}
}

/**
 * Reset visual appearance when menus are closed. Subclasses should define this method.
 */
MenuContainerBinding.prototype.reset = Binding.ABSTRACT_METHOD;

/**
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
MenuContainerBinding.prototype.handleAction = function ( action ) {
	
	MenuContainerBinding.superclass.handleAction.call ( this, action );
	
	if ( action.type == PopupBinding.ACTION_HIDE ) {
		var container = this.getMenuContainerBinding ();
		container.setOpenElement ( false );
		this.reset ();
		action.consume ();
	}
}

MenuBarBinding.prototype = new MenuContainerBinding;
MenuBarBinding.prototype.constructor = MenuBarBinding;
MenuBarBinding.superclass = MenuContainerBinding.prototype;

function MenuBarBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "MenuBarBinding" );
	
	/**
	 * Block common crawlers.
	 * @type {Map<string><boolean>}
	 * @overwrites {Binding#crawlerFilters}
	 */
	this.crawlerFilters	= new List ([ FlexBoxCrawler.ID, FocusCrawler.ID ]);
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
MenuBarBinding.prototype.toString = function () {
	
	return "[MenuBarBinding]";
}

/**
 * Attach classname to clear stylesheet floats.
 * @overloads {Binding#onBindingRegister}
 */
MenuBarBinding.prototype.onBindingRegister = function () {
	
	MenuBarBinding.superclass.onBindingRegister.call ( this );
	this.addActionListener ( MenuBodyBinding.ACTION_UNHANDLED_LEFTRIGHTKEY );
	this.attachClassName ( Binding.CLASSNAME_CLEARFLOAT );
}

/**
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
MenuBarBinding.prototype.handleAction = function ( action ) {
	
	MenuBarBinding.superclass.handleAction.call ( this, action );
	
	switch ( action.type ) {
		case MenuBodyBinding.ACTION_UNHANDLED_LEFTRIGHTKEY :
			
			var menuBody = action.target;
			
			var menus = this.getChildBindingsByLocalName ( "menu" );
			while ( menus.hasNext ()) {
				var menu = menus.getNext ();
			}
			
			switch ( menuBody.arrowKey ) {
				case KeyEventCodes.VK_LEFT :
					this.logger.debug ( "LEFTG" );
					break;
				case KeyEventCodes.VK_RIGHT :
					this.logger.debug ( "RIGHT" );
					break;
			}
			
			break;
	}
}

MenuBinding.prototype = new MenuContainerBinding;
MenuBinding.prototype.constructor = MenuBinding;
MenuBinding.superclass = MenuContainerBinding.prototype;

function MenuBinding () {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "MenuBinding" );
	
	/**
	 * @type {LabelBinding}
	 */
	this.labelBinding = null;
	
	/**
	 * @type {boolean}
	 */
	this.isFocused = false;
}

/**
 * Identifies binding.
 */
MenuBinding.prototype.toString = function () {

	return "[MenuBinding]";
}

/**
 * @overloads {Binding#onBindingAttach}
 */
MenuBinding.prototype.onBindingAttach = function () {

	MenuBinding.superclass.onBindingAttach.call ( this );
	this.buildDOMContent ();
	this.assignDOMEvents ();
}

/**
 * Build DOM content.
 */
MenuBinding.prototype.buildDOMContent = function () {

	var image 		= this.getProperty ( "image" );
	var label 		= this.getProperty ( "label" );
	var tooltip 	= this.getProperty ( "tooltip" );

	this.labelBinding = LabelBinding.newInstance ( this.bindingDocument );
	this.labelBinding.attachClassName ( "menulabel" );
	this.add ( this.labelBinding );

	if ( label ) {
		this.setLabel ( label );
	}
	if ( image ) {
		this.setImage ( image );
	}
	if ( tooltip ) {
		this.setToolTip ( tooltip );
	}
}

/**
 * Reset visual appearance when menus are closed. 
 */
MenuBinding.prototype.reset = function () {
	
	this.detachClassName ( "hover" );
}

/**
 * Set image.
 * @param {string} url
 */
MenuBinding.prototype.setImage = function ( url ) {

	this.setProperty ( "image", url );
	if ( this.isAttached ) {
		this.labelBinding.setImage ( 
			Resolver.resolve ( url )
		);
	}
}

/**
 * Set label.
 * @param {string} label
 */
MenuBinding.prototype.setLabel = function ( label ) {

	this.setProperty ( "label", label );
	if ( this.isAttached ) {
		this.labelBinding.setLabel ( 
			Resolver.resolve ( label )
		);
	}
}

/**
 * Set tooltip.
 * @param {string} tooltip
 */
MenuBinding.prototype.setToolTip = function ( tooltip ) {

	this.setProperty ( "tooltip", tooltip );
	if ( this.isAttached ) {
		this.labelBinding.setToolTip ( 
			Resolver.resolve ( tooltip )
		);
	}
}

/**
 * Get image.
 * @return {string}
 */
MenuBinding.prototype.getImage = function () {

	return this.getProperty ( "image" );
}

/**
 * Get label.
 * @return {string}
 */
MenuBinding.prototype.getLabel = function () {

	return this.getProperty ( "label" );
}


/**
 * Get tooltip.
 * @return {string}
 */
MenuBinding.prototype.getToolTip = function () {

	return this.getProperty ( "tooltip" );
}

/**
 * Assigning DOM events.
 */
MenuBinding.prototype.assignDOMEvents = function () {
	
	this.addEventListener ( DOMEvents.MOUSEDOWN );
	this.addEventListener ( DOMEvents.MOUSEOVER );
	this.addEventListener ( DOMEvents.MOUSEOUT );
	this.addEventListener ( DOMEvents.MOUSEUP );
}

/**
 * @implements {IEventListener}
 * @overloads {Binding#handleEvent}
 * @param {MouseEvent} e
 */
MenuBinding.prototype.handleEvent = function ( e ) {
	
	MenuBinding.superclass.handleEvent.call ( this, e );
	
	var container = this.getMenuContainerBinding ();
	
	if ( !BindingDragger.isDragging ) {
	
		switch ( e.type ) {
			
			case DOMEvents.MOUSEDOWN :
				if ( container.isOpen ( this )) {
					DOMEvents.stopPropagation ( e );
				}
				break;
				
			case DOMEvents.MOUSEOVER :
				if ( container.isOpen () && !container.isOpen ( this )) {
					this.show ();
					this.menuPopupBinding.grabKeyboard ();
				}
				this.attachClassName ( "hover" );
				this.isFocused = true;
				break;
				
			case DOMEvents.MOUSEOUT :
				if ( !container.isOpen ()) {
					this.hide ();
				}
				this.isFocused = false;
				break;
				
			case DOMEvents.MOUSEUP :
				if ( !container.isOpen ( this )) {
					this.show ();
					this.menuPopupBinding.grabKeyboard ();
				}
				DOMEvents.stopPropagation ( e );
				break;
		}
	}
	
	/*
	 * Consuming the event!
	 */
	DOMEvents.stopPropagation ( e );
}


MenuBodyBinding.prototype = new Binding;
MenuBodyBinding.prototype.constructor = MenuBodyBinding;
MenuBodyBinding.superclass = Binding.prototype;

MenuBodyBinding.CLASSNAME_CHECKBOXED = "checkboxed";

/*
 * In case an arrowkeypress could not be handled responsibly, 
 * we can dispatch this and hope that an ancestor binding can.
 */
MenuBodyBinding.ACTION_UNHANDLED_LEFTRIGHTKEY = "menubody unhandled arrowkey";

/**
 * Points to the currently active MenuBodyBinding instance. 
 * Remember to reset this when the menupopup is closed.
 * @type {MenuBodyBinding}
 */
MenuBodyBinding.activeInstance = null;

/**
 * Relay arrowkeypress to the currently active instance.
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
MenuBodyBinding.handleBroadcast = function ( broadcast, arg ) {
	
	var body = MenuBodyBinding.activeInstance;
	var key = arg;
	
	if ( body ) {
		switch ( broadcast ) {
			case BroadcastMessages.KEY_ARROW :
				body.handleArrowKey ( key );
				break;
			case BroadcastMessages.KEY_ENTER :
				body.handleEnterKey ();
				break;
		}
	}
}

/*
 * To avoid filing and unregistering an excessive amount of 
 * EventBroadcaster subscriptions whenever a menu is opened 
 * and closed, all keybaord menu handling is handled thusly.
 */
EventBroadcaster.subscribe ( BroadcastMessages.KEY_ARROW, MenuBodyBinding );
EventBroadcaster.subscribe ( BroadcastMessages.KEY_ENTER, MenuBodyBinding );
EventBroadcaster.subscribe ( BroadcastMessages.KEY_ESCAPE, MenuBodyBinding );

/**
 * @class
 */
function MenuBodyBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "MenuBodyBinding" );
	
	/**
	 * @type {PopupBinding}
	 */
	this._containingPopupBinding = null;
	
	/**
	 * @type {HashMap<string><MenuItemBinding>}
	 */
	this._focused = null;
	
	/**
	 * @type {MenuItemBinding}
	 */
	this._lastFocused = null;
	
	/**
	 * @type {function}
	 */
	this._showSubMenuTimeout = null;
	
	/**
	 * @type {int}
	 */
	this.arrowKey = null;
	
	/*
	 * If set to true, menuitems will be indexed anew.
	 * Use when menuitems are dynamically added or removed.
	 * @see {MenuItemBinding#onBindingAttach}
	 * @type {boolean}
	 */
	this.isDirty = true;
	
	/**
	 * @type {boolean}
	 */
	this._hasImageLayout = false;
	
	/**
	 * @type {boolean}
	 */
	this._hasCheckBoxLayout = false;
}

/**
 * Identifies binding.
 */
MenuBodyBinding.prototype.toString = function () {

	return "[MenuBodyBinding]";
}

/**
 * @overloads {Binding#onBindingAttach}
 */
MenuBodyBinding.prototype.onBindingAttach = function () {

	MenuBodyBinding.superclass.onBindingAttach.call ( this );
	
	/** 
	 * Show no images (until an image shows up).
	 *
	this.attachClassName ( ToolBarBinding.CLASSNAME_TEXTONLY );
	*/
	
	/*
	 * Initialize focused registry.
	 */
	this._focused = {};
	
	this.addEventListener ( DOMEvents.MOUSEDOWN );
	this.addEventListener ( DOMEvents.MOUSEOVER );
	this.addEventListener ( DOMEvents.MOUSEOUT );
	this.addEventListener ( DOMEvents.MOUSEUP );
	
	/*
	 * Grab keyboard when left-right arrow key was 
	 * pressed in descendant menubody with no effect.
	 */
	var self = this;
	this.addActionListener ( MenuBodyBinding.ACTION_UNHANDLED_LEFTRIGHTKEY, {
		handleAction : function ( action ) {
			switch ( action.target ) {
				case self :
					self.releaseKeyboard ();
					self._containingPopupBinding.hide ();
					break;
				default :
					var mouseevent = null;
					var isPreventFocus = true;
					self._lastFocused.focus ();
					self.grabKeyboard ();
					action.consume ();
					break;
			}
		}
	});
	
	/*
	 * Reset focus and release keyboard when popup is closed.
	 */
	this._containingPopupBinding = UserInterface.getBinding ( 
		this.bindingElement.parentNode
	);
	this._containingPopupBinding.addActionListener ( 
		PopupBinding.ACTION_HIDE, {
			handleAction : function () {
				self.resetFocusedItems ( true );
				self.releaseKeyboard ();
			}
		}
	)
}

/**
 * @overloads {Binding#onBindingDispose}
 */
MenuBodyBinding.prototype.onBindingDispose = function () {

	MenuBodyBinding.superclass.onBindingDispose.call ( this );
	if ( MenuBodyBinding.activeInstance == this ) {
		MenuBodyBinding.activeInstance = null;
	}
}

/**
 * When keyboardgrab is assigned, consuming the mouseover event 
 * will make sure that container binding doesn't grab our keyboard. 
 * The other mouseevents get consumed simply because we can.
 * @implements {IEventListener}
 * @overloads {Binding#handleEvent}
 * @param {MouseEvent} e
 */
MenuBodyBinding.prototype.handleEvent = function ( e ) {
	
	MenuBodyBinding.superclass.handleEvent.call ( this, e );
	
	if ( e.type == DOMEvents.MOUSEOUT ) {
		this.resetFocusedItems ();
	}
	switch ( e.type ) {
		case DOMEvents.MOUSEDOWN :
		case DOMEvents.MOUSEOVER :
		case DOMEvents.MOUSEOUT :
		case DOMEvents.MOUSEUP :
			DOMEvents.stopPropagation ( e );
			break;
	}
}

/** 
 * Handle focused item. This would normally be done with 
 * dispatching and catching Actions, but we consider 
 * superfast screen update to be of maximum importance. 
 * @see {MenuItemBinding#focus}
 * @param {MenuItemBinding} binding
 */
MenuBodyBinding.prototype.handleFocusedItem = function ( binding ) {
	
	for ( var key in this._focused ) {
		if ( key != binding.key ) {
			var item = this._focused [ key ];
			item.blur ();
		}
	}
	this._focused [ binding.key ] = binding;
	this._lastFocused = binding;

	/*
	 * Grab that keyboard.
	 */
	if ( MenuBodyBinding.activeInstance != this ) {
		this.grabKeyboard ();
	}
} 

/** 
 * Handle blurred item.
 * @see {MenuItemBinding#blur}
 * @param {MenuItemBinding} binding
 */
MenuBodyBinding.prototype.handleBlurredItem = function ( binding ) {
	
	delete this._focused [ binding.key ];
}

/**
 * Reset focused items.
 * @param {boolean} isTotalReset
 */
MenuBodyBinding.prototype.resetFocusedItems = function ( isTotalReset ) {
	
	for ( var key in this._focused ) {
		var item = this._focused [ key ];
		item.blur ( isTotalReset );
	}
	if ( isTotalReset ) {
		this._lastFocused = null;
	}
}

/** 
 * Refresh the visual appearance of MenuGroupBindings, hiding the separators on 
 * first and last menugroup. This because Explorer won't reckognize first-child 
 * and last-child CSS pseudoselectors in quirksmode.
 */
MenuBodyBinding.prototype.refreshMenuGroups = function () {
	
	if ( !this.isAttached ) { 
	
		throw "refreshMenuGroups: MenuBodyBinding not attached!";
		
	} else {
		
		var groups = this.getChildBindingsByLocalName ( "menugroup" );
		var firstGroup = null;
		var lastGroup = null;
	
		while ( groups.hasNext ()) {
			var group = groups.getNext ();
			if ( !group.isDefaultContent ) {
				group.setLayout ( MenuGroupBinding.LAYOUT_DEFAULT );
				if ( !firstGroup && group.isVisible ) {
					firstGroup = group;
				}
				if ( group.isVisible ) {
					lastGroup = group;
				}
			}
		};
		if ( firstGroup && lastGroup ) {
			firstGroup.setLayout ( MenuGroupBinding.LAYOUT_FIRST );
			lastGroup.setLayout ( MenuGroupBinding.LAYOUT_LAST );
		}
	}
}

/**
 * Grab keyboard control. This method is invoked often, so be careful when editing.
 * @param {boolean} isDefaultAction
 */
MenuBodyBinding.prototype.grabKeyboard = function ( isDefaultAction ) {
	
	MenuBodyBinding.activeInstance = this;
	
	if ( isDefaultAction ) {
		var first = this._getMenuItems ().getFirst ();
		if ( first ) {
			first.focus ();
		}
	}
}

/**
 * Release keyboard control.  This method is invoked 
 * by the containing {@link PopupBinding}.
 */
MenuBodyBinding.prototype.releaseKeyboard = function () {
	
	if ( MenuBodyBinding.activeInstance == this ) {
		MenuBodyBinding.activeInstance = null;	
	}
}

/**
 * Handle enter key pressed. This will fire the command 
 * associated to any focused MenuItemBinding.
 */
MenuBodyBinding.prototype.handleEnterKey = function () {

	var focused = this._lastFocused;

	if (( focused != null ) && (!focused.isMenuContainer )) {
	
		focused.fireCommand ();
		
		/*
		 * Technically not a mouse event, but  
		 * we do wan't to close all open popups.
		 */
		EventBroadcaster.broadcast ( 
			BroadcastMessages.MOUSEEVENT_MOUSEDOWN 
		);
	}
}

/**
 * Handle escape key. This should close all open popups.
 *
MenuBodyBinding.prototype.handleEscapeKey = function () {
	
	alert ( "ESCAPE NOW!" );
}
*/

/*
 * Compute next focus when the arrowkey is pressed.
 * TODO: handle menupopups that opened on the 
 * wrong side because of missing screen estate!
 * @param {int} key
 */
MenuBodyBinding.prototype.handleArrowKey = function ( key ) {

	/*
	 * Store key so that others can know what was pressed.
	 * @see {MenuBarBinding#handleAction}
	 */
	this.arrowKey = key;

	var items 	= this._getMenuItems ();
	var current	= null;
	var next 	= null;
	
	if ( this._lastFocused ) {
	
		current = this._lastFocused
		
		switch ( key ) {
			case KeyEventCodes.VK_UP :
				next = items.getPreceding ( current );
				break;
			case KeyEventCodes.VK_DOWN :
				next = items.getFollowing ( current );
				break;
			case KeyEventCodes.VK_LEFT :
				this.dispatchAction ( MenuBodyBinding.ACTION_UNHANDLED_LEFTRIGHTKEY );
				break;
			case KeyEventCodes.VK_RIGHT :
				if ( this._lastFocused.isMenuContainer ) {
					this.releaseKeyboard ();
					this._lastFocused.show ();
					this._lastFocused.menuPopupBinding.grabKeyboard ( true );
				} else {
					this.dispatchAction ( MenuBodyBinding.ACTION_UNHANDLED_LEFTRIGHTKEY );
				}
				break;
		}
	} else {
		next = items.getFirst ();
	}
	if ( next ) {
		next.focus ();
	}
}

/**
 * Carefully locate menuitems relevant for this menubody only.
 * A dirtyflag system compensates for added and removed items.
 * @return {List<MenuItemBinding>}
 */
MenuBodyBinding.prototype._getMenuItems = function () {
	
	if ( !this._menuItemsList || this.isDirty ) {
		var list = new List ();
		var items = null;
		this.getChildBindingsByLocalName ( "menugroup" ).each ( function ( group ) {
			items = group.getChildBindingsByLocalName ( "menuitem" );
			items.each ( function ( item ) {
				list.add ( item );
			});
		});
		items = this.getChildBindingsByLocalName ( "menuitem" );
		items.each ( function ( item ) {
			list.add ( item );
		});
		this._menuItemsList = list;
		this.isDirty = false;
	}
	return this._menuItemsList;
}

/**
 * Make room for checkbox column. Called by descendant {@link MenuItemBinding}.
 */
MenuBodyBinding.prototype.invokeCheckBoxLayout = function () {
	
	if ( !this.hasClassName ( MenuBodyBinding.CLASSNAME_CHECKBOXED )) {
		this.attachClassName ( MenuBodyBinding.CLASSNAME_CHECKBOXED );
	}
}

/**
 * Make room for checkbox column. Called by descendant {@link MenuItemBinding}.
 * TODO: disable again at some point?
 */
MenuBodyBinding.prototype.invokeImageLayout = function () {
	
	if ( !this._hasImageLayout ) {
		this.detachClassName ( ToolBarBinding.CLASSNAME_TEXTONLY ); 
		this._hasImageLayout = true;
	}
}

/**
 * Emulates basic CSS support in Explorer. Invoked by the containing {@link PopupBinding}.
 * @param {Dimension} dim
 */
MenuBodyBinding.prototype.setDimension = function ( dim ) {
	
	this.getBindingElement ().style.width = new String ( dim.w ) + "px";
}

/**
 * MenuBodyBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {MenuBodyBinding}
 */
MenuBodyBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:menubody", ownerDocument );
	return UserInterface.registerBinding ( element, MenuBodyBinding );
}

MenuGroupBinding.prototype = new Binding;
MenuGroupBinding.prototype.constructor = MenuGroupBinding;
MenuGroupBinding.superclass = Binding.prototype;

MenuGroupBinding.LAYOUT_DEFAULT = 0;
MenuGroupBinding.LAYOUT_FIRST = 1;
MenuGroupBinding.LAYOUT_LAST = 2;

function MenuGroupBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "MenuGroupBinding" );
	
	/**
	 * @type {boolean}
	 */
	this.isVisible = true;
}

/**
 * Identifies binding.
 */
MenuGroupBinding.prototype.toString = function () {

	return "[MenuGroupBinding]";
}

/**
 * Set layout. This method is invoked by the {@link ToolBarBodyBinding}.
 * @param {int} layout
 */
MenuGroupBinding.prototype.setLayout = function ( layout ) {

	switch ( layout ) {
		case MenuGroupBinding.LAYOUT_DEFAULT :
			this.detachClassName ( "first" );
			this.detachClassName ( "last" );
			break;
		case MenuGroupBinding.LAYOUT_FIRST :
			this.attachClassName ( "first" );
			break;	
		case MenuGroupBinding.LAYOUT_LAST :
			this.attachClassName ( "last" );
			break;
	}
}

/**
 * Show group. The unnescessary visibility adjustment is nescessary for explorer.
 * @overwrites {Binding#show}
 */
MenuGroupBinding.prototype.show = function () {
	
	if ( !this.isVisible ) {
		this.bindingElement.style.display = "block";
		this.bindingElement.style.visibility = "visible";
		this.isVisible = true;
	}
}

/**
 * Hide group.
 * @overwrites {Binding#hide}
 */
MenuGroupBinding.prototype.hide = function () {
	
	if ( this.isVisible ) {
		this.bindingElement.style.display = "none";
		this.bindingElement.style.visibility = "hidden";
		this.isVisible = false;
	}
}

/**
 * MenuGroupBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {MenuGroupBinding}
 */
MenuGroupBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:menugroup", ownerDocument );
	return UserInterface.registerBinding ( element, MenuGroupBinding );
}

MenuItemBinding.prototype = new MenuContainerBinding;
MenuItemBinding.prototype.constructor = MenuItemBinding;
MenuItemBinding.superclass = MenuContainerBinding.prototype;

MenuItemBinding.ACTION_COMMAND		= "menuitemcommand";
MenuItemBinding.TYPE_CHECKBOX 		= "checkbox";
MenuItemBinding.TYPE_MENUCONTAINER 	= "menucontainer";
MenuItemBinding.CLASSNAME_CHECKBOX 	= "checkboxindicator";
MenuItemBinding.CLASSNAME_SUBMENU 	= "submenuindicator";
MenuItemBinding.CLASSNAME_HOVER 	= "hover";
MenuItemBinding.CHAR_CHECKBOX 		= "V";
MenuItemBinding.CHAR_SUBMENU 		= String.fromCharCode ( 9658 ); // "►".charCodeAt ( 0 )
MenuItemBinding.TIMEOUT				= 150;

/**
 * @class
 */
function MenuItemBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "MenuItemBinding" );
	
	/**
	 * @type {string}
	 */
	this.type = null;
	
	/**
	 * User can implement this. 
	 * @type {function}
	 */
	this.oncommand = null;
	
	/**
	 * @type {boolean}
	 */
	this.isDisabled = false;
	
	/**
	 * @type {LabelBinding}
	 */
	this.labelBinding = null;
	
	/**
	 * @type {string}
	 */
	this.image = null;
	
	/**
	 * @type {string}
	 */
	this.imageHover = null;
	
	/**
	 * @type {string}
	 */
	this.imageActive = null;
	
	/**
	 * @type {string}
	 */
	this.imageDisabled = null;
	
	/**setDisabled
	 */
	this.imageProfile = null;
	
	/**
	 * @type {boolean}
	 */
	this.isMenuContainer = false;
	
	/**
	 * @type {boolean}
	 */
	this.isTypeSet = false;
	
	/**
	 * @type {boolean}
	 */
	this.isChecked = false;
	
	/**
	 * Flipped by either mouse or keyboard navigation.
	 * @type {boolean}
	 */
	this.isFocused = false;
	
	/**
	 * The containing menubody handles blur whenever a new item is focused. 
	 * This is done by direct method invokation because of maxed performance.
	 * @type {MenuBodyBinding}
	 */
	this._containingMenuBodyBinding = null;
}

/**
 * Identifies binding.
 */
MenuItemBinding.prototype.toString = function () {
	
	return "[MenuItemBinding]";
}

/**
 * Hookup broadcaster mapping and set type.
 */
MenuItemBinding.prototype.onBindingRegister = function () {

	MenuItemBinding.superclass.onBindingRegister.call ( this );
	this.propertyMethodMap [ "isdisabled" ] = this.setDisabled;
	if ( this.type ) {
		this.setProperty ( "type", this.type );
	}
}

/**
 * @overloads {Binding#onBindingAttach}
 */
MenuItemBinding.prototype.onBindingAttach = function () {

	MenuItemBinding.superclass.onBindingAttach.call ( this );
	
	/*
	 * Locate menubody and set a dirty flag. This 
	 * will force menubody to reindex menuitems.
	 */
	this._containingMenuBodyBinding = this.getAncestorBindingByLocalName ( "menubody" );
	this._containingMenuBodyBinding.isDirty = true;
	
	/*
	 * Build.
	 */
	this.parseDOMProperties ();
	this.buildDOMContent ();
	this.assignDOMEvents ();
	
	/**
	 * Intercepted by PopupBinding in order to control overflow.
	 */
	this.dispatchAction ( Binding.ACTION_ATTACHED );
	
}



/**
 * Parse DOM properties.
 */
MenuItemBinding.prototype.parseDOMProperties = function () {

	var image = this.getProperty ( "image" );
	var imageHover = this.getProperty ( "image-hover" );
	var imageActive = this.getProperty ( "image-active" );
	var imageDisabled = this.getProperty ( "image-disabled" );
	
	if ( !this.image && image ) {
		this.image = image;
	}
	if ( !this.imageHover && imageHover ) {
		this.imageHover = image;
	}
	if ( !this.imageActive && imageActive ) {
		this.imageActive = imageActive;
	}
	if ( !this.imageDisabled && imageDisabled ) {
		this.imageDisabled = imageDisabled;
	}
}

/**
 * Build DOM content.
 */
MenuItemBinding.prototype.buildDOMContent = function () {

	var label 			= this.getProperty ( "label" );
	var tooltip 		= this.getProperty ( "tooltip" );
	var type 			= this.getProperty ( "type" );
	var disabled 		= this.getProperty ( "isdisabled" );
	var image 			= this.getProperty ( "image" );
	var imageHover 		= this.getProperty ( "image-hover" );
	var imageActive 	= this.getProperty ( "image-active" );
	var imageDisabled 	= this.getProperty ( "image-disabled" );

	this.labelBinding = LabelBinding.newInstance ( this.bindingDocument );
	this.labelBinding.attachClassName ( "menuitemlabel" );
	this.add ( this.labelBinding );
	
	// assign menupopup
	var menuPopup = this.getMenuPopupBinding ();
	if ( menuPopup ) {
		this.isMenuContainer = true;
		this.setType ( MenuItemBinding.TYPE_MENUCONTAINER );
	}
	
	// compute image profile
	if ( !this.imageProfile ) {
	
		if ( !this.image && image ) {
			this.image = image;
		}
		if ( !this.imageHover && imageHover ) {
			this.imageHover = image;
		}
		if ( !this.imageActive && imageActive ) {
			this.imageActive = imageActive;
		}
		if ( !this.imageDisabled && imageDisabled ) {
			this.imageDisabled = imageDisabled;
		}
		if ( this.image || this.imageHover || this.imageActive || this.imageDisabled ) {
			this.imageProfile = new ImageProfile ( this );
		}
	}
	
	if ( this.imageProfile ) {
		this.setImage ( this.imageProfile.getDefaultImage ());
		/*this._containingMenuBodyBinding.invokeImageLayout ();*/
	} else {
		this.setImage ( null );
	}
		
	if ( label ) {
		this.setLabel ( label );
	}
	if ( tooltip ) {
		this.setToolTip ( tooltip );
	}
	if ( type ) {
		this.setType ( type );
	}
	if ( this.type == MenuItemBinding.TYPE_CHECKBOX ) {
		if ( this.getProperty ( "ischecked" ) == true ) {
			this.check ( true );
		}
	}
	if ( disabled == true ) {
		this.disable ();
	}
	
	/*
	 * Setup command
	 */
	var oncommand = this.getProperty ( "oncommand" );
	if ( oncommand ) {
		if ( this.isMenuContainer ) {
			throw new Error ( "MenuItemBinding with contained menuitems cannot fire commands." );
		} else {
			this.oncommand = function () {
				this.bindingWindow.eval ( oncommand );
			}
		}
	}
	
	/*
	 * So that scrollbarred menus can be keyboard navigated. 
	 * The tabIndex is set to zero when containing popup opens.
	 * @see {PopupBinding#show}
	 *
	this.bindingElement.tabIndex = -1;
	if ( Client.isExplorer ) {
		this.bindingElement.hideFocus = true;
	}
	*/
}

/**
 * Assign DOM events.
 */
MenuItemBinding.prototype.assignDOMEvents = function () {
	
	/*
	 * Rebember that menubody handles blur!
	 */
	this.addEventListener ( DOMEvents.MOUSEOVER );
	this.addEventListener ( DOMEvents.MOUSEUP );
}

/**
 * @implements {IEventListener}
 * @overloads {Binding#handleEvent}
 * @param {MouseEvent} e
 */
MenuItemBinding.prototype.handleEvent = function ( e ) {

	MenuItemBinding.superclass.handleEvent.call ( this, e );
	
	if ( !this.isDisabled && !BindingDragger.isDragging ) {
	
		switch ( e.type ) {
			
			case DOMEvents.MOUSEOVER :
				this.focus ( e );
				break;
			
			case DOMEvents.MOUSEUP :
				DOMEvents.stopPropagation ( e );
				if ( !this.isMenuContainer ) {
					if ( this.type == MenuItemBinding.TYPE_CHECKBOX ) {
						this.setChecked ( !this.isChecked );
					} else {
						this.fireCommand ();
					}
					EventBroadcaster.broadcast ( 
						BroadcastMessages.MOUSEEVENT_MOUSEUP, this 
					);
				}
				break;
		}
	}
}

/**
 * Fire command.
 */
MenuItemBinding.prototype.fireCommand = function () {
	
	if ( !this.isMenuContainer ) {
		if ( this.oncommand ) {
			// TODO: Timeout to close first? Animation.DEFAULT_TIMEOUT?
			this.oncommand ();
		}
		this.dispatchAction ( MenuItemBinding.ACTION_COMMAND );
	}
}

/**
 * Set image. Defaults to a blank image in order to align menuitems correctly.
 * TODO: modify menu layout if NO menuitems specify images.
 * @param {string} url
 */
MenuItemBinding.prototype.setImage = function ( url ) {

	url = url ? url : LabelBinding.DEFAULT_IMAGE;
	this.setProperty ( "image", url );
	if ( this.isAttached ) {
		this.labelBinding.setImage ( 
			Resolver.resolve ( url )
		);
	}
}

/**
 * Set label.
 * @param {string} label
 */
MenuItemBinding.prototype.setLabel = function ( label ) {

	this.setProperty ( "label", label );
	if ( this.isAttached ) {
		this.labelBinding.setLabel (
			Resolver.resolve ( label )
		);
	}
}

/**
 * Set tooltip.
 * @param {string} tooltip
 */
MenuItemBinding.prototype.setToolTip = function ( tooltip ) {

	this.setProperty ( "tooltip", tooltip );
	if ( this.isAttached ) {
		this.labelBinding.setToolTip ( 
			Resolver.resolve ( tooltip )
		);
	}
}

/**
 * Reset visual appearance when menus are closed. 
 */
MenuItemBinding.prototype.reset = function () {

	if ( this.labelBinding.hasClassName ( "hover" )) {
		this.labelBinding.detachClassName ( "hover" );
	}
}

/**
 * Set type.
 * @param {string} type
 */
MenuItemBinding.prototype.setType = function ( type ) {
	
	if ( this.isAttached ) {
		if ( !this.isTypeSet ) {
			switch ( type ) {
				case MenuItemBinding.TYPE_CHECKBOX :
					
					if ( !this.isMenuContainer ) {
					
						// update container appearance
						this._containingMenuBodyBinding.invokeCheckBoxLayout ();
											
						// append checkbox symbol
						var element = this.bindingDocument.createElement ( "div" );
						element.className = MenuItemBinding.CLASSNAME_CHECKBOX;
						element.appendChild ( this.bindingDocument.createTextNode ( MenuItemBinding.CHAR_CHECKBOX ));
						var label = this.labelBinding.bindingElement;
						label.insertBefore ( element, label.firstChild );
						element.style.display = "none";
						this.shadowTree.checkBoxIndicator = element;
						
					} else {
						throw new Error ( "MenuItemBinding: checkboxes cannot contain menus" );
					}
					break;
					
				case MenuItemBinding.TYPE_MENUCONTAINER :
					
					// append arrow symbol
					var element = this.bindingDocument.createElement ( "div" );
					element.className = MenuItemBinding.CLASSNAME_SUBMENU;
					element.appendChild ( this.bindingDocument.createTextNode ( MenuItemBinding.CHAR_SUBMENU ));
					var label = this.labelBinding.bindingElement;
					label.insertBefore ( element, label.firstChild );
					break;
			}
			
			this.type = type;
			this.isTypeSet = true;
			
		} else {
			throw new Error ( "MenuItemBinding: Cannot set type twice." );
		}
	}
	
	this.setProperty ( "type", type );
}

/**
 * Get image.
 * @return {string}
 */
MenuItemBinding.prototype.getImage = function () {

	return this.getProperty ( "image" );
}

/**
 * Get label.
 * @return {string}
 */
MenuItemBinding.prototype.getLabel = function () {

	return this.getProperty ( "label" );
}


/**
 * Get tooltip.
 * @return {string}
 */
MenuItemBinding.prototype.getToolTip = function () {

	return this.getProperty ( "tooltip" );
}

/**
 * Disable menuitem.
 */
MenuItemBinding.prototype.disable = function () {

	this.setDisabled ( true );
}

/**
 * Enable menuitem.
 */
MenuItemBinding.prototype.enable = function () {

	this.setDisabled ( false );
}

/**
 * Set menuitem disabled status.
 * @param {boolean} bool
 */
MenuItemBinding.prototype.setDisabled = function ( bool ) {
	
	this.isDisabled = bool;
	
	if ( this.isDisabled ) {
		this.setProperty ( "isdisabled", true );
	} else {
		this.deleteProperty ( "isdisabled" );
	}	
	
	if ( this.isAttached ) {
		if ( this.isDisabled ) {
			this.labelBinding.detachClassName ( "hover" );
			this.attachClassName ( "isdisabled" );
			if ( this.imageProfile ) {
				var image = this.imageProfile.getDisabledImage ();
				if ( image ) {
					this.setImage ( image );
				}
			}
		} else {
			this.detachClassName ( "isdisabled" );
			if ( this.imageProfile ) {
				var image = this.imageProfile.getDefaultImage ();
				if ( image ) {
					this.setImage ( image );
				}
			}
		}
	}
}

/**
 * Focus.
 * @param {MouseEvent} e
 */
MenuItemBinding.prototype.focus = function ( e ) {
	
	/*
	 * Notice that only the label gets a classname assigned here!
	 */
	this.labelBinding.attachClassName ( MenuItemBinding.CLASSNAME_HOVER );
	
	var container = this.getMenuContainerBinding ();
	if ( container.isOpen () && !container.isOpen ( this )) {
		container._openElement.hide ();
		container.setOpenElement ( false );
	}
	
	/*
	 * Open submenu after short timeout (when mouse-navigating).
	 */
	if ( this.isMenuContainer && e && e.type == DOMEvents.MOUSEOVER ) {
		var container = this.getMenuContainerBinding ();	
		if ( !container.isOpen ( this )) {
			var self = this;
			this._showSubMenuTimeout = window.setTimeout ( function () {
				self.show ();
				self._showSubMenuTimeout = null;
			}, MenuItemBinding.TIMEOUT );
		};
	}
	
	/**
	 * When keyboard navigating, this will adjust any visible scrollbar.
	 */
	if ( !e || e.type != DOMEvents.MOUSEOVER ) {
		if ( this.bindingElement.tabIndex != -1 ) {
			if ( Client.isMozilla ) {
				FocusBinding.focusElement ( this.bindingElement );
			} else {
				var self = this;
				setTimeout ( function () {
					FocusBinding.focusElement ( self.bindingElement );
				}, 0 );
			}
		}
	}
	
	this.isFocused = true;
	this._containingMenuBodyBinding.handleFocusedItem ( this );
}

/**
 * Blur.
 * @param {boolean} isForceBlur
 */
MenuItemBinding.prototype.blur = function ( isForceBlur ) {
	
	/*
	 * Clear submenu timeout.
	 */
	if ( this._showSubMenuTimeout ) {
		window.clearTimeout ( this._showSubMenuTimeout );
		this._showSubMenuTimeout = null;
	}
	
	if ( this.isFocused ) {
		var container = this.getMenuContainerBinding ();
		if ( !container || !container.isOpen ( this ) || isForceBlur ) {
			this.labelBinding.detachClassName ( MenuItemBinding.CLASSNAME_HOVER );
			this.isFocused = false;
			this._containingMenuBodyBinding.handleBlurredItem ( this );
		}
	}
}

/**
 * Check.
 * @param {boolean} isPreventCommand
 */
MenuItemBinding.prototype.check = function ( isPreventCommand ) {
	
	this.setChecked ( true, isPreventCommand );
}

/**
 * Uncheck.
 * @param {boolean} isPreventCommand
 */
MenuItemBinding.prototype.uncheck = function ( isPreventCommand ) {

	this.setChecked ( false, isPreventCommand );
}

/**
 * Always attempt right side positioning of the submenu.
 * @overloads {MenuContainerBinding#show}
 */
MenuItemBinding.prototype.show = function () {
	
	this.menuPopupBinding.position = PopupBinding.POSITION_RIGHT;
	MenuItemBinding.superclass.show.call ( this );
}

/**
 * Set menuitem checked status.
 * @param {boolean} isChecked
 * @param {boolean} isPreventCommand
 */
MenuItemBinding.prototype.setChecked = function ( isChecked, isPreventCommand ) {
	
	this.setProperty ( "ischecked", isChecked );
	if ( this.isAttached ) {
		if ( this.type == MenuItemBinding.TYPE_CHECKBOX ) {
			if ( this.isChecked != isChecked ) {
				this.isChecked = isChecked;
				this.shadowTree.checkBoxIndicator.style.display = 
					isChecked ? "block" : "none";
				if ( !isPreventCommand ) {
					this.fireCommand ();
				}
			}
		}
	}
}

/**
 * MenuItemBinding factory.
 * @param {DOMDocument} ownerDocument
 */
MenuItemBinding.newInstance = function ( ownerDocument ) {

	var menuitem = DOMUtil.createElementNS ( Constants.NS_UI, "ui:menuitem", ownerDocument );
	UserInterface.registerBinding ( menuitem, MenuItemBinding );
	return UserInterface.getBinding ( menuitem );
}

PopupSetBinding.prototype = new MenuContainerBinding;
PopupSetBinding.prototype.constructor = PopupSetBinding;
PopupSetBinding.superclass = MenuContainerBinding.prototype;

/**
 * @class
 */
function PopupSetBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "PopupSetBinding" );
	
	/**
	 * Block common crawlers.
	 * @type {Map<string><boolean>}
	 * @overwrites {Binding#crawlerFilters}
	 */
	this.crawlerFilters	= new List ([ FlexBoxCrawler.ID, FocusCrawler.ID ]);
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
PopupSetBinding.prototype.toString = function () {

	return "[PopupSetBinding]";
}

PopupBinding.prototype = new Binding;
PopupBinding.prototype.constructor = PopupBinding;
PopupBinding.superclass = Binding.prototype;

PopupBinding.ACTION_SHOW 		= "popupshow";
PopupBinding.ACTION_HIDE 		= "popuphide";

PopupBinding.POSITION_TOP 		= "top";
PopupBinding.POSITION_RIGHT 	= "right";
PopupBinding.POSITION_BOTTOM 	= "bottom";
PopupBinding.POSITION_LEFT 		= "left";

PopupBinding.TYPE_NORMAL		= "normal";
PopupBinding.TYPE_FIXED			= "fixed"; // scrollbars on overflow
PopupBinding.FIXED_MAX			= 12;
PopupBinding.CLASSNAME_OVERFLOW	= "overflow";

/**
 * Indexing open popups.
 * @type {Map<string><PopupBinding>}
 */
PopupBinding.activeInstances = new Map ();

/**
 * Any popups open? Note that this method is only accurate 
 * within an error margin of zero milliseconds.
 * @see {PopupBinding#hide}
 * @return {boolean}
 */
PopupBinding.hasActiveInstances = function () {
	
	return PopupBinding.activeInstances.hasEntries ();
}

/**
 * Close active popups when a mousedown or mouseup is broadcasted globally. When the 
 * popup is associated to a ButtonBinding, an intricate setup prevents the popup 
 * from closing as soon as it opens (since the mouse event will both open and 
 * close the popup). Not pretty, but timing bugs were encoutered with other 
 * methods of handling this.
 * @see {ButtonStateManager#handleEvent}
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg This is usually a MouseEvent but it can also be a Binding.
 */
PopupBinding.handleBroadcast = function ( broadcast, arg ) {
	
	switch ( broadcast ) {
		case BroadcastMessages.MOUSEEVENT_MOUSEDOWN :
		case BroadcastMessages.MOUSEEVENT_MOUSEUP :
			if ( PopupBinding.activeInstances.hasEntries ()) {
				var list = new List ();
				PopupBinding.activeInstances.each ( function ( key ) {
					var popup = PopupBinding.activeInstances.get ( key );
					var isAbort = ( arg && arg instanceof ButtonBinding && arg.popupBinding == popup );
					if ( !isAbort ) {
						list.add ( popup );
					}
				});
				list.each ( function ( popup ) {
					popup.hide ();
				});
			}
			break;
		case BroadcastMessages.KEY_ESCAPE :
			if ( PopupBinding.activeInstances.hasEntries ()) {
				PopupBinding.activeInstances.each ( function ( key ) {
					var popup = PopupBinding.activeInstances.get ( key );
					popup.hide ();
				});
			}
			break;
	}
}

/*
 * Subscribing straight up.
 */
EventBroadcaster.subscribe ( BroadcastMessages.MOUSEEVENT_MOUSEDOWN, PopupBinding );
EventBroadcaster.subscribe ( BroadcastMessages.MOUSEEVENT_MOUSEUP, PopupBinding );
EventBroadcaster.subscribe ( BroadcastMessages.KEY_ESCAPE, PopupBinding );

/**
 * @class
 */
function PopupBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "PopupBinding" );

	/**
	 * This should be either a MenuBodyBinding or a PopupBodyBinding.
	 * @type {Binding}
	 */
	this._bodyBinding = null;

	/**
	 * @type {ShadowBinding}
	 * @private
	 */
	this._shadowBinding = null;

	/**
	 * @type {string}
	 */
	this.position = null;
	
	/**
	 * @type {boolean}
	 * @private
	 */
	this.isVisible = false;
	
	/**
	 * TODO: parse from markup
	 * @type {function}
	 */
	this.onshow = null;
	
	/**
	 * TODO: parse from markup
	 * @type {function}
	 */
	this.onhide = null;
	
	/**
	 * @type {object}
	 */
	this.geometry = null;
	
	/**
	 * @see {PopupBinding#_indexMenuContent}
	 * @type {HashMap<string><MenuItemBinding>}
	 */
	this._menuItems = null;
	
	/**
	 * @see {PopupBinding#_indexMenuContent}
	 * @type {HashMap<string><List<MenuGroupBinding>>}
	 */
	this._menuGroups = null;
	
	/**
	 * @type {int}
	 */
	this._menuItemCount = 0;
	
	/**
	 * If set to fixed, scrollbars may appear.
	 * @type {string}
	 */
	this.type = PopupBinding.TYPE_NORMAL;
	
	/** 
	 * Scrollbars are go?
	 * @type {boolean}
	 */
	this._isOverflow = false;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
PopupBinding.prototype.toString = function () {

	return "[PopupBinding]";
}

/**
 * Overloads {Binding#onBindingAttach}
 */
PopupBinding.prototype.onBindingAttach = function () {

	PopupBinding.superclass.onBindingAttach.call ( this );
	this.addActionListener ( Binding.ACTION_ATTACHED );
	
	this.geometry = { // please consider erecting a class for this!
		x : 0,
		y : 0,
		w : 0,
		h : 0
	}
	
	this.buildDOMContent ();
	this.parseDOMProperties ();
	this.assignDOMEvents ();
	
	if ( Client.isExplorer ) {
		this.buildShadowBinding ();
	}
}

/**
 * Dispose shadow when disposed.
 * @overloads {Binding#onBindingDispose}
 */
PopupBinding.prototype.onBindingDispose = function () {
	
	PopupBinding.superclass.onBindingDispose.call ( this );
	if ( PopupBinding.activeInstances.has ( this.key )) {
		PopupBinding.activeInstances.del ( this.key );
	}
	if  ( this._shadowBinding != null ) {
		this._shadowBinding.dispose ();
	}
}

/**
 * Build DOM content. Verifies body element.
 */
PopupBinding.prototype.buildDOMContent = function () {

	var menubody = DOMUtil.getElementsByTagName ( this.bindingElement, "menubody" ).item ( 0 );
	var popupbody = DOMUtil.getElementsByTagName ( this.bindingElement, "popupbody" ).item ( 0 );
	
	if ( menubody ) {
		this._bodyBinding = UserInterface.getBinding ( menubody );
	} else if ( popupbody ) {
		this._bodyBinding = UserInterface.getBinding ( popupbody );
	} else {
		if ( this.bindingElement.hasChildNodes ()) {
			throw new Error ( this + ": DOM structure invalid." );
		} else {
			this._bodyBinding = this.add ( 
				MenuBodyBinding.newInstance ( this.bindingDocument )
			).attach ();
		}
	}
	
	/*
	 * Prepare CSS transition effects.
	 */
	if ( Client.hasTransitions ) {
		this.bindingElement.style.opacity = "0";
	}
}

/**
 * Parse DOM properties.
 */
PopupBinding.prototype.parseDOMProperties = function () {

 	if ( !this.position ) {
		var position = this.getProperty ( "position" );
		this.position = position ? position : PopupBinding.POSITION_BOTTOM;
	}
}

/**
 * Build and configure a {@link ShadowBinding}. 
 * Mozilla uses CSS shadows to accomplish this. 
 */
PopupBinding.prototype.buildShadowBinding = function () {
	
	this._shadowBinding = ShadowBinding.newInstance ( this.bindingDocument );
	this._shadowBinding.attachClassName ( "popupshadow" );
	this._shadowBinding.offset = 3;
	this._shadowBinding.expand = 6;
	this._shadowBinding.shadow ( this );
	this._shadowBinding.attach ();
	
	this.shadowTree.shadow = this._shadowBinding;
}

/**
 * Assign DOM events.
 */
PopupBinding.prototype.assignDOMEvents = function () {

	this.addEventListener ( DOMEvents.MOUSEDOWN );
	this.addEventListener ( DOMEvents.MOUSEUP );
}

/**
 * When adding bindings, in fact they are added to the bodybinding.
 * @overloads {Binding#add}
 * @param {Binding} binding
 * @returns {Binding}
 */
PopupBinding.prototype.add = function ( binding ) {
	
	var returnable = null;
	if ( this._bodyBinding ) {
		this._bodyBinding.add ( binding );
		returnable = binding;
	} else {
		returnable = PopupBinding.superclass.add.call ( this, binding );
	}
	return returnable;
}

/**
 * @overloads {Binding#add}
 * @param {Binding} binding
 * @returns {Binding}
 */
PopupBinding.prototype.addFirst = function ( binding ) {
	
	var returnable = null;
	if ( this._bodyBinding ) {
		this._bodyBinding.addFirst ( binding );
		returnable = binding;
	} else {
		returnable = PopupBinding.superclass.addFirst.call ( this, binding );
	}
	return returnable;
}

/**
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
PopupBinding.prototype.handleAction = function ( action ) {
	
	PopupBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	
	switch ( action.type ) {
		case Binding.ACTION_ATTACHED :
			if ( binding instanceof MenuItemBinding ) {
				this._count ( true );
				action.consume ();
			}
			break;
		case Binding.ACTION_DETACHED :
			if ( binding instanceof MenuItemBinding ) {
				this._count ( false );
				action.consume ();
			}
			break;
	}
}

/**
 * Relevant for fixed popups.
 * @param {boolean} isPlus
 */
PopupBinding.prototype._count = function ( isPlus ) {
	
	if ( this.type == PopupBinding.TYPE_FIXED ) {
		this._menuItemCount = this._menuItemCount +  ( isPlus ? 1 : -1 );
		if ( !this._isOverflow ) {
			if ( this._menuItemCount >= PopupBinding.FIXED_MAX ) {
				this.attachClassName ( PopupBinding.CLASSNAME_OVERFLOW );
				this._isOverflow = true;
			}
		} else {
			if ( this._menuItemCount < PopupBinding.FIXED_MAX ) {
				this.bindingElement.style.height = "auto";
				this.detachClassName ( PopupBinding.CLASSNAME_OVERFLOW );
				this._isOverflow = false;
			}
		}
	}
}

/**
 * Snapt to target element.
 * @param {DOMElement} element
 */
PopupBinding.prototype.snapTo = function ( element ) {
	
	var point = this._getElementPosition ( element );
	
	switch ( this.position ) {
		case PopupBinding.POSITION_TOP :
			point.y -= this.bindingElement.offsetHeight;
			break;
		case PopupBinding.POSITION_RIGHT :
			point.x += element.offsetWidth;
			break;
		case PopupBinding.POSITION_BOTTOM :
			point.y += element.offsetHeight;
			break;
		case PopupBinding.POSITION_LEFT :
			point.x -= this.bindingElement.offsetWidth;
			break;
	}
	
	this.targetElement = element;
	this.bindingElement.style.display = "block";
	this.setPosition ( point.x, point.y );
}

/**
 * Position near mouse event and show.
 * @param {MouseEvent} e
 */
PopupBinding.prototype.snapToMouse = function ( e ) {

	this.snapToPoint ( this._getMousePosition ( e ));
}

/**
 * Position near point and show.
 * @param {Point} point
 */
PopupBinding.prototype.snapToPoint = function ( point ) {

	this.bindingElement.style.display = "block";
	this.setPosition ( point.x, point.y );
	this.show ();
}

/**
 * @param {int} x
 * @param {int} y
 */
PopupBinding.prototype.setPosition = function ( x, y ) {

	this.geometry.x = x;
	this.geometry.y = y;
	
	this.bindingElement.style.left = this.geometry.x + "px";
	this.bindingElement.style.top = this.geometry.y + "px";
}

/**
 * @return {Point}
 */
PopupBinding.prototype.getPosition = function ( x, y ) {

	return new Point ( 
		this.geometry.x, 
		this.geometry.y 
	);
}

/**
 * @returm {Dimension}
 */
PopupBinding.prototype.getDimension = function () {

	return new Dimension ( 
		this.bindingElement.offsetWidth,
		this.bindingElement.offsetHeight
	);
}


/**
 * Calculate position of target element. Result depends on whether or not 
 * the target element is located in the same document as the popup element. 
 * If not, we assume that the popup is located in the top frameset and use 
 * universal positioning.
 * TODO: MenuPopupBinding overwrites this method - eliminate the _underscore!
 * @param {DOMElement} element
 * @return {object}
 */
PopupBinding.prototype._getElementPosition = function ( element ) {

	return element.ownerDocument == this.bindingDocument ?
		DOMUtil.getGlobalPosition ( element ) :
		DOMUtil.getUniversalPosition ( element );
}

/**
 * Calculate mouse position on click. To save calculations, result depends on whether 
 * or not the clicked element is located in the same document as the popup element.
 * @param {MouseEvent} e
 */
PopupBinding.prototype._getMousePosition = function ( e ) {

	var element = DOMEvents.getTarget ( e );
	return element.ownerDocument == this.bindingDocument ?
		DOMUtil.getGlobalMousePosition ( e ) :
		DOMUtil.getUniversalMousePosition ( e );
}

/**
 * Show.
 * @overwrites {Binding#show}
 */
PopupBinding.prototype.show = function () {
	
	if ( this.isVisible == true) { // don't open an already open popup!
		
		this.hide (); // why does this make sense?
	}
	if ( !this.isVisible ) {
		
		PopupBinding.activeInstances.set ( this.key, this );
		this.bindingElement.style.display = "block";
		
		this.dispatchAction ( PopupBinding.ACTION_SHOW );
		this.fitOnScreen ();
		this._makeVisible ( true );
		
		if ( this._bodyBinding instanceof MenuBodyBinding ) {
			this._bodyBinding.refreshMenuGroups ();
		}
		if ( Client.isExplorer ) {
			this._bodyBinding.setDimension ( this.getDimension ());
		}
		
		/**
		 * Enable keyboard navigation.
		 */
		this._enableTab ( true );
		
		/* 
		 * Position the shadow.
		 */
		this.dispatchAction ( Binding.ACTION_VISIBILITYCHANGED );
		this.dispatchAction ( Binding.ACTION_POSITIONCHANGED );
		this.dispatchAction ( Binding.ACTION_DIMENSIONCHANGED );
	}
}

/**
 * Make visible!
 * @param {boolean} isVisible
 */
PopupBinding.prototype._makeVisible = function ( isVisible ) {
	
	var element = this.bindingElement;
	
	/*
	 * CSS transitions on fadeout was abandoned since 
	 * it may give the user time to press menuitems twice...
	 * TODO: Refactor menus to allow this?
	 */
	if ( isVisible ) {
		if ( Client.hasTransitions ) {
			element.style.visibility = "visible";
			element.style.opacity = "1";
		} else {
			element.style.visibility = "visible";
		}
	} else {
		element.style.visibility = "hidden";
		element.style.display = "none";
		if ( Client.hasTransitions ) {
			element.style.opacity = "0";
		}
	}
	
	/*
	if ( !Client.hasTransitions ) {
		if ( isVisible ) {
			element.style.visibility = "visible";
		} else {
			element.style.visibility = "hidden";
			element.style.display = "none";
		}
	} else {
		if ( isVisible ) {
			element.style.visibility = "visible";
			element.style.opacity = "1";
		} else {
			element.style.opacity = "0";
			var self = this;
			setTimeout ( function () {
				if ( !self.isVisible ) {
					element.style.visibility = "hidden";
					element.style.display = "none";
				}
			}, Animation.DEFAULT_TIME );
		}
	}
	*/
	
	this.isVisible = isVisible;
}

/**
 * Enable tabbing. The timeout prevents current selection from blurring when the menu opens.
 * TODO: Move this method to MenuBodyBinding if and when popups are used for non-menu purposes.
 * TODO: Kill this method now that it turns out that none of the above fixes our problem.
 * @param {boolean} isEnable
 */
PopupBinding.prototype._enableTab = function ( isEnable ) {
	
	var self = this;
	var menuItems = this.getDescendantBindingsByLocalName ( "menuitem" );
	
	setTimeout ( function () {
		if ( Binding.exists ( self ) == true ) {
			menuItems.each ( function ( menuItem ) {
				menuItem.bindingElement.tabIndex = isEnable ? 0 : -1;
			});
		}
	}, 0 );
}

/**
 * Hide.
 * @overwrites {Binding#hide}
 
 */
PopupBinding.prototype.hide = function () {
	
	this.releaseKeyboard ();
	
	if ( this.isVisible ) {
		
		/*
		this.bindingElement.style.visibility = "hidden";
		this.bindingElement.style.display = "none";
		*/
		this._makeVisible ( false );
		this.targetElement = null;
		
		this.dispatchAction ( Binding.ACTION_VISIBILITYCHANGED );
		this.dispatchAction ( PopupBinding.ACTION_HIDE );
		
		/**
		 * Disable keyboard navigation.
		 */
		this._enableTab ( false );
		
		/*
		 * This hacky timeout prevents a dialog from closing on return keypress 
		 * while a selector or a dialog is being handled inside the dialog. 
		 * @see {DialogToolBarBinding#handleBroadcast}
		 */
		var self = this;
		setTimeout ( function () {
			if ( !self.isVisible ) { // could have been reopened meanwhile!
				PopupBinding.activeInstances.del ( self.key );
			}
		}, 0 );

	}
}

/**
 * Dont open popups outside screen. Remember that MenuPopupBinding owerwrites this.
 * TODO: this adjusts position at odd times in Explorer!
 */
PopupBinding.prototype.fitOnScreen = function () {
	
	var x = this.bindingElement.offsetLeft;
	var y = this.bindingElement.offsetTop;
	var w = this.bindingElement.offsetWidth;
	var h = this.bindingElement.offsetHeight;
	
	var dim	= this.bindingWindow.WindowManager.getWindowDimensions ();
	var pos = this.boxObject.getUniversalPosition ();
	
	
	/*
	 * Snap to element. 
	 */
	if ( this.targetElement != null ) {
		if ( pos.y + h >= dim.h ) {
			
			/*
			 * This is somewhat hacky - but the "relative" switch 
			 * is effective (for now) in order to hack menupopups
			 */
			switch ( CSSComputer.getPosition ( this.bindingElement.offsetParent )) {
				case "absolute" :
					y = y - h - this.targetElement.offsetHeight;
					if ( y < 0 ) {
						y = 0;
					}
					break;
				case "relative" : // this *really* expects a menugroup...
					y = y - h + this.targetElement.offsetHeight + 9;
					break;
			}
		}
		if ( pos.x + w >= dim.w ) {
			x -= w;
			switch ( this.position ) {
				case PopupBinding.POSITION_RIGHT :
					x -= this.targetElement.offsetWidth;
					break;
				case PopupBinding.POSITION_BOTTOM :
					x += this.targetElement.offsetWidth;
					break;
			}
		}
	} 
	/*
	 * Snap to mouse.
	 */
	else {
		if ( pos.y + h >= dim.h ) {
			y -= h;
			if ( y < 0 ) {
				y = 0;
			}
		}
		if ( pos.x + w >= dim.w ) {
			x -= w;
			if ( x < 0 ) {
				x = 0;
			}
		}
	}
	this.setPosition ( x, y );
}

/**
 * Mousevents will be consumed in order not to close 
 * the popup while handling menuitems. When clicking 
 * a MenuItem, the mouseup event is broadcasted via 
 * the EventBroadcaster, effectively closing the Popup.
 * @implements {IEventListener}
 * @overloads {Binding#handleEvent}
 * @param {MouseEvent} e
 */
PopupBinding.prototype.handleEvent = function ( e ) {

	PopupBinding.superclass.handleEvent.call ( this, e );
	DOMEvents.stopPropagation ( e );
}

/**
 * Empty content (of body).
 */
PopupBinding.prototype.empty = function () {

	this._bodyBinding.detachRecursive ();
	this._bodyBinding.bindingElement.innerHTML = "";
}

/**
 * Grab keyboard control. This could theoretically be done automatically when 
 * popup is opened, but this would conflict with keyboard navigation in menus 
 * supposing it should work like os native menus.
 * @see {MenuBodyBinding#grabKeyboard}
 * @param {boolean} isDefaultAction
 */
PopupBinding.prototype.grabKeyboard = function ( isDefaultAction ) {
	
	// EHM - WHO IS SUPPOSED TO CALL THIS METHOD?
	
	/*
	 * Simpley relay keyboard control to the contained MenuBodyBinding.
	 *
	if ( this._bodyBinding instanceof MenuBodyBinding ) {
		this._bodyBinding.grabKeyboard ( isDefaultAction );
	}
	*/
}

/**
 * Release keyboard control.
 */
PopupBinding.prototype.releaseKeyboard = function () {

	// alert ( "PopupBinding.prototype.releaseKeyboard was deprecated - it seems we still use it!" );
	
	if ( this._bodyBinding != null && this._bodyBinding instanceof MenuBodyBinding ) {
		this._bodyBinding.releaseKeyboard ();
	}
}

/**
 * You should invoke this method manually in order to index menu content!
 */
PopupBinding.prototype._indexMenuContent = function () {

	this._menuItems = {};
	this._menuGroups = {};

	// indexing menugroups
	var list = this.getDescendantBindingsByLocalName ( "menugroup" );
	while ( list.hasNext ()) {
		var item = list.getNext ();
		var rel = item.getProperty ( "rel" );
		if ( rel ) {
			if ( !this._menuGroups [ rel ]) {
				this._menuGroups [ rel ] = new List ();
			}
			this._menuGroups [ rel ].add ( item );
		}
	}
	
	// indexing menuitems
	list = this.getDescendantBindingsByLocalName ( "menuitem" );
	while ( list.hasNext ()) {
		var item = list.getNext ();
		var cmd = item.getProperty ( "cmd" );
		this._menuItems [ cmd ] = item;
	}
}

/**
 * @see {PopupBinding#_indexMenuContent}
 * @return {MenuItemBinding}
 */
PopupBinding.prototype.getMenuItemForCommand = function ( cmd ) {

	var result = null;

	if ( this._menuItems ) {
		if ( this._menuItems [ cmd ]) {
			result = this._menuItems [ cmd ];
		} else {
			throw "PopupBinding.getMenuItemForCommand: No binding for command " + cmd;
		}
	} else {
		throw "Must invoke _indexMenuContent method first!";
	}
	return result;
}

/* 
 * Remembering that bindings may not be 
 * attached we carefully avoid using the 
 * getChildBindingsByLocalName method.
 */
PopupBinding.prototype.clear = function () { 
	
	var bodyBinding = this._bodyBinding;
	if ( bodyBinding ) {
		bodyBinding.detachRecursive ();
		bodyBinding.bindingElement.innerHTML = "";
	}
	
	this._menuItemCount = 0;
}

/**
 * MYBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {MYBinding}
 */
PopupBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:popup", ownerDocument );
	return UserInterface.registerBinding ( element, PopupBinding );
}

PopupBodyBinding.prototype = new Binding;
PopupBodyBinding.prototype.constructor = PopupBodyBinding;
PopupBodyBinding.superclass = Binding.prototype;

/**
 * @class
 */
function PopupBodyBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "PopupBodyBinding" );
}

/**
 * Identifies binding.
 */
PopupBodyBinding.prototype.toString = function () {

	return "[PopupBodyBinding]";
}

/**
 * Emulates basic CSS support in Explorer. Invoked by the containing {@link PopupBinding}.
 * @param {Dimension} dim
 */
PopupBodyBinding.prototype.setDimension = function ( dim ) {
	
	this.getBindingElement ().style.width = new String ( dim.w ) + "px";
}

/**
 * PopupBodyBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {PopupBodyBinding}
 */
PopupBodyBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:popupbody", ownerDocument );
	return UserInterface.registerBinding ( element, PopupBodyBinding );
}

MenuPopupBinding.prototype = new PopupBinding;
MenuPopupBinding.prototype.constructor = MenuPopupBinding;
MenuPopupBinding.superclass = PopupBinding.prototype;

function MenuPopupBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "MenuPopupBinding" );
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
MenuPopupBinding.prototype.toString = function () {

	return "[MenuPopupBinding]";
}

/**
 * Menupopups are always positioned in a local coordinate space.
 * @overwrites {PopupBinding#_getElementPosition}.
 * @param {DOMElement} element
 * @return {Point}
 */
MenuPopupBinding.prototype._getElementPosition = function ( element ) {

	return new Point ( element.offsetLeft, 0 );
}

/**
 * MenuPopupBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {MenuPopupBinding}
 */
MenuPopupBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:menupopup", ownerDocument );
	return UserInterface.registerBinding ( element, MenuPopupBinding );
}

DialogBinding.prototype = new ControlBoxBinding;
DialogBinding.prototype.constructor = DialogBinding;
DialogBinding.superclass = ControlBoxBinding.prototype;

DialogBinding.MODE_DRAGGING	= "dialogdragging";
DialogBinding.MODE_RESIZING = "dialogresizing";
DialogBinding.ACTION_OPEN = "dialogopen";
DialogBinding.ACTION_CLOSE = "dialogclose";
DialogBinding.DEFAULT_WIDTH = 540;
DialogBinding.DEFAULT_HEIGHT = 100;

/**
 * @class
 * @implements {IActivatable}
 */
function DialogBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DialogBinding" );
	
	/**
	 * Don't flex unless maximized - and we do not yet support maximization.
	 * @overloads {FlexBoxBinding#isFlexible}
	 */
	this.isFlexible = false;
	
	/**
	 * @type {DialogMatrixBinding}
	 */
	this._matrix = null;
	
	/**
	 * @type {DialogHeadBinding}
	 */
	this._head = null;
	
	/**
	 * @type {DialogBodyBinding}
	 */
	this._body = null;
	
	/**
	 * @type {DialogCoverBinding}
	 */
	this._cover = null;
	
	/**
	 * @type {TitleBarBinding}
	 */
	this._titlebar = null;
	
	/**
	 * This property is set to an instance of {@link DialogBorderBinding} when resizing.
	 * @type {DialogBorderBinding}
	 */
	this._border = null;
	
	/**
	 * @type {ShadowBinding}
	 */
	this.shadowBinding = null;
	
	/**
	 * Relevant for dragging scenario.
	 * @type {Point}
	 */
	this.startPoint = null;
	
	/**
	 * Stores position and dimension data.
	 * @type {object}
	 */
	this.geometry = null;
	
	/**
	 * @type {boolean}
	 */
	this.isActive = false;
	
	/**
	 * @type {boolean}
	 */
	this.isActivatable = false;
	
	/**
	 * TODO: RENAME ISOPEN!
	 * @type {boolean}
	 */
	this.isVisible = false;
	
	/**
	 * @type {boolean}
	 */
	this._isResizable = true;
	
	/**
	 * @type {boolean}
	 */
	this.isDialogResizable = true;
	
	/**
	 * @type {boolean}
	 */
	this.isModal = false;
	
	/**
	 * @type {string}
	 */
	this.mode = null;
	
	/**
	 * @type {HashMap<string><ControlBinding>}
	 */
	this.controlBindings = {};
	
	/**
	 * @type {int}
	 */
	this._index = null;
	
	/**
	 * THIS SHOULD BE DECLARED
	 * @type {Dimension}
	 *
	this.startDimension = null;
	*/
	
	/**
	 * Use fancy CSS transitions? Disabled for now...
	 * @type {boolean}
	 */
	this._hasTransitions = false; // Client.hasTransitions
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
DialogBinding.prototype.toString = function () {

	return "[DialogBinding]";
}

/*
 * Overloads {FlexBoxBinding#onBindingRegister}
 */
DialogBinding.prototype.onBindingRegister = function () {

	DialogBinding.superclass.onBindingRegister.call ( this ); 
	
	this.addActionListener ( Binding.ACTION_DRAG, this );
	this.addActionListener ( FocusBinding.ACTION_ACTIVATED );
	this.subscribe ( this.bindingWindow.WindowManager.WINDOW_RESIZED_BROADCAST );
	
	this.buildDescendantBindings ();
}

/**
 * Overloads {Binding#onBindingAttach}
 */
DialogBinding.prototype.onBindingAttach = function () {

	DialogBinding.superclass.onBindingAttach.call ( this );
	this.geometry = this.computeDefaultGeometry ();
	
	this.parseDOMProperties ();
	this.buildControlBindings ();
	this.buildBorderBindings ();
	this.attachRecursive ();
	
	if ( Client.isExplorer ) {
		this.buildShadowBinding ();
	}
	
	if ( this._isResizable ) {
		this.attachClassName ( "resizable" );	
	}
	
	if ( this._hasTransitions ) {
		this.bindingElement.style.opacity = "0";
	}
	
	this.setPosition ( new Point ( 0, 0 ));
	this.setDimension ( new Dimension ( DialogBinding.DEFAULT_WIDTH, DialogBinding.DEFAULT_HEIGHT ));
	if ( this.getProperty ( "open" )) {
		this.open ();
	}
}

/**
 * Build descendant bindings.
 * TODO: finally overwrite the add method?
 */
DialogBinding.prototype.buildDescendantBindings = function () {

	// these are always appended dynamically
	this._matrix = DialogMatrixBinding.newInstance ( this.bindingDocument );
	this._head = DialogHeadBinding.newInstance ( this.bindingDocument );
	this._titlebar = DialogTitleBarBinding.newInstance ( this.bindingDocument );
	this.add ( this._matrix );
	this.addFirst ( this._head );
	this._head.add ( this._titlebar );

	// the dialog body may be declared; if not, we append it dynamically
	var dialogbody = DOMUtil.getElementsByTagName ( this.bindingElement, "dialogbody" ).item ( 0 );	
	if ( dialogbody ) {
		this._body = UserInterface.getBinding ( dialogbody );
	} else {
		this._body = DialogBodyBinding.newInstance ( this.bindingDocument );
		this.add ( this._body );
	}
}

/**
 * Build borders.
 */
DialogBinding.prototype.buildBorderBindings = function () {

	var directions = new List ([ 
		DialogBorderBinding.TYPE_NORTH,
		DialogBorderBinding.TYPE_SOUTH,
		DialogBorderBinding.TYPE_EAST,
		DialogBorderBinding.TYPE_WEST
	]);
	while ( directions.hasNext ()) {
		var border = DialogBorderBinding.newInstance ( this.bindingDocument );
		border.setType ( directions.getNext ());
		this.add ( border );
	}
}

/**
 * Build and configure a {@link ShadowBinding}
 * Mozilla uses CSS shadows to accomplish this. 
 */
DialogBinding.prototype.buildShadowBinding = function () {

	this.shadowBinding = ShadowBinding.newInstance ( this.bindingDocument );
	this.shadowBinding.attachClassName ( "dialogshadow" );
	this.shadowBinding.shadow ( this );
	this.shadowBinding.attach ();
}

/**
 * Build dialog controls.
 */
DialogBinding.prototype.buildControlBindings = function () {
	
	var controls = this.getProperty ( "controls" );
	if ( controls ) {
		var types = new List ( controls.split ( " " ));
		while ( types.hasNext ()) {
			var type = types.getNext ();
			switch ( type ) {
				case ControlBinding.TYPE_MAXIMIZE :
				case ControlBinding.TYPE_MINIMIZE :
				case ControlBinding.TYPE_CLOSE :
					var controlBinding = DialogControlBinding.newInstance ( this.bindingDocument );
					controlBinding.setControlType ( type );
					this._titlebar.addControl ( controlBinding );
					this.controlBindings [ type ] = controlBinding;
					break;
				default :
					throw new Error ( 
						"DialogBinding: Control not added: " + type
					);
					break;
			}
		}
	}
}

/**
 * Build and configure a {@link DialogCoverBinding}
 */
DialogBinding.prototype.buildDialogCoverBinding = function () {
	
	this._cover = DialogCoverBinding.newInstance ( this.bindingDocument );
	this.getAncestorBindingByLocalName ( "dialogset" ).add ( this._cover );
	this._cover.cover ( this);
}

/**
 * Parse DOM properties.
 */
DialogBinding.prototype.parseDOMProperties = function () {

	var image 		= this.getProperty ( "image" );
	var label 		= this.getProperty ( "label" );
	var draggable 	= this.getProperty ( "draggable" );
	var resizable 	= this.getProperty ( "resizable" );
	var modal 		= this.getProperty ( "modal" );
	
	if ( image ) {
		this.setImage ( image );
	}
	if ( label ) {
		this.setLabel ( label );
	}
	if ( draggable == false ) {
		this.isDialogDraggable = false;
	}
	if ( resizable == false ) {
		this.isPanelResizable = false;
	}
	if ( modal == true ) {
		this.setModal ( true );
	}
}

/**
 * Set modal.
 * @param {boolean} isModal
 */
DialogBinding.prototype.setModal = function ( isModal ) {
	
	this.isModal = isModal;
}

/**
 * Set label.
 * @param {string} label
 */
DialogBinding.prototype.setLabel = function ( label ) {

	this.setProperty ( "label", label );
	if ( this.isAttached == true ) {
		this._titlebar.setLabel ( 
			Resolver.resolve ( label )
		) 
	};
}

/**
 * Get label.
 * @return {string}
 */
DialogBinding.prototype.getLabel = function () {

	return this.getProperty ( "label" );
}

/**
 * Set image.
 * @param {string} url
 */
DialogBinding.prototype.setImage = function ( url ) {

	this.setProperty ( "image", url );
	if ( this.isAttached ) {
		this._titlebar.setImage ( 
			Resolver.resolve ( url )
		) 
	};
}

/**
 * @overloads {ControlBoxBinding#handleAction}
 * @implements {IActionListener}
 * @param {Action} action
 */
DialogBinding.prototype.handleAction = function ( action ) {
	
	DialogBinding.superclass.handleAction.call ( this, action );
		
	switch ( action.type ) {
	
		case Binding.ACTION_DRAG :
			
			var binding = action.target;		
			if ( this.getState () == ControlBoxBinding.STATE_NORMAL ) {
				switch ( binding.constructor ) {
					case DialogTitleBarBinding :	
						this.mode = DialogBinding.MODE_DRAGGING;
						binding.dragger.registerHandler ( this );
						break;
					case DialogBorderBinding :
						if ( this._isResizable ) {
							this.mode = DialogBinding.MODE_RESIZING;
							this._border = binding;
							binding.dragger.registerHandler ( this );
						}
						break;
				}
			}
			action.consume ();
			break;
		
		case Binding.ACTION_ACTIVATED : 
			if ( !this.isActive ) {
				this.activate ();
			}
			action.consume ();
			break;
			
		/*
		case FocusBinding.ACTION_ACTIVATED :
			
			/*
			 * Simply consume the action. The FocusBinding 
			 * can now analyze the action to get a handle on 
			 * this DialogBinding.
			 *
			this.focusBinding = binding;
			action.consume ();
			break;
		*/
	}
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
DialogBinding.prototype.handleBroadcast = function ( broadcast, arg ) {

	DialogBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		case this.bindingWindow.WindowManager.WINDOW_RESIZED_BROADCAST :
			this.startPoint = this.getPosition ();
			this._setComputedPosition ( 
				new Point ( 0, 0 )
			);
			break;
	}
}

/**
 * Invoked when descendant controls fire.
 * @overloads {ControlBoxBinding#handleInvokedControl}
 * @param {ControlBinding} control
 */
DialogBinding.prototype.handleInvokedControl = function ( control ) {
	
	DialogBinding.superclass.handleInvokedControl.call ( this, control );
	
	switch ( control.controlType ) {
		case ControlBinding.TYPE_CLOSE :
			this.close ();
			break;
	}
}

/**
 * Open dialog.
 * @param {boolean} isAutoHeight Needed to fix an IE bug, see {@link StageDialogBinding#_parsePageBinding} 
 */
DialogBinding.prototype.open = function ( isAutoHeight ) {
	
	if ( this.isModal && this._cover == null ) {
		this.buildDialogCoverBinding ();
	}
	if ( !this.isVisible ) { // WHEN RENAMING THIS TO ISOPEN, SEE STAGEDIALOGBINDING ESCAPE STUFF
	
		this.setProperty ( "open", "true" );
		this.isVisible = true;
		this.isActivatable = true;
		this.activate ();
		
		if ( isAutoHeight ) {
			/*
			 * centering and flexing needs to be performed 
			 * after this method, see StageDialogBinding
			 */
		} else {
			this.centerOnScreen ();
			this.reflex ( true );
		}
		
		this.bindingElement.style.marginTop = "0";
		this.dispatchAction ( DialogBinding.ACTION_OPEN );
		this.dispatchAction ( Binding.ACTION_VISIBILITYCHANGED );
		
		if ( this._hasTransitions ) {
			this.bindingElement.style.opacity = "1";
		}
	}
}

/**
 * Close dialog.
 */
DialogBinding.prototype.close = function () {
	
	if ( this.isVisible ) {
		
		this.isActivatable = false;
		this.deActivate ();
		
		var self = this;
		function doit () {
			
			self.isVisible = false;
			self.deleteProperty ( "open" );
			
			if ( self.shadowBinding != null ) {
				self.dispatchAction ( Binding.ACTION_VISIBILITYCHANGED );
			}
			
			self.bindingElement.style.marginTop = "-10000px";
			self.dispatchAction ( DialogBinding.ACTION_CLOSE );
		}
		
		if ( !this._hasTransitions ) {
			doit ();
		} else {
			var element = self.bindingElement;
			setTimeout ( function () {
				element.style.opacity = "0";
				setTimeout ( function () {
					doit ();
				}, Animation.DEFAULT_TIME );
			}, Animation.DEFAULT_TIME );
		}
	}
}

/**
 * Activate.
 * @implements {IActivatable}
 */
DialogBinding.prototype.activate = function () {

	if ( !this.isActive ) {
		this.isActive = true;
		this.attachClassName ( "active" );
		this.moveToTop ();
		this._titlebar.onActivate ();
		Application.activate ( this );
	}
}

/**
 * Deactivate.
 * @implements {IActivatable}
 */
DialogBinding.prototype.deActivate = function () {

	if ( this.isActive == true ) {			
		this.isActive = false;
		this.detachClassName ( "active" );
		this._titlebar.onDeactivate ();
		Application.deActivate ( this );
	}
}

/**
 * Move panel to highest z-index. Invoked when dialog is activated.
 */
DialogBinding.prototype.moveToTop = function () {
	
	/*
	 * First event intercepted by the DialogSetBinding.
	 * Second event intercepted by the DialogCoverBinding (if present).
	 */
	this.dispatchAction ( Binding.ACTION_MOVETOTOP );
	this.dispatchAction ( Binding.ACTION_MOVEDONTOP );
}

/** 
 * Get z-index.
 * @return {int}
 */
DialogBinding.prototype.getZIndex = function () {
	
	return CSSComputer.getZIndex ( this.bindingElement );
}

/** 
 * Set z-index.
 * @param {int} index
 */
DialogBinding.prototype.setZIndex = function ( index ) {
	
	this.bindingElement.style.zIndex = new String ( index );
}

/**
 * @param {Point} point This argument is not used.
 */
DialogBinding.prototype.onDragStart = function ( point ) {

	switch ( this.mode ) {
		case DialogBinding.MODE_DRAGGING :
		case DialogBinding.MODE_RESIZING :
			this.startPoint = new Point (
				this.bindingElement.offsetLeft,
				this.bindingElement.offsetTop
			);
			this.startDimension = new Dimension (
				this.bindingElement.offsetWidth,
				this.bindingElement.offsetHeight
			);
			break;
	}
}

/**
 * @param {Point} diff
 */
DialogBinding.prototype.onDrag = function ( diff ) {
	
	switch ( this.mode ) {
		case DialogBinding.MODE_DRAGGING :
			this._setComputedPosition ( diff );
			break;
		case DialogBinding.MODE_RESIZING :
			switch ( this._border.getType ()) {
				case DialogBorderBinding.TYPE_NORTH :
					this.resizeNorth ( diff );
					break;
				case DialogBorderBinding.TYPE_SOUTH :
					this.resizeSouth ( diff );
					break;
				case DialogBorderBinding.TYPE_EAST :
					this.resizeEast ( diff );
					break;
				case DialogBorderBinding.TYPE_WEST :
					this.resizeWest ( diff );
					break;
			}
			
			/*
			 * notice the boolean parameter, invoking fast screen update. 
			 * This could potentially threaten Explorer if the dialog 
			 * contains lots of stuff. This works terrible in Mozilla!
			 */
			this.reflex ( true );
			break;
	}
}

/**
 * @param {Point} diff
 */
DialogBinding.prototype.onDragStop = function ( diff ) {

	switch ( this.mode ) {
		case DialogBinding.MODE_DRAGGING :
			this._setComputedPosition ( diff );
			break;
		case DialogBinding.MODE_RESIZING :
			break;
	}
	this.mode = null;
}

/**
 * Resize north.
 * @param {Point} diff
 */
DialogBinding.prototype.resizeNorth = function ( diff ) {

	this.setPosition ( new Point ( this.startPoint.x, this.startPoint.y + diff.y ));
	this.setDimension ( new Dimension ( this.startDimension.w, this.startDimension.h - diff.y ));
}

/**
 * Resize south.
 * @param {Point} diff
 */
DialogBinding.prototype.resizeSouth = function ( diff ) {

	this.setDimension ( new Dimension ( this.startDimension.w, this.startDimension.h + diff.y ));
}

/**
 * Resize east.
 * @param {Point} diff
 */
DialogBinding.prototype.resizeEast = function ( diff ) {

	this.setDimension ( new Dimension ( this.startDimension.w + diff.x, this.startDimension.h ));
}

/**
 * Resize west.
 * @param {Point} diff
 */
DialogBinding.prototype.resizeWest = function ( diff ) {

	this.setPosition ( new Point ( this.startPoint.x + diff.x, this.startPoint.y ));
	this.setDimension ( new Dimension ( this.startDimension.w - diff.x, this.startDimension.h ));
	
}

/**
 * Keep dialog on screen.
 * @param {Point} diff
 */
DialogBinding.prototype._setComputedPosition = function ( diff ) {

 	var win = this.bindingWindow.WindowManager.getWindowDimensions ();
 	var dim = this.getDimension ();
 	
	var x = this.startPoint.x + diff.x;
	var y = this.startPoint.y + diff.y;
	
	x = x < 0 ? 0 : x + dim.w > win.w ? win.w - dim.w : x;
	y = y < 0 ? 0 : y + dim.h > win.h ? win.h - dim.h : y;
	
	this.setPosition ( new Point (  x, y ));
}

/**
 * Set position.
 * @param {Point} p 
 */
DialogBinding.prototype.setPosition = function ( p ) {
	
	var x = p.x;
	var y = p.y;
	
	x = Math.round ( x );
	this.bindingElement.style.left = x + "px";
	this.geometry.x = x;

	y = Math.round ( y );
	this.bindingElement.style.top = y + "px";
	this.geometry.y = y;
	
	if ( this.shadowBinding != null ) {
		this.dispatchAction ( 
			Binding.ACTION_POSITIONCHANGED 
		);
	}
}

/**
 * Get position.
 * @return {Point}
 */
DialogBinding.prototype.getPosition = function () {

	return new Point ( 
		this.geometry.x,
		this.geometry.y 
	);
}

/**
 * Set Dimension.
 * @param {number} w
 * @param {number} h
 */
DialogBinding.prototype.setDimension = function ( dim ) {
	
	if ( !dim ) {
		SystemDebug.stack ( arguments );
	}
	
	var w = dim.w;
	var h = dim.h;
	
	w = Math.round ( w );
	this.bindingElement.style.width = w + "px";
	this.geometry.w = w;
	h = Math.round ( h );
	this.bindingElement.style.height = h + "px";
	this.geometry.h = h;
	
	if ( this.shadowBinding != null ) {
		this.dispatchAction ( 
			Binding.ACTION_DIMENSIONCHANGED 
		);
	}
}

/**
 * Get dimension.
 * @return {Dimension}
 */
DialogBinding.prototype.getDimension = function () {

	return new Dimension ( 
		this.geometry.w,
		this.geometry.h 
	);
}

/**
 * Set resizable.
 * @param {boolean} isResizable
 */
DialogBinding.prototype.setResizable = function ( isResizable ) {
	
	if ( this._isResizable != isResizable ) {
		if ( isResizable ) {
			this.attachClassName ( "resizable" );
		} else {
			this.detachClassName ( "resizable" );
		}
		this._isResizable = isResizable;
	}
}

/**
 * Compute default geometry. This is pretty lame.
 * @return {object}
 */
DialogBinding.prototype.computeDefaultGeometry = function () {
	
	var result	= null;
	var width 	= this.bindingDocument.body.offsetWidth;
	var height 	= this.bindingDocument.body.offsetHeight;
	
	result = {
		x : 0.125 * width,
		y : 0.125 * height,
		w : 0.750 * width,
		h : 0.500 * height
	}
	return result;
}

/**
 * This actually centers the dialog in the containing *window*.
 */
DialogBinding.prototype.centerOnScreen = function () {
	
	var winDim = this.bindingWindow.WindowManager.getWindowDimensions ();
	var dim = this.getDimension ();
	
	this.setPosition ( new Point (
			0.5 * ( winDim.w - dim.w ),
			0.5 * ( winDim.h - dim.h )
		)
	)
}

/**
 * This method is invoked on modal panels by the {@link DialogCoverBinding}.
 */
DialogBinding.prototype.alert = function () {
	
	var binding = this;
	var i = 0;
	
	function blink () {
		if ( i % 2 == 0 ) {
			binding.detachClassName ( "active" );
		} else {
			binding.attachClassName ( "active" );
		}
		if ( i++ < 7 ) {
			setTimeout ( blink, 50 );
		}
	};
	blink ();
}

/**
 * Set dialog controls, disposing existing controls.
 * TODO: method not tested.
 * @param {List<string>} list
 */
DialogBinding.prototype.setControls = function ( list ) {
	
	for ( var type in this.controlBindings ) {
		this.controlBindings [ type ].dispose ();
	}
	var controls = "";
	while ( list.hasNext ()) {
		var type = list.getNext ();
		controls += type + list.hasNext () ? " " : "";
	}
	this.setProperty ( "controls", controls );
	
	if ( this.isAttached ) {
		this.buildControlBindings ();
	}
}

/**
 * DialogBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {DialogBinding}
 */
DialogBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:dialog", ownerDocument );
	return UserInterface.registerBinding ( element, DialogBinding );
}

DialogHeadBinding.prototype = new Binding;
DialogHeadBinding.prototype.constructor = DialogHeadBinding;
DialogHeadBinding.superclass = Binding.prototype;

/**
 * @class
 */
function DialogHeadBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DialogHeadBinding" );
}

/**
 * Identifies binding.
 */
DialogHeadBinding.prototype.toString = function () {

	return "[DialogHeadBinding]";
}

/**
 * DialogHeadBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {DialogHeadBinding}
 */
DialogHeadBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:dialoghead", ownerDocument );
	return UserInterface.registerBinding ( element, DialogHeadBinding );
}

DialogBodyBinding.prototype = new FlexBoxBinding;
DialogBodyBinding.prototype.constructor = DialogBodyBinding;
DialogBodyBinding.superclass = FlexBoxBinding.prototype;

/**
 * @class
 */
function DialogBodyBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DialogBodyBinding" );
	
	/**
	 * @type {DialogBinding}
	 */
	this.panelBinding = null;
	
	/**
	 * @type {boolean}
	 */
	this.isVisible = true;
	
	/**
	 * @type {DialogBinding}
	 */
	this._dialogBinding = null;
}

/**
 * Identifies binding.
 */
DialogBodyBinding.prototype.toString = function () {

	return "[DialogBodyBinding]";
}

/**
 * @overloads {Binding#onBindingAttach}
 */
DialogBodyBinding.prototype.onBindingAttach = function () {

	DialogBodyBinding.superclass.onBindingAttach.call ( this );
	this._dialogBinding = UserInterface.getBinding ( this.bindingElement.parentNode );
}

/**
 * Get position as requested by the {@link ViewBinding} 
 * compensating for dialog border dimensions.
 * @return {Dimension}
 */
DialogBodyBinding.prototype.getPosition = function () {
	
	var pos = this._dialogBinding.getPosition ();
	
	return new Position ( 
		pos.x + this.offsetLeft + DialogBorderBinding.DIMENSION,
		pos.y + this.offsetTop
	);
}

/**
 * Get dimension as requested by the {@link ViewBinding} 
 * compensating for dialog border dimensions.
 * @return {Dimension}
 */
DialogBodyBinding.prototype.getDimension = function () {

	var dim = this.boxObject.getDimension ();
	
	return new Dimension (
		dim.w - 2 * DialogBorderBinding.DIMENSION,
		dim.h - DialogBorderBinding.DIMENSION
	);
}

/**
 * DialogBodyBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {DialogBodyBinding}
 */
DialogBodyBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:dialogbody", ownerDocument );
	return UserInterface.registerBinding ( element, DialogBodyBinding );
}

DialogMatrixBinding.prototype = new MatrixBinding;
DialogMatrixBinding.prototype.constructor = DialogMatrixBinding;
DialogMatrixBinding.superclass = MatrixBinding.prototype;

/**
 * @class
 */
function DialogMatrixBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DialogMatrixBinding" );
	
	/**
	 * @overwrites {Binding#isDraggable}
	 * @type {boolean}
	 */
	this.isDraggable = true;
	
	/**
	 * This property is set by the containing {@link DialogBinding}.
	 * @type {string}
	 * @private
	 */
	this._type = null;
}

/**
 * Identifies binding.
 */
DialogMatrixBinding.prototype.toString = function () {

	return "[DialogMatrixBinding]";
}

/**
 * @overloads {MatrixBinding#onBindingAttach}.
 */
DialogMatrixBinding.prototype.onBindingAttach = function () {

	DialogMatrixBinding.superclass.onBindingAttach.call ( this );
	this.shadowTree.table.className = "matrix dialogmatrix";
	
	/*
	 * Bug implodes table in explorer unless content is added.
	 */
	this._indexTable ();
	this.shadowTree [ MatrixBinding.CENTER ].appendChild ( 
		this.bindingDocument.createTextNode ( "." )
	);
}

/**
 * DialogMatrixBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {DialogMatrixBinding}
 */
DialogMatrixBinding.newInstance = function ( ownerDocument ) {
	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:dialogmatrix", ownerDocument );
	return UserInterface.registerBinding ( element, DialogMatrixBinding );
}

DialogSetBinding.prototype = new Binding;
DialogSetBinding.prototype.constructor = DialogSetBinding;
DialogSetBinding.superclass = Binding.prototype;

/**
 * @class
 */
function DialogSetBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DialogSetBinding" );
}

/**
 * Identifies binding.
 */
DialogSetBinding.prototype.toString = function () {

	return "[DialogSetBinding]";
}

/**
 * Overloads {Binding#onBindingAttach}
 */
DialogSetBinding.prototype.onBindingAttach = function () {
	
	DialogSetBinding.superclass.onBindingAttach.call ( this );
	
	this.addActionListener ( Binding.ACTION_MOVETOTOP, this );
	this.addActionListener ( Binding.ACTION_MOVEDONTOP, this );
}

/**
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
DialogSetBinding.prototype.handleAction = function ( action ) {

	DialogSetBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;

	switch ( action.type ) {
		case Binding.ACTION_MOVETOTOP :
			if ( binding instanceof DialogBinding ) {
				this._moveToTop ( binding );
			}
			break;
		case Binding.ACTION_MOVEDONTOP :
			action.consume ();
			break;
	}
}

/**
 * Move dialog to highest z-index. Increment index by three so that the 
 * {@link DialogCoverBinding} can fit the slot between two dialogs.
 * @param {DialogBinding} binding
 */
DialogSetBinding.prototype._moveToTop = function ( binding ) {
	
	var maxIndex = 0;
	var dialogs = this.getChildBindingsByLocalName ( "dialog" );
	
	dialogs.each ( function ( dialog ) {
		var index = dialog.getZIndex ();
		maxIndex = index > maxIndex ? index : maxIndex;
	});
	
	binding.setZIndex ( maxIndex + 2 );
}

DialogBorderBinding.prototype = new Binding;
DialogBorderBinding.prototype.constructor = DialogBorderBinding;
DialogBorderBinding.superclass = Binding.prototype;

DialogBorderBinding.TYPE_NORTH	= "n";
DialogBorderBinding.TYPE_SOUTH 	= "s";
DialogBorderBinding.TYPE_EAST 	= "e";
DialogBorderBinding.TYPE_WEST 	= "w";
DialogBorderBinding.DIMENSION 	= 4;

/**
 * @class
 */
function DialogBorderBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DialogBorderBinding" );
	
	/**
	 * Overwrites super property.
	 * @type {boolean}
	 */
	this.isDraggable = true;
	
	/**
	 * This property is set by the containing {@link DialogBinding}.
	 * @type {string}
	 * @private
	 */
	this._type = null;
}

/**
 * Identifies binding.
 */
DialogBorderBinding.prototype.toString = function () {

	return "[DialogBorderBinding]";
}

/**
 * @param {string} type
 */
DialogBorderBinding.prototype.setType = function ( type ) {
 
	this.attachClassName ( type );
	this._type = type;
}

/**
 * @return {string}
 */
DialogBorderBinding.prototype.getType = function () {

	return this._type;
}

/**
 * DialogBorderBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {DialogBorderBinding}
 */
DialogBorderBinding.newInstance = function ( ownerDocument ) {
	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:dialogborder", ownerDocument );
	return UserInterface.registerBinding ( element, DialogBorderBinding );
}

DialogCoverBinding.prototype = new Binding;
DialogCoverBinding.prototype.constructor = DialogCoverBinding;
DialogCoverBinding.superclass = Binding.prototype;

/**
 * @class
 */
function DialogCoverBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DialogCoverBinding" );
	
	/**
	 * @type {DialogBinding}
	 */
	this._dialogBinding = null;
}

/**
 * Identifies binding.
 */
DialogCoverBinding.prototype.toString = function () {

	return "[DialogCoverBinding]";
}

/**
 * @param {DialogBinding} panelBinding
 */ 
DialogCoverBinding.prototype.cover = function ( dialogBinding ) {
	
	this._dialogBinding = dialogBinding;
	this._dialogBinding.addActionListener ( DialogBinding.ACTION_OPEN, this );
	this._dialogBinding.addActionListener ( DialogBinding.ACTION_CLOSE, this );
	this._dialogBinding.addActionListener ( Binding.ACTION_MOVEDONTOP, this );
	this.addEventListener ( DOMEvents.MOUSEDOWN );
}

/**
 * @implements {IEventListener}
 * @overloads {Binding#handleEvent}
 * @param {MouseEvent} e
 */
DialogCoverBinding.prototype.handleEvent = function ( e ) {

	DialogCoverBinding.superclass.handleEvent.call ( this, e );
	this._dialogBinding.alert ();
}

/**
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
DialogCoverBinding.prototype.handleAction = function ( action ) {
	
	DialogCoverBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	
	/* 
	 * Don't consume - StageDialogSetBinding is listening!
	 */
	if ( this._dialogBinding.isModal ) {
		switch ( action.type ) {
			case DialogBinding.ACTION_OPEN :
				this.show ();
				break;
			case DialogBinding.ACTION_CLOSE :
				this.hide ();
				break;
			case Binding.ACTION_MOVEDONTOP :
				if ( binding == this._dialogBinding ) {
					this.bindingElement.style.zIndex = new String ( 
						binding.getZIndex () - 1 
					);
				}
				break;
		}
	}
}

/**
 * @implements {IBroadcastListner}
 * @param {string} broadcast
 * @param {object} arg
 */
DialogCoverBinding.prototype.handleBroadcast = function ( broadcast, arg ) {

	DialogCoverBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		case this.bindingWindow.WindowManager.WINDOW_RESIZED_BROADCAST :
			this._max ()
			break;
	}
}

/**
 * Span entire screen estate.
 */
DialogCoverBinding.prototype._max = function () {
	
	var dim = this.bindingWindow.WindowManager.getWindowDimensions ();
	this.bindingElement.style.width = dim.w + "px";
	this.bindingElement.style.height = dim.h + "px";
}

/**
 * @overloads {Binding#show}
 */
DialogCoverBinding.prototype.show = function () {
	
	this._max ();
	
	var broadcast = this.bindingWindow.WindowManager.WINDOW_RESIZED_BROADCAST;
	this.subscribe ( broadcast );
	DialogCoverBinding.superclass.show.call ( this );
}

/**
 * @overloads {Binding#hide}
 */
DialogCoverBinding.prototype.hide = function () {
	
	var broadcast = this.bindingWindow.WindowManager.WINDOW_RESIZED_BROADCAST;
	this.unsubscribe ( broadcast );
	DialogCoverBinding.superclass.hide.call ( this );
}


/**
 * DialogCoverBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {DialogCoverBinding}
 */
DialogCoverBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:dialogcover", ownerDocument );
	return UserInterface.registerBinding ( element, DialogCoverBinding );
}

DialogTitleBarBinding.prototype = new Binding;
DialogTitleBarBinding.prototype.constructor = DialogTitleBarBinding;
DialogTitleBarBinding.superclass = Binding.prototype;

function DialogTitleBarBinding () {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DialogTitleBarBinding" );
	
	/**
	 * @type {TitleBarBodyBinding}
	 */
	this.bodyBinding = null;
	
	/**
	 * @type {LabelBinding}
	 */
	this.labelBinding = null;
	
	/**
	 * @type {ControlGroupBinding}
	 */
	this._controlGroupBinding = null;
	
	/**
	 * @type {boolean}
	 */
	this.isDraggable = true;
}

DialogTitleBarBinding.prototype.toString = function () {
	return "[DialogTitleBarBinding]";
}

/**
 * Overloads {Binding#onBindingRegister}
 */
DialogTitleBarBinding.prototype.onBindingRegister = function () {
	
	DialogTitleBarBinding.superclass.onBindingRegister.call ( this );
	
	this.bodyBinding = this.add (
		DialogTitleBarBodyBinding.newInstance ( this.bindingDocument )
	);
	this.labelBinding = this.bodyBinding.add (
		LabelBinding.newInstance ( this.bindingDocument )
	);
	this.labelBinding.attachClassName ( "dialogtitle" );
}

/**
 * Overloads {Binding#onBindingAttach}
 */
DialogTitleBarBinding.prototype.onBindingAttach = function () {

	DialogTitleBarBinding.superclass.onBindingAttach.call ( this );
	
	var image = this.getProperty ( "image" );
	if ( image ) {
		this.setImage ( image );
	}
	var label = this.getProperty ( "label" );
	if ( label ) {
		this.setLabel ( label );
	}
}

/**
 * Set label.
 * @param {string} label
 */
DialogTitleBarBinding.prototype.setLabel = function ( label ) {

	if ( this.isAttached ) {
		this.labelBinding.setLabel ( label ) 
	};
	this.setProperty ( "label", label );
}

/**
 * Set image.
 * @param {string} url
 */
DialogTitleBarBinding.prototype.setImage = function ( url ) {

	if ( this.isAttached && Client.isWindows ) { // NO IMAGE ON OSX!
		this.labelBinding.setImage ( url ) 
	};
	this.setProperty ( "image", url );
}

/**
 * Add control.
 * @param {ControlBinding} controlBinding
 */
DialogTitleBarBinding.prototype.addControl = function ( controlBinding ) {

	if ( !this._controlGroupBinding ) {
		this._controlGroupBinding = this.bodyBinding.addFirst (
			ControlGroupBinding.newInstance ( this.bindingDocument ) 
		);
	}
	this._controlGroupBinding.add ( controlBinding );
}

/**
 * Invoked by the DialogBinding on activation.
 */
DialogTitleBarBinding.prototype.onActivate = function () {
	
	if ( this._controlGroupBinding ) {
		this._controlGroupBinding.onActivate ();
	}
}

/**
 * Invoked by the DialogBinding on deactivation.
 */
DialogTitleBarBinding.prototype.onDeactivate = function () {
	
	if ( this._controlGroupBinding ) {
		this._controlGroupBinding.onDeactivate ();
	}
}

/**
 * DialogTitleBarBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {MYBinding}
 */
DialogTitleBarBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:titlebar", ownerDocument );
	return UserInterface.registerBinding ( element, DialogTitleBarBinding );
}

DialogTitleBarBodyBinding.prototype = new Binding;
DialogTitleBarBodyBinding.prototype.constructor = DialogTitleBarBodyBinding;
DialogTitleBarBodyBinding.superclass = Binding.prototype;

/**
 * @class
 */
function DialogTitleBarBodyBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DialogTitleBarBodyBinding" );
}

/**
 * Identifies binding.
 */
DialogTitleBarBodyBinding.prototype.toString = function () {

	return "[DialogTitleBarBodyBinding]";
}

/**
 * Attach clear-float classname.
 */
DialogTitleBarBodyBinding.prototype.onBindingRegister = function () {

	DialogTitleBarBodyBinding.superclass.onBindingRegister.call ( this );
	this.attachClassName ( Binding.CLASSNAME_CLEARFLOAT );
}


/**
 * DialogTitleBarBodyBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {DialogTitleBarBodyBinding}
 */
DialogTitleBarBodyBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:titlebarbody", ownerDocument );
	return UserInterface.registerBinding ( element, DialogTitleBarBodyBinding );
}

DialogControlBinding.prototype = new ControlBinding;
DialogControlBinding.prototype.constructor = DialogControlBinding;
DialogControlBinding.superclass = ControlBinding.prototype;

DialogControlBinding.CLASSNAME = "dialogcontrol";

/**
 * @class
 */
function DialogControlBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DialogControlBinding" );
	
	/**
	 * No need for matrix corset here.
	 * @overwrites {ControlBinding#hasMatrix}
	 * @type {boolean}
	 */
	this.hasMatrix = false;
	
	/**
	 * @type {boolean}
	 */
	this.isGhostable = true;
}

/**
 * Identifies binding.
 */
DialogControlBinding.prototype.toString = function () {

	return "[DialogControlBinding]";
}

/**
 * @overloads {Binding#onBindingRegister}
 */
DialogControlBinding.prototype.onBindingRegister = function () {

	DialogControlBinding.superclass.onBindingRegister.call ( this );
	this.setImageProfile ( DialogControlImageProfile );
	this.attachClassName ( DialogControlBinding.CLASSNAME );
}

/**
 * ControlBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {DialogControlBinding}
 */
DialogControlBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:control", ownerDocument );
	return UserInterface.registerBinding ( element, DialogControlBinding );
}

DialogControlImageProfile.prototype = new ControlImageProfile;
DialogControlImageProfile.prototype.constructor = DialogControlImageProfile;
DialogControlImageProfile.superclass = ControlImageProfile.prototype;

var os = Client.isVista ? "vista/" : ( !Client.isWindows ? "osx/" : "" ); // HACK!

DialogControlImageProfile.IMAGE_MINIMIZE = "${root}/skins/system/controls/" + os + "control-minimize-${string}.png";
DialogControlImageProfile.IMAGE_MAXIMIZE = "${root}/skins/system/controls/" + os + "control-maximize-${string}.png";
DialogControlImageProfile.IMAGE_RESTORE = "${root}/skins/system/controls/" + os + "control-restore-${string}.png"; 
DialogControlImageProfile.IMAGE_CLOSE = "${root}/skins/system/controls/" + os + "control-close-${string}.png";

/**
 * This functionality can be implemented in pure CSS when we ditch IE6.0!
 * @param {ControlBinding} binding
 */
function DialogControlImageProfile ( binding ) {
	
	this.binding = binding;
}

DialogTitleBarPopupBinding.prototype = new PopupBinding;
DialogTitleBarPopupBinding.prototype.constructor = DialogTitleBarPopupBinding;
DialogTitleBarPopupBinding.superclass = PopupBinding.prototype;

DialogTitleBarPopupBinding.CMD_RESTORE 			= "restore";
DialogTitleBarPopupBinding.CMD_MINIMIZE 		= "minimize";
DialogTitleBarPopupBinding.CMD_MAXIMIZE 		= "maximize";
DialogTitleBarPopupBinding.CMD_REFRESH 			= "refreshview";
DialogTitleBarPopupBinding.CMD_CLOSE 			= "closedialog";
DialogTitleBarPopupBinding.CMD_VIEWSOURCE 		= "viewsource";
DialogTitleBarPopupBinding.CMD_VIEWGENERATED 	= "viewgenerated";
DialogTitleBarPopupBinding.CMD_VIEWSERIALIZED	= "viewserialized";

function DialogTitleBarPopupBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DialogTitleBarPopupBinding" );
}

/**
 * Identifies binding.
 */
DialogTitleBarPopupBinding.prototype.toString = function () {

	return "[DialogTitleBarPopupBinding]";
}

/**
 * @overloads {PopupBinding#onBindingAttach}
 */
DialogTitleBarPopupBinding.prototype.onBindingAttach = function () {
	
	DialogTitleBarPopupBinding.superclass.onBindingAttach.call ( this );
	this._indexMenuContent ();
}

WindowBindingHighlightNodeCrawler.prototype = new NodeCrawler;
WindowBindingHighlightNodeCrawler.prototype.constructor = WindowBindingHighlightNodeCrawler;
WindowBindingHighlightNodeCrawler.superclass = NodeCrawler.prototype;

WindowBindingHighlightNodeCrawler.CLASSNAME_HIGHLIGHT = "compositec1generatedhighlight";

/**
 * @class
 */
function WindowBindingHighlightNodeCrawler () {

	/**
	 * @type {List<string>}
	 */
	this._keywords = null;
	
	/**
	 * @type {Map<string><RegExp>}
	 */
	this._map = new Map ();
	
	/**
	 * @type {List<DOMTextNode}
	 */
	this._textnodes = null;
	
	this._construct ();
	return this;
}

/**
 * Filter all but Element nodes.
 * @overloads {NodeCrawler#_construct} 
 */
WindowBindingHighlightNodeCrawler.prototype._construct = function () {
	
	ElementCrawler.superclass._construct.call ( this );
	
	this.addFilter ( function ( node, arg ) {
		var result = null;
		if ( node.nodeType == Node.ELEMENT_NODE ) {
			var nodename = node.nodeName.toLowerCase ();
			switch ( nodename ) {
				case "script" :
				case "style" :
				case "textarea" :
					result = NodeCrawler.SKIP_NODE + NodeCrawler.SKIP_CHILDREN;
					break;
			}
		}
		return result;
	});
	
	/*
	 * While crawling, simply collect the suspect textnodes in a list 
	 * in order to avoud document updates that might confuse the crawler. 
	 * The textnodes are finally modified by method onCrawlStop below. 
	 */
	var self = this;
	this.addFilter ( function ( node, arg ) {
		if ( node.nodeType == Node.TEXT_NODE ) {
			var text = node.nodeValue.toLowerCase ();
			self._map.each ( function ( key, exp ) {
				var result = true;
				if ( exp.test ( text )) {
					self._textnodes.add ( node );
					result = false;
				}
				return result;
			});
		}
	});
};

/**
 * Start crawling.
 * @overloads {NodeCrawler#crawl}
 * @param {DOMElement} element
 * @param {object} arg
 */
WindowBindingHighlightNodeCrawler.prototype.crawl = function ( element, arg ) {
	
	this._textnodes = new List ();
	WindowBindingHighlightNodeCrawler.superclass.crawl.call ( this, element, arg );
}

/**
 * Set keywords.
 * @param {List<string>} list
 * @@see {SEODOMParser#setKeys}
 */
WindowBindingHighlightNodeCrawler.prototype.setKeys = function ( list ) {
	
	list.reset ();
	this._map.empty ();
	
	while ( list.hasNext ()) {
		var key = list.getNext ();
		var phrase = key.toLowerCase ().replace ( / /g, "\\W" );
		var exp = new RegExp ( "(" + phrase + ")" );
		this._map.set ( key, exp );
	}
};

/**
 * @overwrites {NodeCrawler#onCrawlStop}
 */
WindowBindingHighlightNodeCrawler.prototype.onCrawlStop = function () {
	
	var self = this;
	if ( this._textnodes.hasEntries ()) {
		this._textnodes.each ( function ( node ) {
			
			var div = self.contextDocument.createElement ( "div" );
			var frag = self.contextDocument.createDocumentFragment ();
			
			div.innerHTML = self._getMarkup ( node.nodeValue );
			while ( div.hasChildNodes ()) {
				frag.appendChild ( div.firstChild );
			}
			node.parentNode.replaceChild ( frag, node );
		});
	}
};

/**
 * Get that markup!
 * @param {string} original
 * @return {string}
 */
WindowBindingHighlightNodeCrawler.prototype._getMarkup = function ( original ) {
		
	var markup = "";
	var TAGSTART = "<span class=\"" + WindowBindingHighlightNodeCrawler.CLASSNAME_HIGHLIGHT + "\" style=\"background-color:yellow;color:black;\">";
	var TAGSTOP = "</span>";
	
	/*
	 * This recursive setup ensures that each multiple 
	 * keywords occurances is highlighted properly.
	 */
	var self = this;
	function iterate ( current ) {
		
		var minindex = -1;
		var minkey = null;
		
		/*
		 * Isolate the regexp match with the lowest position index. 
		 */
		self._map.each ( function ( key, exp ) {
			
			var low = current.toLowerCase ();
			var index = low.search ( exp );
			
			if ( index >-1 ) {
				if ( minindex == -1 ) {
					minindex = index;
				}
				if ( index <= minindex ) {
					minindex = index;
					minkey = key;
				}
			}
		});
		
		/*
		 * Markup the match, cut from string and iterate the rest.
		 */
		if ( minindex > -1 && minkey != null ) {
			
			var pre = current.substring ( 0, minindex );
			var hit = current.substring ( minindex, minindex + minkey.length );
			var pst = current.substring ( minindex + minkey.length, current.length );
			
			markup += pre + TAGSTART + hit + TAGSTOP;					
			iterate ( pst );
			
		} else {
			
			markup += current;
		}
	}
	
	iterate ( original );
	return markup;
}

/*
 * Remove traces of earlier highlight.
 * @param {HTMLElement} element
 */
WindowBindingHighlightNodeCrawler.prototype.reset = function ( element ) {
	
	var spans = new List ( element.getElementsByTagName ( "span" ));
	spans.each ( function ( span ) {
		if ( span.className == WindowBindingHighlightNodeCrawler.CLASSNAME_HIGHLIGHT ) {
			var node = element.ownerDocument.createTextNode ( DOMUtil.getTextContent ( span ));
			span.parentNode.replaceChild ( node, span );
		}
	});
}

WindowBinding.prototype = new FlexBoxBinding;
WindowBinding.prototype.constructor = WindowBinding;
WindowBinding.superclass = FlexBoxBinding.prototype;

WindowBinding.ACTION_LOADED		= "window loaded";
WindowBinding.ACTION_ONLOAD 	= "alien window loaded";
WindowBinding.DEFAULT_URL 		= "${root}/blank.aspx";
WindowBinding.DEFAULT_TITLE 	= "Composite.Management.Blank";
WindowBinding.POSTBACK_URL 		= "${root}/postback.aspx"; 
WindowBinding.POSTBACK_TITLE 	= "Composite.Management.DefaultPostBack";

/**
 * Extract well-formed XHTML source from WindowBinding instance. 
 * This involves a roundtrip to the server, so use with caution. 
 * TODO: handle namespace declarations in contained document?
 * @param {WindowBinding} windowBinding
 * @return {string}
 */
WindowBinding.getMarkup = function ( windowBinding ) {
	
	var result = null;
	if ( windowBinding.isAttached ) {
		var doc = windowBinding.getContentDocument ();
		if ( doc != null ) {
			var root = doc.getElementsByTagName ( "html" ).item ( 0 ); // IE6 compliant documentElement
			var html = "<html xmlns=\"" + Constants.NS_XHTML + "\">" + root.innerHTML + "</html>";
			WebServiceProxy.isFaultHandler = false;
			result = top.MarkupFormatService.HtmlToXhtml ( html );
			WebServiceProxy.isFaultHandler = true;
			if ( result instanceof SOAPFault ) {
				result = null;
			}
		}
	}
	return result;
};

/** 
 * Highlight a list of keywords inside a WindowBinding instance. 
 * This stuff is used for SEOAssistant in preview and browser.
 * @param {WindowBinding} windowBinding
 * @param {List<string>} list
 */
WindowBinding.highlightKeywords = function ( windowBinding, list ) {
	
	if ( WindowBinding._highlightcrawler == null ) {
		WindowBinding._highlightcrawler = new WindowBindingHighlightNodeCrawler ();
	}
	
	if ( windowBinding.isAttached ) {
		var doc = windowBinding.getContentDocument ();
		if ( doc != null ) {
			var crawler = WindowBinding._highlightcrawler;
			crawler.reset ( doc.body );
			if ( list != null ) {
				crawler.setKeys ( list );
				crawler.crawl ( doc.body );
			}
		}
	}
};

/**
 * This fellow handles inline highlighting of keywords in preview windows.
 * @type {WindowBindingHighlightNodeCrawler}
 * @see {WindowBinding.highlightKeywords}
 */
WindowBinding._highlightcrawler = null;

/**
 * @class
 * For some reason, iframe content pages must be loaded dynamically for 
 * Mozilla to display them consistantly after page reload. The WindowBinding 
 * does precisely that. We've added some {@link FlexBoxBinding} functionality.
 */
function WindowBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "WindowBinding" );
	
	/**
	 * @type {string}
	 */
	this._target = null;
	
	/**
	 * @type {HashMap<string><string>}
	 */
	this._parameterMap = null;
	
	/**
	 * Points to the currently hosted PageBinding. Note that this is now a 
	 * prequisite for bindings to be disposed when window gets unloaded!
	 * @type {PageBinding);
	 */
	this._pageBinding = null;
	
	/**
	 * True while reloading. This helps us control cache in Prism.
	 * @type {boolean}
	 */
	this._isReloading = false;
	
	/**
	 * This one watches for the load event in the iframe document. If an  
	 * alien document is loaded, it will automatically be adapted to fit 
	 * (event listeners and stuff is registered).
	 * @type {IEventListener}
	 */
	this._onloadHandler = null;
	
	/**
	 * @type {IEventListener}
	 */
	this._unloadHandler = null;
	
	/**
	 * Used to fire the onload event as soon as possible. That is, 
	 * when the onload event is supposed to fire! Seems that 
	 * Firefox3 evaluates the WindowManager onload event first, 
	 * so that all bindings have been registered (and attached?) 
	 * when the onload event is fired on the iframe.
	 * @type {boolean}
	 */
	this._hasLoadActionFired = false;
	
	/*
	 * Returnable.
	 */
	return this;
};

/**
 * Identifies binding.
 */
WindowBinding.prototype.toString = function () {
	
	return "[WindowBinding]";
};

/**
 * Serialize binding.
 * @return {HashMap<string><object>}
 */
WindowBinding.prototype.serialize = function () {
	
	var result = WindowBinding.superclass.serialize.call ( this );
	if ( result ) {
		result.url = this.getURL ();
	}
	return result;
};

/**
 * @overloads {FlexBoxBinding#onBindingRegister}
 */
WindowBinding.prototype.onBindingRegister = function () {

	WindowBinding.superclass.onBindingRegister.call ( this );
	this.addActionListener ( RootBinding.ACTION_PHASE_3 );
	this.addActionListener ( PageBinding.ACTION_INITIALIZED );
	this.addActionListener ( RootBinding.ACTION_ACTIVATED );
	this.addActionListener ( RootBinding.ACTION_DEACTIVATED );
};

/**
 * @overloads {Binding#onBindingAttach}
 */
WindowBinding.prototype.onBindingAttach = function () {

	WindowBinding.superclass.onBindingAttach.call ( this );
	this.setURL ( this.getURL ());
};

/**
 * Dispose content document on dispose.
 * @overloads {Binding#onBindingDispose}
 */
WindowBinding.prototype.onBindingDispose = function () {
	
	WindowBinding.superclass.onBindingDispose.call ( this );
	
	/*
	 * TODO: Aint this handled by  
	 * the unloadlistener already?
	 */
	this._disposeContentDocument ();
};

/*
 * Ignite a chain reaction to dispose all bindings (in nested frames) within 
 * contained window. Note that chain breaks when a window hosts no PageBinding!
 */
WindowBinding.prototype._disposeContentDocument = function () {
	
	if ( this._pageBinding != null ) {
		var win = this.getContentWindow ();
		if ( win != null ) {
			var manager = this.getContentWindow ().DocumentManager;
			if ( manager != null ) {
				manager.detachAllBindings ();
				this._pageBinding = null;
			}
		}
	}
};

/**
 * Please notice that this implies that a WindowBinding will only dispatch 
 * the ACTION_LOADED loaded event if an on-server file is loaded!!!
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
WindowBinding.prototype.handleAction = function ( action ) {
	
	WindowBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	
	switch ( action.type ) {
	
		case RootBinding.ACTION_PHASE_3 :
			
			if ( binding.bindingDocument == this.getContentDocument ()) {
				if ( this._isReloading == true ) {
					this._isReloading = false;
					if ( Client.isPrism == true ) {
						Prism.enableCache ();
					}
				}
				this.dispatchAction ( WindowBinding.ACTION_LOADED );
			}
			// dont consume - pagebinding may be listening!
			break;
			
		case PageBinding.ACTION_INITIALIZED :
			
			this._onPageInitialize ( binding );
			break;
			
		/*
		 * Simply consume this event. Only descendant bindings   
		 * will be listening. We can listen to the same event   
		 * on the RootBinding in our own bindingDocument.
		 */
		case RootBinding.ACTION_ACTIVATED :
		case RootBinding.ACTION_DEACTIVATED :
			action.consume ();
			break;
	}
};

/**
 * @implements {IFit}
 * @overwrites {FlexBoxBinding#fit}
 * @param {boolean} isForce
 */
WindowBinding.prototype.fit = function ( isForce ) {
	
	if ( !this.isFit || isForce ) {
		if ( this._pageBinding != null ) {
			this.setHeight ( this._pageBinding.getHeight ());
			this.isFit = true;
		}
	}
};
 
/**
 * Invoked when contained page initializes.
 * @param {PageBinding} binding
 */
WindowBinding.prototype._onPageInitialize = function ( binding ) {
	
	/*
	 * Fetch a pointer to the main page.
	 */
	if ( this._pageBinding == null ) {
		if ( binding.bindingWindow == this.getContentWindow ()) {
			this._pageBinding = binding;	
		}
	}
	
	/*
	 * Handle dialog sub pages ...
	 * Remember that the page gets converted 
	 * to a subpage opon attachment already! 
	 * Also remember that the page property 
	 * "fitasdialogsubpage" can override this.
	 *
	if ( binding.isDialogSubPage ) {
		if ( binding.bindingDocument == this.getContentDocument ()) {
			this.setHeight (
				binding.getHeight ()
			);
		}
	}
	*/
};

/**
 * Build the iframe and setup alien watch.
 */
WindowBinding.prototype.buildDOMContent = function () {

	if ( this.shadowTree.iframe != null ) {
		this.bindingElement.removeChild ( this.shadowTree.iframe );
		this.shadowTree.iframe = null;
	}

	this.shadowTree.iframe = DOMUtil.createElementNS ( Constants.NS_XHTML, "iframe", this.bindingDocument );
	this.shadowTree.iframe.setAttribute ( "frameborder", "0" );
	this.shadowTree.iframe.frameBorder = 0;
	this.bindingElement.appendChild ( this.shadowTree.iframe );
	this._registerOnloadListener ( true );
};

/**
 * Register onload listener.
 * @param {boolean} isRegister
 */
WindowBinding.prototype._registerOnloadListener = function ( isRegister ) {
	
	var iframe = this.shadowTree.iframe;
	var action = isRegister ? "addEventListener" : "removeEventListener";

	if ( this._onloadHandler == null ) {
		var self = this;
		this._onloadHandler = {
			handleEvent : function ( e ) {
				
					var isComplete = true;
					if ( Client.isExplorer ) {
						isComplete = iframe.readyState == "complete";
					}
					if ( isComplete == true ) {
						if ( self.getURL () != WindowBinding.DEFAULT_URL ) {
							if ( !self._hasLoadActionFired ) {
								self.onWindowLoaded ( 
									self.getContentWindow ()
								);
							}
						}
					}
				
			}
		}
	}
	
	DOMEvents [ action ] ( 
		this.shadowTree.iframe,
		Client.isExplorer == true ? "readystatechange" : DOMEvents.LOAD, 
		this._onloadHandler
	);
};

/**
 * Setup to reset on unload. This involves binding detachment.
 * @param {boolean} isRegister
 * @return
 */
WindowBinding.prototype._registerUnloadListener = function ( isRegister ) {
	
	var action = isRegister ? "addEventListener" : "removeEventListener";
	
	if ( this._unloadHandler == null ) {
		var self = this;
		this._unloadHandler = {
			handleEvent : function () {
				self._disposeContentDocument ();
				self._hasLoadActionFired = false;
			}
		}
	}
	DOMEvents [ action ] ( 
		this.getContentWindow (),
		DOMEvents.UNLOAD, 
		this._unloadHandler
	);
};

/**
 * Invoked when the contained document fires the onload event. 
 * Note that the default URL doesn't dispatch actions (since 
 * it is nearly always loaded on startup).
 * @param {DOMDocumentView} win
 */
WindowBinding.prototype.onWindowLoaded = function ( win ) {
	
	/*
	 * When overloading, PLACE YOUR CODE HERE! This 
	 * will respect the value of _hasLoadActionFired.
	 */
	
	/*
	 * Strange glitch can occur here. In both 
	 * browsers, apparently. Please investigate.
	 */
	if ( win == null ) {
		this.logger.error ( "WindowBinding#onWindowLoaded: Bad argument: " + this.getURL ());
	} else if ( this.getURL () != WindowBinding.DEFAULT_URL ) {
		if ( !this._hasLoadActionFired ) {
			if ( win != null && win.WindowManager == null && win.document != null && win.document.body != null ) {
				Application.framework ( win.document );
				win.document.body.style.border = "none";
				if ( this._isReloading == true ) {
					this._isReloading = false;
					if ( Client.isPrism ) {
						Prism.enableCache ();
					}
				}
			}
			this._registerUnloadListener ( true );
			this.dispatchAction ( WindowBinding.ACTION_ONLOAD );
			this._hasLoadActionFired = true;
		}
	}
};

/**
 * Set URL.
 * @param {string} url
 */
WindowBinding.prototype.setURL = function ( url ) {

	this.setProperty ( "url", url );
	this._hasLoadActionFired = false;
	
	if ( this.isAttached == true ) {
	
		/*
		 * Mozilla hardcore-caches the page from last page-refresh 
		 * unless we do this ugly hack. This bug is serious, but 
		 * apparently not documented anywhere!
		 * TODO: File this hideous bug.
		 * UPDATE: The bug seems to have been fixed...?
		 */
		if ( this.shadowTree.iframe == null ) { // || Client.isMozilla
			this.buildDOMContent ();
		}
		
		/*
		 * Dispose possible contained bindings.
		 * TODO: Aint this handled by the unloadlistener?
		 */
		this._disposeContentDocument ();
		
		/*
		 * Load resolved URL.
		 */
		this.getFrameElement ().src = Resolver.resolve ( url );
	}
};

/**
 * Unlike an iframe "src" attribute, this doesn't 
 * nescessarily include protocol, host and port information. 
 * If the url was supplied with a "${root}" type pattern, 
 * this will be reflected in the returned result.
 * @return {string}
 */
WindowBinding.prototype.getURL = function () {
	
	var result = WindowBinding.DEFAULT_URL;
	var url = this.getProperty ( "url" );
	if ( url ) {
		result = url;
	}
	return result;
};

/**
 * Reload. TODO: handle the isClearCache stuff!!!!!!!!!!!!
 * @param {boolean} isClearCache Clears the cache in Prism.
 */
WindowBinding.prototype.reload = function ( isClearCache ) {
	
	this._disposeContentDocument ();
	if ( Client.isPrism ) {
		Prism.disableCache ();
	}
	this._isReloading = true;
	this.getContentDocument ().location.reload ();
};

/**
 * Get the iframe element associated to this WindowBinding.
 * @return {DOMElement}
 */
WindowBinding.prototype.getFrameElement = function () {
	
	var result = null;
	if ( this.shadowTree.iframe ) {
		result = this.shadowTree.iframe;
	}
	return result;
};

/**
 * Get the window object hosted by this WindowBinding. 
 * During startup, this may be undefined. 
 * @return {DOMDocumentView}
 */
WindowBinding.prototype.getContentWindow = function () {
	
	var result = null, frame = this.getFrameElement ();
	if ( frame ) {
		result = frame.contentWindow;
	}
	return result;
};

/**
 * Get the document object hosted by this WindowBinding.
 * @return {DOMDocument}
 */
WindowBinding.prototype.getContentDocument = function () {
	
	var result = null, win = this.getContentWindow ();
	if ( win ) {
		result = win.document;
	}
	return result;
};

/**
 * Get the RootBinding contained in this WindowBinding.
 * @return {RootBinding}
 */
WindowBinding.prototype.getRootBinding = function () {
	
	var result = null, doc = this.getContentDocument ();
	if ( doc && doc.body ) {
		result = UserInterface.getBinding ( 
			doc.body 
		);
	}
	return result;
};

/**
 * Get the PageBinding contained in this WindowBinding.
 * @return {PageBinding}
 */
WindowBinding.prototype.getPageBinding = function () {
	
	return this._pageBinding;
};

/**
 * @param {int} height
 */
WindowBinding.prototype.setHeight = function ( height ) {
	
	this.bindingElement.style.height = height + "px";
};

/**
 * Iframes should never undisplay. Contained  
 * document may not survive it (eg applets).
 * @overwrites {Binding#hide}
 */
WindowBinding.prototype.hide = function () {
	
	if ( this.isVisible == true ) {
		this.bindingElement.style.visibility = "hidden";
		this.isVisible = false;
	}
};

/**
 * @overwrites {Binding#show}
 */
WindowBinding.prototype.show = function () {
	
	if ( !this.isVisible ) {
		this.bindingElement.style.visibility = "visible";
		this.isVisible = true;
	}
};

/**
 * Directing all crawlers into contained document 
 * only if it looks lile be a framework document.
 * @implements {ICrawlerHandler}
 * @param {Crawler} crawler
 */
WindowBinding.prototype.handleCrawler = function ( crawler ) {
	
	WindowBinding.superclass.handleCrawler.call ( this, crawler );
	
	if ( crawler.type == NodeCrawler.TYPE_DESCENDING ) {
		var root = this.getRootBinding ();
		if ( root != null ) {
			crawler.nextNode = root.bindingElement;
		} else {
			crawler.response = NodeCrawler.SKIP_CHILDREN;
		}
	}	
};

/**
 * Performs a HTTP post to the given URL.
 * @param {List<object>} list
 * @param {String} url
 */
WindowBinding.prototype.post = function ( list, url ) {
	
	var win = this.getContentWindow ();
	if ( win.isPostBackDocument ) {
		win.submit ( list, url );
	} else  {
		throw "Post aborted";
	}
};

/**
 * WindowBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {WindowBinding}
 */
WindowBinding.newInstance = function ( ownerDocument ) {
	
	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:window", ownerDocument );
	var binding = UserInterface.registerBinding ( element, WindowBinding );
	return binding;
};

PreviewWindowBinding.prototype = new WindowBinding;
PreviewWindowBinding.prototype.constructor = PreviewWindowBinding;
PreviewWindowBinding.superclass = WindowBinding.prototype;

PreviewWindowBinding.URL_FULL_STOP = "${root}/content/misc/preview/stop.aspx";
PreviewWindowBinding.URL_ERROR = "${root}/content/misc/preview/error.aspx";
PreviewWindowBinding.ACTION_RETURN = "return";
PreviewWindowBinding.TIMEOUT_RETURN = parseInt ( 2300 );


/**
 * @class
 * This window is hardwired for HTTP POST previews.
 */
function PreviewWindowBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "PreviewWindowBinding" );
	
	/**
	 * @type {Map<String><String>}
	 */
	this._postBackList = null;
	
	/**
	 * @type {string}
	 */
	this._postBackURL = null;
	
	/**
	 * @type {CoverBinding}
	 */
	this._coverBinding = null;
	
	/**
	 * @type {WindowBinding}
	 */
	this._windowBinding = null;
	
	/**
	 * @type {WindowBinding}
	 */
	this._errorBinding = null;
	
	/**
	 * @type {boolean}
	 */
	this._hasFullStop = false;
	
	/**
	 * @type {boolean}
	 */
	this._isReturning = false;
	 
	/**
	 * @type {ILoadHandler}
	 */
	this._loadhandler = null;
	
	/**
	 * @type {function}
	 */
	this._timeout = null;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
PreviewWindowBinding.prototype.toString = function () {

	return "[PreviewWindowBinding]";
}

/**
 * Append a cover to hide flashes-of-white while navigating.
 */
PreviewWindowBinding.prototype.onBindingAttach = function () {
	
	PreviewWindowBinding.superclass.onBindingAttach.call ( this );
	
	this.bindingElement.style.backgroundColor = "white"; // Mozilla is transparent!
	this._coverBinding = this.add ( CoverBinding.newInstance ( this.bindingDocument ));
	this._coverBinding.attach ();
}

/**
 * @param {DOMDocumentView} win
 * @overloads {WindowBinding#onWindowLoaded}
 */
PreviewWindowBinding.prototype.onWindowLoaded = function ( win ) {

	if ( this.getURL () != WindowBinding.DEFAULT_URL ) {
		if ( !this._hasFullStop ) {
			if ( win.isPostBackDocument ) {
				if ( this._isReturning ) {
					win.submit ( this._postBackList, this._postBackURL );
					this._isReturning = false;
				}
			} else {
				this._coverBinding.hide ();	
			}
			if ( !win.isDefaultDocument ) {	
				var self = this;
				this._loadhandler = {
					handleEvent : function ( e ) {
						self._coverBinding.show ();
						if ( win.isPostBackDocument ) {
							self._postBackList = win.postBackList;
							self._postBackURL = win.postBackURL;
						} else if ( !win.isDefaultDocument ) {
							self._fullStop ();
						}
					}
				};
				DOMEvents.addEventListener ( 
					win, 
					DOMEvents.BEFOREUNLOAD, 
					this._loadhandler 
				);
			}
		}
	}
	
	PreviewWindowBinding.superclass.onWindowLoaded.call ( this, win );
}

/**
 * Show full stop message. Note that the forbidden 
 * page is in fact loaded behind the curtains. 
 */
PreviewWindowBinding.prototype._fullStop = function () {

	this._coverBinding.show ();
	
	if ( this._windowBinding == null ) {
		
		this._windowBinding = this._getWindowBinding ();
		this._windowBinding.setURL ( PreviewWindowBinding.URL_FULL_STOP );
		this._windowBinding.hide ();
		this._windowBinding.attach ();
		
		this._windowBinding.addActionListener ( WindowBinding.ACTION_LOADED, {
			handleAction : function ( action ) {
				action.target.show ();
				action.consume ();
			}
		});
		
	} else {
		
		this._windowBinding.show ();
	}

	this._hasFullStop = true;
	this.addActionListener ( PreviewWindowBinding.ACTION_RETURN );
	this.setURL ( WindowBinding.DEFAULT_URL ); // nuke the forbidden document!
	
	/*
	 * Auto-return after a short timeout. Note that a mouseclick  
	 * anywhere inside the stop page also triggers a return.
	 */
	var self = this;
	this._timeout = setTimeout ( function () {
		self._return ();
	}, PreviewWindowBinding.TIMEOUT_RETURN );
};

/**
 * Show error message. Invoked by the {@link EditorPageBinding}
 * TODO: Fuse this._errorBinding with this._windowBinding?
 */
PreviewWindowBinding.prototype.error = function () {
	
	this._coverBinding.show ();
	
	if ( this._errorBinding == null ) {
		
		this._errorBinding = this._getWindowBinding ();
		this._errorBinding.setURL ( PreviewWindowBinding.URL_ERROR );
		this._errorBinding.hide ();
		this._errorBinding.attach ();
		
		this._errorBinding.addActionListener ( WindowBinding.ACTION_LOADED, {
			handleAction : function ( action ) {
				action.target.show ();
				action.consume ();
			}
		});
		
	} else {
		
		this._errorBinding.show ();
	}

	this._hasError = true;
	this.setURL ( WindowBinding.DEFAULT_URL );
};

/**
 * @return {WindowBinding}
 */
PreviewWindowBinding.prototype._getWindowBinding = function () {
	
	var win = this._coverBinding.add ( WindowBinding.newInstance ( this.bindingDocument ));
	
	/*
	 * TODO: Move to (general) CSS
	 */
	win.isFlexible = false;
	win.bindingElement.style.position = "absolute";
	win.bindingElement.style.width = "100%";
	win.bindingElement.style.height = "100%";
	
	return win;
}

/**
 * @implements {IActionListener}
 * @overloads {PageBinding#handleAction}
 * @param {Action} action
 */
PreviewWindowBinding.prototype.handleAction = function ( action ) {
	
	PreviewWindowBinding.superclass.handleAction.call ( this, action );
	
	switch ( action.type ) {
		case PreviewWindowBinding.ACTION_RETURN :
			this._return ();
			break;
	}
}

/**
 * Return from full stop page.
 */
PreviewWindowBinding.prototype._return = function () {
	
	clearTimeout ( this._timeout );
	this._timeout = null;
	
	this.removeActionListener ( PreviewWindowBinding.ACTION_RETURN );
	this._windowBinding.hide ();
	this._hasFullStop = false;
	this._isReturning = true;
	this.setURL ( WindowBinding.POSTBACK_URL );
}

/**
 * Reset setup. This method is invoked by the  
 * {@link EditorPageBinding} when another tab is selected.
 */
PreviewWindowBinding.prototype.reset = function () {
	
	if ( this._timeout != null ) {
		clearTimeout ( this._timeout );
		this._timeout = null;
	}
	
	if ( this._errorBinding != null ) {
		if ( this._errorBinding.isVisible ) {
			this._errorBinding.hide ();
			
		}
	}
	
	if ( this._windowBinding != null ) {
		if ( this._windowBinding.isVisible ) {
			this._windowBinding.hide ();
		}
	}
	
	if ( this._loadhandler != null ) {
		if ( this.getURL () != WindowBinding.DEFAULT_URL ) {
			DOMEvents.removeEventListener ( 
				this.getContentWindow (), 
				DOMEvents.BEFOREUNLOAD, 
				this._loadhandler 
			);
			this._loadhandler = null;
		}
	}
	
	this._hasError = false;
	this._hasFullStop = false;
	this._isReturning = false;
	
	this._coverBinding.show ();
	this.setURL ( WindowBinding.DEFAULT_URL );
}

RadioGroupBinding.prototype = new Binding;
RadioGroupBinding.prototype.constructor = RadioGroupBinding;
RadioGroupBinding.superclass = Binding.prototype;
RadioGroupBinding.ACTION_SELECTIONCHANGED = "radiogroupselectionchanged";

/**
 * @class
 * Manages checked radiobuttons within descendant element scope.
 */
function RadioGroupBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "RadioGroupBinding" );
	
	/**
	 * @type {Binding}
	 */
	this._checkedRadioBinding = null;
	
	/**
	 * @type {List<ButtonBinding>}
	 */
	this._radioButtonBindings = null;
	
	/**
	 * Flipped when new radiobutton is added.
	 * @see {ButtonBinding#onBindingAttach}
	 * @type {boolean}
	 */
	this._isUpToDate = false;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
RadioGroupBinding.prototype.toString = function () {

	return "[RadioGroupBinding]";
}

/** 
 * @overloads {Binding#onBindingRegister}
 */
RadioGroupBinding.prototype.onBindingRegister = function () {

	RadioGroupBinding.superclass.onBindingRegister.call ( this );
	this.addActionListener ( ButtonBinding.ACTION_RADIOBUTTON_ATTACHED, this );
	this.addActionListener ( ButtonBinding.ACTION_COMMAND, this );
}

/**
 * @overloads {Binding#onBindingInitialize}
 */
RadioGroupBinding.prototype.onBindingInitialize = function () {

	var checkedRadioBinding = null;
	this._getRadioButtonBindings ().each ( function ( binding ) {
		if ( binding.getProperty ( "ischecked" )) {
			checkedRadioBinding = binding;
			return false;
		} else {
			return true;
		}
	});
	if ( checkedRadioBinding ) {
		this._checkedRadioBinding = checkedRadioBinding;
	}
	
	RadioGroupBinding.superclass.onBindingInitialize.call ( this );
}

/** 
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
RadioGroupBinding.prototype.handleAction = function ( action ) {

	RadioGroupBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	
	switch ( action.type ) {
		
		case ButtonBinding.ACTION_RADIOBUTTON_ATTACHED :
			this._isUpToDate = false;
			action.consume ();
			break;
			
		case ButtonBinding.ACTION_COMMAND :
			if ( binding.isRadioButton && !binding.isDisabled ) {
				if ( this._checkedRadioBinding ) {
					this._unCheckRadioBindingsExcept ( binding );
				}
				this._checkedRadioBinding = binding;
				this.dispatchAction ( RadioGroupBinding.ACTION_SELECTIONCHANGED );
				
				/*
				 * Sorry - you have to place your listener on the radiogroup!
				 */
				action.consume ();
			}
			break;
	}
}

/**
 * Set checked button.
 * @param {ButtonBinding} binding
 * @param {boolean} isDisableCommand
 */
RadioGroupBinding.prototype.setCheckedButtonBinding = function ( binding, isDisableCommand ) {
	
	if ( binding instanceof RadioDataBinding ) { // not really supposed to go on here!
		binding = binding.getButton ();
	}
	
	if ( binding.isRadioButton ) {
		switch ( isDisableCommand ) {
			case true :
				this._unCheckRadioBindingsExcept ( binding );
				this._checkedRadioBinding = binding;
				binding.check ( true );
				break;
			default :
				binding.check ();
				break;
		}		
	}
}

/**
 * Get checked button.
 * @return {ButtonBinding}
 */
RadioGroupBinding.prototype.getCheckedButtonBinding = function () {
	
	return this._checkedRadioBinding;
}

/**
 * Uncheck descendant radiobutton execept the one supplied as argument.
 * @param (Binding} selectedBinding
 * @private
 */
RadioGroupBinding.prototype._unCheckRadioBindingsExcept = function ( selectedBinding ) {
	 
	var radioButtons = this._getRadioButtonBindings ();
	radioButtons.each ( function ( binding ) {
		if ( binding.isChecked && binding != selectedBinding ) {
			binding.uncheck ( true );
		}
	});
}

/**
 * @return {List<ButtonBinding>}
 */
RadioGroupBinding.prototype._getRadioButtonBindings = function () {
	
	if ( this._radioButtonBindings === null || !this._isUpToDate ) {
		
		var crawler = new Crawler ();
		var list = new List ();
		
		crawler.addFilter ( function ( element ) {
			
			var result = true;
			var binding = UserInterface.getBinding ( element );
			if ( binding instanceof RadioGroupBinding ) {
				result = NodeCrawler.SKIP_CHILDREN;
			} else {
				if ( binding instanceof ButtonBinding && binding.isRadioButton ) {
					list.add ( binding );
				}
			}
			return result;
		});
		
		crawler.crawl ( this.bindingElement );
		this._radioButtonBindings = list;
		
		/*
		var result = new List ();
		var descendants = this.getDescendantBindingsByLocalName ( "*" );
		descendants.each ( function ( binding ) {
			if ( binding instanceof ButtonBinding && binding.isRadioButton ) {
				result.add ( binding );
			}
		});
		this._radioButtonBindings = result;
		*/
	}
	return this._radioButtonBindings;

}

/**
 * RadioGroupBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {RadioGroupBinding}
 */
RadioGroupBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:radiogroup", ownerDocument );
	return UserInterface.registerBinding ( element, RadioGroupBinding );
}

DataBindingMap.prototype = new Map;
DataBindingMap.prototype.constructor = DataBindingMap;
DataBindingMap.superclass = Map.prototype;

DataBindingMap.TYPE_VALUE = "databindingmap valuetype";
DataBindingMap.TYPE_RESULT = "databindingmap resulttype";

/**
 * @class
 * Notice that this is an utility, not a binding!
 * @param @optional {Map} map
 */
function DataBindingMap ( map ) {
	
	/*
	 * Re-declare super property so that we don't all populate the same Map.
	 */
	this._map = map ? map : {};
	
	/**
	 * Indicates whether or not content is intended 
	 * for serverside or clientside processing.
	 * @type {string}
	 */
	this.type = DataBindingMap.TYPE_RESULT;
}

DataInputBinding.prototype = new DataBinding;
DataInputBinding.prototype.constructor = DataInputBinding;
DataInputBinding.superclass = DataBinding.prototype;

/**
 * @class
 * @implements {IData}
 */
function DataInputBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DataInputBinding" );
	
	/**
	 * @type {string}
	 */
	this.type = null;
	
	/**
	 * @type {boolean}
	 */
	this.isRequired = false;
	
	/**
	 * @type {RegExp}
	 */
	this.expression = null;
	
	/**
	 * @type {boolean}
	 */
	this.isPassword = false;

	/**
	 * Used to cache value while displaying error messages.
	 * @type {string}
	 */
	this._value = null;
	
	/**
	 * @type {boolean}
	 */
	this._isValid = true;
	
	/**
	 * When invalid, this property flags whether or not _testDirty
	 * we are invalid because we are "required". Not to 
	 * be confused with isRequired.
	 * @type {boolean}
	 */
	this._isInvalidBecauseRequired = false;
	
	/**
	 * True when invalid because of minlength.
	 * @type {boolean}
	 */
	this._isInvalidBecauseMinLength == true;
	
	/**
	 * True when invalid because of minlength.
	 * @type {boolean}
	 */
	this._isInvalidBecauseMinLength == true;
	
	/**
	 * True when invalid because of maxlength.
	 * @type {boolean}
	 */
	this._isInvalidBecauseMaxLength == true;
	
	/**
	 * @type {object}
	 */
	this._sessionResult = null;
	
	/**
	 * @type {boolean}
	 */
	this.isDisabled = false;
	
	/**
	 * @type {boolean}
	 */
	this.isReadOnly = false;
	
	/**
	 * @type {function}
	 */
	this._dirtyinterval = null;
	
	/**
	 * @type {boolean}
	 */
	this._isAutoSelect = false;
	
	/**
	 * @type {integer}
	 */
	this.minlength = null;
	
	/**
	 * @type {integer}
	 */
	this.maxlength = null;
	
	/**
	 * Is autopostback?
	 * @type {boolean}
	 */
	this._isAutoPost = false;
	
	/**
	 * Autopost timeout.
	 * @type {function}
	 */
	this._timeout = null;
	
	/**
	 * Autopost time (start when idle, reset onkeydown).
	 * @type {int}
	 */
	this._time = 1500;
	
	/**
	 * Block common crawlers.
	 * @type {Map<string><boolean>}
	 * @overwrites {Binding#crawlerFilters}
	 */
	this.crawlerFilters	= new List ([ DocumentCrawler.ID, FocusCrawler.ID ]);
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
DataInputBinding.prototype.toString = function () {

	return "[DataInputBinding]";
}

/**
 * @overloads {DataBinding#onBindingRegister}
 */
DataInputBinding.prototype.onBindingRegister = function () {

	DataInputBinding.superclass.onBindingRegister.call ( this );
	this.propertyMethodMap [ "value" ] = this.setValue;
}

/**
 * @overloads {DataBinding#onBindingAttach}
 */
DataInputBinding.prototype.onBindingAttach = function () {

	DataInputBinding.superclass.onBindingAttach.call ( this );
	
	this._parseDOMProperties ();
	this._buildDOMContent ();
	this._attachDOMEvents ();
}

/**
 * Disposing an invalid DataInputBinding will automatically 
 * make it valid in the greater scheme of this.
 * @overloads {Binding#onBindingDispose}
 */
DataInputBinding.prototype.onBindingDispose = function () {
	
	DataInputBinding.superclass.onBindingDispose.call ( this );
	
	if ( Client.isExplorer && this.isFocused ) {
		this.unsubscribe ( BroadcastMessages.MOUSEEVENT_MOUSEDOWN, this );
	}
	if ( this._dirtyinterval ) {
		window.clearInterval ( this._dirtyinterval );
	}
	if ( !this._isValid ) {
		this.dispatchAction ( Binding.ACTION_VALID );
	}
}

/**
 * Parse DOM properties.
 */
DataInputBinding.prototype._parseDOMProperties = function () {

	this.type = this.getProperty ( "type" );
	this.isRequired = this.getProperty ( "required" );
	this.isPassword = this.getProperty ( "password" ) == true;
	this.minlength = this.getProperty ( "minlength" );
	this.maxlength = this.getProperty ( "maxlength" );
	this._isAutoPost = this.getProperty ( "autopost" ) == true;
	
	/*
	 * Regular expression?
	 */
	var regexrule = this.getProperty ( "regexrule" );
	if ( regexrule != null ) {
		this.expression = new RegExp ( regexrule )
	}
	
	/*
	 * Here's a quick hack - we should probably formalize this.
	 */
	var onblur = this.getProperty ( "onbindingblur" );
	if ( onblur != null ) {
		this.onblur = function () {
			Binding.evaluate ( onblur, this );
		};
	}
	
	/*
	 * Here's another quick hack.
	 */
	var onvaluechange = this.getProperty ( "onvaluechange" );
	if ( onvaluechange != null ) {
		this.onValueChange = function () {
			Binding.evaluate ( onvaluechange, this );
		};
	}
	
	/*
	 * Certain types should present a default error (balloon). Specifying 
	 * the error *directly* on the binding will overwrite the default error.
	 */
	if ( this.error == null && this.type != null ) {
		var error = DataBinding.errors [ this.type ];
		if ( error != null ) {
			this.error = error;
		}
	}
}

/**
 * Build DOM content.
 */
DataInputBinding.prototype._buildDOMContent = function () {
	
	this.shadowTree.input = this._getInputElement ();
	this.shadowTree.box = DOMUtil.createElementNS ( Constants.NS_UI, "ui:box", this.bindingDocument );
	
	if ( Client.isExplorer == true ) {
		this.bindingElement.hideFocus = true;
	}
	
	var value = this.getProperty ( "value" );
	if ( value != null ) {
		this.setValue ( String ( value ));
	}
	
	var name = this.getProperty ( "name" );
	if ( name != null ) {
		this.setName ( name );
	}
	
	var isDisabled = this.getProperty ( "isdisabled" );
	if ( isDisabled == true ) {
		this.setDisabled ( true );
	}
	
	var isReadOnly = this.getProperty ( "readonly" );
	if ( isReadOnly == true ) {
		this.setReadOnly ( true );
	}
	
	var isAutoSelect = this.getProperty ( "autoselect" );
	if ( isAutoSelect == true ) {
		this._isAutoSelect = true;
	}
	
	this.shadowTree.box.appendChild ( 
		this.shadowTree.input
	);

	this.bindingElement.appendChild ( 
		this.shadowTree.box
	);
	
	/*
	 * Setup ASP.NET identity.
	 */
	if ( this.hasCallBackID ()) {
		// Binding.dotnetify not needed!
	} else if ( this._isAutoPost ) {
		this.logger.warn ( "Autopost " + this.toString () + " without a callbackid?" );
	}
}

/**
 * Get input element! Isolated for subclasses to overwrite.
 * @return {HTMLInputElement}
 */
DataInputBinding.prototype._getInputElement = function () {
	
	var element = DOMUtil.createElementNS ( Constants.NS_XHTML, "input", this.bindingDocument );
	element.type = this.isPassword == true ? "password" : "text";
	element.tabIndex = -1;
	return element;
} 

/**
 * Attach DOM events.
 */
DataInputBinding.prototype._attachDOMEvents = function () {
	
	DOMEvents.addEventListener ( this.shadowTree.input, DOMEvents.FOCUS, this );
	DOMEvents.addEventListener ( this.shadowTree.input, DOMEvents.BLUR, this );
	DOMEvents.addEventListener ( this.shadowTree.input, DOMEvents.KEYDOWN, this );
	DOMEvents.addEventListener ( this.shadowTree.input, DOMEvents.KEYPRESS, this );
}

/**
 * @implements {IEventListener}
 * @overloads {Binding#handleEvent}
 * @param {Event} e
 */
DataInputBinding.prototype.handleEvent = function ( e ) {
	
	DataInputBinding.superclass.handleEvent.call ( this, e );
	
	if ( this.isFocusable == true ) {
		switch ( e.type ) {
			
			case DOMEvents.FOCUS :
			case DOMEvents.BLUR :
				this._handleFocusAndBlur ( e.type == DOMEvents.FOCUS );
				break;
				
			case DOMEvents.KEYPRESS :
				switch ( e.keyCode ) {
					case KeyEventCodes.VK_BACK :
					case KeyEventCodes.VK_INSERT :
					case KeyEventCodes.VK_DELETE :
						this._testDirty ();
						break;
				}
				break;
			
			case DOMEvents.KEYDOWN :
				
				this._testDirty ();
				
				switch ( e.keyCode ) {
				
					/*
					 * Prevent ENTER from submitting containing form.
					 */
					case KeyEventCodes.VK_ENTER :						
						this._handleEnterKey ( e );
						break;
						
					/*
					 * Prevent ESC from reverting new value to original 
					 * value (we create input with JS, so our original 
					 * is empty). This behavior is seen in Explorer only.
					 */
					case KeyEventCodes.VK_ESCAPE :
						DOMEvents.preventDefault ( e );
						break;
				}
				
				/*
				 * Autopost stuff.
				 */
				if ( this.isFocusable && this._isAutoPost ) {
					if ( this._timeout != null ) {
						top.window.clearTimeout ( this._timeout );
					}
					var self = this;
					this._timeout = top.window.setTimeout ( function () {
						if ( Binding.exists ( self )) {
							self.dispatchAction ( PageBinding.ACTION_DOPOSTBACK );
						}
					}, this._time );
				}
				
				break;
		}
	}
}

/**
 * Handle DOM focus and blur.
 * @param {boolean} isFocus
 */
DataInputBinding.prototype._handleFocusAndBlur = function ( isFocus ) {
	
	if ( isFocus ) {
		this.focus ( true );
		this.bindingWindow.standardEventHandler.enableNativeKeys ();
		if ( Client.isExplorer == true ) {
			var self = this;
			setTimeout ( function () {
				if ( Binding.exists ( self ) == true ) {
					self.subscribe ( BroadcastMessages.MOUSEEVENT_MOUSEDOWN );
				}
			}, 0 );
		}
	} else {
		this.blur ( true );
		this.bindingWindow.standardEventHandler.disableNativeKeys ();
		if ( Client.isExplorer == true ) {
			this.unsubscribe ( BroadcastMessages.MOUSEEVENT_MOUSEDOWN );
		}
	}
}

/**
 * Handle ENTER key, preventing form submit. Isolated so that subclasses can overwrite. 
 * @param {KeyEvent} e
 */
DataInputBinding.prototype._handleEnterKey = function ( e ) {
	
	DOMEvents.preventDefault ( e );
	DOMEvents.stopPropagation ( e );
	EventBroadcaster.broadcast ( BroadcastMessages.KEY_ENTER );
}

/**
 * Due to some cataclysmic malfunction in Explorer, the input element may still    
 * be registered as document.activeElement when the help popup is opened - even   
 * though the focus is obviously lost! This setup will force it to blur. Don't 
 * enable this in Mozilla - it will cause stuff to loose focus spontaniously.
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
DataInputBinding.prototype.handleBroadcast = function ( broadcast, arg ) { 
	
	DataInputBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	var self = this;
	
	switch ( broadcast ) {
		
		/*
		 * The timeout allows another databinding to claim the focus first.
		 * Remember that the arg can be a Binding (untill we rafactor), so 
		 * it actually doesn't make sanse that this operation doesn't fail.
		 */
		case BroadcastMessages.MOUSEEVENT_MOUSEDOWN :
			
			if ( Client.isExplorer == true ) {
				var target = DOMEvents.getTarget ( arg );
				if ( target != this.shadowTree.input ) {
					setTimeout ( function () {
						if ( Binding.exists ( self ) == true ) {  // what devilship could require this?
							if ( self.isFocused == true ) {
								self.blur ();
							}
						}
					}, 100 );
				}
			}
			break;
	}
}

/**
 * Focus.
 * @overloads {DataBinding#focus}
 * @param {boolean} isDomEvent
 */
DataInputBinding.prototype.focus = function ( isDomEvent ) {
	
	if ( !this.isFocused && !this.isReadOnly && !this.isDisabled ) {
		DataInputBinding.superclass.focus.call ( this );
		if ( this.isFocused == true ) {
			this._focus ();
			if ( this._isAutoSelect == true ) {
				if ( isDomEvent ) {
					var self = this, element = this.bindingElement, handler = {
						handleEvent : function () {
							self.select ();
							DOMEvents.removeEventListener ( element, DOMEvents.MOUSEUP, this );
						}
					};
					DOMEvents.addEventListener ( element, DOMEvents.MOUSEUP, handler );
				} else {
					this.select ();
				}
			}
			this.onfocus ();
			if ( !isDomEvent ) {
				/*
				 * Timeout fixes a few strange problems...
				 */
				var input = this.shadowTree.input;
				setTimeout ( function () {
					FocusBinding.focusElement ( input );
				}, 0 );
			}
		}
	}
}

/**
 * Select contained text.
 */
DataInputBinding.prototype.select = function () {

	var input = this.shadowTree.input;
	
	setTimeout ( function () {
		if ( Client.isExplorer == true ) {
			var range = input.createTextRange();
			range.moveStart ( "character", 0 );
			range.moveEnd ( "character", input.value.length );
			range.select ();
		} else {
	    	input.setSelectionRange ( 0, input.value.length );
		}
	}, 0 );
}

/**
 * Blur.
 * @overloads {DataBinding#blur}
 * @param {boolean} isDomEvent
 */
DataInputBinding.prototype.blur = function ( isDomEvent ) {
	
	if ( this.isFocused == true ) {
		DataInputBinding.superclass.blur.call ( this );
		if ( !isDomEvent ) {
			this.shadowTree.input.blur ();
		}
		this._blur ();
	}
}

/**
 * Setup validation on focus.
 * @private
 */
DataInputBinding.prototype._focus = function () {
	
	if ( !this._isValid ) {
		if ( this.isPassword ) {
			if ( Client.isMozilla ) {
				this.shadowTree.input.type = "password";
				this.setValue ( this._value );
			}
		} else {
			this.setValue ( this._value );
		}
		this.shadowTree.input.className = "";
	}
	
	this._sessionResult = this.getResult ();
	
	var self = this;
	
	this._dirtyinterval = window.setInterval ( function () {
		if ( Binding.exists ( self ) == true ) {
			self.checkDirty ();
			if ( !self._isValid ) {
				self.validate ( true );
			}
		} else {
			window.clearInterval ( self._dirtyinterval );
			self._dirtyinterval = null;
		}
	}, 500 );
}

/**
 * Validate on blur.
 * @private
 */
DataInputBinding.prototype._blur = function () {
	
	if ( this._dirtyinterval ) {
		window.clearInterval ( this._dirtyinterval );
		this._dirtyinterval = null;
	}
	
	this.checkDirty ();
	this.validate ( true );
	
	if ( Types.isFunction ( this.onblur )) {
		this.onblur ();
	}
	if ( this._isValid ) {
		if ( this.getResult () != this._sessionResult ) {
			/*
			 * If autopostback, remember that this._timeout may still be active now!
			 */
			this.onValueChange ();
		}
	}
}

/**
 * Overwrite this!
 */
DataInputBinding.prototype.onfocus = function () {}

/**
 * Overwrite this!
 */
DataInputBinding.prototype.onblur = function () {}

/**
 * Check dirty.
 */
DataInputBinding.prototype.checkDirty = function () {
	
	if ( !this.isDirty ) {		
		if ( this.getResult () != this._sessionResult ) {
			this.dirty ();
		}
	}
}

/**
 * TODO: This seems to do more or less the same 
 * as the method declared above. Fix this please.
 */
DataInputBinding.prototype._testDirty = function () {
	
	var val = this.getValue ();
	var self = this;
	setTimeout ( function () {
		if ( Binding.exists ( self )) {
			if ( self.getValue () != val ) {
				self.dirty ();
			}
		}
	}, 0 );
};

/**
 * Fires when input looses focus and value is changed.
 * Does nothing by default. Feel free to overwrite.
 */
DataInputBinding.prototype.onValueChange = function () {}

/**
 * Validate.
 * @implements {IData}
 * @param {boolean} isInternal Regrettably, this was added to fix bugs when 
 * 		the blur event would update the text content  immideately followed by  
 * 		a page validation. This would cause glitches with minlength etc...		
 * @return {boolean}
 */
DataInputBinding.prototype.validate = function ( isInternal ) {
	
	if ( isInternal == true || this._isValid ) {
	
		var isValid = this.isValid ();
		
		if ( isValid != this._isValid ) {
			
			this._isValid = isValid;
			
			if ( !isValid ) {
				
				this.attachClassName ( DataBinding.CLASSNAME_INVALID );
				this._value = this.getValue ();
				this.dispatchAction ( Binding.ACTION_INVALID );
				
				if ( !this.isFocused ) {
					
					var message = null;
					if ( this._isInvalidBecauseRequired == true ) {
						message = DataBinding.warnings [ "required" ];
					} else if ( this._isInvalidBecauseMinLength == true ) {
						message = DataBinding.warnings [ "minlength" ];
						message = message.replace ( "${count}", String ( this.minlength ));
					} else if ( this._isInvalidBecauseMaxLength == true ) {
						message = DataBinding.warnings [ "maxlength" ];
						message = message.replace ( "${count}", String ( this.maxlength ));
					} else {
						message = DataBinding.warnings [ this.type ];
					}
					
					this.shadowTree.input.className = DataBinding.CLASSNAME_WARNING;
					if ( message != null ) {
						if ( this.isPassword ) {
							if ( Client.isMozilla ) {
								this.shadowTree.input.type = "text";
								this.setValue ( message );
							} else {
								alert ( message );
							}
						} else {
							this.setValue ( message );
						}
					}
				}
				
			} else {
				this._normalizeToValid ();
			}
		}
	}
	
	return this._isValid;
}

/**
 * Normalize invalid binding, marking the binding valid.
 */
DataInputBinding.prototype._normalizeToValid = function () {
	
	if ( this._isValid ) {
		if ( this._timeout != null ) {
			top.window.clearTimeout ( this._timeout );
		}
		if ( this.hasClassName ( DataBinding.CLASSNAME_INVALID )) {
			this.detachClassName ( DataBinding.CLASSNAME_INVALID );
		}
		this.shadowTree.input.className = ""; 
		this.dispatchAction ( Binding.ACTION_VALID );
	}
};

/**
 * @return {boolean}
 */
DataInputBinding.prototype.isValid = function () {
	
	var isValid = true;
	this._isInvalidBecauseRequired = false;
	this._isInvalidBecauseMinLength = false;
	this._isInvalidaBecuaseMaxLength = false;
	var value = this.getValue ();
	
	if ( value == "" ) {
		if ( this.isRequired == true ) {		
			isValid = false;
			this._isInvalidBecauseRequired = true;
		}
	} else if ( this.type != null ) {
		var expression = DataBinding.expressions [ this.type ];
		if ( !expression.test ( value )) {
			isValid = false;
		}
	} else if ( this.expression != null ) {
		if ( !this.expression.test ( value )) {
			isValid = false;
		}
	}
	if ( isValid && this.minlength != null ) {
		if ( value.length < this.minlength ) {
			this._isInvalidBecauseMinLength = true;
			isValid = false;
		}
	}
	if ( isValid && this.maxlength != null ) {
		if ( value.length > this.maxlength ) {
			this._isInvalidBecauseMaxLength = true;
			isValid = false;
		}
	}
	return isValid;
}

/**
 * @param {boolean} isDisabled
 */
DataInputBinding.prototype.setDisabled = function ( isDisabled ) {
	
	if ( isDisabled != this.isDisabled ) {
		if ( isDisabled ) {
			this.attachClassName ( "isdisabled" );
		} else {
			this.detachClassName ( "isdisabled" );
		}
		var input = this.shadowTree.input;
		if ( isDisabled ) {
			this._disabledHandler = {
				handleEvent : function ( e ) {
					DOMEvents.preventDefault ( e );
					DOMEvents.stopPropagation ( e );
				}
			}
			DOMEvents.addEventListener ( input, DOMEvents.MOUSEDOWN, this._disabledHandler );
		} else {
			DOMEvents.removeEventListener ( input, DOMEvents.MOUSEDOWN, this._disabledHandler );
			this._disabledHandler = null;
		}
		if ( Client.isExplorer ) { // is this needed?
			this.shadowTree.input.disabled = isDisabled;
			this.shadowTree.input.unselectable = isDisabled ? "on" : "off";
		}
		this.isDisabled = isDisabled;
		this.isFocusable = !isDisabled;
		this.dispatchAction ( FocusBinding.ACTION_UPDATE );
	}
}

/**
 * @param {boolean} isReadOnly
 */
DataInputBinding.prototype.setReadOnly = function ( isReadOnly ) {
	
	if ( isReadOnly != this.isReadOnly ) {
		if ( isReadOnly ) {
			this.attachClassName ( "readonly" );
		} else {
			this.detachClassName ( "readonly" );
		}
		this.shadowTree.input.readOnly = isReadOnly;
		this.isReadOnly = isReadOnly;
	}
}

/**
 * Disable.
 */
DataInputBinding.prototype.disable = function () {
	
	if ( !this.isDisabled ) {
		this.setDisabled ( true );
	}
}

/**
 * Enable.
 */
DataInputBinding.prototype.enable = function () {
	
	if ( this.isDisabled ) {
		this.setDisabled ( false );
	}
}

/** 
 * Handle element update.
 * @implements {IUpdateHandler}
 * @overwrites {Binding#handleElement}
 * @param {Element} element
 * @return {boolean}
 */
DataInputBinding.prototype.handleElement = function ( element ) {
	
	return true;
};

/** 
 * Update element.
 * @implements {IUpdateHandler}
 * @overwrites {Binding#updateElement}
 * @param {Element} element
 * @return {boolean}
 */
DataInputBinding.prototype.updateElement = function ( element ) {
	
	var newval = value = element.getAttribute ( "value" );
	if ( newval == null ) {
		newval = "";
	}
	if ( this.getValue () != newval ) {
		var manager = this.bindingWindow.UpdateManager;
		manager.report ( "Property [value] updated on binding \"" + this.getID () + "\"" );
		this.setValue ( newval );
	}
	return true;
};

/**
 * Manifest. Because postback without validation may happen, 
 * we may need override validation message and post an empty 
 * string to the server. "Save" is a validated postback, so 
 * the non-validating string is not made permanent by this.
 * @implements {IData}
 */
DataInputBinding.prototype.manifest = function () {
	
	if ( !this._isValid ) {
		this.setValue ( "" ); // post empty to the server
		this._isValid = true; // prepare for next validation
		this._normalizeToValid (); // reset styling and stuff
	}
}

/**
 * Clean.
 * @overloads {DataBinding#clean}
 * @implements {IData}
 */
DataInputBinding.prototype.clean = function () {
	
	DataInputBinding.superclass.clean.call ( this );
	this._sessionResult = this.getResult ();
}

/**
 * Set value.
 * @param {String} value
 */
DataInputBinding.prototype.setValue = function ( value ) {
	
	if ( value === null ) {
		value = "";
	}
	if ( value != this.getValue ()) {
		this.setProperty ( "value", value );
		if ( this.shadowTree.input != null ) {
			this.shadowTree.input.value = String ( value );
		}
	}
}

/**
 * Get value.
 * @implements {IData}
 * @return {string}
 */
DataInputBinding.prototype.getValue = function () {
	
	var result = null;
	if ( this.shadowTree.input != null ) {
		result = this.shadowTree.input.value; 
	} else {
		result = this.getProperty ( "value" );
	}
	return result;
}

/**
 * Set name.
 * Overloads {DataBinding#setName}
 * @param {string} name
 */
DataInputBinding.prototype.setName = function ( name ) {
	
	DataInputBinding.superclass.setName.call ( this, name );
	
	if ( this.isAttached == true ) {
		this.shadowTree.input.name = name;
	}
}

/**
 * Get result. Unlike getValue, the result is qualified according to type property.
 * @implements {IData}  
 * @return {object}
 */
DataInputBinding.prototype.getResult = function () {

	var result = this.getValue ();
	
	switch ( this.type ) {
		case DataBinding.TYPE_NUMBER :
		case DataBinding.TYPE_INTEGER :
			result = Number ( result );
			break;
	}
	return result;
}

/**
 * Set result.
 * @implements {IData}  
 * @param {object} result
 */
DataInputBinding.prototype.setResult = DataInputBinding.prototype.setValue;

/**
 * DataInputBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {DataInputBinding}
 */
DataInputBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:datainput", ownerDocument );
	return UserInterface.registerBinding ( element, DataInputBinding );
}

TextBoxBinding.prototype = new DataInputBinding;
TextBoxBinding.prototype.constructor = TextBoxBinding;
TextBoxBinding.superclass = DataInputBinding.prototype;

/**
 * @class
 * @implements {IData}
 */
function TextBoxBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "TextBoxBinding" );
	
	/**
	 * For subclasses to negate.
	 * @type {boolean}
	 */
	this._hasWordWrap = true;
	
	/*
	 * Returnable.
	 */
	return this;
	
}

/**
 * Identifies binding.
 */
TextBoxBinding.prototype.toString = function () {

	return "[TextBoxBinding]";
}

/**
 * @overloads {DataInputBinding#_buildDOMContent}
 */
TextBoxBinding.prototype._buildDOMContent = function () {
	
	/*
	 * Note that we nuke the textarea that may have been used to populate  
	 * our value. That's because we'll replace it with our own area...
	 */
	var defaultarea = DOMUtil.getElementsByTagName ( this.bindingElement, "textarea" ).item ( 0 );
	if ( defaultarea != null ) {
		this.setValue ( defaultarea.value );
		defaultarea.parentNode.removeChild ( defaultarea );
	}
	
	/*
	 * Super goes here!
	 */
	TextBoxBinding.superclass._buildDOMContent.call ( this );
	
	/*
	 * Textarea specials.
	 */
	this.shadowTree.input.setAttribute ( "spellcheck", "false" );
	if ( !this._hasWordWrap ) {
		this.shadowTree.input.setAttribute ( "wrap", "off" );
	}
}

/**
 * Get input element. A textarea, in this case.
 * @return {HTMLInputElement}
 */
TextBoxBinding.prototype._getInputElement = function () {
	
	var element = DOMUtil.createElementNS ( Constants.NS_XHTML, "textarea", this.bindingDocument );
	element.tabIndex = -1;
	return element;
} 


/** 
 * Handle element update.
 * @implements {IUpdateHandler}
 * @overwrites {Binding#handleElement}
 * @param {Element} element
 * @return {boolean}
 */
TextBoxBinding.prototype.handleElement = function ( element ) {
	
	return true;
};

/** 
 * Update element.
 * @implements {IUpdateHandler}
 * @overwrites {Binding#updateElement}
 * @param {Element} element
 * @return {boolean}
 */
TextBoxBinding.prototype.updateElement = function ( element ) {
	
	var newval, area = element.getElementsByTagName ( "textarea" ).item ( 0 );
	if ( area != null && area.hasChildNodes ()) {
		newval = DOMUtil.getTextContent ( area );
	}
	// TODO: handle "value" property, though not normally used by server
	if ( newval == null ) {
		newval = "";
	}
	if ( this.getValue () != newval ) {
		var manager = this.bindingWindow.UpdateManager;
		manager.report ( "Property [value] updated on binding \"" + this.getID () + "\"" );
		this.setValue ( newval );
	}
	return true;
};

/**
 * Handle ENTER key. Lets not preventDefault the event!
 * @overwrites {DataInputBinding#_handleEnterKey} 
 * @param {KeyEvent} e
 */
TextBoxBinding.prototype._handleEnterKey = function ( e ) {
	
	DOMEvents.stopPropagation ( e );
};

EditorTextBoxBinding.prototype = new TextBoxBinding;
EditorTextBoxBinding.prototype.constructor = EditorTextBoxBinding;
EditorTextBoxBinding.superclass = TextBoxBinding.prototype;

/**
 * @class
 * Tab indent, tab preservation, no soft text wrap. Because of extremely different implementations, 
 * this has been split into two different bindings. Note that the box must be placed inside an 
 * <ui:flexbox> element to maximize it's sreen estate.
 * @see {MozEditorTextBoxBinding}
 * @see {IEEditorTextBoxBinding}
 */
function EditorTextBoxBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "EditorTextBoxBinding" );
	
	/**
	 * @overloads {TextBoxBinding#_hasWordWrap}
	 * @type {boolean}
	 */
	this._hasWordWrap = false;
}

/**
 * Identifies binding.
 */
EditorTextBoxBinding.prototype.toString = function () {
	
	return "[EditorTextBoxBinding]";
}

/**
 * @implements {IEventListener}
 * @overwrites {TextBoxBinding#handleEvent}
 * @param {Event} e
 */
EditorTextBoxBinding.prototype.handleEvent = function ( e ) {
	
	if ( this.isFocusable == true ) {
		switch ( e.type ) {
			
			case DOMEvents.FOCUS :
			case DOMEvents.BLUR :
				this._handleFocusAndBlur ( e.type == DOMEvents.FOCUS );
				break;
				
			case DOMEvents.KEYDOWN :
				this._handleKeyEvent ( e );
				break;
		}
	}
}

/**
 * @param {KeyEvent} e
 * @overloads {TextBoxBinding#_handleKeyEvent}
 */
EditorTextBoxBinding.prototype._handleKeyEvent = function ( e ) {
	
	switch ( e.keyCode ) {
		
		/*
		 * Handle TAB.
		 */
		case KeyEventCodes.VK_TAB :
			this._handleTabKey ( e.shiftKey );
			DOMEvents.stopPropagation ( e );
			DOMEvents.preventDefault ( e );
			break;
		
		/*
		 * Handle ENTER.
		 */
		case KeyEventCodes.VK_ENTER :
			this._handleEnterKey ();
			DOMEvents.stopPropagation ( e );
			DOMEvents.preventDefault ( e );
			break;
			
		/*
		 * Prevent ESC from reverting new value to original 
		 * value. This is default behavior in Explorer only. 
		 * We create input with JS, so our original is empty.
		 * TODO: This should also escape keyboard nav from editor!
		 */
		case KeyEventCodes.VK_ESCAPE :
			DOMEvents.preventDefault ( e );
			break;
	}
}

/**
 * Subclass must define this.
 * @param {boolean} isReverse
 */
EditorTextBoxBinding.prototype._handleTabKey = Binding.ABSTRACT_METHOD;

/**
 * Subclass must define this.
 */
EditorTextBoxBinding.prototype._handleEnterKey = Binding.ABSTRACT_METHOD;

IEEditorTextBoxBinding.prototype = new EditorTextBoxBinding;
IEEditorTextBoxBinding.prototype.constructor = IEEditorTextBoxBinding;
IEEditorTextBoxBinding.superclass = EditorTextBoxBinding.prototype;

/**
 * Tab indent, tab preservation, no soft text wrap.
 * @class
 */
function IEEditorTextBoxBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "IEEditorTextBoxBinding" );
}

/**
 * Identifies binding.
 */
IEEditorTextBoxBinding.prototype.toString = function () {
	
	return "[IEEditorTextBoxBinding]";
}

/**
 * Handle TAB key.
 * @param {boolean} isReverse
 */
IEEditorTextBoxBinding.prototype._handleTabKey = function ( isReverse ) {
	
	var range = this.bindingDocument.selection.createRange ();
	var isCollapsed = range.text == "";
	
	if ( isCollapsed && !isReverse ) {
	
		range.text = "\t"; // TODO: unindent single line on reverse!
		
	} else {
		
		var text = "";
		var length = range.text.length;
		
		while (( range.moveStart ( "word", -1 ) && range.text.charAt ( 1 ) != "\n" ));
		range.moveStart ( "character", 1 );
		
		var count = 0;
				
		var i = 0, line, lines = range.text.split ( "\n" );
		while (( line = lines [ i++ ]) != null ) {
			if ( isReverse ) {
				line = line.replace ( /^(\s)/mg, "" );
				count ++;
			} else {
				line = line.replace ( /^(.)/mg, "\t$1" );
			}
			text += line + ( lines [ i + 1 ] ? "\n" : "" )
		}
		
		range.text = text;
		range.moveStart ( "character", - length );
		if ( isReverse ) {
			range.moveStart ( "character", 2 * lines.length - 2 ); // seems to work...
		}
		range.select ();
	}
}

/**
 * Handle ENTER key.
 */
IEEditorTextBoxBinding.prototype._handleEnterKey = function () {

	var range = this.bindingDocument.selection.createRange ();
	var clone = range.duplicate ();

	while (( clone.moveStart ( "word", -1 ) && clone.text.indexOf ( "\n" ) ==-1 ));
	clone.moveStart ( "character", 1 );
	
	range.text = "\n" + clone.text.match ( /^(\s)*/ )[ 0 ] + "!";
	range.moveStart ( "character", -1 );
	range.select ();
	range.text = "";
	range.select ();
}

MozEditorTextBoxBinding.prototype = new EditorTextBoxBinding;
MozEditorTextBoxBinding.prototype.constructor = MozEditorTextBoxBinding;
MozEditorTextBoxBinding.superclass = EditorTextBoxBinding.prototype;

/**
 * Tab indent, tab preservation, no soft text wrap.
 * @class
 */
function MozEditorTextBoxBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "MozEditorTextBoxBinding" );
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
MozEditorTextBoxBinding.prototype.toString = function () {
	
	return "[MozEditorTextBoxBinding]";
}

/**
 * Handle TAB key.
 * @param {boolean} isReverse
 */
MozEditorTextBoxBinding.prototype._handleTabKey = function ( isReverse ) {
	
	var lastx;
	var lasty;
	var oss;
	var osy;
	var i;
	var fnd;
	var selectedText = this._getSelectedText ();
	var el = this.shadowTree.input;
	
	lastx = el.scrollLeft;
	lasty = el.scrollTop;
	
	if (!selectedText.match(/\n/)) {
		oss = el.selectionStart;
		el.value = el.value.substr(0, el.selectionStart) + "\t" + el.value.substr(el.selectionEnd);
		el.selectionStart = oss + 1;
		el.selectionEnd = oss + 1;
	} else {
		oss = el.selectionStart;
		osy = el.selectionEnd;
		fnd = 0;
		for (i = oss - 1; i >= 0; i --) {
			if (el.value.charAt(i) == "\n") {
				oss = i + 1;
				fnd = 1;
				break;
			}
		} if (fnd == 0) {
			oss = 0;
		}
		fnd = 0;
		for (i = osy; i < el.value.length; i ++) {
			if (el.value.charAt(i) == "\n") {
				osy = i;
				fnd = 1;
				break;
			}
		} if (fnd == 0) {
			osy = el.value.length;
		}
		el.selectionStart = oss;
		el.selectionEnd = osy;
		selectedText = this._getSelectedText ();
		
		if ( isReverse ) {
			ntext = selectedText.replace( /^(\s)/mg, "" );
		} else {
			ntext = selectedText.replace( /^(.)/mg, "\t$1" );
		}
		el.value = el.value.substr(0, el.selectionStart) + ntext + el.value.substr(el.selectionEnd);
		el.selectionStart = oss;
		el.selectionEnd = osy + (ntext.length - selectedText.length);
	}
	el.scrollLeft = lastx;
	el.scrollTop  = lasty;		
}

/**
 * Handle ENTER key.
 */
MozEditorTextBoxBinding.prototype._handleEnterKey = function () {
	
	var lastx;
	var lasty;
	var oss;
	var osy;
	var el = this.shadowTree.input;

	lastx = el.scrollLeft;
	lasty = el.scrollTop;
	oss = el.selectionStart;
	osy = el.selectionEnd;
	var bfs = el.value.substr(0, el.selectionStart);
	var bfsm = bfs.split(/\r|\n/g);

	var spm = bfsm[bfsm.length - 1].match(/^(\s)*/);
	el.value = el.value.substr(0, el.selectionStart) + "\n" + spm[0] + el.value.substr(el.selectionEnd);
	el.selectionStart = oss + 1 + spm[0].length;
	el.selectionEnd = oss + 1 + spm[0].length;
	
	el.scrollLeft = lastx;
	el.scrollTop  = lasty;
}

/**
 * Get selected text.
 * @return {string}
 */
MozEditorTextBoxBinding.prototype._getSelectedText = function () {
	
	var value 	= this.shadowTree.input.value;
	var start 	= this.shadowTree.input.selectionStart;
	var end 	= this.shadowTree.input.selectionEnd;
	
	return value.substr ( start, end - start );
}

SelectorBinding.prototype = new DataBinding;
SelectorBinding.prototype.constructor = SelectorBinding;
SelectorBinding.superclass = DataBinding.prototype;

SelectorBinding.INDICATOR_IMAGE = Resolver.resolve ( "${skin}/fields/selectorindicator.png" );
SelectorBinding.ACTION_SELECTIONCHANGED = "selectorselectionchanged";
SelectorBinding.ACTION_COMMAND = "selectorcommand";
SelectorBinding.CLASSNAME_POPUP = "selectorpopup";

/**
 * @class
 * @implements {IData}
 */
function SelectorBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SelectorBinding" );
	
	/**
	 * @type {string}
	 */
	this.type = null;
	
	/**
	 * @type {ToolBarButtonBinding}
	 */
	this._buttonBinding = null;
	
	/**
	 * @type {PopupBinding}
	 */
	this._popupBinding = null;
	
	/**
	 * @type {MenuBodyBinding}
	 */
	this._menuBodyBinding = null;
	
	/**
	 * @type {string}
	 */
	this._selectionValue = null;
	
	/**
	 * @type {List<SelectorBindingSelection>}
	 */
	this.selections = null;

	/**
	 * @type {boolean}
	 */
	this.isDisabled = false;
	
	/**
	 * This will be used as default label.
	 * @type {string}
	 */
	this.label = null;
	
	/**
	 * This will be used as default value.
	 * @type {string}
	 */
	this.value = null;
	
	/**
	 * @type {int}
	 */
	this.width = null;
	
	/**
	 * @type {SelectorBindingSelection}
	 */
	this.defaultSelection = null;
	
	/**
	 * @type {string}
	 */
	this.image = null;
	
	/**
	 * @type {string}
	 */
	this.imageHover = null;
	
	/**
	 * @type {string}
	 */
	this.imageActive = null;
	
	/**
	 * @type {string}
	 */
	this.imageDisabled = null;
	
	/**
	 * @type {boolean}
	 */
	this.isDirty = false;
	
	/**
	 * Flipped when menitems need to be reindexed.
	 * @type {boolean}
	 */
	this._isUpToDate = false;
	
	/**
	 * @type {boolean}
	 */
	this._hasKeyboard = false;
	
	/*
	 * Overwritable button implementation.
	 * @see {EditorSelectorBinding}
	 * @type {class}
	 */
	this.BUTTON_IMPLEMENTATION = ClickButtonBinding;
	
	/*
	 * Overwritable menuitem implementation.
	 * @see {EditorSelectorBinding}
	 * @type {class}
	 */
	this.MENUITEM_IMPLEMENTATION = MenuItemBinding;
	
	/**
	 * @type {boolean}
	 */
	this._isImageLayout = true;
	
	/**
	 * @type {boolean}
	 */
	this.isRequired = false;
	
	/**
	 * @type {boolean}
	 */
	this._isValid = true;
	
	/**
	 * Block common crawlers.
	 * @type {Map<string><boolean>}
	 * @overwrites {Binding#crawlerFilters}
	 */
	this.crawlerFilters	= new List ([ DocumentCrawler.ID, FocusCrawler.ID ]);
}

/**
 * Identifies binding.
 */
SelectorBinding.prototype.toString = function () {

	return "[SelectorBinding]";
}

/**
 * @overloads {DataBinding#onBindingAttach}
 */
SelectorBinding.prototype.onBindingAttach = function () {
	
	SelectorBinding.superclass.onBindingAttach.call ( this );
	
	this.selections = new List ();
	
	this.parseDOMProperties ();
	this.buildDOMContent ();
	this.addEventListener ( DOMEvents.FOCUS );
	this.addActionListener ( ButtonBinding.ACTION_COMMAND );
	
	var isDisabled = this.getProperty ( "isdisabled" );
	if ( this.isDisabled || isDisabled ) {
		this.disable ();
	}
}

/**
 * @overloads {DataBinding#onBindingDispose}
 */
SelectorBinding.prototype.onBindingDispose = function () {
		
	SelectorBinding.superclass.onBindingDispose.call ( this );
	
	if ( this._popupBinding && Binding.exists ( this._popupBinding )) {
		this._popupBinding.dispose ();
	}
	if ( this._hasKeyboard == true ) {
		this._releaseKeyboard ();
	}
}


/**
 * Parse DOM properties.
 */
SelectorBinding.prototype.parseDOMProperties = function () {

	var type			= this.getProperty ( "type" );
	var label 			= this.getProperty ( "label" );
	var value 			= this.getProperty ( "value" );
	var width 			= this.getProperty ( "width" );
	var onchange		= this.getProperty ( "onchange" );
	var isRequired		= this.getProperty ( "required" ) == true;
	
	if ( !this.type && type ) {
		this.type = type;
	}
	if ( !this.label && label != null ) {
		this.label = label;
	}
	if ( !this.value && value != null ) {
		this.value = value;	
	}
	if ( !this.width && width ) {
		this.width = width;
	}
	if ( isRequired ) {
		this.isRequired = true;
	}
	if ( onchange ) {
		this.onValueChange = function () {
			Binding.evaluate ( onchange, this );
		};
	}
	this._computeImageProfile ();
}

/*
 * Compute image profile.
 * TODO: Please formalize and explain how selector imageprofile relates to selection imageprofile!
 */
SelectorBinding.prototype._computeImageProfile = function () {

	Binding.imageProfile ( this );
	//alert ( this.imageProfile )
}

/**
 * Build button, indicator and popup. Finally populate by selection elements.
 */
SelectorBinding.prototype.buildDOMContent = function () {

	this.buildButton ();
	this.buildIndicator ();
	this.buildPopup ();
	this.buildSelections ();
	
	this.bindingElement.tabIndex = 0;
	if ( Client.isExplorer == true ) {
		this.bindingElement.hideFocus = true;
	}
}		

/**
 * Build form field for serverside processing.
 */
SelectorBinding.prototype.buildFormField = function () {

	var input = DOMUtil.createElementNS ( Constants.NS_XHTML, "input", this.bindingDocument );
	input.name = this.getName ();
	input.value	= this.getValue ();
	input.type = "hidden";
	
	if ( this.hasCallBackID ()) {
		input.id = this.getCallBackID ();
	}
	
	this.shadowTree.input = input;
	this.bindingElement.appendChild ( input );
}

/**
 * Build button.
 */
SelectorBinding.prototype.buildButton = function () {

	/*
	 * Subclasses can use a different button around here.
	 */
	var buttonImplementation = this.BUTTON_IMPLEMENTATION;

	var button = this.add ( 
		buttonImplementation.newInstance ( this.bindingDocument )
	);
	if ( this.imageProfile != null ) {
		button.imageProfile = this.imageProfile;
	}
	if ( this.width != null ) {
		button.setWidth ( this.width );
	}
	this._buttonBinding = button;
	this.shadowTree.button = button; /* don't serialize */
	button.attach ();
}

/**
 * Building dropdown indicator image.
 * TODO: stylesheet this?
 */
SelectorBinding.prototype.buildIndicator = function () {
	
	var img = this.bindingDocument.createElement ( "img" );
	img.src = SelectorBinding.INDICATOR_IMAGE;
	img.className = "selectorindicatorimage";
	this._buttonBinding.bindingElement.appendChild ( img );
	this.shadowTree.selectorindicatorimage = img;
}

/**
 * Build selections.
 */
SelectorBinding.prototype.buildPopup = function () {
	
	/*
	 * Build the popup.
	 */
	var popupSetBinding = top.app.bindingMap.selectorpopupset;
	var doc = popupSetBinding.bindingDocument;
	var popupBinding = popupSetBinding.add (
		PopupBinding.newInstance ( doc )
	);
	var bodyBinding = popupBinding.add (
		MenuBodyBinding.newInstance ( doc )
	);
	this._popupBinding = popupBinding;
	this._menuBodyBinding = bodyBinding;
	this._popupBinding.attachClassName ( SelectorBinding.CLASSNAME_POPUP );
	this._popupBinding.attachRecursive (); // TODO: not yet?
	
	/*
	 * Unhardcode this when we decide to support submenus in popup.
	 */
	this._popupBinding.type = PopupBinding.TYPE_FIXED;
	
	/*
	 * Assigninging popup to button.
	 */
	popupBinding.attachClassName ( "selectorpopup" );
	popupBinding.addActionListener ( PopupBinding.ACTION_SHOW, this );
	popupBinding.addActionListener ( MenuItemBinding.ACTION_COMMAND, this );
	popupBinding.addActionListener ( PopupBinding.ACTION_HIDE, this );
	this._buttonBinding.setPopup ( popupBinding );
}

/**
 * Build selections.
 */
SelectorBinding.prototype.buildSelections = function () {
	
	/*
	 * Compute default selection.
	 */
	if ( this.defaultSelection == null && ( this.label || this.value )) {
		this.defaultSelection = new SelectorBindingSelection (
			this.label,
			this.value,
			true,
			null // this.imageprofile!
		);
	}
	
	/*
	 * Retrieve selections from markup.
	 */
	var list = this._getSelectionsList ();
	
	/*
	 * Even if list is empty, this will 
	 * still build the default selection.
	 */
	this.populateFromList ( list );
}

/**
 * Parse ui:selection elements into instances of SelectorBindingSelection. 
 * This will be used to populate the selector.
 * @return {List<SelectorBindingSelection>}
 */
SelectorBinding.prototype._getSelectionsList = function () {

	var list = new List ();
	var selections = DOMUtil.getElementsByTagName ( this.bindingElement, "selection" );
	new List ( selections ).each ( function ( selection ) {
	
		var label 			= selection.getAttribute ( "label" );
		var value 			= selection.getAttribute ( "value" );
		var isSelected 		= selection.getAttribute ( "selected" );
		var image			= selection.getAttribute ( "image" );
		var imageHover		= selection.getAttribute ( "image-hover" );
		var imageActive		= selection.getAttribute ( "image-active" );
		var imageDisabled	= selection.getAttribute ( "image-disabled" );
		
		var imageProfile = null;
		
		if ( image || imageHover || imageActive || imageDisabled ) {  
			imageProfile = new ImageProfile ({
				image : image,
				imageHover : imageHover,
				imageActive : imageActive,
				imageDisabled : imageDisabled
			});
		}
		
		list.add ( 
			new SelectorBindingSelection ( 
				label ? label : null,
				value ? value : null,
				isSelected && isSelected == "true",
				imageProfile
			)
		);
	});
	
	return list;
}

/**
 * @param {List<SelectorBindingSelection>} list
 */
SelectorBinding.prototype.populateFromList = function ( list ) {
	
	if ( this.isAttached ) {
	
		/*
		 * Clear existing content, leaving only the default selection.
		 */
		this.clear ();
		
		/*
		 * Add new content.
		 */	
		if ( list.hasEntries ()) {
			var firstItem = null;
			while ( list.hasNext ()) {
				var selection = list.getNext ();
				var item = this.addSelection ( selection );
				if ( !firstItem ) {
					firstItem = item;
				}
			}
			if ( !this._selectedItemBinding ) {
				this.select ( firstItem, true );
			}
			this.shadowTree.selectorindicatorimage.style.display = "block";
		} else {
			this.shadowTree.selectorindicatorimage.style.display = "none";
		}
	} else {
		
		throw "Could not populate unattached selector"; // TODO: Cache the list and wait?
	}
}

/**
 * Add selection, returning the created MenuItemBinding.
 * @param {SelectorBindingSelection} selection
 * @param {boolean} isPositionFirst
 * @return {MenuItemBinding}
 */
SelectorBinding.prototype.addSelection = function ( selection, isPositionFirst ) {
	
	var menuItemImplementation = this.MENUITEM_IMPLEMENTATION;
	
	var bodyBinding = this._menuBodyBinding;
	var bodyDocument = bodyBinding.bindingDocument;
	
	var itemBinding = menuItemImplementation.newInstance ( bodyDocument );
	itemBinding.imageProfile = selection.imageProfile;
	itemBinding.setLabel ( selection.label );
	itemBinding.selectionValue = selection.value;
	
	if ( selection.isSelected ) {
		this.select ( itemBinding, true );
	}
	
	selection.menuItemBinding = itemBinding;
	if ( isPositionFirst ) {
		bodyBinding.addFirst ( itemBinding );
		this.selections.addFirst ( selection );
	} else {
		bodyBinding.add ( itemBinding );
		this.selections.add ( selection );
	}
	
	this._isUpToDate = false;
	return itemBinding;
}

/**
 * Add selection first.
 * @param {SelectorBindingSelection} selection
 * @return {MenuItemBinding}
 */
SelectorBinding.prototype.addSelectionFirst = function ( selection ) {

	return this.addSelection ( selection, true );
}
/** 
 * Dispose existing content. Leave default selection.
 * @param {boolean} isClearAll
 */ 
SelectorBinding.prototype.clear = function ( isClearAll ) {

	this._selectedItemBinding = null;

	if ( this._popupBinding ) {
		
		this._popupBinding.clear ();
		this.selections.clear ();
		
		/*
		 * If not clear all, add default selection. 
		 * Checking that multiple calls to clear 
		 * will not add multiple default selections.
		 */
		if ( !isClearAll && this.defaultSelection != null ) {
			var menuItemBinding = this.addSelection ( 
				this.defaultSelection 
			);
			this.select ( menuItemBinding, true );
		}
	}
}

/**
 * Clear all.
 */
SelectorBinding.prototype.clearAll = function () {
	
	this.clear ( true );
}

/**
 * Disable.
 */
SelectorBinding.prototype.disable = function () {
	
	this.setDisabled ( true );
}

/**
 * Enable.
 */
SelectorBinding.prototype.enable = function () {
	
	this.setDisabled ( false );
}

/**
 * Focus.
 * @implements {IData}
 */
SelectorBinding.prototype.focus = function () {
	
	if ( !this.isFocused ) {
		DataBinding.prototype.focus.call ( this );
		if ( this.isFocused == true ) {
			FocusBinding.focusElement ( this.bindingElement );
			this._grabKeyboard ();
		}	
	}
}

/**
 * Blur.
 * @implements {IData}
 */
SelectorBinding.prototype.blur = function () {

	if ( this.isFocused == true ) {
		DataBinding.prototype.blur.call ( this );
		this._releaseKeyboard ();
		if ( this._popupBinding.isVisible ) {		
			this._popupBinding.hide ();
		}
	}
}

/**
 * Grab keyboard.
 */
SelectorBinding.prototype._grabKeyboard = function () {
	
	if ( !this._hasKeyboard ) {
		this.subscribe ( BroadcastMessages.KEY_ARROW );
		this._hasKeyboard = true;
	}
}

/**
 * Release keyboard.
 */
SelectorBinding.prototype._releaseKeyboard = function () {
	
	if ( this._hasKeyboard == true ) {
		this.unsubscribe ( BroadcastMessages.KEY_ARROW );
		this._hasKeyboard = false;
	}
}

/**
 * Set disabled status.
 * @param {boolean} isDisabled
 */
SelectorBinding.prototype.setDisabled = function ( isDisabled ) {
	
	if ( this.isAttached == true ) {	
		var button = this._buttonBinding;
		this.shadowTree.selectorindicatorimage.style.display = isDisabled ? "none" : "block";
		button.setDisabled ( isDisabled );
	}	
	if ( isDisabled ) {
		this.setProperty ( "isdisabled", true );
	} else {
		this.deleteProperty ( "isdisabled" );
	}
}

/**
 * Reset.
 * @param {boolean} isActionBlocked
 */
SelectorBinding.prototype.reset = function ( isActionBlocked ) {
	
	if ( this.defaultSelection != null ) {
		this.selectByValue ( 
			this.defaultSelection.value,
			isActionBlocked
		);
	}
}

/**
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
SelectorBinding.prototype.handleAction = function ( action ) {
	
	SelectorBinding.superclass.handleAction.call ( this, action );
	
	switch ( action.type ) {
	
		case ButtonBinding.ACTION_COMMAND :
			this._onButtonCommand ();
			action.consume ();
			break;
		case PopupBinding.ACTION_SHOW :		
			this._onPopupShowing ();
			action.consume ();
			break;
		case MenuItemBinding.ACTION_COMMAND :
			this._onMenuItemCommand ( action.target );
			action.consume ();
			break;
		case PopupBinding.ACTION_HIDE :
			/*
			 * If TAB key was pressed, closing the popup, we no  
			 * longer have focus and should not grab the keyboard.
			 */
			var self = this;
			setTimeout ( function () {
				if ( self.isFocused ) {
					self._grabKeyboard ();
				}
			}, 0 );
			action.consume ();
			break;
	}
}

/**
 * On button command.
 */
SelectorBinding.prototype._onButtonCommand = function () {

	this.focus ();
	this._attachSelections ();
	this._restoreSelection ();
	this.dispatchAction ( SelectorBinding.ACTION_COMMAND );
}

/**
 * On popup showing.
 */
SelectorBinding.prototype._onPopupShowing = function () {

	this._fitMenuToSelector ();
	this._releaseKeyboard ();
}

/**
 * On menuitem command.
 * @param {MenuItemBinding} binding
 */
SelectorBinding.prototype._onMenuItemCommand = function ( binding ) {

	this.select ( binding );
	FocusBinding.focusElement ( this.bindingElement );
	this._grabKeyboard ();
}

/**
 * Restore selection.
 */
SelectorBinding.prototype._restoreSelection = function () {
	
	if ( this._selectedItemBinding ) {
		this._selectedItemBinding.focus ();
	}
}

/**
 * For cosmetic reasons, attempting to make 
 * the opening menu as wide as the selector.
 */
SelectorBinding.prototype._fitMenuToSelector = function () {
	
	var selectorWidth = this._buttonBinding.bindingElement.offsetWidth + "px";
	var popupElement = this._popupBinding.bindingElement;
	
	if ( Client.isMozilla == true ) {
		popupElement.style.minWidth = selectorWidth;
	} else {
		popupElement.style.width = selectorWidth;
	}
}

/**
 * 
 * @param {Event} e
 */
SelectorBinding.prototype.handleEvent = function ( e ) {
	
	SelectorBinding.superclass.handleEvent.call ( this, e );
	
	switch ( e.type ) {
		case DOMEvents.FOCUS :
			this.focus ();
			break;
	}
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
SelectorBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	SelectorBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		case BroadcastMessages.KEY_ARROW :
			this.logger.debug ( this._buttonBinding.getLabel ());
			this._handleArrowKey ( arg );
			break;
	}
}

/**
 * Keyboard navigation stuff.
 * @param {int} key
 */
SelectorBinding.prototype._handleArrowKey = function ( key ) {
	
	if ( !this._popupBinding.isVisible ) {
		switch ( key ) {
			case KeyEventCodes.VK_DOWN :
			case KeyEventCodes.VK_UP :
				this._buttonBinding.check ();
				break;
		}
	}
}

/**
 * Select by MenuItemBinding.
 * @param {MenuItemBinding} itemBinding
 * @param {boolean} isActionBlocked True while initializing to block action.
 * @return {boolean} True if something (new) was selected
 */
SelectorBinding.prototype.select = function ( itemBinding, isActionBlocked ) {
	
	var isSuccess = false;
	
	if ( itemBinding != this._selectedItemBinding ) {
		
		this._selectedItemBinding = itemBinding;
		isSuccess = true;
	
		var button = this._buttonBinding;
		this._selectionValue = itemBinding.selectionValue;
		button.setLabel ( itemBinding.getLabel ());
		
		if ( itemBinding.imageProfile != null ) {
			button.imageProfile = itemBinding.imageProfile;
		}
		if ( button.imageProfile != null ) {
			button.setImage ( 
				this.isDisabled == true ?
					button.imageProfile.getDisabledImage () :
					button.imageProfile.getDefaultImage ()
			);
		}
		
		this._updateImageLayout ();
	
		if ( !isActionBlocked ) {
			this.onValueChange ();
			this.dispatchAction ( 
				SelectorBinding.ACTION_SELECTIONCHANGED
			);
			
			/*
			 * TODO: Enable this when dialogs and wizards go AJAX!
			 * 
			if ( this.getProperty ( "callbackid" ) != null ) {
				var self = this;
				setTimeout ( function () { // allow selector to close...
					self.dispatchAction ( PageBinding.ACTION_DOPOSTBACK );
				}, 0 );
			}
			*/
			
			this.dirty ();
		}	
		if ( !this._isValid || ( this.isRequired && !isActionBlocked )) {
			this.validate ();
		}
	}
	
	return isSuccess;
}

/**
 * Hide or show related binding.
 */
SelectorBinding.prototype._relate = function () {
	
	var relate = this.getProperty ( "relate" );
	
	if ( relate ) {
		var element = this.bindingDocument.getElementById ( relate );
		if ( element ) {
			var binding = UserInterface.getBinding ( element );
			if ( binding ) {
				if ( this.isChecked ) {
					binding.show ();
				} else {
					binding.hide ();
				}
			}
		}
	}
}

/**
 * Update image layput.
 */
SelectorBinding.prototype._updateImageLayout = function () {
	
	if ( this._buttonBinding.getImage () == null ) {
		if ( this._isImageLayout == true ) {
			this._buttonBinding.attachClassName ( ToolBarBinding.CLASSNAME_TEXTONLY );
			this._isImageLayout = false;
		}
	} else {
		if ( !this._isImageLayout ) {
			this._buttonBinding.detachClassName ( ToolBarBinding.CLASSNAME_TEXTONLY );
			this._isImageLayout = true;
		}
	}
}

/**
 * Fires when selection changes. Does nothing by default. Feel free 
 * to overwrite. And maybe refactor this methods name some day...
 */
SelectorBinding.prototype.onValueChange = function () {}

/**
 * This will select the *first* selection with a given value.
 * @param {object} value
 * @param {boolean} isActionBlocked
 * @return {boolean} True if something (new) was selected
 */
SelectorBinding.prototype.selectByValue = function ( value, isActionBlocked ) {
	
	var isSuccess = false;
	var bodyBinding = this._menuBodyBinding;
	
	/*
	 * Remember that bindings may not have been attached.
	 */
	var itemElementList = bodyBinding.getDescendantElementsByLocalName ( "menuitem" );
	while ( itemElementList.hasNext ()) {
		var itemBinding = UserInterface.getBinding ( 
			itemElementList.getNext ()
		);
		if ( itemBinding.selectionValue == value ) {
			isSuccess = this.select ( itemBinding, isActionBlocked );
			break;
		}
	}
	
	return isSuccess;
}

/**
 * Remember that the value is hidden around here. The button label is not the value!
 * @return {string}
 */
SelectorBinding.prototype.getValue = function () {
	
	var result = this._selectionValue;
	if ( result != null ) {
		result = String ( result );
	}
	return result;
}

/**
 * Set value. This will change the selectbox selection.
 * @implements {IData}  
 * @param {object} value
 */
SelectorBinding.prototype.setValue = function ( value ) {
	
	this.selectByValue ( String ( value ), true );
}


/**
 * Get result. Unlike getValue, the result may be any object (though only numbers for now).
 * @implements {IData}  
 * @return {object}
 */
SelectorBinding.prototype.getResult = function () {
	
	var result = this._selectionValue;
	
	if ( result == "null" ) { // javascript apocalypse!
		result = null;
	}
	if ( result ) {
		switch ( this.type ) {
			case DataBinding.TYPE_NUMBER :
			case DataBinding.TYPE_INTEGER :
				result = Number ( result );
				break;
		}
	}
	return result;
}

/**
 * Set result. This will change the selectbox selection.
 * @implements {IData}  
 * @param {object} result
 */
SelectorBinding.prototype.setResult = function ( result ) {
	
	this.selectByValue ( result, true );
}

/**
 * Validate.
 * @implements {IData}
 * @return {boolean}
 */
SelectorBinding.prototype.validate = function () {
	
	var isValid = true;
	if ( this.isRequired == true && this.defaultSelection != null ) {
		var value = this.getValue ();
		if ( value == this.defaultSelection.value ) {
			isValid = false;
		}
		if ( isValid != this._isValid ) {
			if ( isValid ) {
				this.dispatchAction ( Binding.ACTION_VALID );
				this.detachClassName ( DataBinding.CLASSNAME_INVALID );
			} else {
				this.dispatchAction ( Binding.ACTION_INVALID );
				this.attachClassName ( DataBinding.CLASSNAME_INVALID );
				this._buttonBinding.setLabel ( DataBinding.warnings [ "required" ]);
			}
		}
		this._isValid = isValid;
	}
	return isValid;
}

/**
 * Manifest. If no value, remove element from post result.
 * @implements {IData}
 */
SelectorBinding.prototype.manifest = function () {
	
	if ( this.isAttached == true ) {
		if ( this.getResult ()) {
			if ( !this.shadowTree.input ) {
				this.buildFormField ();
			}
			this.shadowTree.input.value = this.getValue ();
		} else if ( this.shadowTree.input ) {
			this.shadowTree.input.parentNode.removeChild ( this.shadowTree.input );
			this.shadowTree.input = null;
		}
	}
}

/**
 * Build selections. For faster page load time, the popup bindings 
 * get attached only when user handles the selector button or presses 
 * the enter key.
 */
SelectorBinding.prototype._attachSelections = function () {

	var popup = this._popupBinding;
	if ( !this._isUpToDate ) {
		popup.attachRecursive ();
		this._isUpToDate = true;
	}
}

/**
 * SelectorBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {SelectorBinding}
 */
SelectorBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:selector", ownerDocument );
	return UserInterface.registerBinding ( element, SelectorBinding );
}

SimpleSelectorBinding.prototype = new DataBinding;
SimpleSelectorBinding.prototype.constructor = SimpleSelectorBinding;
SimpleSelectorBinding.superclass = DataBinding.prototype;

/**
 * @class
 * @implements {IData}
 */
function SimpleSelectorBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SimpleSelectorBinding" ); 
	
	/**
	 * @type {HTMLSelectElement}
	 */
	this._select = null;
	
	/**
	 * @type {boolean}
	 */
	this.isRequired = false;
	
	/**
	 * @type {boolean}
	 */
	this._isValid = true;
	
	/**
	 * @type {int}
	 */
	this._cachewidth = 0;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
SimpleSelectorBinding.prototype.toString = function () {

	return "[SimpleSelectorBinding]";
}

/**
 * Find name, then register binding with DocumentManager.
 * @overwrites {Binding#onBindingRegister}
 */
SimpleSelectorBinding.prototype.onBindingRegister = function () {
	
	SimpleSelectorBinding.superclass.onBindingRegister.call ( this );
	
	var name = this.getProperty ( "name" );
	if ( name != null ) {
		this.setName ( name );
	}
}

/**
 * @overloads {DataBinding#onBindingAttach}
 */
SimpleSelectorBinding.prototype.onBindingAttach = function () {
	
	SimpleSelectorBinding.superclass.onBindingAttach.call ( this );
	
	this._select = this.getChildElementByLocalName ( "select" );
	var name = this.getName ();
	if ( name != null ) {
		this._select.name = name;
	}
	
	this._parseDOMProperties ();
	this._buildDOMContent ();
}

/**
 * Parse DOM properties.
 */
SimpleSelectorBinding.prototype._parseDOMProperties = function () {
	
	var onchange = this.getProperty ( "onchange" );
	this.isRequired = this.getProperty ( "required" ) == true;
	
	if ( this.hasCallBackID ()) {
		this._select.id = this.getCallBackID ();
	}
	if ( onchange ) {
		this.onValueChange = function () {
			Binding.evaluate ( onchange, this );
		}
	}
}

/**
 * Build DOM content.
 */
SimpleSelectorBinding.prototype._buildDOMContent = function () {
	
	this.bindingElement.tabIndex = 0;
	if ( Client.isExplorer == true ) {
		this.bindingElement.hideFocus = true;
	}
	
	/*
	 * Rig up select element.
	 */
	var self = this;
	this._select.onchange = function () {
		self.onValueChange ();
		self.dirty ();
		if ( !self._isValid ) {
			self.validate ();
		}
	};
	this._select.onfocus = function () {
		self.focus ( true );
	}
	if ( Client.isExplorer ) {
		this._buildDOMContentIE ();
	}
}

/**
 * Build DOM content especial for Internet Explorer.
 */
SimpleSelectorBinding.prototype._buildDOMContentIE = function () {

	if ( Client.isExplorer ) {
	
		/*
		 * Fix height for IE. We are hacking select elements  
		 * to expand when focused, showing long option texts. 
		 * Why should this be nescessary? It boggles the mind.
		 */
		this.bindingElement.style.height = this.bindingElement.offsetHeight + "px";
		this._cachewidth = this._select.offsetWidth;
		this._select.style.position = "absolute";
		
		/*
		 * This stuff must be done on mouseover and mouseout since    
		 * width must not be modified while evaluating focus and blur. 
		 */
		var self = this;
		this._select.onmouseover = function () {
			if ( !self.isFocused ) {
				self._hack ( true );
			}
		}
		
		this._select.onmouseout = function () {
			if ( !self.isFocused ) {
				self._hack ( false );
			}
		}
	}
}

/**
 * Fires when selection changes. Does nothing by default. Feel free 
 * to overwrite. And maybe refactor this methods name some day...
 */
SimpleSelectorBinding.prototype.onValueChange = function () {}

/**
 * Focus.
 * @overloads {DataBinding#focus}
 * @param {boolean} isMouseEvent
 * @implements {IData}
 */
SimpleSelectorBinding.prototype.focus = function ( isMouseEvent ) {
	
	SimpleSelectorBinding.superclass.focus.call ( this );
	
	if ( this.isFocused ) {
		if ( !isMouseEvent ) {
			FocusBinding.focusElement ( this._select );
			if ( Client.isExplorer ) {
				this._hack ( true );
			}
		}
		this.bindingWindow.standardEventHandler.enableNativeKeys ( false );
	}
};

/**
 * Blur.
 * @overloads {DataBinding#focus}
 * @implements {IData}
 */
SimpleSelectorBinding.prototype.blur = function () {
	
	SimpleSelectorBinding.superclass.blur.call ( this );
	
	if ( !this.isFocused ) {
		this._select.blur ();
		this.bindingWindow.standardEventHandler.disableNativeKeys ();
		if ( Client.isExplorer ) {
			this._hack ( false ); 
		}
		if ( this.isRequired ) {
			this.validate ();
		}
	}
};

/**
 * Let's hack!
 * @param {boolean} isHack
 */
SimpleSelectorBinding.prototype._hack = function ( isHack ) {
	
	if ( Client.isExplorer ) {
		this._select.style.width = isHack ? "auto" : this._cachewidth + "px";
		/*
		 * If hack wasn't really nescessary, we hack it right back.
		 */
		if ( isHack ) {
			if ( this._select.offsetWidth <= this._cachewidth ) {
				this._hack ( false );
			}
		}
	}
}

//ABSTRACT METHODS ............................................................

/**
 * Validate.
 * @implements {IData}
 * @return {boolean}
 */
SimpleSelectorBinding.prototype.validate = function () {
	
	var isValid = true;
	
	if ( this.isRequired ) {
		if ( this.getValue () == null ) {
			isValid = false;
		}
	}
	if ( isValid != this._isValid ) {
		if ( isValid ) {
			this.detachClassName ( DataBinding.CLASSNAME_INVALID );
		} else {
			this.attachClassName ( DataBinding.CLASSNAME_INVALID );
			
			/*
			 * Only "required" could have brought us here...
			 * Warning: This stuff is pretty hacked up!
			 */
			var select = this._select;
			var option = select.options [ select.selectedIndex ];
			var text = DOMUtil.getTextContent ( option );
			
			select.blur (); 
			select.style.color = "#A40000";
			select.style.fontWeight = "bold";
			if ( !Client.isExplorer6 ) {
				DOMUtil.setTextContent ( option, DataBinding.warnings [ "required" ]);
			}
			
			select.onfocus = function () {
				this.style.color = "black";
				this.style.fontWeight = "normal";
				this.onfocus = null;
				if ( !Client.isExplorer6 ) {
					DOMUtil.setTextContent ( option, text );
				}
			};
		}
		this._isValid = isValid;
	}
	
	return isValid;
}

/**
 * Manifest. This will write form elements into page DOM 
 * so that the server recieves something on form submit.
 * @implements {IData}
 */
SimpleSelectorBinding.prototype.manifest = function () {}

/**
 * Get value. This is intended for serversice processing.
 * @implements {IData}
 * @return {string}
 */
SimpleSelectorBinding.prototype.getValue = function () {
	
	var result = null;
	var select = this._select;
	var option = select.options [ select.selectedIndex ];
	var hasValue = true;
	if ( Client.isExplorer ) { // hasAttribute must be new to IE8. We hack it.
		var html = option.outerHTML.toLowerCase ();
		if ( html.indexOf ( "value=" ) ==-1 ) {
			hasValue = false;
		}
	}
	if ( hasValue ) {
		result = option.getAttribute ( "value" ); // option.value returns the textContent!
	}
	return result;
}

/**
 * Set value.
 * @implements {IData}
 * @param {string} value
 */
SimpleSelectorBinding.prototype.setValue = function ( value ) {}

/**
 * Get result. This is intended for clientside processing.
 * @implements {IData}
 * @return {object}
 */
SimpleSelectorBinding.prototype.getResult = function () {
	
	return this.getValue ();
}

/**
 * Set result.
 * @implements {IData}
 * @param {object} value
 */
SimpleSelectorBinding.prototype.setResult = function ( value ) {
	
	this.setValue ( value );
}

/**
 * SimpleSelectorBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {SimpleSelectorBinding}
 */
SimpleSelectorBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_XHTML, "select", ownerDocument );
	return UserInterface.registerBinding ( element, SimpleSelectorBinding );
}

/**
 * @class
 * This is *not* a binding! It is simply an object that 
 * can be fed to a SelectorBinding in order to populate it.
 * @implements {IData}
 * @param {string} label
 * @param {object} value
 * @param {boolean} isSelected
 * @param {ImageProfile} imageProfile
 */ 
function SelectorBindingSelection ( label, value, isSelected, imageProfile ) {
	
	this._init ( label, value, isSelected, imageProfile );
}

SelectorBindingSelection.prototype = {
	
	/**
	 * The visible label on the selection.
	 * @type {string}
	 */
	label : null,
	
	/**
	 * Value is stored internally as a string. You can extract the typecasted value, 
	 * dependant on the selectors type property, by using the getResult method.
	 * @see {SelectorBinding#getResult}
	 * @type {string}
	 */
	value : null,
	
	/**
	 * If set to true, the selection will be selected.
	 * @type {boolean}
	 */
	isSelected : null,
	
	/**
	 * Das image profile.
	 * @type {ImageProfile}
	 */
	imageProfile : null,
	
	/**
	 * This property is set by the SelectorBinding when selection is resolved.
	 * @type {MenuItemBinding}
	 */
	menuItemBinding : null,
	
	/**
	 * Initialize all of the above.
	 * @param {string} label
	 * @param {object} value
	 * @param {boolean} isSelected
	 * @param {ImageProfile} imageProfile
	 */
	_init : function ( label, value, isSelected, imageProfile ) {
		
		if ( label != null ) {
			this.label = String ( label );
		}
		if ( value != null ) {
			this.value = String ( value );
		}
		if ( imageProfile != null ) {
			this.imageProfile = imageProfile;
		}
		this.isSelected = isSelected ? true : false;
	}
}

DataInputSelectorBinding.prototype = new DataInputBinding;
DataInputSelectorBinding.prototype.constructor = DataInputSelectorBinding;
DataInputSelectorBinding.superclass = DataInputBinding.prototype;

DataInputSelectorBinding.INDICATOR_IMAGE = Resolver.resolve ( "${skin}/fields/selectorindicator.png" );
DataInputSelectorBinding.ACTION_SELECTIONCHANGED = "datainputselectorselectionchanged";

/**
 * @class
 * @implements {IData}
 */
function DataInputSelectorBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DataInputSelectorBinding" );
	
	/**
	 * @type {ToolBarButtonBinding}
	 */
	this._buttonBinding = null;
	
	/**
	 * @type {PopupBinding}
	 */
	this._popupBinding = null;
	
	/**
	 * @type {MenuBodyBinding}
	 */
	this._menuBodyBinding = null;
	
	/**
	 * @type {string}
	 */
	this._selectionValue = null;
	
	/**
	 * @type {boolean}
	 */
	this.isDirty = false;
		
	/**
	 * @type {boolean}
	 */
	this._hasKeyboard = false;
	
	/**
	 * Flipped when menitems need to be reattached.
	 * @type {boolean}
	 */
	this._isUpToDate = false;
	
	/**
	 * @type {MenuItemBinding}
	 */
	this._selectedItemBinding = null;
	
	/**
	 * Block common crawlers.
	 * @type {Map<string><boolean>}
	 * @overwrites {Binding#crawlerFilters}
	 */
	this.crawlerFilters	= new List ([ DocumentCrawler.ID, FocusCrawler.ID ]);
}

/**
 * Identifies binding.
 */
DataInputSelectorBinding.prototype.toString = function () {

	return "[DataInputSelectorBinding]";
}

/**
 * @overloads {DataBinding#onBindingDispose}
 * @see {SelectorBinding#onBindingDispose}
 */
DataInputSelectorBinding.prototype.onBindingDispose = SelectorBinding.prototype.onBindingDispose;

/**
 * Build button, build popup and populate by selection elements.
 * @overloads {DataBinding#_buildDOMContent}
 */
DataInputSelectorBinding.prototype._buildDOMContent = function () {
	 
	DataInputSelectorBinding.superclass._buildDOMContent.call ( this );
	
	this.buildButton ();
	this.buildPopup ();
	this.buildSelections ();
}

/**
 * Build button.
 */
DataInputSelectorBinding.prototype.buildButton = function () {

	var button = this.addFirst ( 
		ToolBarButtonBinding.newInstance ( this.bindingDocument )
	); 
	button.popupBindingTargetElement = this.shadowTree.input; 
	button.setImage ( DataInputSelectorBinding.INDICATOR_IMAGE );
	button.attach ();
	 
	var self = this;
	button.oncommand = function () {
	 	self._attachSelections ();
	}
	 
	this._buttonBinding = button;
}

/**
 * Build popup.
 * @see {SelectorBinding#buildPopup}
 */
DataInputSelectorBinding.prototype.buildPopup = SelectorBinding.prototype.buildPopup; 


/**
 * Build selections.
 */
DataInputSelectorBinding.prototype.buildSelections = function () {

	/* 
	 * Parse DOM content.
	 */
	var list = new List ();
	var selections = DOMUtil.getElementsByTagName ( this.bindingElement, "selection" );
	new List ( selections ).each ( function ( selection ) {
		if ( selection.getAttribute ( "label" )) {
			throw "label not supported - use value property!";
		} else {
			var value 	= selection.getAttribute ( "value" );
			var select 	= selection.getAttribute ( "selected" );
			var toolTip = selection.getAttribute ( "tooltip" );
			list.add ({
				value 		: value ? value : null,
				toolTip		: toolTip ? toolTip : null,
				isSelected	: ( select && select == "true" ) ? true : false
			});
		}
	});
	if ( list.hasEntries ()) {
		this.populateFromList ( list );
	}
}

/**
 * @param {List} list
 */
DataInputSelectorBinding.prototype.populateFromList = function ( list ) {
	
	var bodyBinding = this._menuBodyBinding;
	var bodyDocument = bodyBinding.bindingDocument;
	
	/* 
	 * Dispose existing content, remembering that bindings 
	 * may not be attached (before the button is pressed).
	 */
	while ( bodyBinding.bindingElement.hasChildNodes ()) {
		var node = bodyBinding.bindingElement.lastChild;
		if ( node.nodeType == Node.ELEMENT_NODE && UserInterface.hasBinding ( node )) {
			UserInterface.getBinding ( node ).dispose ();
		} else {
			bodyBinding.removeChild ( node );
		}
	}
	 
	/*
	 * Add new content.
	 */
	if ( list.hasEntries ()) {
	
		this._isUpToDate = false;
	
		if ( !this._buttonBinding.isVisible ) {
			this._buttonBinding.show ();
		}
		while ( list.hasNext ()) {
			var entry = list.getNext ();
			var itemBinding = MenuItemBinding.newInstance ( bodyDocument );
			itemBinding.setLabel ( entry.value );
			itemBinding.selectionValue = entry.value;
			if ( entry.toolTip ) {
				itemBinding.setToolTip ( entry.toolTip );
			}
			if ( entry.isSelected ) {
				this.select ( itemBinding, true );
			}
			bodyBinding.add ( itemBinding );
		}
	} else {
		this._buttonBinding.hide ();
	}
}

/**
 * @see {SelectorBinding#handleAction}
 * @param {Action} action
 */
DataInputSelectorBinding.prototype.handleAction = SelectorBinding.prototype.handleAction; 

/**
 * On button command.
 * @see {SelectorBinding#handleAction}
 */
DataInputSelectorBinding.prototype._onButtonCommand = function () {

	this.focus ();
	this._restoreSelection ();
	this.dispatchAction ( SelectorBinding.ACTION_COMMAND );
}

/**
 * On popup showing.
 * @see {SelectorBinding#handleAction}
 */
DataInputSelectorBinding.prototype._onPopupShowing = function () {

	this._fitMenuToSelector ();
	this._restoreSelection ();
	this._releaseKeyboard ();
}

/**
 * On menuitem command.
 * @param {MenuItemBinding} binding
 * @see {SelectorBinding#handleAction}
 */
DataInputSelectorBinding.prototype._onMenuItemCommand = function ( binding ) {

	this.select ( binding );
	FocusBinding.focusElement ( this.bindingElement );
	this._grabKeyboard ();
}

/**
 * Note that we evaluate this method in the context of 
 * both the superclass and the SelectorBinding class.
 * @implements {IBroadcastListener}
 * @see {SelectorBinding#handleAction}
 * @param {string} broadcast
 * @param {object} arg
 */
DataInputSelectorBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	SelectorBinding.prototype.handleBroadcast.call ( this, broadcast, arg );
	
	/*
	 * The DataInputBinding has been hacked to blur when a mousedown 
	 * is registered. This should obviously not extend to our button.
	 */
	switch ( broadcast ) {
		case BroadcastMessages.MOUSEEVENT_MOUSEDOWN :
			if ( arg != this._buttonBinding ) {
				DataInputSelectorBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
			}
			break;
	}
	
}

/**
 * Grab keyboard.
 * @see {SelectorBinding#_grabKeyboard}
 */
DataInputSelectorBinding.prototype._grabKeyboard = SelectorBinding.prototype._grabKeyboard;

/**
 * Release keyboard.
 * @see {SelectorBinding#_releaseKeyboard}
 */
DataInputSelectorBinding.prototype._releaseKeyboard = SelectorBinding.prototype._releaseKeyboard;

/**
 * Keyboard navigation stuff.
 * @see {SelectorBinding#_handleArrowKey}
 * @param {int} key
 */
DataInputSelectorBinding.prototype._handleArrowKey = SelectorBinding.prototype._handleArrowKey;

/**
 * Focus.
 * @implements {IData}
 * @param {boolean} isDomEvent
 */
DataInputSelectorBinding.prototype.focus = function ( isDomEvent ) {
	
	if ( !this.isFocused ) {
		DataInputSelectorBinding.superclass.focus.call ( this, isDomEvent );
		if ( this.isFocused == true ) {
			this._grabKeyboard ();
		}	
	}
	
	/*
	if ( !this._hasKeyboard ) {	
		this._grabKeyboard ();
	}
	DataInputSelectorBinding.superclass.focus.call ( this, isDomEvent );
	*/
}

/**
 * Blur.
 * @implements {IData}
 * @param {boolean} isDomEvent
 */
DataInputSelectorBinding.prototype.blur = function ( isDomEvent ) {
	
	if ( this.isFocused == true ) {
		DataInputSelectorBinding.superclass.blur.call ( this, isDomEvent );
		this._releaseKeyboard ();
		if ( this._popupBinding.isVisible ) {		
			this._popupBinding.hide ();
		}
	}
	/*
	if ( this._hasKeyboard ) {
		this._releaseKeyboard ();
	}
	if ( this._popupBinding.isVisible ) {		
		this._popupBinding.hide ();
	}
	DataInputSelectorBinding.superclass.blur.call ( this, isDomEvent );
	*/
}

/**
 * For cosmetic reasons, attempting to make 
 * the opening menu as wide as the selector.
 * @see {SelectorBinding#handleAction}
 */
DataInputSelectorBinding.prototype._fitMenuToSelector = function () {
	
	var selectorWidth = this.bindingElement.offsetWidth + "px";
	var popupElement = this._popupBinding.bindingElement;
	
	if ( Client.isMozilla ) {
		popupElement.style.minWidth = selectorWidth;
	} else {
		popupElement.style.width = selectorWidth;
	}
}

/**
 * Restore selection.
 */
DataInputSelectorBinding.prototype._restoreSelection = function () {
	
	if ( !this._isUpToDate ) {
		this._attachSelections ();
	}
	
	var items = this._menuBodyBinding.getDescendantBindingsByLocalName ( "menuitem" );
	var value = this.getValue ();
	var selected = null;
	
	items.each ( function ( item ) {
		if ( item.getLabel () == value ) {
			selected = item;
		}
	});
	if ( selected ) {
		selected.focus ();
	}
	
}

/**
 * @param {MenuItemBinding} item
 * @param {boolean} isDefault Set while initializing to block action.
 */
DataInputSelectorBinding.prototype.select = function ( item, isDefault ) {
	
	if ( item != this._selectedItemBinding ) {
		
		this._selectedItemBinding = item;
		
		this.setValue ( item.selectionValue );
		
		if ( !isDefault ) {
			this.dirty ();
			this.dispatchAction ( 
				DataInputSelectorBinding.ACTION_SELECTIONCHANGED
			);
		}
	}
	this.shadowTree.input.focus ();
}

/**
 * Build selections. For faster page load time, the popup bindings 
 * get attached only when user handles the selector button.
 */
DataInputSelectorBinding.prototype._attachSelections = SelectorBinding.prototype._attachSelections;

/**
 * Set result (alias set value).
 * @implements {IData}
 * @param {object} result
 */
DataInputSelectorBinding.prototype.setResult = DataInputSelectorBinding.prototype.setValue;

DataInputDialogBinding.prototype = new DataInputBinding;
DataInputDialogBinding.prototype.constructor = DataInputDialogBinding;
DataInputDialogBinding.superclass = DataInputBinding.prototype;

/**
 * @class
 * @implements {IData}
 */
function DataInputDialogBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DataInputDialogBinding" );
	
	/**
	 * ViewDefinition handle.
	 * @type {string}
	 */
	this._handle = null;
	
	/**
	 * @type {ToolBarButtonBinding}
	 */
	this._dialogButtonBinding = null;
	
	/**
	 * Used to hack the input: No validation when while button is handled.
	 * @type {boolean}
	 */
	this._isButtonClicked = false;
}

/**
 * Identifies binding.
 */
DataInputDialogBinding.prototype.toString = function () {
	
	return "[DataInputDialogBinding]";
}

/**
 * Build button, build popup and populate by selection elements.
 * @overloads {DataInputBinding#_buildDOMContent}
 */
DataInputDialogBinding.prototype._buildDOMContent = function () {
	 
	DataInputSelectorBinding.superclass._buildDOMContent.call ( this );
	this.buildButton ();
}

/**
 * Build button.
 */
DataInputDialogBinding.prototype.buildButton = function () {

	var button = ToolBarButtonBinding.newInstance ( this.bindingDocument );
	button.setImage ( "${icon:popup}" );
	this.addFirst ( button );
	button.attach ();

	var self = this;
	
	button.oncommand = function () {
		
		self._isButtonClicked = true;
		setTimeout ( function () {
			self._isButtonClicked = false;
		}, 1000 );
	
		var handle = self.getProperty ( "handle" );
		var definition = ViewDefinitions [ handle ];
		
		if ( definition instanceof DialogViewDefinition ) {
		
			definition.handler = {
				handleDialogResponse : function ( response, result ) {
					self._isButtonClicked = false;
					if ( response == Dialog.RESPONSE_ACCEPT ) {
						
						self.logger.debug ( "Usecase scenario was hardcoded into DataInputDialogBinding#buildButton" );
						var value = result.getFirst ();
						self.setValue ( value ); // SETUP SPECIFIC - THIS MAY NOT BE SO!!!!
						self.validate ( true );
					}
					self.focus ();
				}
			}
			definition.argument.selectedResult = self.getValue (); // TODO!
			StageBinding.presentViewDefinition ( definition );
			
		} else {
			throw "Definition was either undefine or of a non-dialog type.";
		}
	}
	 
	DOMEvents.addEventListener ( button.getBindingElement (), DOMEvents.MOUSEDOWN, { 
		handleEvent : function ( e ) {
			self._isButtonClicked = true;
		}
	});
	this._dialogButtonBinding = button;
};

/**
 * Invoke dialog programatically.
 */
DataInputDialogBinding.prototype.oncommand = function () {
	
	var button = this._dialogButtonBinding;
	if ( button != null ) {
		button.oncommand ();
	}
};

/**
 * Hack to circumvent validation while dialog is handled.
 * @param {boolean} arg
 * @overloads {DataInputBinding#validate}
 */
DataInputDialogBinding.prototype.validate = function ( arg ) {
	
	var result = true;
	if ( this._isButtonClicked == true ) {
		this._isButtonClicked = false;
	} else {
		result = DataInputDialogBinding.superclass.validate.call ( this, arg );
	}
	return result;
};

DataDialogBinding.prototype = new DataBinding;
DataDialogBinding.prototype.constructor = DataDialogBinding;
DataDialogBinding.superclass = DataBinding.prototype;

DataDialogBinding.ACTION_COMMAND = "datadialog command";

/**
 * @class
 * Notice that this fellow works only as a clientside conrol.  
 * Use the PostBackDataDialogBinding for serverside work.
 * @implements {IData}
 */ 
function DataDialogBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DataDialogBinding" );
	
	/**
	 * @type {ButtonBinding}
	 */
	this._buttonBinding = null;
	
	/**
	 * @type {IDialogResponseHandler}
	 */
	this._handler = null;
	
	/**
	 * This will be served to the associated dialog as argument 
	 * and returned as result when a getResult is invoked.
	 * @type {DataBindingMap}
	 */
	this._map = null;
	
	/**
	 * @type {string}
	 */
	this._dialogViewHandle = null;
	
	/**
	 * @type {boolean}
	 */
	this._hasKeyboard = false;
	
	/**
	 * @type {boolean}
	 */
	this._hasFocus = false;
}

/**
 * Identifies binding.
 */
DataDialogBinding.prototype.toString = function () {
	
	return "[DataDialogBinding]";
}

DataDialogBinding.prototype.onBindingRegister = function () {
	
	DataDialogBinding.superclass.onBindingRegister.call ( this );
	
	this.propertyMethodMap [ "image" ] = this.setImage;
	this.propertyMethodMap [ "label" ] = this.setLabel;
	this.propertyMethodMap [ "tooltip" ] = this.setToolTip;
	this.propertyMethodMap [ "handle" ] = this.setHandle;
	this.propertyMethodMap [ "url" ] = this.setURL;
	this.propertyMethodMap [ "value" ] = this.setValue;
}

/**
 * Overloads {@link Binding#onBindingAttach}
 */
DataDialogBinding.prototype.onBindingAttach = function () {
	
	DataDialogBinding.superclass.onBindingAttach.call ( this );
	
	Binding.imageProfile ( this );
	this._buildButton ();
	
	if ( this.getProperty ( "handle" ) != null || this.getProperty ( "url" )) {
		this._buildIndicator ();
	}
	
	this.bindingElement.tabIndex = 0;
	if ( Client.isExplorer ) {
		this.bindingElement.hideFocus = true;
	}
}

/**
 * Building button.
 */
DataDialogBinding.prototype._buildButton = function () {

	var label	= this.getProperty ( "label" );
	var tooltip = this.getProperty ( "tooltip" );
	
	this._buttonBinding = this.add ( 
		ClickButtonBinding.newInstance ( this.bindingDocument ) 
	);
	if ( label != null ) {
		if ( this.getProperty ( "handle" ) != null || this.getProperty ( "url" ) != null ) {
			this._buttonBinding.setLabel ( label + LabelBinding.DIALOG_INDECATOR_SUFFIX );
		} else {
			this._buttonBinding.setLabel ( label );
		}
	}
	if ( this.imageProfile ) {
		this._buttonBinding.imageProfile = this.imageProfile;
	}
	if ( tooltip != null ) {
		this._buttonBinding.setToolTip ( tooltip );
	}
	this._buttonBinding.addActionListener ( 
		ButtonBinding.ACTION_COMMAND, this 
	);
	this._buttonBinding.attach ();
}

/**
 * Building dialog indicator image.
 */
DataDialogBinding.prototype._buildIndicator = function () {
	
	var img = this.bindingDocument.createElement ( "img" );
	img.src = Resolver.resolve ( "${icon:popup}" );
	img.className = "dialogindicatorimage";
	this._buttonBinding.bindingElement.appendChild ( img );
	this.shadowTree.indicatorimage = img;
}

/**
 * @implemenents {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
DataDialogBinding.prototype.handleAction = function ( action ) {
	
	DataDialogBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	var self = this;
	
	switch ( action.type ) {
		case ButtonBinding.ACTION_COMMAND :
			
			if ( this._handler == null ) {
				this._handler = {
					handleDialogResponse : function ( response, result ) {
						if ( response == Dialog.RESPONSE_ACCEPT ) {
							if ( result instanceof DataBindingMap ) {
								self._map = result;
							} else {
								throw "Invalid dialog result";
							}
						}
					}
				};
			}
			
			if ( binding == this._buttonBinding ) {
				action.consume ();
				this.focus ();	
				this.fireCommand ();
			}
			break;
	}
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 */
DataDialogBinding.prototype.handleBroadcast = function ( broadcast, arg ) {

	DataDialogBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		case BroadcastMessages.KEY_SPACE :
			this.fireCommand ();
			break;
	}
}

/**
 * Open that dialog! An optional ViewDefinition can be build by subclass.
 * @param @optional {ViewDefinition} def
 */
DataDialogBinding.prototype.fireCommand = function ( def ) {
	
	/* 
	 * This can be intercepted by someone 
	 * waiting to change the dialog handler.
	 */
	this.dispatchAction ( this.constructor.ACTION_COMMAND );
	
	var handle = this.getProperty ( "handle" );
	var url	= this.getURL ();
	var definition = null;
	
	if ( handle != null || def != null ) {
		if ( handle != null ) {
			definition = ViewDefinitions [ handle ];
		} else {
			definition = def;
		}
		if ( definition instanceof DialogViewDefinition ) {
			definition.handler = this._handler;
			if ( this._map != null ) { // otherwise mess up StringDataDialogBinding
				definition.argument = this._map;
			}
			StageBinding.presentViewDefinition ( definition );
		}
	} else if ( url != null ) {
		definition = Dialog.invokeModal ( 
			url,
			this._handler, 
			this._map
		);
	}
	
	/*
	 * Release keyboard and be prepared to 
	 * grab it again when the dialog closes.
	 */
	if ( definition != null ) {
		this._dialogViewHandle = definition.handle;
		this._releaseKeyboard ();
	}
}

/**
 * Set label.
 * @param {string} label
 */
DataDialogBinding.prototype.setLabel = function ( label ) {
	
	this.setProperty ( "label", label );
	if ( this.isAttached ) {
		this._buttonBinding.setLabel ( 
			label + LabelBinding.DIALOG_INDECATOR_SUFFIX 
		);
	}
}

/**
 * Set image.
 * @param {string} image
 */
DataDialogBinding.prototype.setImage = function ( image ) {
	
	this.setProperty ( "image", image );
	
	/*
	 * TODO: Refactor this setup!
	 */
	if ( this.imageProfile != null ) {
		this.imageProfile.setDefaultImage ( image );
		if ( this._buttonBinding != null ) {
			this._buttonBinding.imageProfile = this.imageProfile;
			this._buttonBinding.setImage ( this._buttonBinding.imageProfile.getDefaultImage ());
		}
	}
}


/**
 * Set label.
 * @param {string} tooltip
 */
DataDialogBinding.prototype.setToolTip = function ( tooltip ) {
	
	this.setProperty ( "tooltip", tooltip );
	if ( this.isAttached ) {
		this._buttonBinding.setToolTip ( tooltip );
	}	
	
}

/**
 * Set handle.
 * @param {string} handle
 */
DataDialogBinding.prototype.setHandle = function ( handle ) {

	this.setProperty ( "handle", handle );
}

/**
 * Set that URL.
 * @param {string} url
 */
DataDialogBinding.prototype.setURL = function ( url ) {
	
	this.setProperty ( "url", url );
}

/**
 * Get that URL. Isolated so that subclasses may hack it.
 * @return {string}
 */
DataDialogBinding.prototype.getURL = function () {

	return this.getProperty ( "url" );
}

/**
 * Set handler.
 * @param {IDialogResponseHandler} handler
 */
DataDialogBinding.prototype.setHandler = function ( handler ) {
	
	this._handler = handler;
}

/**
 * Focus.
 * @implements {IData}
 */
DataDialogBinding.prototype.focus = function () {
	
	if ( !this.isFocused ) {
		DataBinding.prototype.focus.call ( this );
		FocusBinding.focusElement ( this.bindingElement );
		if ( this.isFocused ) {
			this._grabKeyboard ();
		}
	}
};

/**
 * Blur.
 * @implements {IData}
 */
DataDialogBinding.prototype.blur = function () {
	
	if ( this.isFocused ) {
		DataBinding.prototype.blur.call ( this );
		if ( this._hasKeyboard ) {
			this._releaseKeyboard ();
		}	
	}
}

/**
 * Grab keyboard.
 */
DataDialogBinding.prototype._grabKeyboard = function () {
	
	if ( !this._hasKeyboard ) {
		this.subscribe ( BroadcastMessages.KEY_SPACE );
		this._hasKeyboard = true;
	}
	
}

/**
 * Release keyboard.
 */
DataDialogBinding.prototype._releaseKeyboard = function () {
	
	if ( this._hasKeyboard ) {
		this.unsubscribe ( BroadcastMessages.KEY_SPACE );
		this._hasKeyboard = false;
	}
}

/**
 * Validate.
 * @implements {IData}
 * @return {boolean}
 */
DataDialogBinding.prototype.validate = function () {
	
	return true;
}

/**
 * Manifest. This will write form elements into page DOM 
 * so that the server recieves something on form submit.
 * @implements {IData}
 */
DataDialogBinding.prototype.manifest = function () {
	
	// do nothing
}

/**
 * Get value. This is intended for serversice processing.
 * @implements {IData}
 * @return {string}
 */
DataDialogBinding.prototype.getValue = function () {
	
	return null;
}

/**
 * Get result. This is intended for clientside processing.
 * @implements {IData}
 * @return {DataBindingMap}
 */
DataDialogBinding.prototype.getResult = function () {
	
	return this._map;
}

/**
 * Set result. Notice that the result is automatically 
 * deployed as argument for the associated dialog.
 * @param {DataBindingMap} map
 */
DataDialogBinding.prototype.setResult = function ( map ) {

	if ( map instanceof DataBindingMap ) {
		this._map = map;
	} else {
		throw "Invalid argument";
	}
}

/**
 * DataDialogBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {DataDialogBinding}
 */
DataDialogBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:datadialog", ownerDocument );
	return UserInterface.registerBinding ( element, DataDialogBinding );
}

PostBackDataDialogBinding.prototype = new DataDialogBinding;
PostBackDataDialogBinding.prototype.constructor = PostBackDataDialogBinding;
PostBackDataDialogBinding.superclass = DataDialogBinding.prototype;

PostBackDataDialogBinding.ACTION_COMMAND = "postbackdialog command";

/**
 * Engineered to carry a single string value.
 */
function PostBackDataDialogBinding () {
    
    /**
     * @type {DOMElement}
     */
    this.input = null;
    
    /*
     * Returnable.
     */
    return this;
}

/**
 * Overloads {@link Binding#onBindingAttach}
 */
PostBackDataDialogBinding.prototype.onBindingAttach = function () {
	
	PostBackDataDialogBinding.superclass.onBindingAttach.call ( this ); 
	
	Binding.dotnetify ( this );
	
	var self = this;
	this._handler = {
    	handleDialogResponse : function ( response, result ) {
    		if ( response == Dialog.RESPONSE_ACCEPT ) {
    			self._onDialogAccept ( result );
    		} else {
    			self._onDialogCancel ();
    		}
    	}
    }
}

/**
 * @param {WHAT?} result THIS CAN BE A LIST (TREESELECTORS) PLEAR CLEAR THIS UP!
 * @returns
 */
PostBackDataDialogBinding.prototype._onDialogAccept = function ( result ) {
	
	result = new String ( result );
	
	this.dirty ();
	this.setValue ( encodeURIComponent ( result ));
	
	var self = this;
    setTimeout ( function () { // close dialog first!
    	if ( self.ondialogaccept != null ) {
    		self.ondialogaccept ();
    	}
    	self.dispatchAction( PageBinding.ACTION_DOPOSTBACK ); 
	}, 0 );
};

PostBackDataDialogBinding.prototype._onDialogCancel = function () {
	
	if ( this.ondialogcancel != null ) {
		this.ondialogcancel ();
	}
};

/**
 * Get that URL. The URL must follow our plan, which is to have an url 
 * property "hello?hey=" to which we append the VALUE of the control, 
 * "howdy", order to launch the dialog residing on the url "hello?hey=howdy".  
 * @overwrites {DataDialogBinding#getURL}
 */
PostBackDataDialogBinding.prototype.getURL = function () {

	var url = this.getProperty ( "url" );
	var suf = this.getValue (); // encodeURIComponent now on server!
	return new String ( url + suf );
}

/**
 * @overwrites {DataDialogBinding#manifest}
 * @implements {IData}
 */
PostBackDataDialogBinding.prototype.manifest = function () {
	
	var value = this.getValue ();
	if ( value == null ) {
		value = "";
	}
	this.shadowTree.dotnetinput.value = value;
};

/**
 * @implements {IData}
 * @return {string}
 */
PostBackDataDialogBinding.prototype.setValue = function ( value ) {
	
	this.setProperty ( "value", value );
};

/**
 * @overwrites {DataDialogBinding#getValue}
 * @implements {IData}
 * @return {string}
 */
PostBackDataDialogBinding.prototype.getValue = function () {
	
	return this.getProperty ( "value" );
};

/**
 * NOT FOR CLIENTSIDE USE.
 * @overwrites {DataDialogBinding#getResult}
 * @implements {IData}
 */
PostBackDataDialogBinding.prototype.getResult = function () {
	
	return null;
};

/**
 * NOT FOR CLIENTSIDE USE.
 * @overwrites {DataDialogBinding#setResult}
 * @param {String} result
 * @implements {IData}
 */
PostBackDataDialogBinding.prototype.setResult = function ( result ) {};

/**
 * PostBackDataDialogBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {PostBackDataDialogBinding}
 */
PostBackDataDialogBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:postbackdialog", ownerDocument );
	return UserInterface.registerBinding ( element, PostBackDataDialogBinding );
};

ViewDefinitionPostBackDataDialogBinding.prototype = new PostBackDataDialogBinding;
ViewDefinitionPostBackDataDialogBinding.prototype.constructor = ViewDefinitionPostBackDataDialogBinding;
ViewDefinitionPostBackDataDialogBinding.superclass = PostBackDataDialogBinding.prototype;

/**
 * This fellow will clone a ViewDefinition while  
 * allowing user to modify search properties and more.
 */
function ViewDefinitionPostBackDataDialogBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ViewDefinitionPostBackDataDialogBinding" );
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
ViewDefinitionPostBackDataDialogBinding.prototype.toString = function () {

	return "[ViewDefinitionPostBackDataDialogBinding]";
}

/**
 * Temporarliy modify the all-functions dialog definition.
 * @overloads {DataDialogBinding#fireCommand}
 */
ViewDefinitionPostBackDataDialogBinding.prototype.fireCommand = function () {
	
	var label = this.getProperty ( "dialoglabel" );
	var search = this.getProperty ( "providersearch" );
	var key = this.getProperty ( "providerkey" );
	var handle = this.getProperty ( "handle" )
	
	if ( handle != null ) {
	
		var def = ViewDefinition.clone ( 
			handle,
			"Generated.ViewDefinition.Handle." + KeyMaster.getUniqueKey ()
		);
		
		/*
		 * Label
		 */
		if ( label != null ) {
			if ( def.argument == null ) {
				def.argument = {};
			}
			def.argument.label = label;
		}
		
		/*
		 * Search
		 */
		if ( search != null ) {
			if ( def.argument == null ) {
				def.argument = {};
			}
			if ( def.argument.nodes == null ) {
				def.argument.nodes = [];
			}
			def.argument.nodes [ 0 ].search = search;
		}
		
		/*
		 * Key
		 */
		if ( key != null ) {
			if ( def.argument == null ) {
				def.argument = {};
			}
			if ( def.argument.nodes == null ) {
				def.argument.nodes = [];
			}
			def.argument.nodes [ 0 ].key = key;
		}
		
		/*
		 * Super
		 */
		ViewDefinitionPostBackDataDialogBinding.superclass.fireCommand.call ( this, def );
		
	} else {
		throw "Attribute \"handle\" required.";
	}
};

/**
 * ViewDefinitionPostBackDataDialogBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {ViewDefinitionPostBackDataDialogBinding}
 */
ViewDefinitionPostBackDataDialogBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:postbackdialog", ownerDocument );
	return UserInterface.registerBinding ( element, ViewDefinitionPostBackDataDialogBinding );
}

NullPostBackDataDialogBinding.prototype = new DataBinding;
NullPostBackDataDialogBinding.prototype.constructor = NullPostBackDataDialogBinding;
NullPostBackDataDialogBinding.superclass = DataBinding.prototype;

NullPostBackDataDialogBinding.LABEL_NULL = "(No selection)";
NullPostBackDataDialogBinding.LABEL_DEFAULT = "Select";

NullPostBackDataDialogBinding.VALUE_NULL = "null";
NullPostBackDataDialogBinding.VALUE_SELECTED = "selected";

NullPostBackDataDialogBinding.ACTION_COMMAND = "nullpostbackdatadialog command";


/**
 * @class
 */
function NullPostBackDataDialogBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "NullPostBackDataDialogBinding" );
	
	/**
	 * @type {ViewDefinitionPostBackDataDialogBinding}
	 */
	this._datathing = null;
	
	/**
	 * @type {NullPostBackDataDialogSelectorBinding}
	 */
	this._selector = null;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
NullPostBackDataDialogBinding.prototype.toString = function () {

	return "[NullPostBackDataDialogBinding]";
}

/**
 * @overloads {Binding#onBindingAttach}
 */
NullPostBackDataDialogBinding.prototype.onBindingAttach = function () {
	
	NullPostBackDataDialogBinding.superclass.onBindingAttach.call ( this );
	
	this.propertyMethodMap [ "label" ] = this.setLabel;
	var self = this;
	this.propertyMethodMap [ "value" ] = function ( value ) {
		self._datathing.setValue ( value );
	};
	this.propertyMethodMap [ "selectorlabel" ] = function () {
		if ( Application.isDeveloperMode ) {
			alert ( "Selectorlabel property not supported yet!" )
		}
	}
	
	this.addActionListener ( PageBinding.ACTION_DOPOSTBACK );
	this._buildDataDialog ();
	this._buildSelector ();
}

/**
 * Build PostBackDataDialogBinding.
 */
NullPostBackDataDialogBinding.prototype._buildDataDialog = function () {
	
	this._datathing = this.add ( ViewDefinitionPostBackDataDialogBinding.newInstance ( this.bindingDocument ));
	
	// transfer properties to datathing
	new List ([ "callbackid", "handle", "name", "providersearch", "providerkey", "value" ]).each ( function ( prop ) {
		this._datathing.setProperty ( prop, this.getProperty ( prop ));
		this.setProperty ( prop, null );
	}, this );
	
	var self = this;
	this._datathing.ondialogcancel = function () {
		var value = self.getValue (); 
		if ( value == "" || value == null ) {
			self._selector.setLabel ( NullPostBackDataDialogBinding.LABEL_NULL );
		} else {
			self._selector.setLabel ( self.getLabel ());
		}
	}
	
	this._datathing.hide ();
	this._datathing.attach ();
}

/**
 * Build selector thingy.
 */
NullPostBackDataDialogBinding.prototype._buildSelector = function () {

	this._selector = this.add ( NullPostBackDataDialogSelectorBinding.newInstance ( this.bindingDocument ));
	
	var value = this.getProperty ( "value" );
	var label = this.getProperty ( "selectorlabel" );
	
	if ( label == null ) {
		label = NullPostBackDataDialogBinding.LABEL_DEFAULT;
	}
	
	var list = new List ();
	list.add ( 
		new SelectorBindingSelection ( 
			NullPostBackDataDialogBinding.LABEL_NULL, 
			NullPostBackDataDialogBinding.VALUE_NULL,
			value == null
		)
	);
	list.add ( 
		new SelectorBindingSelection (
			label + LabelBinding.DIALOG_INDECATOR_SUFFIX, 
			NullPostBackDataDialogBinding.VALUE_SELECTED,
			value != null,
			new ImageProfile ({
				image : "${icon:popup}"
			})
		)
	);
	
	this._selector.master = this;
	this._selector.attach ();
	this._selector.populateFromList ( list );
	
	// override label from default selection!
	var value = this.getValue (); 
	if ( value == "" || value == null ) {
		this._selector.setLabel ( NullPostBackDataDialogBinding.LABEL_NULL );
	} else {
		this._selector.setLabel ( this.getLabel ());
	}
}

/**
 * @implements {IActionHandler}
 * @param {Action} action
 */
NullPostBackDataDialogBinding.prototype.handleAction = function ( action ) {
	
	NullPostBackDataDialogBinding.superclass.handleAction.call ( this, action );
	
	switch ( action.type ) {
		case PageBinding.ACTION_DOPOSTBACK :
			if ( action.target == this._datathing ) {
				
				// we are waiting for server 
				// to update label property...
				
				var label = this.getProperty ( "label" );
				this._selector.setLabel ( "" );
				this.dispatchAction ( PageBinding.ACTION_DOPOSTBACK );
				
				/*
				 * ... but if user selected the SAME item, the 
				 * UpdateManager sees no update and we must 
				 * manually restore the old label. This should 
				 * be moved to an evented setup at some point... 
				 */
				var self = this;
				setTimeout ( function () {
					if ( self.getProperty ( "label" ) == label ) {
						self._selector.setLabel ( label );
					}
				}, 500 );
				
				
				/*
				var value = this._datathing.getValue ();
				var label = decodeURIComponent ( value );
				
				this._selector.setLabel ( label );
				this._selector.setToolTip ( label );
				this.setValue ( value );
				*/
				
				action.consume ();
			}
			break;
	}
}

/**
 * @return {String}
 */
NullPostBackDataDialogBinding.prototype.getLabel = function () {
	
	return this.getProperty ( "label" );
}

/**
 * @param {String} label
 */
NullPostBackDataDialogBinding.prototype.setLabel = function ( label ) {
	
	this.setProperty ( "label", label );
	if ( this._selector != null ) {
		this._selector.setLabel ( label );
	}
}

/**
 * @return {String}
 */
NullPostBackDataDialogBinding.prototype.getValue = function () {
	
	return this._datathing.getValue ();
}

/**
 * @param {String} value
 */
NullPostBackDataDialogBinding.prototype.setValue = function ( value ) {
	
	this._datathing.setValue ( value );
	this.dispatchAction ( PageBinding.ACTION_DOPOSTBACK );
}

NullPostBackDataDialogBinding.prototype.action = function () {
	
	this._datathing.fireCommand ();
}


// MUST IMPLEMENT! .............................................

/**
 * Validate.
 * @implements {IData}
 * @return {boolean}
 */
NullPostBackDataDialogBinding.prototype.validate = function () {
	
	return true;
}

/**
 * Manifest. This will write form elements into page DOM 
 * so that the server recieves something on form submit.
 * @implements {IData}
 */
NullPostBackDataDialogBinding.prototype.manifest = function () {}

/**
 * Get result. This is intended for clientside processing.
 * @implements {IData}
 * @return {object}
 */
NullPostBackDataDialogBinding.prototype.getResult = function () {}

/**
 * Set result.
 * @implements {IData}
 * @param {object} value
 */
NullPostBackDataDialogBinding.prototype.setResult = function () {}

NullPostBackDataDialogSelectorBinding.prototype = new SelectorBinding;
NullPostBackDataDialogSelectorBinding.prototype.constructor = NullPostBackDataDialogSelectorBinding;
NullPostBackDataDialogSelectorBinding.superclass = SelectorBinding.prototype;

/**
 * @class
 */
function NullPostBackDataDialogSelectorBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "NullPostBackDataDialogSelectorBinding" );

	/**
	 * @type {NullPostBackDataDialogBinding}
	 */
	this.master = null;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
NullPostBackDataDialogSelectorBinding.prototype.toString = function () {

	return "[NullPostBackDataDialogSelectorBinding]";
}

/**
 * @overloads {SelectorBinding#select}
 * @param {MenuItemBinding} itemBinding
 * @param {boolean} isActionBlocked True while initializing to block action.
 * @return {boolean} True if something (new) was selected
 */
NullPostBackDataDialogSelectorBinding.prototype.select = function ( itemBinding, isActionBlocked ) {

	if ( NullPostBackDataDialogSelectorBinding.superclass.select.call ( this, itemBinding, isActionBlocked )) {
		this._buttonBinding.setImage ( null );
		this._updateImageLayout ();
		if ( this._selectionValue == NullPostBackDataDialogBinding.VALUE_SELECTED ) {
			if ( this.master.getValue () != null ) {
				
				//this._buttonBinding.setLabel ( this.master.getLabel ());
			}
		}
	}
}

NullPostBackDataDialogSelectorBinding.prototype.setLabel = function ( label ) {
	
	this._buttonBinding.setLabel ( label );
}

NullPostBackDataDialogSelectorBinding.prototype.setToolTip = function ( tooltip ) {
	
	this._buttonBinding.setToolTip ( tooltip );
}

/**
 * @implements {IActionListener}
 * @overloads {SelectorBinding#handleAction}
 * @param {Action} action
 */
NullPostBackDataDialogSelectorBinding.prototype.handleAction = function ( action ) {
	
	NullPostBackDataDialogSelectorBinding.superclass.handleAction.call ( this, action )
	
	switch ( action.type ) {
		case MenuItemBinding.ACTION_COMMAND :
			var menuitem = action.target;
			var master = this.master;
			if ( menuitem.selectionValue == NullPostBackDataDialogBinding.VALUE_SELECTED ) {
				this.setLabel ( menuitem.getLabel ());
				setTimeout ( function () {
					master.action ();
				}, 0 );
			} else {
				this.master.setValue ( "" );
			}
			master.dirty ();
			break;
	}
}

/**
 * @overwrites {SelectorBinding#manifest}
 */
NullPostBackDataDialogSelectorBinding.prototype.manifest = function () {
	
	// do nothing
}

/**
 * NullPostBackDataDialogSelectorBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {NullPostBackDataDialogSelectorBinding}
 */
NullPostBackDataDialogSelectorBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:selector", ownerDocument );
	return UserInterface.registerBinding ( element, NullPostBackDataDialogSelectorBinding );
}

MultiSelectorBinding.prototype = new DataBinding;
MultiSelectorBinding.prototype.constructor = MultiSelectorBinding;
MultiSelectorBinding.superclass = DataBinding.prototype;

MultiSelectorBinding.DISPLAY_SELECTED = "selected";
MultiSelectorBinding.DISPLAY_UNSELECTED = "unselected";
MultiSelectorBinding.ACTION_COMMAND = "multiselector command";
MultiSelectorBinding.ACTION_SELECTIONCHANGED = "multiselector selection changed";

/**
 * @class
 * @implements {IData}
 */
function MultiSelectorBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "MultiSelectorBinding" );
	
	/**
	 * @type {boolean}
	 */
	this.isEditable = true;
	
	/**
	 * @type {boolean}
	 */
	this.isSelectable = false;
	
	/**
	 * @type {DataDialogBinding}
	 */
	this._dataDialogBinding = null;
	
	/**
	 * @type {List<SelectorBindingSelection>}
	 */
	this.selections = null;
	
	/**
	 * Mapping selected entries (highlighted entries, that is).
	 * type {Map<string><HTMLDivElement>}
	 */
	this._selectionMap = null;
	
	/**
	 * What to display - selected or unselected 
	 * selections? Defaults to selected.
	 * @type {string}
	 */
	this._display = MultiSelectorBinding.DISPLAY_SELECTED;
	
	/**
	 * @type {HTMLDivElement}
	 */
	this._lastSelectedElement = null;
	
	/**
	 * Block common crawlers.
	 * @overwrites {Binding#crawlerFilters}
	 * @type {List<string>}
	 */
	this.crawlerFilters	= new List ([ DocumentCrawler.ID, FocusCrawler.ID ]);
}

/**
 * Identifies binding.
 */
MultiSelectorBinding.prototype.toString = function () {
	
	return "[MultiSelectorBinding]";
}

/**
 * @overloads {DataBinding#onBindingAttach}
 */
MultiSelectorBinding.prototype.onBindingAttach = function () {
	
	MultiSelectorBinding.superclass.onBindingAttach.call ( this );
	
	this.selections = this._getSelectionsList ();
	this.addActionListener ( DataDialogBinding.ACTION_COMMAND );
	this.addActionListener ( MultiSelectorDataDialogBinding.ACTION_RESULT );
	this.addEventListener ( DOMEvents.MOUSEDOWN );
	this._buildDOMContent ();
	this._parseDOMProperties ();
	this.populateFromList ( this.selections );
	
	/*
	 * Setup doubleclick.
	 */
	var dataDialog = this._dataDialogBinding;
	if ( dataDialog != null ) {
		DOMEvents.addEventListener ( this.shadowTree.box, DOMEvents.DOUBLECLICK, {
			handleEvent : function () {
				dataDialog.fireCommand ();
			}
		});
	}
}

/**
 * Build DOM content.
 */
MultiSelectorBinding.prototype._buildDOMContent = function () {
	
	// build box for result display
	this.shadowTree.box = DOMUtil.createElementNS ( Constants.NS_UI, "ui:box", this.bindingDocument );
	this.bindingElement.appendChild ( this.shadowTree.box );
}

/**
 * Parse DOM properties, instantiating editation and selectation.
 */
MultiSelectorBinding.prototype._parseDOMProperties = function () {
	
	var editable = this.getProperty ( "editable" );
	var selectable = this.getProperty ( "selectable" );
	var display = this.getProperty ( "display" );
	
	if ( editable != false ) {
		this._buildEditorButton ();
	} else {
		this.isEditable = false;
	}
	if ( selectable ) {
		this.isSelectable = true;
		this._selectionMap = new Map ();
	}
	if ( display ) {
		this._display = display;
	}
}

/**
 * Build button to launch editor. The button is actually a {@link MultiSelectorDataDialogBinding}.
 */ 
MultiSelectorBinding.prototype._buildEditorButton = function () {
	
	if ( this.isEditable ) {
	
		var datadialog = MultiSelectorDataDialogBinding.newInstance ( this.bindingDocument );
		datadialog.selections = this.selections;
		this.add ( datadialog );
		datadialog.attach ();
		
		this._dataDialogBinding = datadialog;
		this.shadowTree.datadialog = datadialog;
	}
}

/**
 * Populate multiselector. Clearing existing selections.
 * @param {List<SelectorBindingSelection>} list
 */
MultiSelectorBinding.prototype.populateFromList = function ( list ) {
	
	list.reset ();
	var isDisplay = false;
	
	this.shadowTree.box.innerHTML = "";
	
	while ( list.hasNext ()) {
		var selection = list.getNext ();
		switch ( this._display ) {
			case MultiSelectorBinding.DISPLAY_SELECTED :
				isDisplay = selection.isSelected;
				break;
			case MultiSelectorBinding.DISPLAY_UNSELECTED :
				isDisplay = selection.isSelected != true;
				break;
		}
		if ( isDisplay ) {
			this.shadowTree.box.appendChild (
				this._getElementForSelection ( selection )
			);
		}
	}
	
	this.selections = list;
	if ( this._dataDialogBinding ) {
		this._dataDialogBinding.selections = this.selections;
	}
}

/**
 * Append selections to existing selections. Note that 
 * automatic selection has been hardcoded into this.
 * @param {List<SelectorBindingSelection>} list
 * @param {boolean} isAssimilate If set to true, selection.isSelected is forced to adapt.
 */
MultiSelectorBinding.prototype.cumulateFromList = function ( list, isAssimilate ) {

	var box = this.shadowTree.box;
	var isDisplay = false;
	
	if ( list.hasEntries ()) {
	
		list.reverse ().reset ();
		while ( list.hasNext ()) { 
			var selection = list.getNext ();	
			if ( isAssimilate ) {
				selection.isSelected = this._display == MultiSelectorBinding.DISPLAY_SELECTED;
				isDisplay = true;
			} else {
				switch ( this._display ) {
					case MultiSelectorBinding.DISPLAY_SELECTED :
						isDisplay = selection.isSelected;
						break;
					case MultiSelectorBinding.DISPLAY_UNSELECTED :
						isDisplay = selection.isSelected != true;
						break;
				}
			}
			if ( isDisplay ) {
				var element = this._getElementForSelection ( selection );
		 		box.insertBefore ( element, box.firstChild );
		 		CSSUtil.attachClassName ( element, "selected" );
				this._selectionMap.set ( selection.value, element );
		 	}
		}
		
		// Because we autoselect, we can fire this.
		this.dispatchAction ( MultiSelectorBinding.ACTION_SELECTIONCHANGED );
	}
}

/**
 * Build a DIV element. This is very popular.
 * @param {SelectorBindingSelection} selection
 * @return {HTMLDivElement}
 */
MultiSelectorBinding.prototype._getElementForSelection = function ( selection ) {

	var element = DOMUtil.createElementNS ( Constants.NS_XHTML, "div", this.bindingDocument );
	element.appendChild ( this.bindingDocument.createTextNode ( selection.label ));
	element.setAttribute ( "label", selection.label );
	element.setAttribute ( "value", selection.value );
	return element;
}

/**
 * Has selection (highlighted entry)?
 * @return {boolean}
 */
MultiSelectorBinding.prototype.hasHighlight = function () {
	
	return this._selectionMap && this._selectionMap.hasEntries ();
}

/**
 * Focus on mousedown.
 * @implements {IActionListener}
 * @overloads {Binding#handleEvent}
 * @param {Action} action
 */
MultiSelectorBinding.prototype.handleEvent = function ( e ) {
	
	MultiSelectorBinding.superclass.handleEvent.call ( this, e );
	
	switch ( e.type ) {
		case DOMEvents.MOUSEDOWN :
			if ( !this.isFocused ) {
				this.focus ();
			}
			if ( this.isSelectable ) {
				var element = DOMEvents.getTarget ( e );
				var nodename = DOMUtil.getLocalName ( element );
				if ( nodename == "div" ) {
					this._handleMouseDown ( element );
					this.dispatchAction ( MultiSelectorBinding.ACTION_SELECTIONCHANGED );
				}
			}
			break;
	}
}

/**
 * Mousedown. Handling multiselect on shiftdown.
 * @param {HTMLDivElement} element
 */
MultiSelectorBinding.prototype._handleMouseDown = function ( element ) {

	if ( Keyboard.isShiftPressed && this._lastSelectedElement ) {
		
		var elements = this._getElements ();
		var value1 = element.getAttribute ( "value" );
		var value2 = this._lastSelectedElement.getAttribute ( "value" );
		
		var isSelect = false;
		while ( elements.hasNext ()) {
			var el = elements.getNext ();
			switch ( el.getAttribute ( "value" )) {
				case value1 :
				case value2 :
					isSelect = !isSelect;
					break;
			}
 			if ( isSelect ) {
 				this._hilite ( el );
 			} else {
 				this._unhilite ( el );
 			}
 			this._hilite ( this._lastSelectedElement );
 			this._hilite ( element );
		}
	} else {
		if ( Keyboard.isControlPressed && this._isHilited ( element )) {
			this._unhilite ( element );
		} else {
			this._hilite ( element );
		}
		if ( !Keyboard.isControlPressed ) {
			var self = this;
			this._getElements ().each ( function ( el ) {
				if ( el != element ) {
					self._unhilite ( el );
				}
			});
		}
	}
	
	this._lastSelectedElement = element;
}

/**
 * Highlight element.
 * @param {HTMLDivElement} element
 */
MultiSelectorBinding.prototype._hilite = function ( element ) {
	
	var value = element.getAttribute ( "value" );
	if ( !this._selectionMap.has ( value )) {
		CSSUtil.attachClassName ( element, "selected" );
		this._selectionMap.set ( value, element );
	}
}

/**
 * Don't highlight element.
 * @param {HTMLDivElement} element
 */
MultiSelectorBinding.prototype._unhilite = function ( element ) {

	var value = element.getAttribute ( "value" );
	if ( this._selectionMap.has ( value )) {
		CSSUtil.detachClassName ( element, "selected" );
		this._selectionMap.del ( value );
	}
}

/**
 * Is element highlighted?
 * @param {HTMLDivElement} element
 */
MultiSelectorBinding.prototype._isHilited = function ( element ) {

	return CSSUtil.hasClassName ( element, "selected" );
}

/**
 * Focus when button is handled; and hide the internal DataDialogBinding.
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
MultiSelectorBinding.prototype.handleAction = function ( action ) {
	
	MultiSelectorBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	
	switch ( action.type ) {
		
		/*
		 * Invoked when dialog is opened.
		 */
		case DataDialogBinding.ACTION_COMMAND :
			if ( binding == this._dataDialogBinding ) {
				if ( !this.isFocused ) {
					this.focus ();
				}
				this.dispatchAction ( MultiSelectorBinding.ACTION_COMMAND );
				action.consume ();
			}
			break;
			
		/*
		 * Invoked when dialog is closed.
		 */
		case MultiSelectorDataDialogBinding.ACTION_RESULT :
			this.populateFromList ( binding.result );
			this.dirty ();
			binding.result = null;
			action.consume ();
			break;
	}
}

/**
 * 
 * @return {List<SelectorBindingSelection}
 */
MultiSelectorBinding.prototype.extractSelected = function () {
	
	var result = null;
	if ( this.isSelectable ) {
		result = new List ();
		if ( this._selectionMap && this._selectionMap.hasEntries ()) {
		
			/*
			THIS WOULD EXTRACT IN RANDOM ORDER!
			this._selectionMap.each ( function ( key, element ) {
				element.parentNode.removeChild ( element );
				result.add ( new SelectorBindingSelection (
					element.getAttribute ( "label" ),
					element.getAttribute ( "value" ),
					true // hmmm....
				));
			});
			*/
			
			var self = this;
			this._getElements ().each ( function ( element ) {
				if ( self._isHilited ( element )) {
					element.parentNode.removeChild ( element );
					result.add ( new SelectorBindingSelection (
						element.getAttribute ( "label" ),
						element.getAttribute ( "value" ),
						true // hmmm....
					));
				}
			});
			
			this._selectionMap = new Map ();
			this.dispatchAction ( MultiSelectorBinding.ACTION_SELECTIONCHANGED );
		}
	}
	return result;
} 
 
/**
 * Reposition selected elements. Move either up or down.
 * @param {boolean} isUp
 */
MultiSelectorBinding.prototype.reposition = function ( isUp ) {
	
	/*
	 * Cannot use selectionMap because we need 
	 * to process sequentially in DOM node order.
	 */
	var elements = this._getElements ();
	if ( !isUp ) {
		elements.reverse ();
	}
	
	var isContinue = true;
	while ( isContinue && elements.hasNext ()) {
		var element = elements.getNext ();
		if ( this._isHilited ( element )) {
			switch ( isUp ) {
				case true :
					if ( element.previousSibling ) {
						element.parentNode.insertBefore ( element, element.previousSibling );
					} else {
						isContinue = false;
					}
					break;
				case false :
					if ( element.nextSibling ) {
						element.parentNode.insertBefore ( element, element.nextSibling.nextSibling );
					} else {
						isContinue = false;
					}
					break;
			}
		}
	}
}

/**
 * Parse DIV elements into a list of SelectorBindingSelection instances. 
 * Eeach SelectorBindingSelection is annotated with DIV highlighted status.
 * @see {MultiSelectorDialogPageBinding#_updateUpDownBroadcasters} 
 */
MultiSelectorBinding.prototype.toSelectionList = function () {
	
	var result = new List ();
	var isSelected = this._display == MultiSelectorBinding.DISPLAY_SELECTED;
	var self = this;
	
	this._getElements ().each ( function ( element ) {
		var selection = new SelectorBindingSelection (
			element.getAttribute ( "label" ),
			element.getAttribute ( "value" ),
			isSelected
		);
		selection.isHighlighted = self._isHilited ( element );
		result.add ( selection );
	});
	
	return result;
}

/**
 * Get those DIV elements.
 * @return {List<HTMLDivElement>}
 */
MultiSelectorBinding.prototype._getElements = function () {

	return new List ( 
		DOMUtil.getElementsByTagName ( 
			this.shadowTree.box, "div" 
		)
	);
}

/**
 * Parse ui:selection elements into instances of SelectorBindingSelection. 
 * This is used to populate the selector on startup.
 * @return {List<SelectorBindingSelection}
 */
MultiSelectorBinding.prototype._getSelectionsList = SelectorBinding.prototype._getSelectionsList;


// IMPLEMENT IDATA ...........................................................

/**
 * Validate.
 * @implements {IData}
 * @return {boolean}
 */
MultiSelectorBinding.prototype.validate = function () {
	
	return true;
}

/**
 * Manifest. This will write form elements into page DOM 
 * so that the server recieves something on form submit.
 * @implements {IData}
 */
MultiSelectorBinding.prototype.manifest = function () {
	
	/*
	 * We need to submit an "array" sort of thing. 
	 * First clear possible existing form elements.
	 */
	var inputs = new List ( DOMUtil.getElementsByTagName ( this.bindingElement, "input" ));
	if ( inputs.hasEntries ()) {
		inputs.each ( function ( input ) {
			input.parentNode.removeChild ( input );
		});
	}
	
	/*
	 * Build inputs for selected selections.
	 */
	this.selections.reset ();
	while ( this.selections.hasNext ()) {
		var selection = this.selections.getNext ();
		if ( selection.isSelected ) {
			var input = DOMUtil.createElementNS ( Constants.NS_XHTML, "input", this.bindingDocument );
			input.name = this._name;
			input.value = selection.value;
			this.bindingElement.appendChild ( input );
		}
	}
}

/**
 * Get value. This is intended for serversice processing.
 * @implements {IData}
 * @return {string}
 */
MultiSelectorBinding.prototype.getValue = function () {
	
	return "HEJ!";
}

/**
 * Set value.
 * @implements {IData}
 * @param {string} value
 */
MultiSelectorBinding.prototype.setValue = function ( value ) {
	
	alert ( value );
}

/**
 * Get result. This is intended for clientside processing.
 * @implements {IData}
 * @return {array
 */
MultiSelectorBinding.prototype.getResult = function () {
	
	alert ( "TODO: MultiSelectorBinding#getResult" );
	return new Array ();
}

/**
 * Set result.
 * @implements {IData}
 * @param {array} array
 */
MultiSelectorBinding.prototype.setResult = function ( array ) {

	alert ( "TODO: MultiSelectorBinding#setResult" );
}

HTMLDataDialogBinding.prototype = new PostBackDataDialogBinding;
HTMLDataDialogBinding.prototype.constructor = HTMLDataDialogBinding;
HTMLDataDialogBinding.superclass = PostBackDataDialogBinding.prototype;

/**
 * @class
 * This will open a {@link WysiwygEditorBinding} in a dialog.
 */
function HTMLDataDialogBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "HTMLDataDialogBinding" );
}

/**
 * Identifies binding.
 */
HTMLDataDialogBinding.prototype.toString = function () {
	
	return "[HTMLDataDialogBinding]";
}

/**
 * @overloads {StringDataDialogBinding#onBindingAttach}
 */
HTMLDataDialogBinding.prototype.onBindingAttach = function () {
	
	if ( this.getProperty ( "label" ) == null ) {
		this.setProperty ( "label", "Edit HTML" ); // TODO: stringbundle this!
	}
	HTMLDataDialogBinding.superclass.onBindingAttach.call ( this );
}

/**
 * @overwrites {DataDialogBinding#fireCommand}
 */
HTMLDataDialogBinding.prototype.fireCommand = function () {
	
	this.dispatchAction ( DataDialogBinding.ACTION_COMMAND );
	
	/*
	 * Build argument for editor configuration.
	 */
	var argument = {
		label : DataBinding.getAssociatedLabel ( this ),
		value : decodeURIComponent ( this.getValue ()),
		configuration : {
			"formattingconfiguration"	: this.getProperty ( "formattingconfiguration" ),
			"elementclassconfiguration"	: this.getProperty ( "elementclassconfiguration" ),
			"configurationstylesheet" 	: this.getProperty ( "configurationstylesheet" ),
			"presentationstylesheet" 	: this.getProperty ( "presentationstylesheet" ),
			"embedablefieldstypenames"	: this.getProperty ( "embedablefieldstypenames" )
		}
	}
	
	/*
	 * The dialoghandler is defined by superclass.
	 * @see {DataDialogBinding}
	 */
	var definition = ViewDefinitions [ "Composite.Management.VisualEditorDialog" ];
	definition.handler = this._handler;
	definition.argument = argument;
	StageBinding.presentViewDefinition ( definition );
	
	this._releaseKeyboard ();
}

MultiSelectorDataDialogBinding.prototype = new DataDialogBinding;
MultiSelectorDataDialogBinding.prototype.constructor = MultiSelectorDataDialogBinding;
MultiSelectorDataDialogBinding.superclass = DataDialogBinding.prototype;

MultiSelectorDataDialogBinding.ACTION_RESULT = "multiselectordatadialog result";

/**
 * @class
 * This is intended for use by the {@link MultiSelectorBinding} as 
 * an internal binding only. Don't use it for anything else.
 */
function MultiSelectorDataDialogBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "MultiSelectorDataDialogBinding" );
	
	/**
	 * Hardwired viewdefinition!
	 * @overwrites {DataDialogBinding#_dialogViewHandle}
	 * @type {string}
	 */
	this._dialogViewHandle = "Composite.Management.MultiSelectorDialog";
	
	/**
	 * @overwrites {DataBinding#isFocusable}
	 * @type {boolean}
	 */
	this.isFocusable = false;
	
	/**
	 * This property is set by the MultiSelectorBinding.
	 * @see {MultiSelectorBinding#_buildEditorButton}
	 * @type {List<SelectorBindingSelection>}
	 */
	this.selections = null;
	 
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
MultiSelectorDataDialogBinding.prototype.toString = function () {
	
	return "[MultiSelectorDataDialogBinding]";
}

/**
 * @overloads {StringDataDialogBinding#onBindingAttach}
 */
MultiSelectorDataDialogBinding.prototype.onBindingAttach = function () {
	
	this.setProperty ( "label", StringBundle.getString ( "ui", "Website.Misc.MultiSelector.LabelEditSelections" ) );
	MultiSelectorDataDialogBinding.superclass.onBindingAttach.call ( this );
}

/**
 * @overwrites {DataDialogBinding#fireCommand}
 */
MultiSelectorDataDialogBinding.prototype.fireCommand = function () {
	
	this.dispatchAction ( DataDialogBinding.ACTION_COMMAND );
	
	/*
	 * Build argument for selections editor.
	 */
	var argument = {
		label : DataBinding.getAssociatedLabel ( this ),
		selections : this.selections
	}
	
	/*
	 * Build dialog handler. Action intercepted 
	 * by hosting MultiSelecotorBinding.
	 */
	var self = this;
	var handler = {
		handleDialogResponse : function ( response, result ) {
			if ( response == Dialog.RESPONSE_ACCEPT ) {
				self.result = result;
				self.dispatchAction ( MultiSelectorDataDialogBinding.ACTION_RESULT );
			}
		}
	}
	
	/*
	 * Launch dialog.
	 */
	var definition = ViewDefinitions [ this._dialogViewHandle ];
	definition.handler = handler;
	definition.argument = argument;
	StageBinding.presentViewDefinition ( definition );
}

/**
 * MultiSelectorDataDialogBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {MultiSelectorDataDialogBinding}
 */
MultiSelectorDataDialogBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:datadialog", ownerDocument );
	return UserInterface.registerBinding ( element, MultiSelectorDataDialogBinding );
}

LazyBindingSetBinding.prototype = new Binding;
LazyBindingSetBinding.prototype.constructor = LazyBindingSetBinding;
LazyBindingSetBinding.superclass = Binding.prototype;

/**
 * @class
 */
function LazyBindingSetBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "LazyBindingSetBinding" );
}

/**
 * Identifies binding.
 */
LazyBindingSetBinding.prototype.toString = function () {
	
	return "[LazyBindingSetBinding]";
}

LazyBindingBinding.prototype = new DataBinding;
LazyBindingBinding.prototype.constructor = LazyBindingBinding;
LazyBindingBinding.superclass = DataBinding.prototype;

/*
 * Used when constructing IDs for LazyBindings.
 */
LazyBindingBinding.ID_APPENDIX = "lazybinding";

/**
 * Change LazyBinding server submit value.
 * @param {Binding} binding
 */
LazyBindingBinding.wakeUp = function ( binding ) {

	var id = binding.bindingElement.id + LazyBindingBinding.ID_APPENDIX;
	var element = binding.bindingDocument.getElementById ( id );
	if ( element != null ) {
		var lazyBinding = UserInterface.getBinding ( element );
		lazyBinding.setResult ( true );
	}
}

/**
 * @class
 */
function LazyBindingBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "LazyBindingBinding" );
	
	/**
	 * @overwrites {DataBinding#isFocusable}
	 */
	this.isFocusable = false;
	
	/**
	 * Flipped when lazy binding wakes up.
	 * @type {boolean}
	 */
	this._isLazy = false;
}

/**
 * Identifies binding.
 */
LazyBindingBinding.prototype.toString = function () {
	
	return "[LazyBindingBinding]";
}

/**
 * Mark lazy bindings in containing document. 
 * Attached bindings will not be affected.
 * @overloads {DataBinding#onBindingRegister}
 */
LazyBindingBinding.prototype.onBindingRegister = function () {
	
	LazyBindingBinding.superclass.onBindingRegister.call ( this );
	
	var id = this.getProperty ( "bindingid" );
	if ( id != null ) {
		
		// generation of the lazybindings ID attribute has been moved to XSLT! 
		// this.bindingElement.id = id + LazyBindingBinding.ID_APPENDIX;
		
		var element = this.bindingDocument.getElementById ( id );
		if ( element != null ) {
			var binding = UserInterface.getBinding ( element );
			if ( binding && !binding.isAttached ) {
				binding.isLazy = true;	
			} else {
				element.setAttribute ( "lazy", true );
			}
		}
	}
}

/**
 * Validate.
 * @implements {IData}
 * @return {boolean}
 */
LazyBindingBinding.prototype.validate = function () {
	
	return true;
}

/**
 * Manifest. This will write form elements into page DOM 
 * so that the server recieves something on form submit.
 * @implements {IData}
 */
LazyBindingBinding.prototype.manifest = function () {
	
	/*
	 * TODO: Migrate to Binding.dotnetify!
	 */
	if ( this.isAttached ) {
		if ( this.shadowTree.input == null ) {
			this.shadowTree.input = DOMUtil.createElementNS ( Constants.NS_XHTML, "input", this.bindingDocument );
			this.shadowTree.input.type = "hidden";
			this.shadowTree.input.name = this.getName ();
			this.bindingElement.appendChild ( this.shadowTree.input );
		}	
		this.shadowTree.input.value = this.getValue ();
	}
}

/**
 * Get value. This is intended for serversice processing.
 * @implements {IData}
 * @return {string}
 */
LazyBindingBinding.prototype.getValue = function () {
	
	return String ( this._isLazy );
}

/**
 * Set value.
 * @implements {IData}
 * @return {object}
 */
LazyBindingBinding.prototype.setValue = function () {
	
	throw "Not implemented";
}

/**
 * Get result. This is intended for clientside processing.
 * @implements {IData}
 * @return {object}
 */
LazyBindingBinding.prototype.getResult = function () {
	
	return this._isLazy;
}

/**
 * Set result. This is intended for clientside processing.
 * @see {LazyBindingBinding#wakeUp}
 * @implements {IData}
 * @param {boolean} isLazy
 */
LazyBindingBinding.prototype.setResult = function ( isLazy ) {
	
	this._isLazy = isLazy
}

EditorDataBinding.prototype = new WindowBinding;
EditorDataBinding.prototype.constructor = EditorDataBinding;
EditorDataBinding.superclass = WindowBinding.prototype;


/**
 * This WindowBinding implements the DataBinding interface.
 * @implements {IData}
 * @class
 */
function EditorDataBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "EditorDataBinding" );
	
	/**
	 * @implements {IFocusable}
	 * @type {boolean}
	 */
	this.isFocusable = false; // HUH?
	
	/**
	 * Sublcasses will define this.
	 * @type {string}
	 */
	this._url = WindowBinding.DEFAULT_URL;
	
	/**
	 * @type {boolean}
	 */
	this.isDirty = false;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
EditorDataBinding.prototype.toString = function () {

	return "[EditorDataBinding]";
};

/**
 * @overloads {WindowBinding#onBindingRegister}
 * @overloads {DataBinding#onBindingRegister}
 */
EditorDataBinding.prototype.onBindingRegister = function () {
	
	EditorDataBinding.superclass.onBindingRegister.call ( this );
	DataBinding.prototype.onBindingRegister.call ( this );
	
	/*
	 * Hide IE flash-of-white when loading.
	 */
	this._coverBinding = this.add ( 
		CoverBinding.newInstance ( this.bindingDocument )
	).attach ();
	
	var url = this._url;
	var provider = this.getProperty ( "stateprovider" );
	var handle = this.getProperty ( "handle" );
	if ( provider != null && handle != null ) {
		url = url.replace ( "${stateprovider}", provider ).replace ( "${handle}", handle );
	} else {
		url = url.split ( "?" )[ 0 ];
	}
	this.logger.debug ( "Loading URL: " + url );
	this.setURL ( url );
};

/**
 * @overloads {DataBinding#onBindingAttach}
 */
EditorDataBinding.prototype.onBindingAttach = function () {

	EditorDataBinding.superclass.onBindingAttach.call ( this );
	this.addActionListener ( Binding.ACTION_DIRTY );
	Application.lock ( this ); // unlocked by method _onPageInitialize
};

/**
 * Unlock when contained page initializes.
 * @overloads {WindowBinding#_onPageInitialize}
 * @param {PageBinding} binding
 */
EditorDataBinding.prototype._onPageInitialize = function ( binding ) {
	
	EditorDataBinding.superclass._onPageInitialize.call ( this, binding );
	
	if ( this._pageBinding != null ) {
		Application.unlock ( this );
		this._coverBinding.hide ();
	}
} 

/**
 * TODO: Should this fellow be transferred to IData?
 * @param {String} name
 */
EditorDataBinding.prototype.setName = DataBinding.prototype.setName;



// IMPLEMENT IDATA ...........................................................

/**
 * Validate.
 * @implements {IData}
 * @return {boolean}
 */
EditorDataBinding.prototype.validate = function () {
	
	return this._pageBinding.validateAllDataBindings ();
};

/**
 * @overloads {WindowBinding#handleAction}
 * @implements {IActionListener}
 * @param {Action} action
 */
EditorDataBinding.prototype.handleAction = function ( action ) {
	
	EditorDataBinding.superclass.handleAction.call ( this, action );
	
	/*
	 * Collect dirty actions and assign them to myself. 
	 */
	switch ( action.type ) {
		case Binding.ACTION_DIRTY :
			if ( action.target != this ) {
				if ( !this.isDirty ) {
					this.dirty ();
				}
				action.consume ();
			}
			break;
	}
}

/**
 * This binding does not manifest itself in current context window, but it  
 * may instruct contained window to instigate a postback. Long story, but  
 * the return value will instruct the {PageBinding} to stop the press and wait.
 * @see {PageBinding#_setupDotNet}
 * @overloads {DataBinding#manifest}
 * @implements {IData}
 * @return {EditorDataBinding}
 */
EditorDataBinding.prototype.manifest = function () {}

/**
 * Pollute dirty flag. Note that the local DataManager is NOT informed about this 
 * since the dirty event should not count as a real update to this.contextDocument. 
 * This way, we know how to save only frames that were really updated... 
 * @implements {IData}
 */
EditorDataBinding.prototype.dirty = function () {
	
	if ( !this.isDirty ) {
		this.isDirty = true;
		this.dispatchAction ( Binding.ACTION_DIRTY );
	}
}

/**
 * Clean dirty flag. Note recursive iframe infiltration!
 * @implements {IData}
 */
EditorDataBinding.prototype.clean = function () {
	
	this._pageBinding.cleanAllDataBindings ();
	DataBinding.prototype.clean.call ( this );
}

/**
 * Focus.
 * @implements {IFocusable}
 */
EditorDataBinding.prototype.focus = function () {
	
	// TODO: focus first focusable!!!!
};

/**
 * Blur.
 * @implements {IFocusable}
 */
EditorDataBinding.prototype.blur = function () {};

/**
 * Get name.
 * @return {string}
 */
EditorDataBinding.prototype.getName = function () {};

/**
 * Get value. This is intended for serversice processing.
 * @implements {IData}
 * @return {string}
 */
EditorDataBinding.prototype.getValue = function () {};

/**
 * Set value.
 * @implements {IData}
 * @param {string} value
 */
EditorDataBinding.prototype.setValue = function ( value ) {};

/**
 * Get result. This is intended for clientside processing.
 * @implements {IData}
 * @return {object}
 */
EditorDataBinding.prototype.getResult = function () {
	
	return null;
};

/**
 * Set result.
 * @implements {IData}
 * @param {object} result
 */
EditorDataBinding.prototype.setResult = function ( result ) {};

FunctionEditorDataBinding.prototype = new EditorDataBinding;
FunctionEditorDataBinding.prototype.constructor = FunctionEditorDataBinding;
FunctionEditorDataBinding.superclass = EditorDataBinding.prototype;


/**
 * @class
 */
function FunctionEditorDataBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "FunctionEditorDataBinding" );
	
	/**
	 * @overwrites {EditorDataBinding#_url}
	 */
	this._url = "${root}/content/misc/editors/functioncalleditor/functioncalleditor.aspx?StateProvider=${stateprovider}&Handle=${handle}";
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
FunctionEditorDataBinding.prototype.toString = function () {

	return "[FunctionEditorDataBinding]";
};

ParameterEditorDataBinding.prototype = new EditorDataBinding;
ParameterEditorDataBinding.prototype.constructor = ParameterEditorDataBinding;
ParameterEditorDataBinding.superclass = EditorDataBinding.prototype;


/**
 * @class
 */
function ParameterEditorDataBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ParameterEditorDataBinding" );
	
	/**
	 * @overwrites {EditorDataBinding#_url}
	 */
	this._url = "${root}/controls/FormsControls/FormUiControlTemplates/DeveloperTools/FunctionParameterEditor.aspx?StateProvider=${stateprovider}&handle=${handle}";
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
ParameterEditorDataBinding.prototype.toString = function () {

	return "[ParameterEditorDataBinding]";
};

/**
 * @implements {IData}
 */
ParameterEditorDataBinding.prototype.getValue = function () {
	
	return Math.random ();
}

FilePickerBinding.prototype = new DataBinding;
FilePickerBinding.prototype.constructor = FilePickerBinding;
FilePickerBinding.superclass = DataBinding.prototype;


/**
 * @class
 * @implements {IData}
 */
function FilePickerBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "FilePickerBinding" );
	
	/**
	 * @type {boolean}
	 */
	this.isReadOnly = true;
	
	/**
	 * @type {boolean}
	 */
	this._isValid = true;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
FilePickerBinding.prototype.toString = function () {

	return "[FilePickerBinding]";
}

/**
 * @overloads {DataBinding#onBindingAttach}
 * @return
 */
FilePickerBinding.prototype.onBindingAttach = function () {
	
	FilePickerBinding.superclass.onBindingAttach.call ( this );
	
	var real = this.getDescendantElementsByLocalName ( "input" ).getLast ();
	var fake = this.getDescendantBindingByLocalName( "datainput" );
	
	fake.isFocusable = false;
	
	var self = this;
	real.onchange = function () {
		fake.setValue ( this.value );
		self.dirty ();
		if ( !self._isValid ) {
			self.validate ();
		}
	}
}

// IMPLEMENT IDATA .............................................................

/**
 * Validate.
 * @implements {IData}
 * @return {boolean}
 */
FilePickerBinding.prototype.validate = function () {
	
	var result = true;
	if ( this.getProperty ( "required" )) {
		var fake = this.getDescendantBindingByLocalName( "datainput" );
		result = fake.getValue () != "";
	}
	if ( !result && this._isValid ) {
		this._isValid = false;
		this.dispatchAction ( Binding.ACTION_INVALID );
	} else if ( result && !this._isValid ) {
		this.dispatchAction ( Binding.ACTION_VALID );
	}	
	return result;
}

/**
 * Focus.
 * @overloads {DataBinding#focus}
 */
FilePickerBinding.prototype.focus = function () {
	
	FilePickerBinding.superclass.focus.call ( this );
	
	if ( this.isFocused ) {
		var fake = this.getDescendantBindingByLocalName ( "datainput" );
		if ( fake != null ) {
			fake.attachClassName ( DataBinding.CLASSNAME_FOCUSED );
		}
	}
}

/**
 * Blur.
 * @overloads {DataBinding#focus}
 */
FilePickerBinding.prototype.blur = function () {
	
	FilePickerBinding.superclass.blur.call ( this );

	if ( !this.isFocused ) {
		var fake = this.getDescendantBindingByLocalName ( "datainput" );
		if ( fake != null ) { // how could it be? A mystery...
			fake.detachClassName ( DataBinding.CLASSNAME_FOCUSED );
		}
	}
}

/**
 * Manifest. This will write form elements into page DOM 
 * so that the server recieves something on form submit.
 * @implements {IData}
 */
FilePickerBinding.prototype.manifest = function () {
	
	// do nothing
}

/**
 * Get value. This is intended for serversice processing.
 * @implements {IData}
 * @return {string}
 */
FilePickerBinding.prototype.getValue = function () {
	
	// do nothing - highly specialized setup
}

/**
 * Set value.
 * @implements {IData}
 * @param {string} value
 */
FilePickerBinding.prototype.setValue = function () {
	
	// do nothing
}

/**
 * Get result. This is intended for clientside processing.
 * @implements {IData}
 * @return {object}
 */
FilePickerBinding.prototype.getResult = function () {
	
	// do nothing
}

/**
 * Set result.
 * @implements {IData}
 * @param {object} value
 */
FilePickerBinding.prototype.setResult = function () {
	
	// do nothing
}

RequestBinding.prototype = new Binding;
RequestBinding.prototype.constructor = RequestBinding;
RequestBinding.superclass = Binding.prototype;

/**
 * This must be BOTH the client-id and the callback-id.
 * @type {String}
 */
RequestBinding.CALLBACK_ID = "__REQUEST";

/**
 * This is the client-id of the input field that we must 
 * poluate in order to let the server know who we are...
 * @type {String}
 */
RequestBinding.INPUT_ID = "__CONSOLEID"

/**
 * @class
 */
function RequestBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "RequestBinding" );
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
RequestBinding.prototype.toString = function () {

	return "[RequestBinding]";
}
 
/**
 * @overloads {Binding#onBindintAttach}
 */
RequestBinding.prototype.onBindingAttach = function () {
	
	RequestBinding.superclass.onBindingAttach.call ( this );
	
	this.setCallBackID ( RequestBinding.CALLBACK_ID );
	Binding.dotnetify ( this );
	
	var input = this.bindingDocument.getElementById ( RequestBinding.INPUT_ID );
	if ( input != null ) {
		input.value = Application.CONSOLE_ID;
	}
}

/**
 * Postback message. Defaults to current EditorPageBinding#message
 * @param {String} message
 */
RequestBinding.prototype.postback = function ( message) {
	
	message = message != null ? message : EditorPageBinding.message;
	this.shadowTree.dotnetinput.value = message;
	this.dispatchAction ( PageBinding.ACTION_DOPOSTBACK );
}

FieldGroupBinding.prototype = new Binding;
FieldGroupBinding.prototype.constructor = FieldGroupBinding;
FieldGroupBinding.superclass = Binding.prototype;

FieldGroupBinding.CENTER	= "group-c";
FieldGroupBinding.NORTH 	= "group-n";
FieldGroupBinding.SOUTH 	= "group-s";
FieldGroupBinding.EAST 		= "group-e";
FieldGroupBinding.WEST 		= "group-w";
FieldGroupBinding.NORTHEAST	= "group-ne";
FieldGroupBinding.NORTHWEST	= "group-nw";
FieldGroupBinding.SOUTHEAST	= "group-se";
FieldGroupBinding.SOUTHWEST	= "group-sw";

FieldGroupBinding.ACTION_HIDE = "fieldgrouphide";
FieldGroupBinding.CLASSNAME_NOLABEL = "nolabel";
FieldGroupBinding.CLASSNAME_FIRST = "first"; // attached by FieldsBinding!

/**
 * @class
 */
function FieldGroupBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "FieldGroupBinding" );
}

/**
 * Identifies binding.
 */
FieldGroupBinding.prototype.toString = function () {

	return "[FieldGroupBinding]";
}

/**
 * Notice that we need to do this on register already!
 * @overloads {Binding#onBindingRegister}
 */
FieldGroupBinding.prototype.onBindingRegister = function () {

	FieldGroupBinding.superclass.onBindingRegister.call ( this );
	this.propertyMethodMap [ "label" ] = this.setLabel;
	this._innerHTML ();
	this._buildDOMContent ();
}

/**
 * Perform the questionable "surround" html stunt. 
 * Please avoid this setup when possible.
 */
FieldGroupBinding.prototype._innerHTML = function () {
	
	var template = Templates.getTemplateElementText ( "fieldgroupmatrix.xml" );
	var markup = template.replace ( "${markup}", this.bindingElement.innerHTML );	
	
	try {
		this.bindingElement.innerHTML = markup;
	} catch ( exception1 ) {
		this.logger.error ( "Exeption in innerHTML!" ); // WHAT IS THIS????????
		markup = markup.replace ( /\&nbsp;/g, "" );
		this.bindingElement.innerHTML = markup;
	}
	
	var self = this;
	var table = DOMUtil.getElementsByTagName ( this.bindingElement, "table" ).item ( 0 );
	new List ( table.rows ).each ( function ( row ) {
		new List ( row.cells ).each ( function ( cell ) {
			self.shadowTree [ cell.className ] = cell;
		});
	});
}

/**
 * Build DOM content.
 */
FieldGroupBinding.prototype._buildDOMContent = function () { 
	
	var label = this.getProperty ( "label" );
	if ( label ) {
		this.setLabel ( label );
	} else {
		this.attachClassName ( FieldGroupBinding.CLASSNAME_NOLABEL );
	}
}

/**
 * Set label.
 * @parm {string} label
 */
FieldGroupBinding.prototype.setLabel = function ( label ) {
	
	this.setProperty ( "label", label );
	
	if ( this.shadowTree.labelBinding == null ) {
	
		var labelBinding = LabelBinding.newInstance ( this.bindingDocument );
		var cell = this.shadowTree [ FieldGroupBinding.NORTH ];
		labelBinding.attachClassName ( "fieldgrouplabel" );
		cell.insertBefore ( 
			labelBinding.bindingElement,
			cell.getElementsByTagName ( "div" ).item ( 1 )
		);
		labelBinding.attach ();
		this.shadowTree.labelBinding = labelBinding;
	}
	
	this.shadowTree.labelBinding.setLabel ( 
		Resolver.resolve ( label )
	);
}

/** 
 * Get label.
 * @return {string}
 */
FieldGroupBinding.prototype.getLabel = function () {
	
	return this.getProperty ( "label" );
}

/**
 * Make sure that added content is placed in matrix center.
 * @overwrites {Binding#add}  
 * @param {Binding} binding
 * @return {Binding}
 */
FieldGroupBinding.prototype.add = function ( binding ) {

	this.shadowTree [ FieldGroupBinding.CENTER ].appendChild ( binding.bindingElement );
	return binding;
}

/**
 * Make sure that added content is placed in matrix center.
 * @overwrites {Binding#addFirst}
 * @param {Binding} binding
 * @return {Binding}
 */
FieldGroupBinding.prototype.addFirst = function ( binding ) {
	
	var centerCell = this.shadowTree [ FieldGroupBinding.CENTER ];
	centerCell.insertBefore ( binding.bindingElement, centerCell.firstChild );
	return binding;
}

FieldBinding.prototype = new Binding;
FieldBinding.prototype.constructor = FieldBinding;
FieldBinding.superclass = Binding.prototype;

/**
 * @class
 */
function FieldBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "FieldBinding" );
	
	/**
	 * @type {string}
	 */
	this.bindingRelation = null;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
FieldBinding.prototype.toString = function () {

	return "[FieldBinding]";
}

/**
 * @overloads {Binding#onBindingRegister}
 */
FieldBinding.prototype.onBindingRegister = function () {
	
	FieldBinding.superclass.onBindingRegister.call ( this );
	this.attachClassName ( Binding.CLASSNAME_CLEARFLOAT );
	
	var relation = this.getProperty ( "relation" );
	if ( relation != null ) {
		this.bindingRelation = relation;
		this.subscribe ( BroadcastMessages.BINDING_RELATE );
		this.hide ();
	}
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
FieldBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	FieldBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		case BroadcastMessages.BINDING_RELATE :
			if ( arg.relate == this.bindingRelation && arg.origin == this.bindingDocument ) {
				if ( arg.result == true ) {
					if ( !this.isVisible ) {
						this.show ();
						this.dispatchAction ( Binding.ACTION_UPDATED );
					}
				} else {
					if ( this.isVisible ) {
						this.hide ();
						this.dispatchAction ( Binding.ACTION_UPDATED );
					}
				}
			}
			break;
	}
}

/**
 * FieldBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {FieldBinding}
 */
FieldBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:field", ownerDocument );
	return UserInterface.registerBinding ( element, FieldBinding );
}                                                          

FieldsBinding.prototype = new Binding;
FieldsBinding.prototype.constructor = FieldsBinding;
FieldsBinding.superclass = Binding.prototype;

FieldsBinding.ACTION_LAYOUT_UPDATED = "fieldslayoutupdated";

/**
 * @class
 */
function FieldsBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "FieldsBinding" );
	
	/**
	 * @type {int}
	 */
	this._invalidCount = 0;
	
	/**
	 * Tracking invalid fields for user message.
	 * @type {Map<string><string>}
	 */
	this._invalidFieldLabels = null;
	
	/**
	 * Block flex crawler.
	 * @overwrites {Binding#crawlerFilters}
	 * @type {List<string>}
	 */
	this.crawlerFilters	= new List ([ FlexBoxCrawler.ID, FitnessCrawler.ID ]);
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
FieldsBinding.prototype.toString = function () {

	return "[FieldsBinding]";
}

/**
 * @overloads {Binding#onBindingRegister}.
 */
FieldsBinding.prototype.onBindingRegister = function () {

	FieldsBinding.superclass.onBindingRegister.call ( this );
	
	this.addActionListener ( Binding.ACTION_INVALID );
	this.addActionListener ( Binding.ACTION_VALID );
	this.addActionListener ( FieldGroupBinding.ACTION_HIDE );
	
	this._invalidFieldLabels = new Map ();
}

/**
 * Display block when initialized (display none in stylesheet).
 * @overloads {Binding#onBindingInitialize}.
 */
FieldsBinding.prototype.onBindingInitialize = function () {

	FieldsBinding.superclass.onBindingInitialize.call ( this );
	this.bindingElement.style.display = "block";
	
	/**
	 * Emulate CSS first-child pseudoselector for IE... 
	 */
	var firstgroup = this.getDescendantBindingByLocalName ( "fieldgroup" );
	if ( firstgroup != null ) {
		firstgroup.attachClassName ( FieldGroupBinding.CLASSNAME_FIRST );
	}
}

/**
 * Disposing an invalid FieldsBinding will automatically 
 * make it valid in the greater scheme of things.
 * @overloads {Binding#onBindingDispose}.
 */
FieldsBinding.prototype.onBindingDispose = function () {

	FieldsBinding.superclass.onBindingDispose.call ( this );
	
	if ( this._invalidCount > 0 ) {
		this.dispatchAction ( Binding.ACTION_VALID );
	}
}

/**
 * Validate all contained bindings and return true only if everything validates.
 * @return {boolean}
 */
FieldsBinding.prototype.validate = function () {
	
	var isValid = true;
	
	var bindings = this.getDescendantBindingsByLocalName ( "*" );
	while ( bindings.hasNext ()) {
		var binding = bindings.getNext ();
		if ( Interfaces.isImplemented ( IData, binding )) {
			var isBindingValid = binding.validate ();
			if ( isValid && !isBindingValid ) {
				isValid = false;
			}
		}
	}
	return isValid;
}

/**
 * Get result. This returns a name-value hashmap for all contained DataBindings. 
 * Notice that the {@link DocumentManager} has a equivalent method extract information 
 * from *all* databindings within the local scope. Also notice that we call the getResult 
 * method instead of getValue. The value is for the serverside while the "result" is 
 * automatically typecasted for clientside handling.
 * @return {HashMap<string><object>}
 *
FieldsBinding.prototype.getDataBindingResultMap = function () {
	
	throw "Method needs updating";
	
	var result = {};
	 
	var bindings = this.getDescendantBindingsByLocalName ( "*" );
	while ( bindings.hasNext ()) {
		var binding = bindings.getNext ();
		if ( Interfaces.isImplemented ( IData, binding )) {
			result [ binding.getName ()] = binding.getResult ();	
		}
	}
	return result;
}
*/

/**
 * Around here we simply collect and count valid/invalid actions in order 
 * to dispatch a unified valid/invalid action for this entire binding.
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
FieldsBinding.prototype.handleAction = function ( action ) {
	
	FieldsBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	
	if ( binding != this ) {
		switch ( action.type ) {
			
			/*
			 * Tracking invalid DataBindings. Error display handled.
			 */
			case Binding.ACTION_INVALID :
			
				/*
				 * Tracking statusbar errors (displayed by EditorPageBinding).
				 */
				var label = DataBinding.getAssociatedLabel ( binding );
				if ( label ) {
					this._invalidFieldLabels.set ( binding.key, label );
				}
				
				/*
				 * Show balloon error? Note that balloons are supressed for "required" errors.
				 */
				if ( binding.error ) {
					if ( !binding.isInvalidBecauseRequired ) {
						ErrorBinding.presentError ({
							text: binding.error
						}, binding );
					}
				}
				
				/*
				 * Count invalid bindings.
				 */
				if ( this._invalidCount == 0 ) {
					this.dispatchAction ( Binding.ACTION_INVALID );	
				}
				this._invalidCount ++;	
				action.consume ();
				break;
				
			case Binding.ACTION_VALID :
				if ( this._invalidFieldLabels.has ( binding.key )) {
					this._invalidFieldLabels.del ( binding.key );
				}
				this._invalidCount --;
				if ( this._invalidCount == 0 ) {
					this.dispatchAction ( Binding.ACTION_VALID );	
				}
				action.consume ();
				break;
		}
	}
}

/**
 * Get labels of invalid bindings.
 * @return {List<string>}
 */
FieldsBinding.prototype.getInvalidLabels =  function () {
	
	var result = null;
	if ( this._invalidFieldLabels.hasEntries ()) {
		result = this._invalidFieldLabels.toList ();
	}
	return result;
}

/**
 * FieldsBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {FieldsBinding}
 */
FieldsBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:fields", ownerDocument );
	return UserInterface.registerBinding ( element, FieldsBinding );
}

FieldDescBinding.prototype = new Binding;
FieldDescBinding.prototype.constructor = FieldDescBinding;
FieldDescBinding.superclass = Binding.prototype;

/**
 * The fielddescbinding constructs a {@link LabelBinding}  
 * in order to support alphatransparent PNG images.
 * @class
 */
function FieldDescBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "FieldDescBinding" );
	
	return this;
}

/**
 * Identifies binding.
 */
FieldDescBinding.prototype.toString = function () {

	return "[FieldDescBinding]";
}

/** 
 * @overloads {Bindong#onBindingAttach}
 */
FieldDescBinding.prototype.onBindingAttach = function () {
	
	// FieldDescBinding.superclass.onBindingAttach.call ( this );
	Binding.prototype.onBindingAttach.call ( this );
	
	this.buildDOMContent (); 
	this.attachDOMEvents ();
}

/**
 * Build DOM content.
 */
FieldDescBinding.prototype.buildDOMContent = function () {

	// image
	var image = this.getProperty ( "image" );
	if ( image ) {
		this.setImage ( image );
	}
	
	// tooltip
	var tooltip	= this.getProperty ( "tooltip" );
	if ( tooltip ) {
		this.setToolTip ( tooltip );
	}
	
	// label
	var label = this.getProperty ( "label" );
	if ( label ) {
		this.setLabel ( label );
	}
}

/**
 * Attach DOM events.
 * Attach listeners to focus DataBinding when label is clicked.
 */
FieldDescBinding.prototype.attachDOMEvents = function () {

	/*
	 * Don't use mousedown since this will simultaneously blur HTML input fields.
	 */
	this.addEventListener ( DOMEvents.CLICK );
}

/**
 * Focus related DataBinding when label is clicked.
 * @implements {IEventListener}
 * @overloads {Binding#handleEvent}
 * @param {MouseEvent} e
 */
FieldDescBinding.prototype.handleEvent = function ( e ) {

	FieldDescBinding.superclass.handleEvent.call ( this, e );
	
	switch ( e.type ) { 
		case DOMEvents.CLICK :
			var field = this.getAncestorBindingByLocalName ( "field" );
			if ( field ) {
				var isContinue = true;
				field.getDescendantBindingsByLocalName ( "*" ).each (
					function ( binding ) {
						if ( Interfaces.isImplemented ( IData, binding )) {
							binding.focus ();
							isContinue = false;
						}
						return isContinue;
					}
				);
			}
			break;
	}	
}

/**
 * Set label.
 * @param {string} label
 */
FieldDescBinding.prototype.setLabel = function ( label ) {
	
	this.setProperty ( "label", label );
	if ( this.isAttached ) {
		this.bindingElement.innerHTML = Resolver.resolve ( label );
	}
}

/**
 * Get label. First check label property; then analyze text content.
 * @return {string}
 */
FieldDescBinding.prototype.getLabel = function () {
	
	var label = this.getProperty ( "label" );
	if ( !label ) {
		var node = this.bindingElement.firstChild;
		if ( node && node.nodeType == Node.TEXT_NODE ) {
			label = node.data;
		}
	}
	return label;
}

/**
 * Set image.
 * TODO: getter?
 * @param {string} image
 */
FieldDescBinding.prototype.setImage = function ( image ) {
	
	this.setProperty ( "image", image );
	if ( this.isAttached ) {
		throw "FieldDescBinding: Images not suppoerted!";
	}
}

/** 
 * Set tooltip.
 * TODO: getter?
 * @param {string} tooltip
 */
FieldDescBinding.prototype.setToolTip = function ( tooltip ) {
	
	this.setProperty ( "tooltip", tooltip );
	if ( this.isAttached ) {
		this.bindingElement.title = tooltip;
	}
}

/**
 * FieldDescBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {FieldDescBinding}
 */
FieldDescBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:fielddesc", ownerDocument );
	return UserInterface.registerBinding ( element, FieldDescBinding );
}

FieldDataBinding.prototype = new Binding;
FieldDataBinding.prototype.constructor = FieldDataBinding;
FieldDataBinding.superclass = Binding.prototype;

/**
 * @class
 * This doesn't really do anything. But it's nice to have...
 */
function FieldDataBinding () {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "FieldDataBinding" );
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
FieldDataBinding.prototype.toString = function () {

	return "[FieldDataBinding]";
}

/**
 * FieldDataBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {FieldDataBinding}
 */
FieldDataBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:fielddata", ownerDocument );
	return UserInterface.registerBinding ( element, FieldDataBinding );
}

FieldHelpBinding.prototype = new Binding;
FieldHelpBinding.prototype.constructor = FieldHelpBinding;
FieldHelpBinding.superclass = Binding.prototype;

FieldHelpBinding.INDICATOR_IMAGE = "${skin}/fields/fieldhelpindicator.png";

/**
 * @class
 */
function FieldHelpBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "FieldHelpBinding" );
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
FieldHelpBinding.prototype.toString = function () {

	return "[FieldHelpBinding]";
}

/**
 * @overloads {Binding#onBindingAttach}
 */
FieldHelpBinding.prototype.onBindingAttach = function () {
	
	FieldHelpBinding.superclass.onBindingAttach.call ( this );
	
	this.buildPopupBinding ();
	this.buildPopupButton ();
}

/**
 * @overloads {Binding#onBindingDispose}
 */
FieldHelpBinding.prototype.onBindingDispose = function () {
	
	FieldHelpBinding.superclass.onBindingDispose.call ( this );
	
	var popup = this._fieldHelpPopupBinding;
	if ( popup ) {
		popup.dispose ();
	}
}

/**
 * Build popup.
 */
FieldHelpBinding.prototype.buildPopupBinding = function () {
	
	var popupSetBinding = app.bindingMap.fieldhelpopupset;
	var doc = popupSetBinding.bindingDocument;
	var popupBinding = popupSetBinding.add (
		PopupBinding.newInstance ( doc )
	);
	var bodyBinding = popupBinding.add (
		PopupBodyBinding.newInstance ( doc )
	);
	popupBinding.position = PopupBinding.POSITION_RIGHT;
	popupBinding.attachClassName ( "fieldhelppopup" );
	
	/*
	 * Help can be written inside the tag or supplied in the label attribute.
	 */
	if ( this.bindingElement.hasChildNodes ()) {
		bodyBinding.bindingElement.innerHTML = this.bindingElement.innerHTML;
	} else {
		var label = this.getProperty ( "label" );
		if ( label ) {
			bodyBinding.bindingElement.innerHTML = Resolver.resolve ( label );
		}
	}
	
	this.bindingElement.innerHTML = "";
	this._fieldHelpPopupBinding = popupBinding;
}

/**
 * Build DOM content.
 */
FieldHelpBinding.prototype.buildPopupButton = function () {

	var field = this.getAncestorBindingByLocalName ( "field" );
	
	if ( field ) {
	
		field.attachClassName ( "fieldhelp" );
		
		var button = ClickButtonBinding.newInstance ( this.bindingDocument );
		button.attachClassName ( "fieldhelp" ); 
	 	button.setImage ( FieldHelpBinding.INDICATOR_IMAGE );
	 	this.add ( button );
	 	button.attach ();
	 	
	 	var self = this;
	 	button.oncommand = function () {
			self.attachPopupBinding ();
		}
		
		button.setPopup ( this._fieldHelpPopupBinding );
	 	this._fieldHelpButton = button;
	}
}

/**
 * Attach popup. For faster page load time, the popup bindings 
 * get attached only when user handles the button.
 */
FieldHelpBinding.prototype.attachPopupBinding = function () {

	var popup = this._fieldHelpPopupBinding;
	if ( popup && !popup.isAttached ) {
		popup.attachRecursive ();
	}
}

RadioDataGroupBinding.prototype = new RadioGroupBinding;
RadioDataGroupBinding.prototype.constructor = RadioDataGroupBinding;
RadioDataGroupBinding.superclass = RadioGroupBinding.prototype;

/**
 * @class
 * @implements {IData}
 */
function RadioDataGroupBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "RadioDataGroupBinding" );
	
	/**
	 * @type {string}
	 */
	this._name = null;
	
	/**
	 * @type {boolean}
	 */
	this.isDirty = false;
	
	/**
	 * @type {boolean}
	 */
	this._hasFocus = false;
	
	/**
	 * @implements {IData}
	 * @type {boolean}
	 */
	this.isFocusable = true;
	
	/**
	 * @implements {IData}
	 * @type {boolean}
	 */
	this.isFocused = false;
}

/**
 * Identifies binding.
 */
RadioDataGroupBinding.prototype.toString = function () {

	return "[RadioDataGroupBinding]";
}

/**
 * @overloads {RadioGroupBinding#onBindingRegister}
 */
RadioDataGroupBinding.prototype.onBindingRegister = function () {
	
	RadioDataGroupBinding.superclass.onBindingRegister.call ( this );
	DataBinding.prototype.onBindingRegister.call ( this );
	this.addActionListener ( RadioGroupBinding.ACTION_SELECTIONCHANGED, this );
}

/**
 * @overloads {RadioGroupBinding#onBindingAttach}
 */
RadioDataGroupBinding.prototype.onBindingAttach = function () {
	
	RadioDataGroupBinding.superclass.onBindingAttach.call ( this );
	
	this.bindingElement.tabIndex = 0;
	if ( Client.isExplorer ) {
		this.bindingElement.hideFocus = true;
	}
	
	var self = this;
	DOMEvents.addEventListener ( this.bindingElement, DOMEvents.FOCUS, {
		handleEvent : function () {
			self.focus ( true );
		}
	});
}

/**
 * @overloads {Binding#onBindingDispose}
 */
RadioDataGroupBinding.prototype.onBindingDispose = function () {
	
	RadioDataGroupBinding.superclass.onBindingDispose.call ( this );
	DataBinding.prototype.onBindingDispose.call ( this );
}

/**
 * Dispatching dirty events.
 * @implements {IActionListener}
 * @overloads {RadioGroupBinding#handleAction}
 * @param {Action} action
 */
RadioDataGroupBinding.prototype.handleAction = function ( action ) {
	
	RadioDataGroupBinding.superclass.handleAction.call ( this, action );
	
	switch ( action.type ) {
		case RadioGroupBinding.ACTION_SELECTIONCHANGED :
			this.dirty ();
			break;
	}
}

/**
 * We need to trap the arrowkey events in order to stop the page from scrolling 
 * when radiobuttons are keyboardnavigated. Notice that keyboardhandling by itself 
 * is handled similarly to other DataBindings (using the EventBroadcaster).
 * @implements {IEventListener}
 * @overloads {Binding#handleEvent}
 * @param {KeyEvent} e
 */
RadioDataGroupBinding.prototype.handleEvent = function ( e ) {
	
	RadioDataGroupBinding.superclass.handleEvent.call ( this, e );
	
	if ( e.type == DOMEvents.KEYDOWN ) {
		switch ( e.keyCode ) {
			case KeyEventCodes.VK_DOWN :
			case KeyEventCodes.VK_UP :
				DOMEvents.stopPropagation ( e );
				DOMEvents.preventDefault ( e );
				Keyboard.keyArrow ( e.keyCode ); // will trigger EventBroadcaster
				break;
		}
	}
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
RadioDataGroupBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	RadioDataGroupBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		case BroadcastMessages.KEY_ARROW :
		
			var current = null;
			var next = null;
			var radios = null;
			
			switch ( arg ) {
				case KeyEventCodes.VK_DOWN :
				case KeyEventCodes.VK_UP :
					radios = this.getChildBindingsByLocalName ( "radio" );
					while ( !current && radios.hasNext ()) { 
						var radio = radios.getNext ();
						if ( radio.getProperty ( "ischecked" )) {
							current = radio;
						}
					};
					break;
			}
			if ( current ) {
				switch ( arg ) {
					case KeyEventCodes.VK_DOWN :
						next = radios.getFollowing ( current );
						while ( next != null && next.isDisabled ) {
							next = radios.getFollowing ( next );
						}
						break;
					case KeyEventCodes.VK_UP :
						next = radios.getPreceding ( current );
						while ( next != null && next.isDisabled ) {
							next = radios.getPreceding ( next );
						}
						break;
				}
			}
			if ( next != null ) {
				this.setCheckedButtonBinding ( next );
			}
			break;
	}
}

/**
 * Set name. The name property is registered with the window-scope  
 * {@link DocumentManager} for easy retrieval in other contexts.
 * @param {string} name
 */
RadioDataGroupBinding.prototype.setName = DataBinding.prototype.setName;

/**
 * Get name.
 * @implements {IData}
 * @return {string}
 */
RadioDataGroupBinding.prototype.getName = DataBinding.prototype.getName;

/**
 * Set dirty flag.
 * @implements {IData}
 */
RadioDataGroupBinding.prototype.dirty = DataBinding.prototype.dirty;

/**
 * Reset dirty flag.
 * @implements {IData}
 */
RadioDataGroupBinding.prototype.clean = DataBinding.prototype.clean;

/**
 * Focus.
 * @param {boolean} isDOMEvent
 * @implements {IData}
 */
RadioDataGroupBinding.prototype.focus = function ( isDOMEvent ) {
	
	if ( !this.isFocused ) {
		DataBinding.prototype.focus.call ( this );
		if ( this.isFocused ) {
			if ( !isDOMEvent ) {
				FocusBinding.focusElement ( this.bindingElement );
			}
			this.addEventListener ( DOMEvents.KEYDOWN );
			this.subscribe ( BroadcastMessages.KEY_ARROW );
		}
	}
}

/**
 * Blur.
 * @implements {IData}
 */
RadioDataGroupBinding.prototype.blur = function () {
	
	if ( this.isFocused ) {
		DataBinding.prototype.blur.call ( this );
		this.removeEventListener ( DOMEvents.KEYDOWN );
		this.unsubscribe ( BroadcastMessages.KEY_ARROW );	
	}
}

/**
 * Validate.
 * @implements {IData}
 * @return {boolean}
 */
RadioDataGroupBinding.prototype.validate = function () {
	
	return true; // TODO: validate "required"! Do we even wan't to support this?
}

/**
 * Manifest. This will write form elements into page DOM 
 * so that the server recieves something on form submit.
 * @implements {IData}
 */
RadioDataGroupBinding.prototype.manifest = function () {
	
	if ( this.isAttached ) {
		if ( !this.shadowTree.input ) {
			var input = DOMUtil.createElementNS ( 
				Constants.NS_XHTML, "input", this.bindingDocument
			);
			input.type = "hidden";
			input.name = this._name;
			this.bindingElement.appendChild ( input );
			this.shadowTree.input = input;
		}
		this.shadowTree.input.value = this.getValue ();
	}
}

/**
 * Get value. This is intended for serversice processing.
 * @implements {IData}
 * @return {string}
 */
RadioDataGroupBinding.prototype.getValue = function () {
	
	var result = null;
	var radios = this.getChildBindingsByLocalName ( "radio" );
	while ( !result && radios.hasNext ()) { 
		var radio = radios.getNext ();
		if ( radio.isChecked ) {
			result = radio.getProperty ( "value" );
		}
	};
	return result;
}

/**
 * Get result. This is intended for clientside processing.
 * @implements {IData}
 * @return {object}
 */
RadioDataGroupBinding.prototype.getResult = RadioDataGroupBinding.prototype.getValue;

/**
 * Set value.
 * TODO!
 * @implements {IData}
 * @param {string} value
 */
RadioDataGroupBinding.prototype.setValue = function ( value ) {}

/**
 * Set result.
 * TODO!
 * @implements {IData}
 * @param {object} result
 */
RadioDataGroupBinding.prototype.setResult = function ( result ) {}

RadioDataBinding.prototype = new Binding;
RadioDataBinding.prototype.constructor = RadioDataBinding;
RadioDataBinding.superclass = Binding.prototype;

/**
 * @class
 * TODO: note on how RadioGroupBindings handles only buttons
 */
function RadioDataBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "RadioDataBinding" );
	
	/** 
	 * This has something to do with the mechanics of the containing RadioDataGroup.
	 * @type {boolean}
	 */
	this.isRadioButton = false;
	
	/** 
	 * @type {boolean}
	 */
	this.isChecked = false;
	
	/** 
	 * TODO: implement this some day!
	 * @type {object}
	 */
	this._result = null;
	
	/**
	 * @type {string}
	 */
	this.bindingRelate = null;
	
	/*
	 * Returnable. 
	 */
	return this;
}

/**
 * Identifies binding.
 */
RadioDataBinding.prototype.toString = function () {

	return "[RadioDataBinding]";
}

/*
 * Build radiobutton on REGISTER already. This because of radiogroup initialization.
 */
RadioDataBinding.prototype.onBindingRegister = function () {
	
	RadioDataBinding.superclass.onBindingRegister.call ( this );
	
	/*
	 * This may not always be enough, see below...
	 */
	this.propertyMethodMap [ "checked" ] = function ( isChecked ) {
		if ( isChecked != this.isChecked ) {
			this.setChecked ( isChecked, true );
		}
	};
	
	/*
	 * To ensure maximum synchronizity with the server,  
	 * we check for checkedness on ALL postback responses.
	 */
	this.propertyMethodMap [ "checksum" ] = function () {
		var isChecked = this.getProperty ( "ischecked" );
		if ( isChecked != this.isChecked ) {
			this.setChecked ( isChecked, true );
		}
	};
	
	this._buttonBinding = this.add ( 
		RadioButtonBinding.newInstance ( this.bindingDocument )
	);
	this._hack ();
	
	if ( this.getProperty ( "ischecked" ) == true ) {
		this.check ( true );
	}
	
}

/**
 * @overloads {Binding#onBindingAttach}
 */
RadioDataBinding.prototype.onBindingAttach = function () {

	RadioDataBinding.superclass.onBindingAttach.call ( this );
	
	this.attachClassName ( Binding.CLASSNAME_CLEARFLOAT );
	this._buttonBinding.attach ();
	this._buildDOMContent ();
}

/**
 * Build DOM content.
 */
RadioDataBinding.prototype._buildDOMContent = function () {
	
	var relate = this.getProperty ( "relate" );
	var oncommand = this.getProperty ( "oncommand" );
	
	if ( relate ) {
		this.bindingRelate = relate;
		this.relate ();
	}
	if ( oncommand ) {
		this.oncommand = function () {
			Binding.evaluate ( oncommand, this );
		};
	}
	
	/*
	 * Setup ASP.NET callback.
	 */
	if ( this.hasCallBackID ()) {
		Binding.dotnetify ( this );
	}
	
	this._buildLabelText ();
}

/**
 * Broadcast relation.
 */
RadioDataBinding.prototype.relate = function () {
	
	if ( this.bindingRelate != null ) {
		this.logger.warn ( "Relations not properly implemented!" ); // see method setChecked...
		EventBroadcaster.broadcast ( BroadcastMessages.BINDING_RELATE, {
			relate : this.bindingRelate,
			origin : this.bindingDocument,
			result : this.isChecked
		});
	}
}

/**
 * TODO: note on how RadioGroupBindings handles only buttons
 * {@see RadioGroupBinding#setCheckedButtonBinding}
 * @return {RadioButtonBinding}
 */
RadioDataBinding.prototype.getButton = function () {
	
	return this._buttonBinding;
}

/**
 * Shameful hack, all because of Explorers CSS rendering challanges.
 */
RadioDataBinding.prototype._hack = function () {

	var self = this;
	var callbackid = this.getCallBackID ();
	
	this._buttonBinding.check = function ( isDisableCommand ) {
		RadioButtonBinding.prototype.check.call ( this, isDisableCommand );
		self.setProperty ( "ischecked", true );
		self.isChecked = true;
		self.relate ();
		//if ( callbackid != null ) { TODO!
			//alert ( self );
		//}
	}
	
	this._buttonBinding.uncheck = function ( isDisableCommand ) {
		RadioButtonBinding.prototype.uncheck.call ( this, isDisableCommand );
		self.deleteProperty ( "ischecked" );
		self.isChecked = false;
		self.relate ();
		//if ( callbackid != null ) { TODO!
			//alert ( self );
		//}
	}
	
	this._buttonBinding.oncommand = function () {
		self.isChecked = this.isChecked;
		self.relate ();
		if ( Types.isFunction ( self.oncommand )) {
			self.oncommand ();
		}	
	}
}

/**
 * @param {boolean} isChecked
 * @param {boolean} isDisableCommand Optional.
 */
RadioDataBinding.prototype.setChecked = function ( isChecked, isDisableCommand ) {
	
	//if ( this.isAttched == true ) {
	this._buttonBinding.setChecked ( isChecked, isDisableCommand );
	if ( this.bindingRelate != null ) {
		this.relate (); // TOOOOOOOOOOOOOOO EARLY ON REGISTER!!!!!!!!!!!!!!!!!!!!!!!!!!!
	}
	//}
	this.setProperty ( "ischecked", isChecked );
}

/**
 * @param {boolean} isDisableCommand Optional.
 */
RadioDataBinding.prototype.check = function ( isDisableCommand ) {
	
	this.setChecked ( true, isDisableCommand );	
}

/**
 * @param {boolean} isDisableCommand Optional.
 */
RadioDataBinding.prototype.uncheck = function ( isDisableCommand ) {
	
	this.setChecked ( false, isDisableCommand );	
}

/**
 * Flip disabled.
 * @param {boolean} isDisabled
 */
RadioDataBinding.prototype.setDisabled = function ( isDisabled ) {
	
	if ( isDisabled != this.isDisabled ) {
		this.isDisabled = isDisabled;
		this._buttonBinding.setDisabled ( isDisabled );
		if ( isDisabled ) {
			this.attachClassName ( DataBinding.CLASSNAME_DISABLED );
		} else {
			this.detachClassName ( DataBinding.CLASSNAME_DISABLED );
		}
	}
}

/**
 * Disable.
 */
RadioDataBinding.prototype.disable = function () {

	if ( !this.isDisabled ) {
		this.setDisabled ( true );
	}
}

/**
 * Enable.
 */
RadioDataBinding.prototype.enable = function () {
	
	if ( this.isDisabled ) {
		this.setDisabled ( false );
	}
}

/**
 * @implements {IEventListener}
 * @overloads {Binding#handleEvent}
 * @param {MouseEvent} e
 */
RadioDataBinding.prototype.handleEvent = function ( e ) {
	
	RadioDataBinding.superclass.handleEvent.call ( this, e );
	
	if ( e.type == DOMEvents.CLICK ) {
		var target = DOMEvents.getTarget ( e );
		switch( target ) {
			case this.shadowTree.labelText :
				if ( !this.isChecked && !this.isDisabled ) {
					this.check ();
				}
				break;
		}
	}
}

/**
 * Explorer cannot overwrite inherited "white-space: nowrap" 
 * in a regular button, so we need to build a special label.
 */
RadioDataBinding.prototype._buildLabelText = function () {
	
	var label = this.getProperty ( "label" );
	if ( label ) {
		this.shadowTree.labelText = DOMUtil.createElementNS ( 
			Constants.NS_UI, 
			"ui:datalabeltext", 
			this.bindingDocument 
		);
		this.shadowTree.labelText.appendChild ( 
			this.bindingDocument.createTextNode ( 
				Resolver.resolve ( label )
			)
		);
		DOMEvents.addEventListener ( 
			this.shadowTree.labelText, 
			DOMEvents.CLICK, 
			this 
		);
		this.bindingElement.appendChild ( 
			this.shadowTree.labelText 
		);
	}
}

/**
 * Set label.
 * @param {string} label
 */
RadioDataBinding.prototype.setLabel = function ( label ) {
	
	if ( this.shadowTree.labelText != null ) {
		this.shadowTree.labelText.firstChild.data = label;
	}
	this.setProperty ( "label", label );
}

CheckBoxBinding.prototype = new Binding;
CheckBoxBinding.prototype.constructor = CheckBoxBinding;
CheckBoxBinding.superclass = Binding.prototype;

CheckBoxBinding.ACTION_COMMAND = "checkbox command";

/**
 * @class
 * @implements {IData}
 */
function CheckBoxBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "CheckBoxBinding" );
	
	/**
	 * @type {CheckButtonBinding}
	 */
	this._buttonBinding = null;
	
	/**
	 * @type {string}
	 */
	this._name = null;
	
	/**
	 * @type {boolean}
	 */
	this.isDirty = false;
	
	/**
	 * @type {boolean}
	 */
	this.isChecked = false;
	
	/**
	 * @type {object}
	 */
	this._result = null;
	
	/**
	 * @implements {IData}
	 * @type {boolean}
	 */
	this.isFocusable = true;
	
	/**
	 * @implements {IData}
	 * @type {boolean}
	 */
	this.isFocused = false;
}

/**
 * Identifies binding.
 */
CheckBoxBinding.prototype.toString = function () {
	
	return "[CheckBoxBinding]";
}

/**
 * Register databinding.
 * @overloads {Binding#onBindingRegister}.
 */
CheckBoxBinding.prototype.onBindingRegister = function () {
	
	/*
	 * The button must be buld now so that we can check it before attachment...
	 */
	CheckBoxBinding.superclass.onBindingRegister.call ( this );
	DataBinding.prototype.onBindingRegister.call ( this );
	this._buildButtonBinding ();
	
	/*
	 * This may not always be enough, see below...
	 */
	this.propertyMethodMap [ "checked" ] = function ( isChecked ) {
		if ( isChecked != this.isChecked ) {
			this.setChecked ( isChecked, true );
		}
	};
	
	/*
	 * To ensure maximum synchronizity with the server,  
	 * we check for checkedness on ALL postback responses.
	 */
	this.propertyMethodMap [ "checksum" ] = function () {
		var isChecked = this.getProperty ( "ischecked" );
		if ( isChecked != this.isChecked ) {
			this.setChecked ( isChecked, true );
		}
	};
};

/**
 * @overloads {Binding#onBindingAttach}
 */
CheckBoxBinding.prototype.onBindingAttach = function () {
	
	CheckBoxBinding.superclass.onBindingAttach.call ( this );
	this.attachClassName ( Binding.CLASSNAME_CLEARFLOAT );
	
	this.bindingElement.tabIndex = 0;
	if ( Client.isExplorer ) {
		this.bindingElement.hideFocus = true;
	}
	
	this._buildDOMContent ();
}

/**
 * Unregister binding with the window-scope {@link DataManager}.
 * @overloads {Binding#onBindingDispose}
 */
CheckBoxBinding.prototype.onBindingDispose = function () {
	
	CheckBoxBinding.superclass.onBindingRegister.call ( this );
	DataBinding.prototype.onBindingDispose.call ( this );
}


/**
 * Build DOM content.
 */
CheckBoxBinding.prototype._buildDOMContent = RadioDataBinding.prototype._buildDOMContent;

/**
 * Makes the label active.
 * @implements {IEventListener}
 * @param {Event} e
 */
CheckBoxBinding.prototype.handleEvent = function ( e ) {

	CheckBoxBinding.superclass.handleEvent.call ( this, e );
	
	if ( e.type == DOMEvents.CLICK ) {
		var target = DOMEvents.getTarget ( e );
		switch( target ) {
			case this.shadowTree.labelText :
				this.setChecked ( !this.isChecked );
				break;
		}
	}
}

/**
 * Relate binding.
 */
CheckBoxBinding.prototype.relate = RadioDataBinding.prototype.relate;

/**
 * Listens for [space] keypress.
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
CheckBoxBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	CheckBoxBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		case BroadcastMessages.KEY_SPACE :
			this.setChecked ( !this.isChecked );
			break;
	}
}

/**
 * Build button.
 */
CheckBoxBinding.prototype._buildButtonBinding = function () {

	this._buttonBinding = this.add ( 
		CheckButtonBinding.newInstance ( this.bindingDocument )
	);
	
	/*
	 * Consume the button action. 
	 * Dispatch more specific action.
	 */
	var self = this;
	this._buttonBinding.addActionListener ( 
		ButtonBinding.ACTION_COMMAND, {
			handleAction : function ( action ) {
				action.consume ();
				self.dispatchAction ( 
					CheckBoxBinding.ACTION_COMMAND 
				);
			}
		}
	);
	
	this._hack ();
	this._buttonBinding.attach ();
	
	if ( this.getProperty ( "ischecked" )) {
		this.check ( true );
	}
}

/**
 * Shameful hack, all because of Explorers CSS rendering challanges.
 */
CheckBoxBinding.prototype._hack = function () {

	var self = this;
	var callbackid = this.getCallBackID ();
	
	this._buttonBinding.check = function ( isDisableCommand ) {
		ButtonBinding.prototype.check.call ( this, isDisableCommand );
		self.setProperty ( "ischecked", true );
		self.isChecked = true;
		self.relate ();
		if ( !isDisableCommand ) {
			self.focus ();
		}
	};
	
	this._buttonBinding.uncheck = function ( isDisableCommand ) {
		ButtonBinding.prototype.uncheck.call ( this, isDisableCommand );
		self.setProperty ( "ischecked", false );
		self.isChecked = false;
		self.relate ();
	};

	this._buttonBinding.oncommand = function () {
		self.isChecked = this.isChecked;
		self.focus ();
		self.relate ();
		if ( self.oncommand ) {
			self.oncommand ();
		}
		self.dirty ();
		if ( callbackid != null ) {
			self.dispatchAction ( PageBinding.ACTION_DOPOSTBACK );
		}
	};
}

/**
 * @param {boolean} isChecked
 * @param {boolean} isDisableCommand Optional.
 */
CheckBoxBinding.prototype.setChecked = RadioDataBinding.prototype.setChecked;

/**
 * @param {boolean} isDisableCommand Optional.
 */
CheckBoxBinding.prototype.check = RadioDataBinding.prototype.check

/**
 * @param {boolean} isDisableCommand Optional.
 */
CheckBoxBinding.prototype.uncheck = RadioDataBinding.prototype.uncheck

/**
 * Build label.
 */
CheckBoxBinding.prototype._buildLabelText = RadioDataBinding.prototype._buildLabelText;

/**
 * Set label. 
 * @param {string} label
 */
CheckBoxBinding.prototype.setLabel = RadioDataBinding.prototype.setLabel;

/**
 * @implements {IEventListener}
 * @param {MouseEvent} e
 *
CheckBoxBinding.prototype.handleEvent = RadioDataBinding.prototype.handleEvent;
*/


// IMPLEMENT IDATA ...................................................................

/**
 * Set name. The name property is registered with the window-scope  
 * {@link DocumentManager} for easy retrieval in other contexts.
 * @param {string} name
 */
CheckBoxBinding.prototype.setName = DataBinding.prototype.setName;

/**
 * Get name.
 * @implements {IData}
 * @return {string}
 */
CheckBoxBinding.prototype.getName = DataBinding.prototype.getName;

/**
 * Set dirty flag.
 * @implements {IData}
 */
CheckBoxBinding.prototype.dirty = DataBinding.prototype.dirty;

/**
 * Reset dirty flag.
 * @implements {IData}
 */
CheckBoxBinding.prototype.clean = DataBinding.prototype.clean;

/**
 * Focus.
 * @implements {IData}
 */
CheckBoxBinding.prototype.focus = function () {
	
	if ( !this.isFocused ) {
		DataBinding.prototype.focus.call ( this );
		if ( this.isFocused ) {
			FocusBinding.focusElement ( this.bindingElement );
			this.subscribe ( BroadcastMessages.KEY_SPACE );
		}
	}
}

/**
 * Blur.
 * @implements {IData}
 */
CheckBoxBinding.prototype.blur = function () {
	
	if ( this.isFocused ) {
		DataBinding.prototype.blur.call ( this );
		this.unsubscribe ( BroadcastMessages.KEY_SPACE );
	}
}

/**
 * Validate.
 * @implements {IData}
 * @return {boolean}
 */
CheckBoxBinding.prototype.validate = function () {
	
	var result = true;
	var parent = this.bindingElement.parentNode;

	if ( parent ) {
		var binding = UserInterface.getBinding ( parent );
		if ( binding && binding instanceof CheckBoxGroupBinding ) {
			if ( binding.isRequired ) {
				if ( binding.isValid ) {
					result = binding.validate ();
				} else {
					result = false;
				}
			}
		}
	}
	return result
}

/**
 * Manifest. This will write form elements into page DOM 
 * so that the server recieves something on form submit.
 * @implements {IData}
 */
CheckBoxBinding.prototype.manifest = function () {
	
	if ( this.isAttached ) {
		switch ( this.isChecked ) {
			case true :
				if ( !this.shadowTree.input ) {
					var input = DOMUtil.createElementNS ( 
						Constants.NS_XHTML, "input", this.bindingDocument
					);
					input.type = "hidden";
					input.name = this._name;
					input.style.display = "none";
					this.bindingElement.appendChild ( input );
					this.shadowTree.input = input;
				}
				this.shadowTree.input.value = this.getValue ();
				break;
			case false :
				if ( this.shadowTree.input ) {
					this.bindingElement.removeChild ( this.shadowTree.input );
					this.shadowTree.input = null;
				}
				break;
		}
	}
}

/**
 * Get value. This is intended for serverside processing.
 * @implements {IData}
 * @return {string}
 */
CheckBoxBinding.prototype.getValue = function () {
	
	var result = null;
	var value = this.getProperty ( "value" );
	if ( this.isChecked ) {
		result = value ? value : "on";
	}
	return result;
}

/**
 * Set value.
 * @implements {IData}
 * @param {string} value
 */
CheckBoxBinding.prototype.setValue = function ( value ) {
	
	if ( value == this.getValue () || value == "on" ) {
		this.check ( true );
	} else if ( value != "on" ) {
		this.setPropety ( "value", value );
	}
}

/**
 * Get result. This is intended for clientside processing. 
 * If a result is set, it will return false or result. 
 * If not, it will return false or true.
 * @implements {IData}
 * @return {object}
 */
CheckBoxBinding.prototype.getResult = function () {
	
	var result = false;
	if ( this.isChecked ) {
		result = this._result != null ? this._result : true;
	}
	return result;
}

/**
 * Set result.
 * @implements {IData}
 * @param {object} object
 */
CheckBoxBinding.prototype.setResult = function ( object ) {
	
	if ( typeof object == "boolean" ) {
		this.setChecked ( object, true );
	} else {
		this._result = object;
	}
}

/**
 * CheckBoxBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {CheckBoxBinding}
 */
CheckBoxBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:checkbox", ownerDocument );
	return UserInterface.registerBinding ( element, CheckBoxBinding );
}

CheckBoxGroupBinding.prototype = new Binding;
CheckBoxGroupBinding.prototype.constructor = CheckBoxGroupBinding;
CheckBoxGroupBinding.superclass = Binding.prototype;

/**
 * @class
 */
function CheckBoxGroupBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "CheckBoxGroupBinding" );
	
	/**
	 * @type {boolean}
	 */
	this.isRequired = false;
	
	/**
	 * @type {boolean}
	 */
	this.isValid = true;
}

/**
 * Identifies binding.
 */
CheckBoxGroupBinding.prototype.toString = function () {
	
	return "[CheckBoxGroupBinding]";
}

/**
 * Identifies binding.
 */
CheckBoxGroupBinding.prototype.onBindingAttach = function () {
	
	CheckBoxGroupBinding.superclass.onBindingAttach.call ( this );
	this.isRequired = this.getProperty ( "required" ) == true;
}

/**
 * @return {boolean}
 */
CheckBoxGroupBinding.prototype.validate = function () {
	
	var result = true;
	if ( this.isRequired ) {
		var checkboxes = this.getDescendantBindingsByLocalName ( "checkbox" );
		if ( checkboxes.hasEntries ()) {
			result = false;
			while ( checkboxes.hasNext () && !result ) {
				if ( checkboxes.getNext ().isChecked ) {
					result = true;
				}
			}
		}
		if ( result == false ) {
			this._showWarning ( true );
			this.dispatchAction ( Binding.ACTION_INVALID );
			this.addActionListener ( CheckBoxBinding.ACTION_COMMAND );
		}
	}
	return result;
}

/**
 * Show or hide warning.
 * @param {boolean} isShow
 */
CheckBoxGroupBinding.prototype._showWarning = function ( isShow ) {
	
	if ( isShow ) {
		if ( !this._labelBinding ) {
			var labelBinding = LabelBinding.newInstance ( this.bindingDocument );
			labelBinding.attachClassName ( "invalid" );
			labelBinding.setImage ( "${icon:error}" );
			labelBinding.setLabel ( "Selection required" );
			this._labelBinding = this.addFirst ( labelBinding );
			this._labelBinding.attach ();
		}
	} else if ( this._labelBinding ) {
		this._labelBinding.dispose ();
		this._labelBinding = null;
	}
}

/**
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
CheckBoxGroupBinding.prototype.handleAction = function ( action ) {
	
	CheckBoxGroupBinding.superclass.handleAction.call ( this, action );
	
	switch ( action.type ) {
		case CheckBoxBinding.ACTION_COMMAND :
			this._showWarning ( false );
			this.dispatchAction ( Binding.ACTION_VALID );
			this.removeActionListener ( CheckBoxBinding.ACTION_COMMAND );
			break;
	}
}

/**
 * CheckBoxGroupBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {CheckBoxGroupBinding}
 */
CheckBoxGroupBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:checkboxgroup", ownerDocument );
	return UserInterface.registerBinding ( element, CheckBoxGroupBinding );
}

BalloonSetBinding.prototype = new Binding;
BalloonSetBinding.prototype.constructor = BalloonSetBinding;
BalloonSetBinding.superclass = Binding.prototype;

/**
 * @class
 */
function BalloonSetBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "BalloonSetBinding" );
}

/**
 * Identifies binding.
 */
BalloonSetBinding.prototype.toString = function () {
	
	return "[BalloonSetBinding]";
}

BalloonBinding.prototype = new MatrixBinding;
BalloonBinding.prototype.constructor = BalloonBinding;
BalloonBinding.superclass = MatrixBinding.prototype;

/**
 * Time before each position update in milliseconds. 
 * Also the timeout before balloon is shown, for some reason.
 */
BalloonBinding.TIMEOUT = parseInt ( 200 );

/*
 * Position offsets. Attempting to place 
 * the balloon elegantly relative to binding.
 */
BalloonBinding.OFFSET_X =  parseInt ( 14 );
BalloonBinding.OFFSET_Y =  parseInt ( 6 );

/*
 * 
 */
BalloonBinding.ACTION_SNAP = "balloon snap";

/**
 * Classname attached to a left hand balloon.
 */
BalloonBinding.CLASSNAME_LEFT = "left";

/**
 * Used to locate an appropriate balloon environment. 
 * TODO: Design para-frame binding type locator? For now, 
 * environments need to be made aware of the BallonBinding.
 */
BalloonBinding.ACTION_INITIALIZE = "ballon initialize";

/**
 * @class
 */
function BalloonBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "BalloonBinding" );
	
	/**
	 * We snap to this binding.
	 * @type {IData}
	 */
	this._snapTargetBinding = null;
	
	/**
	 * We nondisplay the balloon when outside the boundaries of this binding. 
	 * Typically a DockBinding, a DialogBinding or a ScrollBoxBinding.
	 * @type {Binding}
	 */
	this._environmentBinding = null;

	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
BalloonBinding.prototype.toString = function () {
	
	return "[BalloonBinding]";
}

/**
 * Note that the binding is *invisible* when created!
 * @see {BalloonBinding#newInstance}
 * @overloads {MatrixBinding#onBindintAttach}
 */
BalloonBinding.prototype.onBindingAttach = function () {
	
	BalloonBinding.superclass.onBindingAttach.call ( this );
	
	this.addActionListener ( Binding.ACTION_ACTIVATED );
	this.addActionListener ( ControlBinding.ACTION_COMMAND );
	
	/*
	 * Build close button.
	 */
	this._controlGroupBinding = this.add (
		ControlGroupBinding.newInstance ( this.bindingDocument ) 
	);
	var controlBinding = DialogControlBinding.newInstance ( this.bindingDocument );
	controlBinding.setControlType ( ControlBinding.TYPE_CLOSE );
	this._controlGroupBinding.add ( controlBinding );
	this._controlGroupBinding.attachRecursive ();
	
	/*
	 * Build speak elements.
	 */
	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:balloonspeak", this.bindingDocument );
	this.bindingElement.appendChild ( element );
	
	var label = this.getLabel ();
	if ( label != null ) {
		this.setLabel ( label );
	}
}

/**
 * @overloads {Binding#onBindintAttach}
 */
BalloonBinding.prototype.onBindingDispose = function () {
	
	BalloonBinding.superclass.onBindingDispose.call ( this );
	
	if ( this._updateInterval ) {
		window.clearInterval ( this._updateInterval );
		this._updateInterval = null;
	}
	
	var binding = this._snapTargetBinding;
	if ( Binding.exists ( binding ) == true ) {
		binding.removeActionListener ( Binding.ACTION_BLURRED, this );
		binding.removeActionListener ( Binding.ACTION_VALID, this );
	}
}

/**
 * Snap to databinding.
 * @param {IData} binding
 */
BalloonBinding.prototype.snapTo = function ( binding ) {
	
	if ( Interfaces.isImplemented ( IData, binding )) {
		
		this._snapTargetBinding = binding;
		
		var action = binding.dispatchAction ( BalloonBinding.ACTION_INITIALIZE );
		if ( action && action.isConsumed ) {
			this._environmentBinding = action.listener;
		}
		if ( this._environmentBinding ) {
			
			binding.addActionListener ( Binding.ACTION_BLURRED, this );
			binding.addActionListener ( Binding.ACTION_VALID, this );
			this.subscribe ( BroadcastMessages.VIEW_CLOSED );
		
			/*
			 * Position and update on timed interval.
			 * TODO: why is the position wrong if we invoke _updatePosition now?
			 */
			var self = this;
			this._updateInterval = window.setInterval ( function () {
				if ( Binding.exists ( binding ) == true ) {
					self._updatePosition ();
				} else {
					self.dispose ();
				}
			}, BalloonBinding.TIMEOUT );
			
			/*
			 * Note that the target, not the balloon, 
			 * is dispatching this action...
			 */
			binding.dispatchAction ( BalloonBinding.ACTION_SNAP );
			
		} else {
			throw "No environment fit for balloons!";
		}
	}
}

/**
 * @param {Point} point
 */
BalloonBinding.prototype._updatePosition = function () {
	
	var target = this._snapTargetBinding;
	var environment = this._environmentBinding;
	var root = UserInterface.getBinding ( target.bindingDocument.body );
	
	if ( Binding.exists ( target ) && Binding.exists ( environment )) {
		
		if ( !root.isActivated ) {
			if ( this.isVisible == true ) {
				this.hide ();
			}
		} else if ( target.isAttached && environment.isAttached ) {
		
			var tPoint = target.boxObject.getUniversalPosition ();
			var ePoint = environment.boxObject.getUniversalPosition ();
			
			ePoint.y += environment.bindingElement.scrollTop;
			ePoint.x += environment.bindingElement.scrollLeft;
			
			var tDim = target.boxObject.getDimension ();
			var eDim = environment.boxObject.getDimension ();
			
			/*
			 * Calculations to undispay balloon if target is not 
			 * visible within the boudaries of the environment.
			 */
			var isAbort = false;	
			if ( tPoint.y + tDim.h < ePoint.y ) {
				isAbort = true;
			} else if ( tPoint.x + tDim.w < ePoint.x ) {
				isAbort = true;
			} else if ( tPoint.y > ePoint.y + eDim.h ) {
				isAbort = true;
			} else if ( tPoint.x > ePoint.x + eDim.w ) {
				isAbort = true;
			}
			
			if ( !isAbort ) {
				this._setComputedPosition ( tPoint, ePoint, tDim, eDim );
				if ( !this.isVisible ) {
					this.show ();
				}
			} else if ( this.isVisible == true ) {
				this.hide ();
			}
		}
	} else {
		this.dispose ();
	}
}

/**
 * Compute position so that balloon is always visible.
 * @param {Point} tPoint
 * @param {Point} ePoint
 * @param {Dimension} tDim
 * @param {Dimension} eDim
 */
BalloonBinding.prototype._setComputedPosition = function ( tPoint, ePoint, tDim, eDim ) {
	
	var wDim = WindowManager.getWindowDimensions ();
	var bDim = this._getDimension ();
	var point = tPoint;
	var isLeft = false;
	
	/*
	 * Display balloon on the left side?
	 */
	if ( tPoint.x + tDim.w + bDim.w + BalloonBinding.OFFSET_X >= wDim.w ) { // ballon outside app window?
		isLeft = true;
	} else if ( tPoint.x + tDim.w >= ePoint.x + eDim.w ) { // target cut by environment box (on the right side)?
		isLeft = true;
	}
	
	if ( isLeft ) {
		point.x -= ( bDim.w + BalloonBinding.OFFSET_X );
		this.attachClassName ( BalloonBinding.CLASSNAME_LEFT );
	} else {
		point.x += tDim.w + BalloonBinding.OFFSET_X;
	 	this.detachClassName ( BalloonBinding.CLASSNAME_LEFT );
	}
	
	/*
	 * Make the balloon appear above the target. 
	 */
	point.y -= ( bDim.h );
	point.y += BalloonBinding.OFFSET_Y;
	
	this._setPosition ( point );
}

/**
 * Dispose the balloon when associated view closes and 
 * whenever a new view is opened (otherwise the balloon 
 * may block the opened view). 
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
BalloonBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	BalloonBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
	
		/*
		 * If our view closed, close the balloon now.
		 * Don't wait for interval to find out.
		 */
		case BroadcastMessages.VIEW_CLOSED :
			if ( this._isAssociatedView ( arg ) == true ) {
				this.dispose ();
			}
			break;
	}
}

/**
 * Does a ViewBinding with a certain handle contain my snaptarget Binding?
 * @param {string} handle
 * @return {boolean}
 */
BalloonBinding.prototype._isAssociatedView = function ( handle ) {
	
	var result = false;
	if ( this._snapTargetBinding ) {
		var view = this._snapTargetBinding.getAncestorBindingByType ( ViewBinding, true );
		if ( view && view.getHandle () == handle ) {
			result = true;
		}
	}
	return result;
}

/**
 * Set position. This has been fitted with a mechanism that 
 * doesn't update the position while CSS transforms are running.
 * @param {Point} point
 */
BalloonBinding.prototype._setPosition = function ( point ) {
	
	var isAbort = false;
	var pos = this.boxObject.getLocalPosition ();
	if ( this._point != null ) {
		if ( pos.x != this._point.x || pos.y != this._point.y ) {
			isAbort = true;
		}   
	}
	if ( !isAbort ) {
		this.bindingElement.style.left = point.x + "px";
		this.bindingElement.style.top = point.y + "px";
		this._point = point;
	}
}

/**
 * @return {Point}
 */
BalloonBinding.prototype._getPosition = function () {
	
	return new Point ( 
		this.bindingElement.offsetLeft,
		this.bindingElement.offsetTop
	);
}
 
 /**
 * @return {Dimension}
 */
BalloonBinding.prototype._getDimension = function () {
	
	return new Dimension ( 
		this.bindingElement.offsetWidth,
		this.bindingElement.offsetHeight
	);
}

/** 
 * Cannot use "display" property because we need to compute on width and height.
 * @overwrites {Binding#hide}
 */
BalloonBinding.prototype.hide = function () {
	
	if ( this.isVisible ) {
		this.bindingElement.style.visibility = "hidden";
		this.isVisible = false;
	}
}

/**
 * @overwrites {Binding#show}
 */
BalloonBinding.prototype.show = function () {
	
	if ( !this.isVisible ) {
		this.bindingElement.style.visibility = "visible";
		this.isVisible = true;
	}
}

/**
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
BalloonBinding.prototype.handleAction = function ( action ) {
	
	BalloonBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	
	switch ( action.type ) {
	
		case Binding.ACTION_ACTIVATED :
			if ( this._snapTargetBinding ) {
				this._snapTargetBinding.dispatchAction ( 
					Binding.ACTION_ACTIVATED 
				);
				action.consume ();
			}
	
		/**
		 * Note that the binding may be blurred when the server (not the  
		 * client) deems it invalid. In that case, a dialog may be opened,  
		 * blurring the binding, but the call to method validate will 
		 * still return true (because only the server knows for sure). 
		 * In that case, we have to make sure not to dispose the balloon.
		 */
		case Binding.ACTION_BLURRED :
		case Binding.ACTION_VALID :	
			if ( binding == this._snapTargetBinding ) {
				var self = this;
				setTimeout ( function () {
					if ( !Binding.exists ( binding )) {
						self.dispose ();
					} else if ( binding.validate ()) {
						var isDispose = true;
						if ( action.type == Binding.ACTION_BLURRED ) {
							var root = binding.bindingDocument.body;
							var bind = UserInterface.getBinding ( root );
							if ( !root.isActivated ) { // dialog was opened
								isDispose = false;
							}
						}
						if ( isDispose ) {
							self.dispose ();
						}
					}
				}, 0 );
			}
			break;
			
		case ControlBinding.ACTION_COMMAND :
			this.dispose ();
			break;
	}
}

/** 
 * Set label
 * @param {string} label
 */
BalloonBinding.prototype.setLabel = function ( label ) {
	
	if ( this.isAttached == true ) {
		if ( !this._isTableIndexed ) {
			this._indexTable ();
		}
		var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:balloontext", this.bindingDocument );
		var text = this.bindingDocument.createTextNode ( label );
		element.appendChild ( text );
		this.shadowTree [ MatrixBinding.CENTER ].appendChild ( element );
	}
	this.setProperty ( "label", label );
}

/** 
 * Get label.
 * @return {string}
 */
BalloonBinding.prototype.getLabel = function () {
	
	return this.getProperty ( "label" );
}

/**
 * BalloonBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {BalloonBinding}
 */
BalloonBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:balloon", ownerDocument );
	var binding = UserInterface.registerBinding ( element, BalloonBinding );
	binding.hide ();
	return binding;
}

ErrorBinding.prototype = new Binding;
ErrorBinding.prototype.constructor = ErrorBinding;
ErrorBinding.superclass = Binding.prototype;

ErrorBinding.ACTION_INITIALIZE = "error initialize";

/**
 * Display error in BalloonBinding somewhere near a DataBinding.
 * @param {object} error A simple object with one property "text" (for now).
 * @param {IData} binding
 */
ErrorBinding.presentError = function ( error, binding ) {
	
	if ( Interfaces.isImplemented ( IData, binding ) == true ) {
		
		/*
		 * Analyze environment in order to determine whether or not we are 
		 * in a dialog, in which case another BalloonSetBinding is used.
		 * TODO: refactor with getAncestorBindingByType ( xxx, true )???
		 */
		var isDialog, action = binding.dispatchAction ( ErrorBinding.ACTION_INITIALIZE );
		if ( action && action.isConsumed ) {
			switch ( action.listener.constructor ) {
				case StageBinding :
					isDialog = false;
					break;
				case StageDialogBinding :
					isDialog = true;
					break;
			}
		}
		var balloonset = isDialog ? 
			top.app.bindingMap.dialogballoonset : 
			top.app.bindingMap.balloonset;
		var balloon = balloonset.add (
			BalloonBinding.newInstance ( top.app.document )
		);
		balloon.setLabel ( error.text );
		balloon.snapTo ( binding );
		balloon.attach ();
	}
}

/**
 * @class
 */
function ErrorBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ErrorBinding" );
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
ErrorBinding.prototype.toString = function () {
	
	return "[ErrorBinding]";
}

/**
 * Notice that the binding disposes as soon as it attaches.
 * @overloads {Binding#onBindingAttach}
 */
ErrorBinding.prototype.onBindingAttach = function () {
	
	ErrorBinding.superclass.onBindingAttach.call ( this );
	
	var dataManager = this.bindingWindow.DataManager;
	var text = this.getProperty ( "text" );
	var name = this.getProperty ( "targetname" );
	
	var binding = dataManager.getDataBinding ( name );
	if ( binding ) {
		ErrorBinding.presentError ({
			text : text
		}, binding );
	} else {
		alert ( "ErrorBinding dysfunction: No such DataBinding!\n" + name );
		if ( name.indexOf ( "_" ) >-1 ) {
			alert ( "Name contaings '_' - replace with '$' ?" );
		}
	}
	this.dispose ();
}

FocusBinding.prototype = new FlexBoxBinding;
FocusBinding.prototype.constructor = FocusBinding;
FocusBinding.superclass = FlexBoxBinding.prototype;

/**
 * This property is set to true on the currently focused binding. 
 * TODO: Why was this exactly?
 * @type {string}
 */
FocusBinding.MARKER = "focusbindingcurrentfocus";

/**
 * @see {DockBinding}
 * @see {DialogBinding} TODO!
 */
FocusBinding.ACTION_ACTIVATED = "focusmanager activated";
FocusBinding.ACTION_ATTACHED = "focusmanager attached";
FocusBinding.ACTION_UPDATE = "focusmanager update required";
FocusBinding.ACTION_FOCUS = "focusmanager focus";
FocusBinding.ACTION_BLUR = "focusmanager blur";

/**
 * Since explorer doesn't react kindly to invisible or hidden 
 * elements recieving the focus, better relay through here. 
 * This will ensure some public damage control, but still 
 * log an exception.
 * @param {DOMElement} element
 * @return {boolean} True on successful focus
 */
FocusBinding.focusElement = function ( element ) {
	
	var isSuccess = true;
	
	try {
		element.focus ();
		Application.focused ( true );
	} catch ( exception ) {
		var binding = UserInterface.getBinding ( element );
		var logger = SystemLogger.getLogger ( "FocusBinding.focusElement" );
		logger.warn ( "Could not focus " + ( binding ? binding.toString () : String ( element )));
		isSuccess = false;
	}
	return isSuccess;
}

/**
 * @type {IFocus}
 */
FocusBinding.focusedBinding = null;

/**
 * @type {FocusBinding}
 */
FocusBinding.activeInstance = null;

/**
 * Because DOT NET will kill bindings spontaneously, we keep references
 * to focused bindings based on contextwindows and IDs. 
 * @param {IFocusable} binding 
 * @return {object} An object with a single method to extract the binding.
 */
FocusBinding.getCachedFocus = function ( binding ) {
	
	var win = binding.bindingWindow;
	var id = binding.bindingElement.id;
	
	return {
		getBinding : function () {
			var result = null;
			try {
				if ( Binding.exists ( binding )) {
					result = win.bindingMap [ id ]; // TODO: AVOID BINDINGMAP!
				}
			} catch ( exception ) {
				// explorer may still puke on this!
			}
			return result;
		}
	}
}

/**
 * Navigate next.
 * @param {boolean} isReverse
 */
FocusBinding.navigateNext = function ( isReverse ) {
	
	if ( Binding.exists ( FocusBinding.activeInstance )) {
		FocusBinding.activeInstance.focusNext ( isReverse );
	}
}

/**
 * Navigate previous.
 */
FocusBinding.navigatePrevious = function () {
	
	FocusBinding.navigateNext ( true );
}

/**
 * @class
 */
function FocusBinding () {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "FocusManangerBinding" );
	
	/**
	 * @type {List<IFocusable>}
	 */
	this._focusableList = null;

	/**
	 * @type {boolean}
	 */
	this._isUpToDate = false;
	
	/**
	 * If ancestor FocusBinding claims to be a (strong) focus manager, 
	 * this will be set to false. In that case, you may stop reading here, 
	 * none of the methods below will be invoked.
	 * @type {boolean}
	 */
	this._isFocusManager = true;
	
	/** 
	 * If set to false, descendant FocusBinding instances may construct 
	 * local focus zones. This is exactly the case for the top PageBinding 
	 * and the StageBinding. And that is probably how it should stay.
	 * @type {boolean}
	 */
	this.isStrongFocusManager = true;
	
	/**
	 * @type {object}
	 */
	this._cachedFocus = null;
	 
	/**
	 * Note that flexibility is negated by default. Actually we only 
	 * need to subclass FlexBoxBinding around here because IE6 doesn't 
	 * support CSS min-height; this causes trouble inside dialogs.
	 * @overwrites {FlexBoxBinding#isFlexible}
	 */
	this.isFlexible = false;
	
	/* 
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
FocusBinding.prototype.toString = function () {
	
	return "[FocusManangerBinding]";
}

/**
 * @overloads {Binding#onBindingAttach}
 */
FocusBinding.prototype.onBindingAttach = function () {
	
	if ( this.getProperty ( "focusmanager" ) == false ) {
		this._isFocusManager = false;
	} else {
		if ( this.getProperty ( "strongfocusmanager" ) == false ) {
			this.isStrongFocusManager = false;
		}
		if ( this._isFocusManager ) {
			var action = this.dispatchAction ( FocusBinding.ACTION_ATTACHED );	
			if ( action && action.isConsumed ) {
				if ( action.listener.isStrongFocusManager ) {
					this._isFocusManager = false;
				}
			}
			if ( this._isFocusManager ) {
				this.addActionListener ( Binding.ACTION_ACTIVATED );
				this.addActionListener ( Binding.ACTION_FOCUSED );
				this.addActionListener ( Binding.ACTION_BLURRED );
				this.addActionListener ( FocusBinding.ACTION_UPDATE );
				this.addActionListener ( FocusBinding.ACTION_FOCUS );
				this.addActionListener ( FocusBinding.ACTION_BLUR );
				//this.addActionListener ( UpdatePanelBinding.ACTION_UPDATED );
				this.addActionListener ( FocusBinding.ACTION_ATTACHED );
			}
		}
	}	
	FocusBinding.superclass.onBindingAttach.call ( this );
}

/**
 * @overloads {Binding#onBindingDispose}
 */
FocusBinding.prototype.onBindingDispose = function () {
	
	FocusBinding.superclass.onBindingDispose.call ( this );
	if ( FocusBinding.activeInstance == this ) {
		FocusBinding.activeInstance = null;
	}
}

/**
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
FocusBinding.prototype.handleAction = function ( action ) {

	FocusBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	var crawler = null;
	
	if ( this._isFocusManager ) {
		
		switch ( action.type ) {
		
			case FocusBinding.ACTION_ATTACHED :
				
				if ( binding != this ) {
					this._isUpToDate = false;
				}
				action.consume (); // by consuming this, we dictate the "strength" of descendant focusbinding. 
				break;
			
			case FocusBinding.ACTION_UPDATE :
				
				if ( binding != this ) {
					this._isUpToDate = false;
					action.consume ();
				}
				break;
				
			case FocusBinding.ACTION_BLUR :
				
				if ( Application.isOperational ) {
					
					crawler = new FocusCrawler ();
					crawler.mode = FocusCrawler.MODE_BLUR;
					crawler.crawl ( binding.bindingElement );
					
					/*
					 * Otherwise a hidden field (in a hidden 
					 * deck) could be refocused onActivate. 
					 * TODO: only if filter actually blurred something (?)
					 */
					if ( this._cachedFocus != null ) {
						this._cachedFocus = null;
					}
				}
				action.consume ();
				break;
				
			case FocusBinding.ACTION_FOCUS :
				
				if ( Application.isOperational && binding != this ) {
					
					crawler = new FocusCrawler ();
					crawler.mode = FocusCrawler.MODE_FOCUS;
					crawler.crawl ( binding.bindingElement );
				}
				action.consume ();
				break;
				
			case Binding.ACTION_FOCUSED :
				
				if ( Interfaces.isImplemented ( IFocusable, binding )) {
					this.claimFocus ();
					this._onFocusableFocused ( binding );
				}
				action.consume ();
				break;
				
			case Binding.ACTION_BLURRED :
				
				if (  Interfaces.isImplemented ( IFocusable, binding )) {
					this._onFocusableBlurred ( binding );
				}
				action.consume ();
				break;
				
			/*
			case UpdatePanelBinding.ACTION_UPDATED :
				
				/* 
				 * TODO: Re-enable this stuff! 
				 * TODO: don't speculate on FocusBinding.focusedBinding
				 * TODO: support descendant WindowBindings
				 *
				if ( !FocusBinding.focusedBinding ) {
					if ( this._cachedFocus ) {
						var binding = this._cachedFocus.getBinding ();
						if ( binding && !binding.isFocused ) {
							binding.focus ();
						}
					}
				}
				action.consume (); // probably no need to propagate this furhter...
				break;
			*/
		}
	}
}

/**
 * Move focus to next {@link IFocusable} binding. If the last focused 
 * binding has lost it's focus for some reason, focus this instead.
 * @param {boolean} isReverse
 */
FocusBinding.prototype.focusNext = function ( isReverse ) {
	
	var focused = null;
	var list = this._getFocusableList ();
	
	if ( list.reset ().hasEntries ()) {
	
		while ( focused == null && list.hasNext ()) {
			var binding = list.getNext ();
			if ( this._cachedFocus && binding == this._cachedFocus.getBinding ()) {
				focused = binding;
			}
		}
		if ( focused != null ) {
			if ( binding.isFocused ) {
				var next = isReverse ? 
					list.getPreceding ( focused ) :
					list.getFollowing ( focused );
				if ( !next ) {
					next = isReverse ?
						list.getLast () :
						list.getFirst ();
				}
				next.focus ();
			} else {
				focused.focus ();
			}
		} else {
			list.getFirst ().focus ();
		}
	}
}

/**
 * Claim focus!
 */
FocusBinding.prototype.claimFocus = function () {
	
	FocusBinding.activeInstance = this;
}

/**
 * Build list and return it.
 * @return {List<IFocusable>}
 */
FocusBinding.prototype._getFocusableList = function () {
	
	// TODO: overwrite StageBinding!
	
	if ( !this._isUpToDate ) {
		
		var crawler = new FocusCrawler ();
		var list = new List ();
		
		crawler.mode = FocusCrawler.MODE_INDEX;
		crawler.crawl ( this.bindingElement, list );
		
		this._focusableList = list;
		this._isUpToDate = true;
	}
	
	return this._focusableList;
}

/**
 * Focus first focusable *if* our activatable is active!
 * TODO: move this check somewhere else?
 */
FocusBinding.prototype._focusFirstFocusable = function () {
	
	if ( this._isFocusManager && this.isActivated ) {
		
		/*
		 * For some strange reason, Explorer has lost 
		 * the ability to focus inputs reliably unless 
		 * focus was moved to something else first...
		 */
		try {
			var win = this.bindingWindow; 
			win.focus (); // this seems to fix it!
		} catch ( exception ) {
			// Explorer can always find an exception for the focus event...
		}
		var list = this._getFocusableList ();
		
		if ( list != null ) {
			if ( list.hasEntries ()) {
				list.getFirst ().focus ();
			}
		} else {
			this.logger.warn ( "Could not compute focusable list." );
		}
	}
}

/**
 * Focus previously focused focusable binding. 
 * Now say it three times really fast.
 */
FocusBinding.prototype._focusPreviouslyFocused = function () {
	
	/*
	 * Locate last focused binding.
	 */
	if ( this._cachedFocus ) {
		var binding = this._cachedFocus.getBinding ();
		if ( binding && !binding.isFocused ) {
			binding.focus ();
		}
	}
}

/**
 * On focusable focused.
 * @param {IFocusable} binding
 */
FocusBinding.prototype._onFocusableFocused = function ( binding ) {

	if ( binding != FocusBinding.focusedBinding ) {
		if ( FocusBinding.focusedBinding != null ) {
			if ( Binding.exists ( FocusBinding.focusedBinding )) {
				FocusBinding.focusedBinding.blur ();
			}
		}
		FocusBinding.focusedBinding = binding;
		binding.setProperty ( FocusBinding.MARKER, true );
		
		this._cachedFocus = FocusBinding.getCachedFocus ( binding );
	}
}

/**
 * On focusable blurred.
 * @param {IFocusable} binding
 */
FocusBinding.prototype._onFocusableBlurred = function ( binding ) {
	
	binding.deleteProperty ( FocusBinding.MARKER );
	if ( binding == FocusBinding.focusedBinding ) {
		FocusBinding.focusedBinding = null;
	}
}

TabsButtonBinding.prototype = new ButtonBinding;
TabsButtonBinding.prototype.constructor = TabsButtonBinding;
TabsButtonBinding.superclass = ButtonBinding.prototype;
TabsButtonBinding.RESERVED_SPACE = 36;
TabsButtonBinding.NODENAME_TABBOX = "tabbox";

TabsButtonBinding.CHAR_INDICATOR = String.fromCharCode ( 187 ); // "»".charCodeAt ( 0 )

function TabsButtonBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "TabsButtonBinding" );
	
	/**
	 * @type {List}
	 */
	this.hiddenTabBindings = null;
	
	/**
	 * @type {List}
	 * @private
	 */
	this.menuItemBindings = null;
	
	/**
	 * @type {TabBoxBinding}
	 * @private
	 */
	this.containingTabBoxBinding = null;
	
	/**
	 * @type {TabBinding}
	 */
	this.selectedTabBinding = null;
	
	/**
	 * @type {boolean}
	 */
	this.isVisible = false;
	
	/**
	 * @type {int}
	 */
	this.snapshotWindowWidth = null;
}

/**
 * Identifies binding.
 */
TabsButtonBinding.prototype.toString = function () {

	return "[TabsButtonBinding]";
}

/**
 * Overloads {ButtonBinding#onBindingRegister}
 */
TabsButtonBinding.prototype.onBindingRegister = function () {
	
	TabsButtonBinding.superclass.onBindingRegister.call ( this );
	this.hiddenTabBindings = new List ();
	this.menuItemBindings = new List ();
}

/**
 * Build DOM content.
 */
TabsButtonBinding.prototype.buildDOMContent = function () {

	TabsButtonBinding.superclass.buildDOMContent.call ( this );

	this.containingTabBoxBinding = this.getAncestorBindingByLocalName ( this.constructor.NODENAME_TABBOX );
	//this.addActionListener ( ButtonBinding.ACTION_COMMAND, this );
	
	var span = this.bindingDocument.createElement ( "span" );
	span.appendChild ( this.bindingDocument.createTextNode ( TabsButtonBinding.CHAR_INDICATOR ));
	span.className = "arrow";
	this.labelBinding.bindingElement.appendChild ( span );
}

/**
 * Show tabmanager. Automaticaly updates tabbutton tabcount.
 * @overwrites {Binding#show}
 * @param {int} xposition
 */
TabsButtonBinding.prototype.show = function ( xposition ) {

	this.bindingElement.style.left = xposition + "px";
	this.setLabel ( 
		this.hiddenTabBindings.getLength ().toString ()
	);
	TabsButtonBinding.superclass.show.call ( this );
}

/**
 * Hide the button while resizing window horizontally. 
 * TODO: find ud af det!
 * @implements {IResizeHandler}
 *
TabsButtonBinding.prototype.fireOnResize = function () {

	var width = this.bindingWindow.WindowManager.getWindowDimensions ().w;
	if ( this.isVisible && width != this.snapshotWindowWidth ) {
		this.hide ();
	}
	this.snapshotWindowWidth = width;
}
*/

/**
 * This method is invoked by the {@link TabsBinding}
 */
TabsButtonBinding.prototype.reset = function () {
	
	if ( this.menuItemBindings.hasEntries ()) {
		while ( this.menuItemBindings.hasNext ()) {
			this.menuItemBindings.getNext ().dispose ();
		}
	}
	this.hiddenTabBindings.clear ();
	this.menuItemBindings.clear ();
	this.selectedTabBinding = null;
	this.isPopulated = false;
}

/**
 * @param {TabBinding} tabBinding
 */
TabsButtonBinding.prototype.registerHiddenTabBinding = function ( tabBinding ) {

	this.hiddenTabBindings.add ( tabBinding );
}

/**
 * Overloads {ButtonBinding#fireCommand}
 */
TabsButtonBinding.prototype.fireCommand = function () {
	
	if ( this.isChecked && !this.isPopulated ) {	
		this.hiddenTabBindings.reset ();
		while ( this.hiddenTabBindings.hasNext ()) {
			var tabBinding = this.hiddenTabBindings.getNext ();
			var item = MenuItemBinding.newInstance ( 
				this.popupBinding.bindingDocument 
			);
			item.setLabel ( tabBinding.getLabel ());
			item.setImage ( tabBinding.getImage ());	
			item.associatedTabBinding = tabBinding;
			var self = this;
			item.oncommand = function () {
				self.selectedTabBinding = this.associatedTabBinding;
			}
			this.popupBinding.add ( item );
			this.menuItemBindings.add ( item );
			
			this.popupBinding.attachRecursive ();
		}
		this.isPopulated = true;
	}
	
	this.popupBinding.addActionListener ( PopupBinding.ACTION_HIDE, this );
	TabsButtonBinding.superclass.fireCommand.call ( this );
}

/**
 * Make the selected tabBinding visible!
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
TabsButtonBinding.prototype.handleAction = function ( action ) {

	TabsButtonBinding.superclass.handleAction.call ( this, action );
	
	switch ( action.type ) {
		case PopupBinding.ACTION_HIDE :
			this.popupBinding.removeActionListener ( PopupBinding.ACTION_HIDE, this );
			var tabBinding = this.selectedTabBinding;
			if ( tabBinding ) {
				this.containingTabBoxBinding.moveToOrdinalPosition ( tabBinding, 0 );
				this.containingTabBoxBinding.select ( tabBinding );
			}
			action.consume ();
			break;
	}
}

/**
 * TabsButtonBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {TabsButtonBinding}
 */
TabsButtonBinding.newInstance = function ( ownerDocument ) {

	var toolbarbutton = DOMUtil.createElementNS ( Constants.NS_UI, "ui:toolbarbutton", ownerDocument );
	toolbarbutton.setAttribute ( "type", "checkbox" );
	toolbarbutton.setAttribute ( "popup", "app.bindingMap.tabsbuttonpopup" );	
	toolbarbutton.className = "tabbutton";
	return UserInterface.registerBinding ( toolbarbutton, TabsButtonBinding );
}

TabBoxBinding.prototype = new FlexBoxBinding;
TabBoxBinding.prototype.constructor = TabBoxBinding;
TabBoxBinding.superclass = FlexBoxBinding.prototype;

TabBoxBinding.ASSOCIATION_KEY 	= "tabboxkey";

TabBoxBinding.ACTION_ATTACHED	= "tabbox attached";
TabBoxBinding.ACTION_SELECTED 	= "tabbox selected";
TabBoxBinding.ACTION_UNSELECTED = "tabbox unselected";
TabBoxBinding.ACTION_UPDATED 	= "tabbox updated";
TabBoxBinding.UPDATE_ORDINAL	= "tabbox ordinalupdate";
TabBoxBinding.UPDATE_ATTACH		= "tabbox attachupdate";
TabBoxBinding.UPDATE_DETACH		= "tabbox detachupdate";

TabBoxBinding.INVALID_TAB_IMAGE = "${icon:error}";
TabBoxBinding.BALLOON_TAB_IMAGE = "${icon:balloon}";

/**
 * Setup keyboard navigation: Advance tab selection on an inferred current  
 * tabbox by pressing CTRL + TAB and hold SHIFT to travel backwards. 
 * Any tabbox will register as current when: 
 *     The onBindingAttach method is invoked
 *     A descendant binding dispatches Binding.ACTION_ACTIVATED
 *     A descendant binding dispatches Binding.ACTION_FOCUSED 
 */
EventBroadcaster.subscribe ( BroadcastMessages.KEY_TAB, {
	handleBroadcast : function () {
		if ( Keyboard.isControlPressed ) {
			var current = TabBoxBinding.currentActiveInstance;
			if ( current != null && Binding.exists ( current )) {
				/*
				 * Disabled because Firefox may sometimes think that 
				 * the CONTROL key is pressed - when it's not. 
				 * Let's wait a few Firefox versions before enabling...
				 * 
				 * current.advanceSelection ( !Keyboard.isShiftPressed );
				 */
			}
		}
	}
});

/**
 * @type {TabBoxBinding}
 */
TabBoxBinding.currentActiveInstance = null;

/**
 * @class
 * Go get'em tabbox.
 * TODO: Rewrite this oldschool stuff entirely! Subclass DecksBinding.
 */
function TabBoxBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "TabBoxBinding" );

	/**
	 * @type {HashMap}
	 * @private
	 */
	this._tabBoxPairs = {};
	
	/**
	 * @type {DOMElement}
	 * @private
	 */
	this._selectedTabElement = null;
	
	/**
	 * @type {TabBinding}
	 * @private
	 */
	this._selectedTabBinding = null;
	
	/**
	 * @type {DOMElement}
	 */
	this._tabsElement = null;
	
	/**
	 * @type {DOMElement}
	 */
	this._tabPanelsElement = null;
	
	/**
	 * By default counting <tabs> and <tabpanels>.
	 * @type {int}
	 *
	this._totalMemberCount = 2;
	*/
	
	/**
	 * @type {int}
	 */
	this._attachedMemberCount = 0;
	
	/**
	 * @type {boolean}
	 */
	this._isMembersAttached = false;
	
	/**
	 * @type {boolean}
	 */
	this.isEqualSize = false;
	
	/*
	 * Prepare for tabboxes with completely different element names.
	 */
	this._nodename_tab = "tab";
	this._nodename_tabs = "tabs";
	this._nodename_tabpanel = "tabpanel";
	this._nodename_tabpanels = "tabpanels";
	
	/*
	 * Prepare for tabboxes with completely different binding constructors.
	 */
	this._impl_tab = TabBinding;
	this._impl_tabs = TabsBinding;
	this._impl_tabpanel = TabPanelBinding;
	this._impl_tabpanels = TabPanelsBinding;
	
	/*
	 * When the ACTION_UPDATE action is dispatched, 
	 * this property reflects the nature of update.
	 * @type {string}
	 */
	this.updateType = null;
	
	/*
	 * True when tabs or tabpanels was appended 
	 * or remove via UpdateManager updates.
	 * @type {boolean}
	 */
	this._hasBastardUpdates = false;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
TabBoxBinding.prototype.toString = function () {

	return "[TabBoxBinding]";
}

/**
 * @overloads {FlexBoxBinding#onBindingRegister}
 */
TabBoxBinding.prototype.onBindingRegister = function () {
	
	TabBoxBinding.superclass.onBindingRegister.call ( this );
	
	this.addActionListener ( Binding.ACTION_ATTACHED );
	this.addActionListener ( Binding.ACTION_DETACHED );
	this.addActionListener ( Binding.ACTION_ACTIVATED );
	this.addActionListener ( Binding.ACTION_FOCUSED );
	this.addActionListener ( PageBinding.ACTION_INITIALIZED );
	
	/*
	 * Intercept tabs and tabpanels appended 
	 * via UpdateManager updates.
	 */
	DOMEvents.addEventListener ( this.bindingDocument.documentElement, DOMEvents.AFTERUPDATE, this );
	DOMEvents.addEventListener ( this.bindingElement, DOMEvents.AFTERUPDATE, this );
}

/**
 * @overloads {Binding#onBindingAttach}
 */
TabBoxBinding.prototype.onBindingAttach = function () {

	TabBoxBinding.superclass.onBindingAttach.call ( this );
	TabBoxBinding.currentActiveInstance = this;
	
	/*
	 * Shorthand <tabs> and <tabpanels>.
	 */
	this._tabsElement = this.getTabsElement ();
	this._tabPanelsElement = this.getTabPanelsElement ();
	
	/*
	 * Count tabbox members.
	 */
	var tabCount = this.getTabElements ().getLength ();
	var tabPanelCount = this.getTabPanelElements ().getLength ();
	//this._totalMemberCount = this._totalMemberCount + tabCount + tabPanelCount;
	
	/*
	 * Initialize.
	 */
	if ( !this._tabsElement || !this._tabPanelsElement ) {
		throw new Error ( this.toString () + " DOM subtree invalid." );
	} else if ( tabCount != tabPanelCount ) {
		throw new Error ( this.toString () + " DOM subtree invalid." );
	} else {
		
		if ( this.getProperty ( "type" ) == "boxed" ) {
			this.setFlexibility ( false );
			this.attachClassName ( "boxed" );
		}
		
		this.buildDOMContent ();
		this._TEMPNAME ();
		
		if ( this.getProperty ( "equalsize" ) == true ) {
			this.dispatchAction ( PageBinding.ACTION_BLOCK_INIT );
			this.setFlexibility ( false );
			this.attachClassName ( "equalsize" );
			this.isEqualSize = true;
			this.addMembers ( this.getDescendantBindingsByLocalName ( "*" ));
		} else {
			this.addMember ( this.getTabsBinding ());
			this.addMember ( this.getTabPanelsBinding ());
			this.addMembers ( this.getTabBindings ());
			this.addMembers ( this.getTabPanelBindings ());
		}
	}
}

/**
 * Go get'em tabbox.
 */
TabBoxBinding.prototype.onBindingInitialize = function () {
	
	/*
	 * Hack up warning system.
	 */
	var tabPanelElements = this.getTabPanelElements ();
	while ( tabPanelElements.hasNext ()) {
		this._setupWarningSystem ( 
			UserInterface.getBinding ( 
				tabPanelElements.getNext ()
			)
		);
	}
	
	/*
	 * TODO: consider when to reinforce equalsize!
	 */
	if ( this.isEqualSize ) {
		this.enforceEqualSize ();
		this.dispatchAction ( PageBinding.ACTION_UNBLOCK_INIT );
	}
	
	this.dispatchAction ( TabBoxBinding.ACTION_ATTACHED );
	
	TabBoxBinding.superclass.onBindingInitialize.call ( this );
}


/**
 * IE6 cannot handle the nescessary css selectors to 
 * style tabs below this without a special classname. 
 * This method fixes it.
 */
TabBoxBinding.prototype.buildDOMContent = function () {
	
	var tabsPosition = DOMUtil.getOrdinalPosition ( this._tabsElement );
	var tabPanelsPosition = DOMUtil.getOrdinalPosition ( this._tabPanelsElement );
	
	var classname = tabsPosition > tabPanelsPosition ? "tabsbelow" : "tabsontop";
	this.attachClassName ( classname );
}

TabBoxBinding.prototype._TEMPNAME = function () {
	
	var tabs = this.getTabElements ();
	var tabpanels = this.getTabPanelElements ();
	var selectedTab = null;
	
	var selectedindex = this.getProperty ( "selectedindex" );
	if ( selectedindex != null ) {
		if ( selectedindex > tabs.getLength () - 1 ) {
			throw "Selectedindex out of range";
		}
	}
	if ( tabs.hasEntries ()) {
		var index = 0;
		while ( tabs.hasNext ()) {
			var tab = tabs.getNext ();
			var tabpanel = tabpanels.getNext ();
			this.registerTabBoxPair ( tab, tabpanel );
			if ( selectedindex && index == selectedindex ) {
				tab.setAttribute ( "selected", "true" );
			} else if ( tab.getAttribute ( "selected" ) == "true" ) {
				selectedTab = tab;	
			}
			index ++;
		}
		if ( !selectedTab ) {
			selectedTab = tabs.getFirst ();
			selectedTab.setAttribute ( "selected", "true" );
		}
	}
}

/**
 * Scale tabpanels to fit tallest contained tabpanel.
 * @param {boolean} isMaxingOut If set to true, tabbox can only grow taller.
 */
TabBoxBinding.prototype.enforceEqualSize = function ( isMaxingOut ) {
	
	var oldheight = null;
	var newheight = null;
	
	if ( this.isEqualSize ) {
		
		var padding = CSSComputer.getPadding ( this._tabPanelsElement );
		var max = 0, tabPanels = this.getTabPanelElements ();
		tabPanels.each ( function ( tabPanel ) {
			max = tabPanel.offsetHeight > max ? tabPanel.offsetHeight : max; 
		});
		newheight = max + padding.top + padding.bottom;
		if ( isMaxingOut && this._tabPanelsElement.style.height != null ) {
			oldheight = this._tabPanelsElement.offsetHeight;
		}
		if ( oldheight != null || newheight > oldheight ) {
			this._tabPanelsElement.style.height = newheight + "px";
		}
	}
}

/**
 * A somewhat hacked system for the tabs to display notifications 
 * when errors or balloons explode inside the associated tabpanel.
 * @param {TabPanelBinding} tabpanel
 */
TabBoxBinding.prototype._setupWarningSystem = function ( tabpanel ) {
	
	tabpanel._invalidCount = 0;
	tabpanel.addActionListener ( Binding.ACTION_INVALID, this );
	tabpanel.addActionListener ( Binding.ACTION_VALID, this );
	tabpanel.addActionListener ( BalloonBinding.ACTION_SNAP, this );
}

/**
 * Elaborate setup to make sure that tabbox members are properly initialized 
 * before the tabbox can announce to the outside world that is is ready to go.
 * TODO: DEPRECATE THIS SPECIALIZED SETUP IN FAVOUR OF STANDARD MEMBER DEPENDENCY!!! 
 * @implements {IActionListener}
 * @overloads {FlexBoxBinding#handleAction}
 * @param {Action} action 
 */
TabBoxBinding.prototype.handleAction = function ( action ) {
	
	TabBoxBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	var listener = action.listener;
	
	switch ( action.type ) {
	
		case Binding.ACTION_ATTACHED :
			
			/*
			if ( !this._isMembersAttached ) {
				switch ( binding.constructor ) {
					case this._impl_tab :
					case this._impl_tabs :
					case this._impl_tabpanel :
					case this._impl_tabpanels :
						if ( ++ this._attachedMemberCount == this._totalMemberCount ) {
							this._isMembersAttached = true;
							this.onMembersAttached ();
						}
						action.consume ();	
						break;
				}
			}
			*/
			break;
			
		case Binding.ACTION_DETACHED :
			if ( binding.constructor == this._impl_tab ) {
				this.updateType = TabBoxBinding.UPDATE_DETACH;
				this.dispatchAction ( TabBoxBinding.ACTION_UPDATED );
				action.consume ();	
			}
			break;
		
		case PageBinding.ACTION_INITIALIZED :
			if ( binding.isDialogSubPage && this.isEqualSize ) {	
				this.enforceEqualSize ();
			}
			break;
			
		case Binding.ACTION_INVALID :
			listener._invalidCount ++;
			if ( listener._invalidCount == 1 ) {
				var self = this;
				setTimeout ( function () {
					if ( !listener.isSelected ) {
						self._showWarning ( listener, true );
					}
				}, 0 );
			}
			break;
			
		case Binding.ACTION_VALID :
			if ( listener._invalidCount > 0 ) {
				listener._invalidCount --;
				if ( listener._invalidCount == 0 ) {
					if ( listener.isSelected ) {
						this._showWarning ( listener, false ); 
					}
				}
			}
			break;
			
		case BalloonBinding.ACTION_SNAP :
			this._showBalloon ( listener, true );
			break;
			
		case Binding.ACTION_ACTIVATED :
		case Binding.ACTION_FOCUSED :
			if ( action._tabboxstamp == null ) {
				TabBoxBinding.currentActiveInstance = this;
				action._tabboxstamp = "stamped";
			}
			break;
	}
}

/**
 * Register tabs and tabpanels appended via UpdateManager updates.
 * @implements {IEventHandler}
 * @overloads {Binding#handleEvent}
 * @param {Event} e
 */
TabBoxBinding.prototype.handleEvent = function ( e ) {
	
	TabBoxBinding.superclass.handleEvent.call ( this, e );
	
	switch ( e.type ) {
		case DOMEvents.AFTERUPDATE :
			
			var target = DOMEvents.getTarget ( e );
			
			if ( target == this.bindingDocument.documentElement ) {
				
				// TODO: Check for validity of structure
				
				if ( this._hasBastardUpdates ) {
					
					this._hasBastardUpdates = false;
					
					// welcome new tabs
					var tabs = this.getTabElements ();
					var tabpanels = this.getTabPanelElements ();
					tabs.each ( function ( tab, index ) {
						if ( tab.getAttribute ( TabBoxBinding.ASSOCIATION_KEY ) == null ) {
							var tabPanel = tabpanels.get ( index );
							this.registerTabBoxPair ( tab, tabPanel );
						}
					}, this );
					
					// dismiss gone tabs
					var pairs = this._tabBoxPairs;
					for ( var key in pairs ) {
						var tab = pairs [ key ].tab;
						if ( tab.parentNode == null ) {
							this.unRegisterTabBoxPair ( tab )
						}
					}
				}
			} else {
				
				// TODO: Investigate double updates
				
				if ( !this._hasBastardUpdates ) {
					var name = DOMUtil.getLocalName ( target );
					switch ( target.__updateType ) {
						case Update.TYPE_INSERT :
							switch ( name ) {
								case this._nodename_tab :
								case this._nodename_tabpanel :
									var parent = target.parentNode;
									if ( parent == this._tabsElement || parent == this._tabPanelsElement ) {
										this._hasBastardUpdates = true;
									}
									break;
							}
							break;
						case Update.TYPE_REMOVE :
							switch ( name ) {
								case this._nodename_tabs :
								case this._nodename_tabpanels :
									if ( target == this._tabsElement || target == this._tabPanelsElement ) {
										this._hasBastardUpdates = true;
									}
									break;
							}
							break;
					}
				}
			}
			break;
	}
}

/**
 * Select tab by argument.
 * @param {object} arg This should be a string (tab id) or a TabBinding instance.
 * @param {boolean} isManaged If set to true, application focus will not be updated.
 */
TabBoxBinding.prototype.select = function ( arg, isManaged ) {
	
	var tabBinding = this.getBindingForArgument ( arg ); 
	
	if ( tabBinding != null && !tabBinding.isSelected ) {
		
		/*
		 * Deselect old selection.
		 */
		if ( this._selectedTabBinding != null ) {	
			this._selectedTabBinding.unselect ();
			this.getTabPanelBinding ( this._selectedTabBinding ).unselect ();
		}
		
		this.dispatchAction ( TabBoxBinding.ACTION_UNSELECTED );
		
		/*
		 * Show selected tab-tabpanel set.
		 */
		tabBinding.select ( isManaged );
		this.getTabPanelBinding ( tabBinding ).select ( isManaged );
		
		/*
		 * Update selectedIndex property.
		 */
		var selectedindex = this.getProperty ( "selectedindex" );
		if ( selectedindex != null ) {
			this.setProperty ( 
				"selectedindex", 
				DOMUtil.getOrdinalPosition ( tabBinding.bindingElement, true )
			);
		}
		
		this._selectedTabBinding = tabBinding;
		this.dispatchAction ( TabBoxBinding.ACTION_SELECTED );
		this.dispatchAction ( FocusBinding.ACTION_UPDATE );
		 
		/*
		 * Error and balloon stuff.
		 */
		if ( tabBinding.getImage () == TabBoxBinding.BALLOON_TAB_IMAGE ) {
			var panel = this.getTabPanelBinding ( tabBinding );
			this._showBalloon ( panel, false );
		}
	}
}

/**
 * Building unique keys for each TabBinding and corresponding TabPanelBinding.
 * @param {DOMElement} tab
 * @param {DOMElement} tabPanel
 * @private
 */
TabBoxBinding.prototype.registerTabBoxPair = function ( tab, tabPanel ) {
	
	var key = KeyMaster.getUniqueKey ();

	tab.setAttribute ( TabBoxBinding.ASSOCIATION_KEY, key );
	tabPanel.setAttribute ( TabBoxBinding.ASSOCIATION_KEY, key );
	
	this._tabBoxPairs [ key ] = {
		tab : tab,
		tabPanel : tabPanel
	}
}

/**
 * Unregister tab and associated tabpanel.
 * @param {DOMElement} tab
 */
TabBoxBinding.prototype.unRegisterTabBoxPair = function ( tab ) {
	
	var key = tab.getAttribute ( TabBoxBinding.ASSOCIATION_KEY );
	delete this._tabBoxPairs [ key ];
}

/**
 * Get the TabPanelBinding associated to a given TabBinding.
 * @param {TabBinding} tabBinding
 * @return {TabPanelBinding}
 * @private
 */
TabBoxBinding.prototype.getTabPanelBinding = function ( tabBinding ) {
	
	var result = null;
	try {
		var key = tabBinding.getProperty ( TabBoxBinding.ASSOCIATION_KEY );
		var tabPanelElement = this._tabBoxPairs [ key ].tabPanel;
		result = UserInterface.getBinding ( tabPanelElement );
	} catch ( exception ) {
		this.logger.error ( exception );
		SystemDebug.stack ( arguments )
	}
	return result;
}

/**
 * Get the TabBinding associated to a given TabPanelBinding.
 * @param {TabPanelBinding} tabPanelBinding
 * @return {TabBinding}
 * @private
 */
TabBoxBinding.prototype.getTabBinding = function ( tabPanelBinding ) {

	var key = tabPanelBinding.getProperty ( TabBoxBinding.ASSOCIATION_KEY );
	var tabElement = this._tabBoxPairs [ key ].tab;
	return UserInterface.getBinding ( tabElement );
}


/** 
 * Creates a new TabBinding instance. By isolating 
 * the method, subclasses can overwrite it.
 * @return {TabBinding}
 */
TabBoxBinding.prototype.summonTabBinding = function () {
	
	return TabBinding.newInstance ( this.bindingDocument );
}

/**
 * Creates a new TabPanelBinding instance.
 * @return {TabPanelBinding}
 */
TabBoxBinding.prototype.summonTabPanelBinding = function () {
	
	var tabpanel = this._impl_tabpanel.newInstance ( this.bindingDocument );
	this._setupWarningSystem ( tabpanel );
	return tabpanel;
}

/**
 * This is the easy way to append a new tab: With a tab label and a nodetree to 
 * be used as tabpanel content. When going from zero to one tab, the first tab is 
 * selected. You can also use the appendTabByBindings method.
 * @see TabBoxBinding#appendTabByBindings
 * @param {string} label
 * @param {DOMElement} tabPanelSubTree
 * @return {TabBinding}
 *
TabBoxBinding.prototype.appendTab = function ( label, tabPanelSubTree ) {
	
	alert ( "TabBoxBinding.appendTab: Refactor!" );
	
	// build tab, autoselecting first tab.
	var tabBinding = this.summonTabBinding ();
	var tabElement = tabBinding.bindingElement;
	tabBinding.setLabel ( label );
	if ( !this.getTabElements ().hasEntries ()) {
		tabBinding.setProperty ( "selected", true );
	}
	
	// build tabpanel.
	var tabPanelBinding = this.summonTabPanelBinding ();
	var tabPanelElement = tabPanelBinding.bindingElement;
	if ( tabPanelSubTree ) { 
		tabPanelElement.appendChild ( tabPanelSubTree );
	}
		
	// register and append.
	this.registerTabBoxPair ( tabElement, tabPanelElement );
	this._tabsElement.appendChild ( tabElement );
	this._tabPanelsElement.appendChild ( tabPanelElement );
	
	// dispatch action and return tab binding.
	this.updateType = TabBoxBinding.UPDATE_ATTACH;
	this.dispatchAction ( TabBoxBinding.ACTION_UPDATED );
	return tabBinding;
}
*/

/**
 * Append new tab with a {@link TabBinding} instance and an object to be used as 
 * tabpanel content. When going from zero to one tab, the first tab is selected. 
 * @param {TabBinding} tabBinding
 * @param {object} tabPanelContent This can be either a Binding or a DOMElement
 */
TabBoxBinding.prototype.appendTabByBindings = function ( tabBinding, tabPanelContent ) {
	
	// prepare tab, autoselecting first tab.
	var tabElement = tabBinding.bindingElement;
	tabBinding.setProperty ( "selected", true );
	
	// build tabpanel.
	var tabPanelBinding = this.summonTabPanelBinding ();
	var tabPanelElement = tabPanelBinding.bindingElement;
	if ( tabPanelContent ) { 
		tabPanelElement.appendChild ( 
			tabPanelContent instanceof Binding ? 
			tabPanelContent.bindingElement : tabPanelContent 
		);
	}

	// register, append and attach
	this.registerTabBoxPair ( tabElement, tabPanelElement );
	
	//this._tabsElement.appendChild ( tabElement );
	UserInterface.getBinding ( this._tabsElement ).add ( tabBinding );
	this._tabPanelsElement.appendChild ( tabPanelElement );
	
	tabBinding.attach ();
	UserInterface.getBinding ( tabPanelElement ).attachRecursive ();
	
	// dispatch action and return tab binding.
	this.updateType = TabBoxBinding.UPDATE_ATTACH;
	this.dispatchAction ( TabBoxBinding.ACTION_UPDATED );
	return tabBinding;
}

/**
 * Import tab.
 * @param {TabBinding} tabBinding
 */
TabBoxBinding.prototype.importTabBinding = function ( tabBinding ) {
	
	var that			= tabBinding.containingTabBoxBinding;
	var tabPanelBinding = that.getTabPanelBinding ( tabBinding );
	var tabPanelElement = tabPanelBinding.getBindingElement ();
	var tabElement 		= tabBinding.getBindingElement ();
	
	that.dismissTabBinding ( tabBinding );
	
	this._tabsElement.appendChild ( tabElement );
	this._tabPanelsElement.appendChild ( tabPanelElement );
	this.registerTabBoxPair ( tabElement, tabPanelElement );
	
	tabBinding.containingTabBoxBinding = this;
	
	this.select ( tabBinding );
	this.dispatchAction ( Binding.ACTION_ACTIVATED );
	this.dispatchAction ( TabBoxBinding.ACTION_UPDATED );
}

/**
 * Remove tab - and the associated tabpanel!
 * @param {TabBinding} tabBinding
 */
TabBoxBinding.prototype.removeTab = function ( tabBinding ) {

	var bestTab = null; 
	if ( tabBinding.isSelected ) {
		bestTab = this.getBestTab ( tabBinding );
		this._selectedTabBinding = null;
	}
	
	var tabPanelBinding = this.getTabPanelBinding ( tabBinding );
	this.unRegisterTabBoxPair ( tabBinding.bindingElement );

	tabBinding.dispose ();
	tabPanelBinding.dispose ();
	
	if ( bestTab != null ){
		this.select ( bestTab );
	}
	
	this.updateType = TabBoxBinding.UPDATE_DETACH;
	this.dispatchAction ( TabBoxBinding.ACTION_UPDATED );
}

/**
 * @param {TabBinding} tabBinding
 */ 
TabBoxBinding.prototype.dismissTabBinding = function ( tabBinding ) {

	if ( tabBinding.isSelected ) {
		this.selectBestTab ( tabBinding );
	}
}

/**
 * @param {TabBinding} missingTabBinding This binding IS ABOUT to be disposed...
 */
TabBoxBinding.prototype.selectBestTab = function ( missingTabBinding ) {
	
	var bestTab = this.getBestTab ( missingTabBinding );
	
	if ( bestTab ) {
	 	this.select ( bestTab );
	} else {
		this._selectedTabBinding = null;
	}
}

/**
 * @param {TabBinding} missingTabBinding This binding IS ABOUT to be disposed...
 */
TabBoxBinding.prototype.getBestTab = function ( missingTabBinding ) {

	var bestTabBinding 	= null;
	var tabPosition 	= missingTabBinding.getOrdinalPosition ( true );
	var tabBindings 	= this.getTabBindings ();
	var tabsLength 		= tabBindings.getLength ();
	var lastPosition 	= tabsLength - 1;

	if ( tabsLength == 1 ) { // first tab
	 	bestTabBinding 	= null;
	} else if ( tabPosition == lastPosition ) { // last tab
		bestTabBinding = tabBindings.get ( tabPosition - 1 );
	} else {
		bestTabBinding = tabBindings.get ( tabPosition + 1 );
	}
	return bestTabBinding;
}

/**
 * Move tab and corresponding tabpanel to specified position.
 * @param {TabBinding}
 * @param {int} index
 */
TabBoxBinding.prototype.moveToOrdinalPosition = function ( tabBinding, index ) {
	
	var target = this.bindingDocument.getElementById ( tabBinding.bindingElement.id ); // ie!
	var tab = this.getTabElements ().get ( index );
	this._tabsElement.insertBefore ( target, tab );
	this.updateType = TabBoxBinding.UPDATE_ORDINAL;
	this.dispatchAction ( TabBoxBinding.ACTION_UPDATED );
}

/**
 * Get tabs element.
 * @return {DOMElement}
 */
TabBoxBinding.prototype.getTabsElement = function () {

	return DOMUtil.getElementsByTagName ( 
		this.bindingElement, 
		this._nodename_tabs 
	).item ( 0 );
}

/**
 * Get tabpanels element.
 * @return {DOMElement}
 */
TabBoxBinding.prototype.getTabPanelsElement = function () {

	return DOMUtil.getElementsByTagName ( 
		this.bindingElement,
		this._nodename_tabpanels 
	).item ( 0 );
}

/**
 * Get tab elements. Taking care not to include tabs from descendant tabboxes in result.
 * @return {List<Element>}
 */
TabBoxBinding.prototype.getTabElements = function () {
	
	var nodename = this._nodename_tab;
	var children = new List ( this._tabsElement.childNodes );
	var result = new List ();

	while ( children.hasNext ()) {
		var child = children.getNext ();
		if ( child.nodeType == Node.ELEMENT_NODE && DOMUtil.getLocalName ( child ) == nodename ) {
			result.add ( child );
		}
	}
	return result;
}

/**
 * Get tabpanel elements.
 * @return {List<Element>}
 */
TabBoxBinding.prototype.getTabPanelElements = function () {
	
	var nodename = this._nodename_tabpanel;
	var children = new List ( this._tabPanelsElement.childNodes );
	var result = new List ();
	
	children.each ( function ( child ) {
		if ( child.nodeType == Node.ELEMENT_NODE && DOMUtil.getLocalName ( child ) == nodename ) {
			result.add ( child );
		}
	});
	return result;
}

/**
 * Get tabs binding.
 * @return {TabsBinding}
 */
TabBoxBinding.prototype.getTabsBinding = function () {
	
	return this.getChildBindingByLocalName ( this._nodename_tabs ); 
}

/**
 * Get tabpanels binding.
 * @return {TabPanelsBinding}
 */
TabBoxBinding.prototype.getTabPanelsBinding = function () {
	
	return this.getChildBindingByLocalName ( this._nodename_tabpanels );
}

/**
 * Get tab bindings.
 * @return {List<TabBinding>}
 */
TabBoxBinding.prototype.getTabBindings = function () {

	var result = new List ();
	var elements = this.getTabElements ();
	
	elements.each ( function ( element ) {
		result.add ( 
			UserInterface.getBinding ( element )
		);
	});
	
	return result;
}

/**
 * Get tabpanel bindings.
 * @return {List<TabPanelBinding>
 */
TabBoxBinding.prototype.getTabPanelBindings = function () {
	
	var result = new List ();
	this.getTabPanelElements ().each ( function ( element ) {
		result.add ( UserInterface.getBinding ( element ));
	});
	return result;
}

/**
 * Get the selected TabBinding.
 * @return {TabBinding}
 */
TabBoxBinding.prototype.getSelectedTabBinding = function () {

	return this._selectedTabBinding;
}

/**
 * Get the selected TabPanelBinding.
 * @return {TabPanelBinding}
 */
TabBoxBinding.prototype.getSelectedTabPanelBinding = function () {
	
	var result = null;
	if ( this._selectedTabBinding ) {
		result = this.getTabPanelBinding (
			this._selectedTabBinding 
		);
	}
	return result;
}

/**
 * @param {TabPanelBinding} tabPanelBinding
 * @param {boolean} isShowWarning
 */
TabBoxBinding.prototype._showWarning = function ( tabPanelBinding, isShowWarning ) {
	
	var tabBinding = this.getTabBinding ( tabPanelBinding );
	
	if ( isShowWarning ) {
		if ( tabBinding.labelBinding.hasImage ) {
			tabBinding._backupImage = tabBinding.getImage ();
		}
		tabBinding.setImage ( TabBoxBinding.INVALID_TAB_IMAGE );
	} else {
		if ( tabBinding._backupImage ) {
			tabBinding.setImage ( tabBinding._backupImage );
		} else {
			tabBinding.setImage ( false );
		}
	}
}

/** 
 * TODO: Are we sure that errors get evaluated first?
 * @param {TabPanelBinding} tabPanelBinding
 * @param {boolean} isShowWarning
 */
TabBoxBinding.prototype._showBalloon = function ( tabPanelBinding, isShow ) {
	
	var tabBinding = this.getTabBinding ( tabPanelBinding );
	
	if (( isShow && !tabBinding.isSelected ) || !isShow ) { // don't put image on selected tab
		
		/*
		 * Don't mess with error indicators...
		 */
		if ( tabBinding.getImage () != TabBoxBinding.INVALID_TAB_IMAGE ) {
			if ( isShow ) {
				if ( tabBinding.labelBinding.hasImage ) {
					tabBinding._backupImage = tabBinding.getImage ();
				}
				tabBinding.setImage ( TabBoxBinding.BALLOON_TAB_IMAGE );
			} else {
				if ( tabBinding._backupImage != null ) {
					tabBinding.setImage ( tabBinding._backupImage );
				} else {
					tabBinding.setImage ( false );
				}
			}
		}
	}
}

/**
 * Advance tab selection.
 * @param {boolean} isForward
 */
TabBoxBinding.prototype.advanceSelection = function ( isForward ) {
	
	var tab = this.getSelectedTabBinding ();
	var tabs = this.getTabBindings ();
	var index = tab.getOrdinalPosition ( true );
	var next = null;
	
	var visible = new List ();
	tabs.each ( function ( t ) { // exclude hidden tabs
		if ( t.isVisible ) {
			visible.add ( t );
		}
	});
	 
	if ( visible.getLength () > 1 ) {
		if ( index == 0 && !isForward ) {
			next = visible.getLast ();
		} else if ( index == visible.getLength () - 1 && isForward ) {
			next = visible.getFirst ();
		} else {
			if ( isForward ) {
				next = tab.getNextBindingByLocalName ( this._nodename_tab );
			} else {
				next = tab.getPreviousBindingByLocalName ( this._nodename_tab );
			} 
		}
		if ( next != null ) {
			this.select ( next );
		}
	}
}

TabsBinding.prototype = new Binding;
TabsBinding.prototype.constructor = TabsBinding;
TabsBinding.superclass = Binding.prototype;
TabsBinding.NODENAME_TABBOX = "tabbox";
TabsBinding.TABBUTTON_IMPLEMENTATION = TabsButtonBinding;

/**
 * @implements {IBroadcastListener}
 */
function TabsBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "TabsBinding" );

	/**
	 * @type {TabBoxBinding}
	 */
	this.containingTabBoxBinding = null;
	
	/**
	 * @type {TabManagerBinding}
	 */
	this.tabsButtonBinding = null;
	
	/**
	 * @type {int}
	 */
	this._cachedOffsetWidth = parseInt ( 0 );

	/**
	 * Prevents the occasiona "too much recursion"...
	 * @type {boolean}
	 */
	this.isManaging = false;
	
	/**
	 * Block common crawlers.
	 * @overwrites {Binding#crawlerFilters}
	 * @type {List<string>}
	 */
	this.crawlerFilters	= new List ([ FlexBoxCrawler.ID, FocusCrawler.ID ]);
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
TabsBinding.prototype.toString = function () {

	return "[TabsBinding]";
}

/**
 * Attach classname to clear stylesheet floats.
 * @overloads {Binding#onBindingRegister}
 */
TabsBinding.prototype.onBindingRegister = function () {

	TabsBinding.superclass.onBindingRegister.call ( this );
	this.attachClassName ( Binding.CLASSNAME_CLEARFLOAT );
}

/**
 * @overloads {Binding#onBindingAttach}
 */
TabsBinding.prototype.onBindingAttach = function () {

	TabsBinding.superclass.onBindingAttach.call ( this );
	
	this.containingTabBoxBinding = this.getAncestorBindingByType ( TabBoxBinding );
	this.containingTabBoxBinding.addActionListener ( TabBoxBinding.ACTION_UPDATED, this );
	this.buildDOMContent ();
	this.dispatchAction ( Binding.ACTION_ATTACHED );
}

/**
 * Build DOM content.
 */
TabsBinding.prototype.buildDOMContent = function () {
	
	// build a hook for visual styling
	var div = this.bindingDocument.createElement ( "div" );
	div.className = "tabliner";
	this.bindingElement.insertBefore ( div, this.bindingElement.firstChild );
	
	// build the tabmanager
	this.shadowTree.tabManager = this.bindingDocument.createElement ( "div" );
	this.shadowTree.tabManager.className = "tabmanager";
	
	var tabButtonImplementation = this.constructor.TABBUTTON_IMPLEMENTATION;
	this.tabsButtonBinding = tabButtonImplementation.newInstance ( this.bindingDocument );
	this.shadowTree.tabsButton = this.tabsButtonBinding;
	this.add ( this.tabsButtonBinding );
	this.tabsButtonBinding.attach ();
}

/**
 * Invoke tabmanager update when tabbox is modified.
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
TabsBinding.prototype.handleAction = function ( action ) {

	TabsBinding.superclass.handleAction.call ( this, action );
	
	switch ( action.type ) {
		case TabBoxBinding.ACTION_UPDATED  :
			if ( !this.isManaging ) {
				var self = this;
				function manage () {
					self.manage ();
				}
				setTimeout ( manage, 0 );
			}
			break;
	}
}

/**
 * Update tabsbutton when tabbox environment is resized.
 * A size check is added to prevent unnescessary management.
 * A timeout is enforced for browser convenience.
 */
TabsBinding.prototype.flex = function () {
	
	if ( this.isAttached == true ) {
		var self = this;
		function manage () {
			if ( Binding.exists ( self ) == true ) {
				var currentOffsetWidth = self.bindingElement.offsetWidth;
				if ( currentOffsetWidth != self._cachedOffsetWidth ) {
					self.manage ();
				}
				self._cachedOffsetWidth = currentOffsetWidth;
			}
		}
		setTimeout ( manage, 0 );
	}
}

/**
 * Hide the tabsbutton when adding new tabs. This will 
 * prevent the button from jumping around (timeout issue). 
 * If necessary, the button is shown by manage method.
 * @overloads {Binding#add}
 * @param {Binding} binding
 * @return {Binding}
 */
TabsBinding.prototype.add = function ( binding ) {
	
	if ( binding instanceof TabBinding ) {
		if ( this.tabsButtonBinding && this.tabsButtonBinding.isVisible ) {
			this.tabsButtonBinding.hide ();
		}
	}
	return TabsBinding.superclass.add.call ( this, binding );
}

/**
 * Manage tab layout.
 * TODO: this routine is way too complex - please refactor!
 */
TabsBinding.prototype.manage = function () {
	
	if ( Binding.exists ( this ) == true && this.isVisible ) {
	
		this.isManaging = true;
	
		var isOverflow = false;
		var tabBinding, tab, tabs = this.containingTabBoxBinding.getTabElements ();
		var tabButtonImplementation = this.constructor.TABBUTTON_IMPLEMENTATION;
		var width = this.bindingElement.offsetWidth - tabButtonImplementation.RESERVED_SPACE;
		var lastVisibleTabBinding = null;
	
		var sum = 0, visibleCount = 0;
		var isContinue = true;	
		
		if ( tabs.hasEntries ()) {
		
			this.tabsButtonBinding.reset ();
			
			while ( tabs.hasNext () && isContinue ) {
				tab = tabs.getNext ();
				tabBinding = UserInterface.getBinding ( tab );
				if ( !lastVisibleTabBinding ) {
					lastVisibleTabBinding = tabBinding;
				}
				sum += tab.offsetWidth;
				if ( sum >= width ) {
					isOverflow = true;
					if ( tabBinding.isSelected ) {
						if ( !DOMUtil.isFirstElement ( tabBinding.bindingElement, true )) {
							this.isManaging = false;
							if ( lastVisibleTabBinding ) {
								lastVisibleTabBinding.hide (); // prevents jumping tabs!
								if ( this.tabsButtonBinding.isVisible ) {
									this.tabsButtonBinding.hide ();
								}
							}
							this.containingTabBoxBinding.moveToOrdinalPosition ( // this will invoke a new manage!
								tabBinding,
								visibleCount - 1
							);
							isContinue = false; 
						}
					} else {
						tabBinding.hide ();
						this.tabsButtonBinding.registerHiddenTabBinding ( tabBinding );
					}
				} else {
					tabBinding.show ();
					lastVisibleTabBinding = tabBinding;
					visibleCount ++;
				}
			}
			if ( isContinue ) {
				if ( isOverflow && this.tabsButtonBinding.hiddenTabBindings.hasEntries ()) {
					var lastElement = lastVisibleTabBinding.getBindingElement ();
					var xposition = lastElement.offsetLeft + lastElement.offsetWidth;
					var button = this.tabsButtonBinding;
					setTimeout ( function () {
						button.show ( xposition + 4 );
					}, 50 );
				} else {
					this.tabsButtonBinding.hide ();
				}
			}
		}
		
		this.isManaging = false;
	}
}

TabBinding.prototype = new MatrixBinding;
TabBinding.prototype.constructor = TabBinding;
TabBinding.superclass = MatrixBinding.prototype;

TabBinding.ACTION_SELECTED = "tabselected";
TabBinding.ACTION_UNSELECTED = "tabunselected";
TabBinding.NODENAME_TABBOX = "tabbox";

/**
 * @class
 * TabBinding.
 */
function TabBinding () {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "TabBinding" );
	
	/**
	 * This property is set by the {@link TabBoxBinding}.
	 * @type {string}
	 */
	this.tabboxkey = null;
	
	/**
	 * @type {boolean}
	 */
	this.isSelected	= false;
	
	/**
	 * @type {LabelBinding}
	 */
	this.labelBinding = null;
	
	/**
	 * @type {TabBoxBinding}
	 * @private
	 */
	this.containingTabBoxBinding = null;
	
	/**
	 * Block common crawlers.
	 * @type {Map<string><boolean>}
	 * @overwrites {Binding#crawlerFilters}
	 */
	this.crawlerFilters	= new List ([ DocumentCrawler.ID, FlexBoxCrawler.ID, FocusCrawler.ID ]);
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
TabBinding.prototype.toString = function () {

	return "[TabBinding]";
}

/**
 * Serialize binding.
 * @return {HashMap<string><object>}
 */
TabBinding.prototype.serialize = function () {
	
	var result = TabBinding.superclass.serialize.call ( this );
	if ( result ) {
		result.label = this.getLabel ();
		result.image = this.getImage ();
		result.tooltip = this.getToolTip ();
	}
	return result;
}

/**
 * Dispatching action to initialize containing tabboxbinding.
 * Overloads {Binding#onBindingAttach}
 */
TabBinding.prototype.onBindingAttach = function () {
	
	TabBinding.superclass.onBindingAttach.call ( this );
	this.defaultElementPosition = DOMUtil.getComputedStyle ( this.bindingElement, "position" );
	this.defaultElementLeft = DOMUtil.getComputedStyle ( this.bindingElement, "left" );
	this.containingTabBoxBinding = this.getAncestorBindingByType ( TabBoxBinding );
	this.buildDOMContent ();
	this.assignDOMEvents ();
	this.dispatchAction ( Binding.ACTION_ATTACHED );
	
	if ( this.getProperty ( "selected" ) == true ) {
		this.containingTabBoxBinding.select ( this );
	}	
}

/**
 * Build DOM content.
 */
TabBinding.prototype.buildDOMContent = function () {

	var image 		= this.bindingElement.getAttribute ( "image" );
	var label 		= this.bindingElement.getAttribute ( "label" );
	var tooltip 	= this.bindingElement.getAttribute ( "tooltip" );

	/*
	 * Assign default classname.
	 */
	this.bindingElement.className = "default";

	this.labelBinding = LabelBinding.newInstance ( this.bindingDocument );
	this.shadowTree.labelBinding = this.labelBinding;
	this.labelBinding.attachClassName ( "tablabel" );
	this.add ( this.labelBinding );

	if ( label ) {
		this.setLabel ( label );
	}
	if ( image ) {
		this.setImage ( image );
	}
	if ( tooltip ) {
		this.setToolTip ( tooltip );
	}
}

/**
 * @param {string} string
 */
TabBinding.prototype.setImage = function ( url ) {
	
	this.setProperty ( "image", url );
	if ( this.isAttached ) {
		this.labelBinding.setImage ( 
			url
		);
	}
}

/**
 * @return {string}
 */
TabBinding.prototype.getImage = function () {

	return this.getProperty ( "image" );
}

/**
 * @param {string} label
 */
TabBinding.prototype.setLabel = function ( label ) {

	if ( label != null ) {
		this.setProperty ( "label", label );	
		if ( this.isAttached ) {
			this.labelBinding.setLabel ( label )
		}
	}
}

/**
 * @return {string}
 */
TabBinding.prototype.getLabel = function () {

	return this.getProperty ( "label" );
}

/**
 * @param {string} tooltip
 */
TabBinding.prototype.setToolTip = function ( tooltip ) {

	if ( tooltip ) {
		this.setProperty ( "tooltip", tooltip );	
		if ( this.isAttached ) {
			this.labelBinding.setToolTip ( tooltip )
		}
	}
}

/**
 * @return {string}
 */
TabBinding.prototype.getToolTip = function () {

	return this.getProperty ( "tooltip" );
}

/**
 * Assigning DOM events.
 */
TabBinding.prototype.assignDOMEvents = function () {
	
	this.addEventListener ( DOMEvents.MOUSEDOWN );
	this.addEventListener ( DOMEvents.MOUSEENTER );
	this.addEventListener ( DOMEvents.MOUSELEAVE );
}

/**
 * @implements {IEventListener}.
 * @overlads {Binding#handleEvent}
 * @param {MouseEvent} e
 */
TabBinding.prototype.handleEvent = function ( e ) {

	TabBinding.superclass.handleEvent.call ( this, e );
	
	if ( !this.isSelected ) {
	
		var isAbort = false;
		if ( Client.isMozilla == true ) {
			/*
			 * something must be done!
			var related = e.relatedTarget;
			var current = e.currentTarget;
			this.logger.debug ( current.parentNode == related );
			*/
		}	
		if ( !isAbort ) {
			switch ( e.type ) {
				case DOMEvents.MOUSEENTER :
				case DOMEvents.MOUSEOVER :
					if ( !this.isSelected ) {
						this.bindingElement.className = "hover";
					}
					break;
				case DOMEvents.MOUSELEAVE :
				case DOMEvents.MOUSEOUT :
					if ( !this.isSelected ) {
						this.bindingElement.className = "default";
					}
					break;
				case DOMEvents.MOUSEDOWN :
					if ( !DOMEvents.isRightButton ( e )) {
						this.containingTabBoxBinding.select ( this );
					}
					break;
			}
		}
	}
}

/**
 * Select tab. This method should only be invoked by the {@link TabBoxBinding}.
 * TODO: Rename to invokeManagedSelect
 */
TabBinding.prototype.select = function ( isManaged ) {

	this.show (); // here?
	this.isSelected = true;
	this.setProperty ( "selected", true );
	this.bindingElement.className = "selected";
}

/**
 * Unselect tab. This method should only be invoked by the {@link TabBoxBinding}.
 * TODO: Rename to invokeManagedUnselect
 */
TabBinding.prototype.unselect = function () {

	this.isSelected = false;
	this.deleteProperty ( "selected" );
	this.bindingElement.className = "default";
}

/**
 * Hide tab. Notice that we cannot simply use "display:none" because we need access 
 * to the offsetWidth property when managing tabstrip layout. Accessing style property 
 * directly instead of assigning a CSS classname is preferred because its faster.
 * @overwrites {Binding#hide}
 */
TabBinding.prototype.hide = function () {

	if ( this.isVisible ) {
		this.bindingElement.style.position = "absolute";
		this.bindingElement.style.left = "-1000px";
		this.isVisible = false;
	}
}

/**
 * Show tab. 
 * @overwrites {Binding#show}
 */
TabBinding.prototype.show = function () {

	if ( !this.isVisible ) {
		this.bindingElement.style.position = this.defaultElementPosition;
		this.bindingElement.style.left = this.defaultElementLeft;
		this.isVisible = true;
	}
}


/**
 * TabBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {TabBinding}
 */
TabBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:tab", ownerDocument );
	return UserInterface.registerBinding ( element, TabBinding );
}

TabPanelsBinding.prototype = new FlexBoxBinding;
TabPanelsBinding.prototype.constructor = TabPanelsBinding;
TabPanelsBinding.superclass = FlexBoxBinding.prototype;

/**
 * @class
 */
function TabPanelsBinding () {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "TabPanelsBinding" );
	
	/**
	 * @type {TabBoxBinding}
	 */
	this.containingTabBoxBinding = null;
	
	/**
	 * Storing tabpanels dimensions in order to economize flex iterations.
	 * @see {TabPanelBinding#_invokeManagedRecursiveFlex}
	 * @type {Dimension}
	 */
	this._lastKnownDimension = null;

}

/**
 * Identifies binding.
 */
TabPanelsBinding.prototype.toString = function () {

	return "[TabPanelsBinding]";
}

/**
 * @overloads {FlexBoxBinding#onBindingRegister}
 */
TabPanelsBinding.prototype.onBindingRegister = function () {
	
	TabPanelsBinding.superclass.onBindingRegister.call ( this );
	this._lastKnownDimension = new Dimension ( 0, 0 );
}

/**
 * Returns true if dimensions changed since method was lastly invoked.
 * @see {TabPanelBinding#_invokeManagedRecursiveFlex}
 * @return {boolean}
 */
TabPanelsBinding.prototype.hasDimensionsChanged = function () {
	
	var result = false;
	var dim1 = this.boxObject.getDimension ();
	var dim2 = this._lastKnownDimension;
	
	if ( dim2 == null || !Dimension.isEqual ( dim1, dim2 )) {
		result = true;
		this._lastKnownDimension = dim1;
	}
	
	return result;
}

/**
 * @overloads {Binding#onBindingAttach}
 */
TabPanelsBinding.prototype.onBindingAttach = function () {

	TabPanelsBinding.superclass.onBindingAttach.call ( this );
	this.containingTabBoxBinding = this.getAncestorBindingByType ( TabBoxBinding );
	this.setFlexibility ( this.containingTabBoxBinding.isFlexible );
	this.dispatchAction ( Binding.ACTION_ATTACHED );
}


TabPanelBinding.prototype = new Binding;
TabPanelBinding.prototype.constructor = TabPanelBinding;
TabPanelBinding.superclass = Binding.prototype;

function TabPanelBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "TabPanelBinding" );
	
	/**
	 * This property is set by the TabBoxBinding
	 * @type {string}
	 */
	this.tabboxkey = null;
	
	/**
	 * @type {boolean}
	 */
	this.isVisible = false;
	
	/**
	 * @type {IFocusable}
	 */
	this._focusedBinding = null;

	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
TabPanelBinding.prototype.toString = function () {

	return "[TabPanelBinding]";
}

/**
 * Dispatching action to initialize containing tabboxbinding.
 * Overloads {Binding#onBindingAttach}
 */
TabPanelBinding.prototype.onBindingAttach = function () {

	TabPanelBinding.superclass.onBindingAttach.call ( this );
	this.dispatchAction ( Binding.ACTION_ATTACHED );
	this.addActionListener ( BalloonBinding.ACTION_INITIALIZE );
}

/**
 * Select tabpanel.
 * @param {boolean} isManaged If set to true, application focus will not be updated.
 */
TabPanelBinding.prototype.select = function ( isManaged ) {
	
	if ( !this.isSelected ) {
		
		if ( this.isLazy ) {
			
			this.wakeUp ( "select" );
			
		} else {
		
			this.isSelected = true;
			this.isVisible = true;
			this.bindingElement.style.position = "static";
			
			/*
			 * Start flex iterator?
			 */
			this._invokeManagedRecursiveFlex ();
			
			/*
			 * TODO: Even if seleted, focus shift should only be invoked   
			 * when no VISIBLE binding inside the dock has the current focus. 
			 */
			if ( isManaged != true ) {
				this.dispatchAction ( FocusBinding.ACTION_FOCUS );
			}
		}
	
	}
}

/**
 * Unselect tabpanel.
 */
TabPanelBinding.prototype.unselect = function () {
	
	if ( this.isSelected ) {
		
		/*
		 * Blur any focused binding within the tabpanel.
		 */
		this.dispatchAction ( FocusBinding.ACTION_BLUR );
		
		this.isSelected = false;
		this.isVisible = false;
		
		this.bindingElement.style.position = "absolute";
	}
}

/**
 * Invoke recursive flex ONLY IF tabpanels height 
 * has changed since last show (or when first shown).
 * UPDATE: THIS HAS BEEN DISABLED
 */
TabPanelBinding.prototype._invokeManagedRecursiveFlex = function () {
	
	this.reflex ( true );
	
	/*
	 * There's an issue here with lazy panels waking up. 
	 * It may be nescessary simply to reflex!
	 *
	if ( this.isAttached == true ) {
		
		var tabpanels = UserInterface.getBinding ( this.bindingElement.parentNode );
		if ( tabpanels.hasDimensionsChanged ()) {
			this.reflex ();
		}
	}
	*/
}

/**
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
TabPanelBinding.prototype.handleAction = function ( action ) {
	
	TabPanelBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	
	switch ( action.type ) {
		case BalloonBinding.ACTION_INITIALIZE :
			action.consume ();
			break;
	}
}

/**
 * TabPanelBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {TabPanelBinding}
 */
TabPanelBinding.newInstance = function ( ownerDocument ) {
	
	var tabpanel = DOMUtil.createElementNS ( Constants.NS_UI, "ui:tabpanel", ownerDocument );
	UserInterface.registerBinding ( tabpanel, TabPanelBinding );
	return UserInterface.getBinding ( tabpanel );
}

SplitBoxBinding.prototype = new FlexBoxBinding;
SplitBoxBinding.prototype.constructor = SplitBoxBinding;
SplitBoxBinding.superclass = FlexBoxBinding.prototype;
SplitBoxBinding.ORIENT_HORIZONTAL = "horizontal";
SplitBoxBinding.ORIENT_VERTICAL = "vertical";

/**
 * @class
 */
function SplitBoxBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SplitBoxBinding" );
	
	/**
	 * Defaults to horizontal layout.
	 * @type {string}
	 */
	this._orient = SplitBoxBinding.ORIENT_HORIZONTAL;
	
	/**
	 * @type {boolean}
	 */
	this.isLayoutInitialized = false;
	
	/**
	 * @type {boolean}
	 */
	this._isFirstLayout = true;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
SplitBoxBinding.prototype.toString = function () {

	return "[SplitBoxBinding]";
}

/**
 * Serialize binding.
 * Overloads {FlexBoxBinding#serialize}
 * @return {HashMap<string><object>}
 */
SplitBoxBinding.prototype.serialize = function () {
	
	var result = SplitBoxBinding.superclass.serialize.call ( this );
	if ( result ) {
	 	result.orient = this.getOrient ();
		result.layout = this.getLayout ();
	}
	return result;
}

/**
 * @overloads {Binding#onBindingAttach}
 */
SplitBoxBinding.prototype.onBindingAttach = function () {
	
	SplitBoxBinding.superclass.onBindingAttach.call ( this );
	
	this.addActionListener ( SplitterBinding.ACTION_DRAGGED, this );	
	this.addActionListener ( SplitterBinding.ACTION_COLLAPSE, this );
	this.addActionListener ( SplitterBinding.ACTION_UNCOLLAPSE, this );
	
	this._initializeLayout ();
	this._initializeOrient ();
	this._initializeSplitters ();
}

/** 
 * The layout attribute is easy to work with for content authors, 
 * but for internal work we prefer to split it up and assign it 
 * as attributes on descendant splitpanels.
 */
SplitBoxBinding.prototype._initializeLayout = function () {
	
	var splitPanels = this.getSplitPanelElements ();
	if ( splitPanels.hasEntries ()) { 
		var ratios = new List ( 
			this.getLayout ().split ( ":" )
		);
		if ( ratios.getLength () != splitPanels.getLength ()) {
			throw new Error ( this + " DOM subree invalid" ); 
		} else {
			splitPanels.each ( function ( splitPanel ) {
				splitPanel.setAttribute ( "ratio", ratios.getNext ());
			});
		}
	}
	
	// flag initialized status
	this.isLayoutInitialized = true;
}

/**
 * Initialize splitbox orientation.
 */ 
SplitBoxBinding.prototype._initializeOrient = function () {
	
	var orient = this.getProperty ( "orient" );
	if ( orient ) {
		this._orient = orient;
	}
	this.attachClassName ( this._orient );
}

/**
 * Initialize splitters.
 */ 
SplitBoxBinding.prototype._initializeSplitters = function () {

	var splitters = this.getSplitterBindings ();
	while ( splitters.hasNext ()) {
		var splitterBinding = splitters.getNext ();
		if ( splitterBinding && splitterBinding.getProperty ( "collapsed" ) == true ) {
			splitterBinding.collapse ();
		}
	}
}

/**
 * @implements {IActionListener}
 * @overloads {FlexBoxBinding#handleAction}
 * @param {Action} action
 */
SplitBoxBinding.prototype.handleAction = function ( action ) {

	SplitBoxBinding.superclass.handleAction.call ( this, action );

	switch ( action.type ) {
		case SplitterBinding.ACTION_DRAGGED :
			this.refreshLayout ();
			action.consume ();
			break;
		case SplitterBinding.ACTION_COLLAPSE :
			this.collapse ( action.target );
			action.consume ();
			break;
		case SplitterBinding.ACTION_UNCOLLAPSE :
			this.unCollapse ( action.target );
			action.consume ();
			break;
	}
}

/**
 * Overload flex method to maintain splitpanel ratios when resizing.
 * @overloads {FlexBoxBinding#flex}
 * @implements {IFlexible}
 */
SplitBoxBinding.prototype.flex = function () {
	
	SplitBoxBinding.superclass.flex.call ( this );

	if ( this.isAttached == true ) {
		this.invokeLayout ( true ); // true arg blocks new reflex chain...
	}
}

/**
 * Collapse splitter. Note that you should always invoke collapse by 
 * calling the corresponding method on the {@link SplitterBinding}.
 * @param {SplitterBinding} splitter
 */
SplitBoxBinding.prototype.collapse = function ( splitterBinding ) {
	
	this._getSplitPanelBindingForSplitter ( splitterBinding ).collapse ();
	this.invokeLayout ();
}

/**
 * Uncollapse splitter.
 * @param {SplitterBinding} splitter
 */
SplitBoxBinding.prototype.unCollapse = function ( splitterBinding ) {
	
	this._getSplitPanelBindingForSplitter ( splitterBinding ).unCollapse ();
	this.invokeLayout ();
}

/**
 * Get SplitPanelBinding dependant on the SplitterBindings "collapse" property.
 * @param {SplitterBinding} splitter
 */
SplitBoxBinding.prototype._getSplitPanelBindingForSplitter = function ( splitterBinding ) {

	var ordinal = DOMUtil.getOrdinalPosition ( splitterBinding.bindingElement, true );
	var splitPanel, splitPanels = this.getSplitPanelElements ();
	
	switch ( splitterBinding.getCollapseDirection ()) {
		case SplitterBinding.COLLAPSE_BEFORE :
			splitPanel = splitPanels.get ( ordinal );	
			break;
		case SplitterBinding.COLLAPSE_AFTER :
			splitPanel = splitPanels.get ( ordinal + 1 );
			break;
	}	
	return UserInterface.getBinding ( splitPanel );
	
}

/**
 * Invoke current layout.
 * @param @optional {boolean} isFlexing True if layout was invoked by FlexBoxCrawler.
 */
SplitBoxBinding.prototype.invokeLayout = function ( isFlexing ) {

	var isHorizontal = this.isHorizontalOrient ();
	var panelBindings = this.getSplitPanelBindings ();
	var splitterBindings = this.getSplitterBindings ();
	var ratios = new List ();
	var ratio, sum = 0;
	var fixedPanelSum = 0;
	
	/*
	 * NOTE FOR STAGSPLITBOXES: the calculation of fixedPanelSum is only 
	 * accurate  because we have exactly two splitpanels in each stage splitbox. 
	 * If more panels are added, the calculation becomes inacurate.
	 */
	panelBindings.each ( function ( panelBinding ) {
		if ( panelBinding.isFixed == true ) {
			if ( !panelBindings.hasNext ()) {
				fixedPanelSum += panelBinding.getFix ();
			}
			ratios.add ( 0 );
			sum += 0;
		} else {
			ratio = panelBinding.getRatio ();
			ratios.add ( ratio );
			sum += ratio;
		}
	});
	if ( sum == 0 ) { // TODO: this avoids division by zero, but can it break something?
		this.logger.warn ( "Division by zero was hacked" );
		sum = 1;
	}
	if ( ratios.getLength () != panelBindings.getLength ()) {
		throw new Error ( 
			this + " Invalid property (ratio)" 
		);
	} else {
		var total = isHorizontal ? this.getWidth () : this.getHeight ();
		total -= fixedPanelSum;
		splitterBindings.each ( function ( splitterBinding ) {
			if ( splitterBinding.isVisible ) {
				total -= SplitterBinding.DIMENSION;
			}
		});
		var unit = total / sum;
		var spancount = 0;
		
		var self = this;
		
		panelBindings.each ( function ( panelBinding ) {
			var span = 0;
			var ratio = ratios.getNext ();
			if ( panelBinding.isFixed ) {
				span = panelBinding.getFix ();
			} else {
				span = Math.round ( unit * ratio );
				if ( isNaN ( span )) {
					alert ( "isNaN ( span ) [" + this.getProperty ( "layout" ) + "]" );
				}
			}
			
			
			// TODO: this correction should not be performed on fixed panels!
			spancount += span;
			while ( spancount > total ) {
				spancount--;
				span--;
			}
			if ( !panelBinding.isFixed ) {
				if ( isHorizontal ) {
					panelBinding.setWidth ( span );
				} else {
					panelBinding.setHeight ( span );
				}
			}	
		});
	}

	if ( isFlexing != true ) {
		this.reflex ();
	}
	
	/*
	 * Handle persistance.
	 */
	if ( this._persist && this._persist.layout ) {
		var persistlayout = this.getLayout ();
		if ( persistlayout ) { // can this fail?
 			this.setProperty ( "layout", persistlayout );
 		}
	}
}

/**
 * Compute new layout.
 */
SplitBoxBinding.prototype.computeLayout = function () {
	
	var isHorizontal		= this.isHorizontalOrient ();
	var panelBindings		= this.getSplitPanelBindings ();
	var splitterBindings 	= this.getSplitterBindings ();
	var splitterBinding 	= null;
	var ratio 				= null;
	var unit 				= null;
	var offset 				= null;
	var span 				= null;
	
	panelBindings.each ( function ( panelBinding ) {
		
		if ( !unit ) { // TODO: collapsed first binding?
			unit = isHorizontal ? panelBinding.getWidth () : panelBinding.getHeight ();
		}
		span = isHorizontal ? panelBinding.getWidth () : panelBinding.getHeight ();
		if ( offset ) {
			span -= offset;
			offset = null;
		}
		splitterBinding = splitterBindings.getNext ();
		if ( splitterBinding && splitterBinding.offset ) {
			offset = splitterBinding.offset;
			span += offset;
		}
		
		panelBinding.setRatio ( span / unit );
	});
}

/**
 * Refresh layout.
 */
SplitBoxBinding.prototype.refreshLayout = function () {

	this.computeLayout ();
	this.invokeLayout ();
}

/**
 * Set layout. 
 */
SplitBoxBinding.prototype.setLayout = function ( layout ) {

	this.logger.debug ( layout );
	this.setProperty ( "layout", layout );
	this._initializeLayout ();
	this.invokeLayout ();
}

/**
 * Get layout.
 * @param {string} layout
 */
SplitBoxBinding.prototype.getLayout = function () {

	if ( !this.isLayoutInitialized ) {
		if ( !this.getProperty ( "layout" )) {
			this.setProperty ( "layout", this.getDefaultLayout ());
		}
	} else {
		var layout = "", panelBindings = this.getSplitPanelBindings ();
		 panelBindings.each ( function ( panelBinding ) {
		 	layout += panelBinding.getRatio ().toString ();
			layout += panelBindings.hasNext () ? ":" : "";
		 });
		this.setProperty ( "layout", layout );
	}
	return new String ( 
		this.getProperty ( "layout" )
	);
}

/**
 * @return {string}
 */
SplitBoxBinding.prototype.getDefaultLayout = function () {

	var elements = this.getSplitPanelElements ();
	elements.each ( function ( element ) {
		layout += "1" + ( elements.hasNext () ? ":" : "" );
	});
	this.setProperty ( "layout", layout )
}

/**
 * Set width.
 * @param {number} width
 */
SplitBoxBinding.prototype.setWidth = function ( width ) {

	this.bindingElement.style.width = width + "px";
}

/**
 * Get width.
 * @return {number}
 */
SplitBoxBinding.prototype.getWidth = function () {

	return this.bindingElement.offsetWidth;
}

/**
 * Set width.
 * @param {number} height
 */
SplitBoxBinding.prototype.setHeight = function ( height ) {

	this.bindingElement.style.height = height + "px";
}

/**
 * Get height.
 * @return {number}
 */
SplitBoxBinding.prototype.getHeight = function () {

	return this.bindingElement.offsetHeight;
}

/**
 * Get orient property.
 * TODO: make a setter for this property (implies layout recalc)?
 */
SplitBoxBinding.prototype.getOrient = function () {

	return this.getProperty ( "orient" )
}

/**
 * Is horizontal orient?.
 * @return {boolean}
 */
SplitBoxBinding.prototype.isHorizontalOrient = function () {

	return this._orient == SplitBoxBinding.ORIENT_HORIZONTAL;
}

/**
 * Get splitpanel elements. Taking care not to include 
 * splitpanels from descendant splitboxes in result.
 * TODO: store result untill some kind of dirty flag is set
 * @return {List<DOMElement>}
 */
SplitBoxBinding.prototype.getSplitPanelElements = function () {

	return this.getChildElementsByLocalName ( "splitpanel" );
}

/**
 * Get splitpanel bindings.
 * @return {List<SplitPanelBinding>}
 */
SplitBoxBinding.prototype.getSplitPanelBindings = function () {

	return this.getChildBindingsByLocalName ( "splitpanel" );
}

/**
 * Get splitter elements.
 * TODO: store result untill some kind of dirty flag is set
 * @return {List<DOMElement>}
 */
SplitBoxBinding.prototype.getSplitterElements = function () {

	return this.getChildElementsByLocalName ( "splitter" );
}

/**
 * Get splitter bindings.
 * @return {List<SplitterBinding>}
 */
SplitBoxBinding.prototype.getSplitterBindings = function () {

	return this.getChildBindingsByLocalName ( "splitter" );
}

/**
 * @overloads {FlexBoxBinding#fit}
 * @param {boolean} isForce
 */
SplitBoxBinding.prototype.fit = function ( isForce ) {
	
	if ( !this.isFit || isForce ) {
	
		if ( this.isHorizontalOrient ()) {
			
			var max = 0;
			var panels = this.getSplitPanelBindings ();
			panels.each ( function ( panel ) {
				var height = panel.bindingElement.offsetHeight;
				max = height > max ? height : max;
			});
			//if ( max > this._getFitnessHeight ()) { // check disabled!
				this._setFitnessHeight ( max );
			//}
		
		} else {
			
			// but wont this be easy to fix? just call super!
			throw "SplitBoxBinding enforceFitness not supported vertically!";
		}
		
		this.isFit = true;
	
	}
}

/**
 * SplitBoxBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {SplitBoxBinding}
 */
SplitBoxBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:splitbox", ownerDocument );
	return UserInterface.registerBinding ( element, SplitBoxBinding );
}

SplitPanelBinding.prototype = new ControlBoxBinding;
SplitPanelBinding.prototype.constructor = SplitPanelBinding;
SplitPanelBinding.superclass = ControlBoxBinding.prototype;
//SplitPanelBinding.MIN_WIDTH = 220;

/**
 * @class
 * Notice that we inherit ControlBoxBinding. This dependency can be assumed specific 
 * for stage layout splitboxes. Consider refactoring this (postponed for now 
 * because IE gets stressed by too many flexboxes).
 */
function SplitPanelBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SplitPanelBinding" );
	
	/** 
	 * @type {SplitBoxBinding} 
	 */
	this._containingSplitBoxBinding = null;
	
	/** 
	 * @type {boolean} 
	 */
	this.isCollapsed = false;
	
	/** 
	 * @type {boolean} 
	 */
	this.isFixed = false;
	
	/**
	 * @type {boolean}
	 */
	this.isVisible = true;
	
	/**
	 * @type {int}
	 */
	this._fixedSpan = null;
	
	/**
	 * This could in theory be disabled, but it fixes a rendering bug in Explorer.
	 * Notice that the property gets switched once in a while by the splitbox.
	 * @see {SplitBoxBinding#invokeLayout} 
	 * @overwrites {FlexBoxBinding#isFlexible}
	 * @type {boolean}
	 */
	this.isFlexible = true; //TRUE
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
SplitPanelBinding.prototype.toString = function () {

	return "[SplitPanelBinding]";
}

/*
SplitPanelBinding.prototype.serialize = function () {
	// ratio
	// ratiocache
	// collapsed
}
*/

/**
 * @overloads {ControlBoxBinding#onBindingAttach}
 */
SplitPanelBinding.prototype.onBindingAttach = function () {
	
	SplitPanelBinding.superclass.onBindingAttach.call ( this );
	
	this._containingSplitBoxBinding = this.getAncestorBindingByLocalName ( "splitbox" );
	this.attachClassName ( this._containingSplitBoxBinding.getOrient ());
	this.parseDOMProperties ();
}

/**
 * Parse DOM properties.
 */
SplitPanelBinding.prototype.parseDOMProperties = function () {
	
	// the type property is reflected in the CSS classname
	var type = this.getProperty ( "type" );
	if ( type ) {
		this.attachClassName ( type );
	}

	// implement fixed width
	var fix = this.getProperty ( "fix" );
	if ( fix ) {
		this.setFix ( fix );
	}
	
	var hidden = this.getProperty ( "hidden" );
	if ( hidden ) {
		this.hide ();
	}
}

/**
 * Collapse.
 */
SplitPanelBinding.prototype.collapse = function () {

	this.hide ();
	this.isCollapsed = true;
	this.setProperty ( "collapsed", "true" );
}

/**
 * Collapse.
 */
SplitPanelBinding.prototype.unCollapse = function () {

	this.show ();
	this.isCollapsed = false;
	this.deleteProperty ( "collapsed" );
}

/**
 * Hide.
 * @overwrites {Binding#hide}
 */
SplitPanelBinding.prototype.hide = function () {
	
	if ( this.isVisible == true ) {
		this.setProperty ( "ratiocache", this.getRatio ());
		this.setRatio ( 0 );
		this.bindingElement.style.display = "none"; // nescessary for Explorer!
		this.setProperty ( "hidden" , true );
		this.isVisible = false;
	}
}

/**
 * Show.
 * @overwrites {Binding#show}
 */
SplitPanelBinding.prototype.show = function () {

	if ( !this.isVisible ) {
		var ratiocache = this.getProperty ( "ratiocache" );
		if ( ratiocache ) {
		 	this.setRatio ( ratiocache );
			this.deleteProperty ( "ratiocache" );
		} else {
			this._containingSplitBoxBinding.computeLayout (); // ADDED!
		}
		this.bindingElement.style.display = "block";
		this.deleteProperty ( "hidden" );
		this.isVisible = true;
		
		/*
		} else {
			throw new Error ( "SplitPanelBinding: missing required property: ratiocache" );
		}
		*/
	}
}

/**
 * Set width.
 * @param {number} width
 */
SplitPanelBinding.prototype.setWidth = function ( width ) {

	if ( !this.isFixed  ) {
		if ( width != this.getWidth ()) {
			if ( width < 0 ) {
				width = this.getWidth (); // TODO: EXPLORER BUG!
				this.logger.warn ( "SplitPanelBinding#setWidth bug in Internet Explorer!" );
			}
			try {
				this.bindingElement.style.width = width + "px";
			} catch ( exception ) {
				alert ( "SplitPanelBinding#setWidth: Occult width: " + width );
				alert ( arguments.caller.callee );
			}
		}
	}
}

/**
 * Get width.
 * @return {number}
 */
SplitPanelBinding.prototype.getWidth = function () {

	var result = null;
	if ( this.isFixed ) {
		result = this.getFix ();
	} else {
		result = this.bindingElement.offsetWidth;
	}
	return result;
}

/**
 * Set width.
 * @param {number} height
 */
SplitPanelBinding.prototype.setHeight = function ( height ) {
	
	/*
	SystemDebug.stack ( arguments );
	this.logger.debug ( Math.random ())
	*/
	
	if ( !this.isFixed ) {
		if ( height != this.getHeight ()) {
			try {
				this.bindingElement.style.height = height + "px";
			} catch ( exception ) {
				alert ( "SplitPanelBinding.prototype.setHeight" + arguments.caller.callee );
			}
		}
	}
}

/**
 * Get height.
 * @return {number}
 */
SplitPanelBinding.prototype.getHeight = function () {

	var result = null;
	if ( this.isFixed ) {
		result = this.getFix ();
	} else {
		result = this.bindingElement.offsetHeight;
	}
	return result;
}

/**
 * Set ratio. This property is set by the {@link SplitBoxBinding}
 * @param {number} value
 */
SplitPanelBinding.prototype.setRatio = function ( value ) {

	this.setProperty ( "ratio", value );
}

/**
 * Get ratio. Remember to consider fixation when using the ratio.
 * @return {number}
 */
SplitPanelBinding.prototype.getRatio = function () {

	return this.getProperty ( "ratio" );
}

/**
 * Set or remove fix.
 * TODO: something is wrong with horizontal splitboxes - should be investigated.
 * @param {int} fixedspan Fixed span in pixels - use null or false to unfix.
 */
SplitPanelBinding.prototype.setFix = function ( fixedSpan ) {
	
	if ( fixedSpan ) {
		this._fixedSpan = fixedSpan;
		switch ( this._containingSplitBoxBinding.getOrient ()) {
			case SplitBoxBinding.ORIENT_HORIZONTAL :
				this.logger.warn ( "Fix not properly supported on horizontal splitboxes!" );
				this.setWidth ( fixedSpan ); /***/
				break;
			case SplitBoxBinding.ORIENT_VERTICAL :
				this.setHeight ( fixedSpan );
				break;
		}
		this.isFixed = true;
	} else {
		this._fixedSpan = null;
		this.isFixed = false;
		// TODO: should this recalculate splitbox layout?
	}
}

/**
 * Get fixed width/height.
 * @return {int}
 */
SplitPanelBinding.prototype.getFix = function () {
	
	return this._fixedSpan;
}

/**
 * SplitPanelBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {SplitPanelBinding}
 */
SplitPanelBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:splitpanel", ownerDocument );
	return UserInterface.registerBinding ( element, SplitPanelBinding );
}

SplitterBinding.prototype = new Binding;
SplitterBinding.prototype.constructor = SplitterBinding;
SplitterBinding.superclass = Binding.prototype;

SplitterBinding.DIMENSION = 8;
SplitterBinding.BUFFER = 30;

SplitterBinding.COLLAPSE_AFTER = "after";
SplitterBinding.COLLAPSE_BEFORE = "before";

SplitterBinding.ACTION_DRAGSTART = "splitter dragstart";
SplitterBinding.ACTION_DRAGGED = "splitter dragged";
SplitterBinding.ACTION_COLLAPSE = "splitter collapse";
SplitterBinding.ACTION_UNCOLLAPSE = "splitter uncollapse";

SplitterBinding.CLASSNAME_ACTIVE = "active";
SplitterBinding.CLASSNAME_HOVER = "hover";

/**
 * @class
 * TODO: extend FlexBoxBinding to fix rendering bug in explorer!
 */
function SplitterBinding () {

	/** 
	 * @type {SystemLogger} 
	 */
	this.logger = SystemLogger.getLogger ( "SplitterBinding" );
	
	/** 
	 * @type {boolean} 
	 */
	this.isDraggable = true;
	
	/** 
	 * @type {boolean} 
	 */
	this.isDragging = false;
	
	/** 
	 * @type {boolean} 
	 */
	this.isCollapsed = false;
	
	/**
	 * @type {boolean}
	 */
	this.isDisabled = true;
	
	/** 
	 * @type {SplitBoxBinding} 
	 */
	this._containingSplitBoxBinding = null;
	
	/** 
	 * @type {string} 
	 */
	this._collapseDirection = SplitterBinding.COLLAPSE_AFTER;
	
	/** 
	 * @type {int} 
	 */
	this.offset = null;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
SplitterBinding.prototype.toString = function () {

	return "[SplitterBinding]";
}

/**
 * Serialize binding.
 * Overloads {Binding#serialize}
 * @return {HashMap<string><object>}
 */
SplitterBinding.prototype.serialize = function () {
	
	var result = SplitBoxBinding.superclass.serialize.call ( this );
	if ( result ) {
		result.collapse = this.getProperty ( "collapse" );
		result.collapsed = this.getProperty ( "collapsed" );
		result.disabled = this.getProperty ( "isdisabled" );
	}
	return result;
}

/**
 * @overloads {Binding#onBindingAttach}
 */
SplitterBinding.prototype.onBindingAttach = function () {

	SplitterBinding.superclass.onBindingAttach.call ( this );
	
	this.addActionListener ( Binding.ACTION_DRAG );
	
	this._containingSplitBoxBinding = this.getAncestorBindingByLocalName ( "splitbox" );
	this.attachClassName ( this._containingSplitBoxBinding.getOrient ());
	this._collapseDirection = this.getProperty ( "collapse" );
	
	this.buildDOMContent ();
	this.attachDOMEvents ();
	
	var hidden = this.getProperty ( "hidden" );
	if ( hidden ) {
		this.hide ();
	}
}

/**
 * Build DOM content.
 */
SplitterBinding.prototype.buildDOMContent = function () {
	
	this.shadowTree.splitterBody = DOMUtil.createElementNS ( 
		Constants.NS_UI, "ui:splitterbody", this.bindingDocument
	);
	this.bindingElement.appendChild ( this.shadowTree.splitterBody );
	
	/*
	 * When stage splitpanels are unmaximized, the splitter 
	 * may dissapear in Mozilla unless we append some content.
	 */
	if ( Client.isMozilla == true ) {
		var text = this.bindingDocument.createTextNode ( "!" );
		this.bindingElement.appendChild ( text );
	}
}

/**
 * Attach DOM event listeners.
 */
SplitterBinding.prototype.attachDOMEvents = function () {
	
	this.addEventListener ( DOMEvents.MOUSEOVER );
	this.addEventListener ( DOMEvents.MOUSEOUT );
}

/**
 * Collapse. Containing SplitBoxBinding handles the splitpanels. Remember to 
 * uncollapse (ie, dont call this method twice with different directions). UDPATE TEXT????
 */
SplitterBinding.prototype.collapse = function () {
	
	if ( !this.isCollapsed ) {
		this.hide ();
		this.setProperty ( "collapsed", "true" );
		this.isCollapsed = true;
		this.dispatchAction ( SplitterBinding.ACTION_COLLAPSE );
	}
}

/**
 * Uncollapse.
 */
SplitterBinding.prototype.unCollapse = function () {
	
	if ( this.isCollapsed == true ) {
		this.show ();
		this.deleteProperty ( "collapsed" );
		this.isCollapsed = false;
		this.dispatchAction ( SplitterBinding.ACTION_UNCOLLAPSE );
	}
}

/**
 * Get collapse direction.
 * @return {string}
 */
SplitterBinding.prototype.getCollapseDirection = function () {
	
	return this._collapseDirection;
}

/**
 * Set collapse direction.
 * @param {string} direction
 */
SplitterBinding.prototype.setCollapseDirection = function ( direction ) {
	
	this.setProperty ( "collapse", direction );
	this._collapseDirection = direction;
}


/**
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
SplitterBinding.prototype.handleAction = function ( action ) {
	
	SplitterBinding.superclass.handleAction.call ( this, action );
	
	switch ( action.type ) {
		case Binding.ACTION_DRAG :
			this.dragger.registerHandler ( this );
			action.consume ();
			break;
	}
}

/**
 * @implements {IEventListener}
 * @overloads {Binding#handleEvent}
 * @param {MouseEvent} e
 */
SplitterBinding.prototype.handleEvent = function ( e ) {
	
	SplitterBinding.superclass.handleEvent.call ( this, e );
	
	var binding = this;
	
	if ( !this.isDragging && !this.isDisabled ) {
		switch ( e.type ) {
			case DOMEvents.MOUSEOVER :
				window.splitterTimeout = window.setTimeout ( function () {
					binding.shadowTree.splitterBody.className = SplitterBinding.CLASSNAME_HOVER;
				}, 250 );
				break;
			case DOMEvents.MOUSEOUT :
				if ( window.splitterTimeout ) {
					window.clearTimeout ( window.splitterTimeout );
				}
				if ( binding.shadowTree.splitterBody.className == SplitterBinding.CLASSNAME_HOVER ) {
					this.shadowTree.splitterBody.className = "";
				}
				break;
		}
	}
}

/**
 * Notice that the {@link StageSplitterBinding} overwrites this method.
 * @param {Point} point
 */
SplitterBinding.prototype.onDragStart = function ( point ) {
	
	this.attachClassName ( SplitterBinding.CLASSNAME_ACTIVE );
	this.shadowTree.splitterBody.className = SplitterBinding.CLASSNAME_ACTIVE;
	this.isDragging = true;
}

/**
 * Notice that the {@link StageSplitterBinding} overwrites this method.
 * @param {Point} diff
 */
SplitterBinding.prototype.onDrag = function ( diff ) {

	diff = this.getEvaluatedDiff ( diff );

	if ( this._containingSplitBoxBinding.isHorizontalOrient ()) {
		this.shadowTree.splitterBody.style.left = diff.x + "px";
	} else {
		this.shadowTree.splitterBody.style.top = diff.y + "px";
	}
}

/**
 * Dispatced action causes containing slitbox to redraw.
 * Notice that the {@link StageSplitterBinding} overwrites this method.
 * @see {SplitBoxBinding#handleAction}
 * @param {Point} diff
 */
SplitterBinding.prototype.onDragStop = function ( diff ) {

	diff = this.getEvaluatedDiff ( diff );

	/*
	 * Redraw containing layout
	 */
	this.offset = this._containingSplitBoxBinding.isHorizontalOrient () ? diff.x : diff.y;
	this.dispatchAction ( SplitterBinding.ACTION_DRAGGED );
	this.offset = null;
	
	/* 
	 * Reset splitter setup
	 */
	this.detachClassName ( SplitterBinding.CLASSNAME_ACTIVE );
	this.shadowTree.splitterBody.className = "";
	this.isDragging = false;
	
	if ( this._containingSplitBoxBinding.isHorizontalOrient ()) {
		this.shadowTree.splitterBody.style.left = "0";
	} else {
		this.shadowTree.splitterBody.style.top = "0";
	}
}

/**
 * Given a point, returns a point withing the allowed positioning area of the splitter.
 * @param {Point} diff
 * @return {Point}
 */
SplitterBinding.prototype.getEvaluatedDiff = function ( diff ) {
	
	switch ( this._containingSplitBoxBinding.getOrient ()) {
	
		case SplitBoxBinding.ORIENT_HORIZONTAL :
			var x = this.bindingElement.offsetLeft;
			var w = this.bindingElement.offsetWidth;
			var t = this.bindingElement.parentNode.offsetWidth;
			var min = - x + SplitterBinding.BUFFER;
			var max = t - x - w - SplitterBinding.BUFFER;
			diff.x = diff.x <= min ? min : diff.x;
			diff.x =  diff.x >= max ? max : diff.x;
			break;
		
		case SplitBoxBinding.ORIENT_VERTICAL :
			var y = this.bindingElement.offsetTop;
			var h = this.bindingElement.offsetHeight;
			var t = this.bindingElement.parentNode.offsetHeight;
			var min = - y + SplitterBinding.BUFFER;
			var max = t - y - h - SplitterBinding.BUFFER;
			diff.y = diff.y <= min ? min : diff.y;
			diff.y =  diff.y >= max ? max : diff.y;
			break;
	}
	return diff;
}

/**
 * Disable.
 */
SplitterBinding.prototype.disable = function () {
	
	if ( !this.isDisabled ) {
		alert ( "disable" );
		this.isDisabled = true;
		this.disableDragging ();
		this.setProperty ( "isdisabled", true );
	}
}

/**
 * Enable.
 */
SplitterBinding.prototype.enable = function () {
	
	if ( this.isDisabled == true ) {
		this.isDisabled = false;
		this.enableDragging ();
		this.deleteProperty ( "isdisabled" );
	}
}

/**
 * SplitterBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {SplitterBinding}
 */
SplitterBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:splitter", ownerDocument );
	return UserInterface.registerBinding ( element, SplitterBinding );
}

DecksBinding.prototype = new FlexBoxBinding;
DecksBinding.prototype.constructor = DecksBinding;
DecksBinding.superclass = FlexBoxBinding.prototype;
DecksBinding.ACTION_SELECTED = "decks deck selected";
DecksBinding.NODENAME_DECK = "deck";

/**
 * @class
 */
function DecksBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DecksBinding" );
	
	/**
	 * @type {DeckBinding}
	 */
	this._selectedDeckBinding = null;
	
	/**
	 * Storing decks dimensions in order to economize flex iterations.
	 * @see {DeckBinding#_invokeManagedRecursiveFlex}
	 * @type {Dimension}
	 */
	this._lastKnownDimension = null;
}

/**
 * Identifies binding.
 */
DecksBinding.prototype.toString = function () {

	return "[DecksBinding]";
}

/**
 * Overloads {FlexBoxBinding#onBindingRegister}
 */
DecksBinding.prototype.onBindingRegister = function () {

	DecksBinding.superclass.onBindingRegister.call ( this );
	this._lastKnownDimension = new Dimension ( 0, 0 );
	this.attachClassName ( "deckselement" );
}

/**
 * If no selected deck is specified, default select the first deck. The 
 * actual selection is invoked by the DeckBindings onBindingAttach method.
 * @overloads {Binding#onBindingAttach}
 */
DecksBinding.prototype.onBindingAttach = function () {

	DecksBinding.superclass.onBindingAttach.call ( this );
	
	var selectedindex = this.getProperty ( "selectedindex" );
	
	var decks = this.getDeckElements ();
	if ( decks.hasEntries ()) {
		var hasSelected = false;
		var index = 0;
		while ( decks.hasNext ()) {
			var deck = decks.getNext ();
			if ( selectedindex && index == selectedindex ) {
				deck.setAttribute ( "selected", "true" );
				hasSelected = true;
			} else if ( deck.getAttribute ( "selected" ) == "true" ) {
				hasSelected = true;
			}
			index ++;
		}
		if ( !hasSelected ) {
			decks.getFirst ().setAttribute ( "selected", "true" );
		}
	}
}

/**
 * Get deck elements.
 * @return {List<DOMElement>}
 */
DecksBinding.prototype.getDeckElements = function () {

	return this.getChildElementsByLocalName ( this.constructor.NODENAME_DECK );
}

/**
 * Select deck by one of three parameter types.
 * @param {object} arg This can be either an DOMElement, a DeckBinding or a string (element id).
 */
DecksBinding.prototype.select = function ( arg ) {

	var deckBinding = this.getBindingForArgument ( arg );
	
	if ( deckBinding != null ) {
		if ( deckBinding != this._selectedDeckBinding ) {
			if ( this._selectedDeckBinding ) {
				this._selectedDeckBinding.unselect ();
			}
			deckBinding.select ();
			this._selectedDeckBinding = deckBinding;
			var selectedindex = this.getProperty ( "selectedindex" );
			if ( selectedindex != null ) {
				this.setProperty ( 
					"selectedindex", 
					DOMUtil.getOrdinalPosition ( deckBinding.bindingElement, true )
				);
			}
			this.dispatchAction ( DecksBinding.ACTION_SELECTED );
			this.dispatchAction ( FocusBinding.ACTION_UPDATE );
		}
	} else {
		throw "No deck for argument " + arg;
	}
}

/**
 * Returns true if dimensions changed 
 * since method was lastly invoked.
 * @see {DeckBinding#_invokeManagedRecursiveFlex}
 * @return {boolean}
 */
DecksBinding.prototype.hasDimensionsChanged = function () {
	
	var result = false;
	var dim1 = this.boxObject.getDimension ();
	var dim2 = this._lastKnownDimension;
	
	if ( !Dimension.isEqual ( dim1, dim2 )) {
		result = true;
		this._lastKnownDimension = dim1;
	}
	
	return result;
}

/**
 * Get selected deck.
 * @return {DeckBinding}
 */
DecksBinding.prototype.getSelectedDeckBinding = function () {
	
	return this._selectedDeckBinding;
}

/**
 * DecksBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {DecksBinding}
 */
DecksBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:decks", ownerDocument );
	return UserInterface.registerBinding ( element, DecksBinding );
}

DeckBinding.prototype = new FlexBoxBinding;
DeckBinding.prototype.constructor = DeckBinding;
DeckBinding.superclass = FlexBoxBinding.prototype;

DeckBinding.ACTION_SELECTED = "deck selected";
DeckBinding.ACTION_UNSELECTED = "deck unselected";
DeckBinding.NODENAME_DECKS = "decks";
DeckBinding.CLASSNAME = "deckelement";

/**
 * @class
 */
function DeckBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DeckBinding" );
	
	/**
	 * @type {boolean}
	 */
	this.isSelected = false;
	
	/**
	 * @type {boolean}
	 */
	this.isVisible = false;
	
	/**
	 * @type {DecksBinding}
	 */
	this.containingDecksBinding = null;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
DeckBinding.prototype.toString = function () {

	return "[DeckBinding]";
}

/**
 * Assign special classname.
 * Overloads {Binding#onBindingRegister}
 */
DeckBinding.prototype.onBindingRegister = function () {

	DeckBinding.superclass.onBindingRegister.call ( this );
	this.addActionListener ( BalloonBinding.ACTION_INITIALIZE );
	this.attachClassName ( DeckBinding.CLASSNAME );
}

/**
 * Overloads {Binding#onBindingAttach}
 */
DeckBinding.prototype.onBindingAttach = function () {

	DeckBinding.superclass.onBindingAttach.call ( this );
	this.containingDecksBinding = this.getAncestorBindingByLocalName ( this.constructor.NODENAME_DECKS );
	if ( this.getProperty ( "selected" ) == true ) {
		this.containingDecksBinding.select ( this );
	}
}

/**
 * @implements {IActionListener}
 * @overloads {FlexBoxBinding#handleAction}
 * @param {Action} action
 */
DeckBinding.prototype.handleAction = function ( action ) {
	
	DeckBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	switch ( action.type ) {
		case BalloonBinding.ACTION_INITIALIZE :
			action.consume ();
			break;
	}
}

/**
 * Select deck. This method is invoked by the {@link DecksBinding}.
 */
DeckBinding.prototype.select = function () {
	
	if ( !this.isSelected ) {
	
		if ( this.isLazy == true ) {	
			this.wakeUp ( "select" );
		} else {
			
			this.isSelected = true;
			this.isVisible = true;	
			this.setProperty ( "selected", "true" );
			this.bindingElement.style.position = "static";
			
			/*
			 * Start flex iterator?
			 */
			this._invokeManagedRecursiveFlex ();
			
			/*
			 * Proudly announce.
			 */
			this.dispatchAction ( DeckBinding.ACTION_SELECTED );
			
			/*
			 * TODO: Even if seleted, focus shift should only be invoked   
			 * when no VISIBLE binding inside the dock has the current focus. 
			 */
			var root = UserInterface.getBinding ( this.bindingDocument.body );
			if ( root.isActivated ) {
				this.dispatchAction ( FocusBinding.ACTION_FOCUS );
			}
		}
	}
}

/**
 * Unselect deck. This method is invoked by the {@link DecksBinding}.
 */
DeckBinding.prototype.unselect = function () {
	
	if ( this.isSelected ) {
		
		/*
		 * Blur any focused binding within the tabpanel.
		 */
		this.dispatchAction ( FocusBinding.ACTION_BLUR );
		
		this.deleteProperty ( "selected" );
		this.isSelected = false;
		this.isVisible = false;
		this.bindingElement.style.position = "absolute";
		
		this.dispatchAction ( DeckBinding.ACTION_UNSELECTED );
	}
}

/**
 * Invoke recursive flex ONLY IF decks height 
 * has changed since last show (or when first shown).
 * TODO: This doesn't work!
 * TODO: Make this work!
 */
DeckBinding.prototype._invokeManagedRecursiveFlex = function () {
	
	this.reflex ( true ); // why true? Otherwise explorer decks dont work...
	
	/*
	if ( this.isAttached == true ) {
		if ( this.containingDecksBinding.hasDimensionsChanged ()) {
			this.reflex ();
		}
	}
	*/
}

/**
 * DeckBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {DeckBinding}
 */
DeckBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:deck", ownerDocument );
	return UserInterface.registerBinding ( element, DeckBinding );
}

ToolBarBinding.prototype = new Binding;
ToolBarBinding.prototype.constructor = ToolBarBinding;
ToolBarBinding.superclass = Binding.prototype;

ToolBarBinding.TYPE_TEXTONLY				= "textonly";
ToolBarBinding.TYPE_IMAGESONLY				= "imagesonly";
ToolBarBinding.TYPE_DEFAULT					= "imagesandtext";
ToolBarBinding.CLASSNAME_TEXTONLY 			= "textonly";
ToolBarBinding.CLASSNAME_IMAGESONLY 		= "imagesonly";
ToolBarBinding.CLASSNAME_IMAGESIZELARGE 	= "imagesizelarge";
ToolBarBinding.CLASSNAME_IMAGESIZEXLARGE 	= "imagesizexlarge";
ToolBarBinding.IMAGESIZE_NORMAL 			= "normal";
ToolBarBinding.IMAGESIZE_LARGE 				= "large";
ToolBarBinding.IMAGESIZE_XLARGE 			= "xlarge";

/**
 * @class
 * TODO: The toolbar is rigged up for quick disabling of images 
 * and text. This feature may be refactored out at some point...
 */
function ToolBarBinding () {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ToolBarBinding" );
	
	/**
	 * @type {boolean}
	 */
	this.hasImages = true;
	
	/**
	 * @type {boolean}
	 */
	this.hasText = true;
	
	/**
	 * @type {string}
	 */
	this._imageSize = ToolBarBinding.IMAGESIZE_NORMAL;
	
	/**
	 * @type {string}
	 */
	this.type = ToolBarBinding.TYPE_DEFAULT;
	
	/**
	 * Used to impose a default height to the toolbar.
	 * @type {boolean}
	 */
	this._hasDefaultContent = true;
	
	/**
	 * Right-aligned toolbarbody.
	 * @type {ToolBarBodyBinding}
	 * @private
	 */
	this._toolBarBodyRight = null;
	
	/**
	 * Left-aligned toolbarbody.
	 * @type {ToolBarBodyBinding}
	 * @private
	 */
	this._toolBarBodyLeft = null;
	
	/**
	 * Block common crawlers.
	 * @overwrites {Binding#crawlerFilters}
	 * @type {List<string>}
	 */
	this.crawlerFilters	= new List ([ FlexBoxCrawler.ID, FocusCrawler.ID, FitnessCrawler.ID ]);
	
	/**
	 * Enables us to invoke buildDOMContent already on binding registration. 
	 * This will come in handy when toolbar content is setup for lazy attachment.
	 * @type {boolean}
	 */
	this._hasDOMContent = false;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
ToolBarBinding.prototype.toString = function () {

	return "[ToolBarBinding]";
}

/**
 * Attach classname to clear stylesheet floats.
 */
ToolBarBinding.prototype.onBindingRegister = function () {
	
	ToolBarBinding.superclass.onBindingRegister.call ( this );
	this.attachClassName ( Binding.CLASSNAME_CLEARFLOAT );
}

/**
 * Initialize layout settings.
 */
ToolBarBinding.prototype.onBindingAttach = function () {
	
	ToolBarBinding.superclass.onBindingAttach.call ( this );
	
	this.parseDOMProperties ();
	this.buildDOMContent ();
	
	this.addMembers (
		this.getChildBindingsByLocalName ( "toolbarbody" )
	);
}

/**
 * Invoked when toolbarbodys initialize. Indexes left and right 
 * toolbarbody. More bodys can be added, but we don't handle them.
 * @param {ToolBarBodyBinding} binding
 */
ToolBarBinding.prototype.onMemberInitialize = function ( binding ) {
	
	/*
	 * The left toolbarbody is the first toolbar encounted NOT righ-taligned.
	 * The right toolbarbody is the first right-aligned toolbar encountered.
	 */
	if ( binding instanceof ToolBarBodyBinding ) {
		if ( binding.isRightAligned ) {
			if ( !this._toolBarBodyRight ) {
				this._toolBarBodyRight = binding;
			}
		} else {
			if ( !this._toolBarBodyLeft ) {
				this._toolBarBodyLeft = binding;
			}
		}
	}
	
	ToolBarBinding.superclass.onMemberInitialize.call ( this, binding );
}

/**
 * Initialize toolbar size and type.
 */
ToolBarBinding.prototype.parseDOMProperties = function () {

	var imagesize = this.getProperty ( "imagesize" );
	var type = this.getProperty ( "type" );
	
	if ( imagesize ) {
		this.setImageSize ( imagesize );
	}
	if ( type ) {
		this.setType ( type );
	} else {
		this.setType ( this.type );
	}
}

/**
 * Build an invisible toolbargroup to set the default toolbar height. This way, 
 * we don't need to specify a fixed toolbar height; we can let toolbarbuttons 
 * padding and margin control the height. Notice that the group is added directly 
 * to the toolbar itself and not to a toolbarbody. This way, the toolbargroup can 
 * be ignored in future code, but it implies that toolbarbodies *should not* affect 
 * the height of the toolbar (they should have no borders, margins and paddings).
 */
ToolBarBinding.prototype.buildDOMContent = function () {
	
	if ( this._hasDefaultContent == true && !this._hasDOMContent ) {
		var groupBinding = ToolBarGroupBinding.newInstance ( this.bindingDocument );
		groupBinding.add ( ToolBarButtonBinding.newInstance ( this.bindingDocument ));
		groupBinding.isDefaultContent = true;
		this.add ( groupBinding );
		groupBinding.attachRecursive ();
		this._hasDOMContent = true;
		
	}
}

/**
 * A special classname "max" will maximize a toolbargroups width.
 * @implements {IFlexible}
 */
ToolBarBinding.prototype.flex = function () {
	
	var left = this._toolBarBodyLeft;
	var right = this._toolBarBodyRight;
	
	if ( left != null && left.hasClassName ( "max" )) {
		this._maxToolBarGroup ( left, right );
	}
	
	if ( right != null && right.hasClassName ( "max" )) {
		this._maxToolBarGroup ( right, left );
	}
}

/**
 * This is pretty hacked...
 * @param {ToolBarGroupBinding} max
 * @param {ToolBarGroupBinding} other
 */
ToolBarBinding.prototype._maxToolBarGroup = function ( max, other ) {
	
	var width = this.boxObject.getDimension ().w;
	var padding = CSSComputer.getPadding ( this.bindingElement );
	width -= ( padding.left + padding.right );
	if ( other != null ) {
		width -= other.boxObject.getDimension ().w;
		if ( !Client.isWindows ) {
			width -= 1; // eh!
		}
		if ( Client.isExplorer ) {
			width -= 15; // // eeeeeeeeeeeeeeeeeeh!
		}
	}
	
	max.bindingElement.style.width = width + "px";
}

/**
 * Handy fetch toolbargroup by index.
 * @param {int} index 
 * @return {ToolBarGroupBinding}
 */
ToolBarBinding.prototype.getToolBarGroupByIndex = function ( index ) {
	
	return this.getDescendantBindingsByLocalName ( "toolbargroup" ).get ( index );
}

/**
 * Add toolbargroup left-aligned.
 * @param {Binding} binding
 * @param {boolean} isBulkAdd Minimize css engine work
 * @return {Binding}
 */
ToolBarBinding.prototype.addLeft = function ( binding, isBulkAdd ) {

	var returnable = null;
	if ( this._toolBarBodyLeft != null ) {
		returnable = this._toolBarBodyLeft.add ( binding, isBulkAdd );
	} else {
		throw new Error ( "No left toolbarbody" );
	}
	return returnable;
}

/**
 * Add toolbargroup left-aligned first.
 * @param {Binding} binding
 * @param {boolean} isBulkAdd
 * @return {Binding}
 */
ToolBarBinding.prototype.addLeftFirst = function ( binding, isBulkAdd ) {

	var returnable = null;
	if ( this._toolBarBodyLeft ) {
		returnable = this._toolBarBodyLeft.addFirst ( binding, isBulkAdd );
	} else {
		throw new Error ( "No left toolbarbody" );
	}
	return returnable;
}

/**
 * Add toolbargroup right-aligned.
 */
ToolBarBinding.prototype.addRight = function ( binding ) {

	var returnable = null;
	if ( this._toolBarBodyRight ) {
		returnable = this._toolBarBodyRight.add ( binding );
	} else {
		throw new Error ( "No left toolbarbody" );
	}
	return returnable;
}

/**
 * Please dispose toolbar content with this method, taking care not to dispose toolbarbodies.
 */
ToolBarBinding.prototype.empty = function () {

	this.emptyLeft ();
	this.emptyRight ();
}

/**
 * Dispose left-aligned toolbar content.
 */
ToolBarBinding.prototype.emptyLeft = function () {

	if ( this._toolBarBodyLeft ) {
 		this._toolBarBodyLeft.empty ();
	}
}

/**
 * Dispose right-aligned toolbar content.
 */
ToolBarBinding.prototype.emptyRight = function () {

	if ( this._toolBarBodyRight ) {
 		this._toolBarBodyRight.empty ();
	}
}

/** 
 * Set image size.
 * @param {string} size
 */
ToolBarBinding.prototype.setImageSize = function ( size ) {

	switch ( size ) {
		case ToolBarBinding.IMAGESIZE_LARGE :
			this.attachClassName ( ToolBarBinding.CLASSNAME_IMAGESIZELARGE );
			this.detachClassName ( ToolBarBinding.CLASSNAME_IMAGESIZEXLARGE );
			break;
		case ToolBarBinding.IMAGESIZE_XLARGE :
			this.attachClassName ( ToolBarBinding.CLASSNAME_IMAGESIZEXLARGE );
			this.detachClassName ( ToolBarBinding.CLASSNAME_IMAGESIZELARGE );
			break;
		default :
			this.detachClassName ( ToolBarBinding.CLASSNAME_IMAGESIZELARGE );
			this.detachClassName ( ToolBarBinding.CLASSNAME_IMAGESIZEXLARGE );
			break;
	}
	this._imageSize = size;
	this.setProperty ( "imagesize", size );
}

/**
 * @return {string}
 */
ToolBarBinding.prototype.getImageSize = function () {
	
	return this._imageSize;
}

/** 
 * Show images only. Constructed so that you can't disable both images and text.
 */
ToolBarBinding.prototype.showImagesOnly = function () {
	
	this.detachClassName ( ToolBarBinding.CLASSNAME_TEXTONLY );
	this.attachClassName ( ToolBarBinding.CLASSNAME_IMAGESONLY );
	this.hasImages = true;
	this.hasText = false;
}

/**
 * Show text only.
 */
ToolBarBinding.prototype.showTextOnly = function () {
	
	this.detachClassName ( ToolBarBinding.CLASSNAME_IMAGESONLY );
	this.attachClassName ( ToolBarBinding.CLASSNAME_TEXTONLY );
	this.hasImages = false;
	this.hasText = true;
}

/**
 * Show both images and text.
 */
ToolBarBinding.prototype.showBoth = function () {
	
	this.detachClassName ( ToolBarBinding.CLASSNAME_IMAGESONLY );
	this.detachClassName ( ToolBarBinding.CLASSNAME_TEXTONLY );
	this.hasImages = true;
	this.hasText = true;
}

/**
 * Set type.
 * @param {string} type 
 */
ToolBarBinding.prototype.setType = function ( type ) {
	
	switch ( type ) {
		case ToolBarBinding.TYPE_TEXTONLY :
			this.showTextOnly ();
			break;
		case ToolBarBinding.TYPE_IMAGESONLY :
			this.showImagesOnly ();
			break;
		default :
			this.showBoth ();
			break
	}
	this.setProperty ( "type", type );
}

/**
 * ToolBarBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {ToolBarBinding}
 */
ToolBarBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:toolbar", ownerDocument );
	return UserInterface.registerBinding ( element, ToolBarBinding );
}

ToolBarBodyBinding.prototype = new Binding;
ToolBarBodyBinding.prototype.constructor = ToolBarBodyBinding;
ToolBarBodyBinding.superclass = Binding.prototype;

/**
 * @class
 */
function ToolBarBodyBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ToolBarBodyBinding" );
	
	/**
	 * @type {boolean}
	 */
	this.isRightAligned = false;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
ToolBarBodyBinding.prototype.toString = function () {

	return "[ToolBarBodyBinding]";
}

/**
 * Overloads {Binding#onBindingAttach}
 */
ToolBarBodyBinding.prototype.onBindingAttach = function () {

	ToolBarBodyBinding.superclass.onBindingAttach.call ( this );
	
	this.addMembers (
		this.getChildBindingsByLocalName ( "toolbargroup" )
	);
	if ( this.getProperty ( "align" ) == "right" || this.isRightAligned ) {
		this.alignRight ();
	}
}

/**
 * Fires when children toolbargroups are initialized.
 * @overloads {Binding#onBindingInitialize}
 */
ToolBarBodyBinding.prototype.onBindingInitialize = function () {

	this.refreshToolBarGroups ();
	ToolBarBodyBinding.superclass.onBindingInitialize.call ( this );
}

/**
 * Invoke right-aligned layout.
 */
ToolBarBodyBinding.prototype.alignRight = function () {

	this.attachClassName ( "alignright" );
	this.setProperty ( "align", "right" );
	this.isRightAligned = true;
}


/** 
 * Refresh the visual appearance of toolbargroups. 
 * First and last group shall not show toolbarseparators. 
 * Explorer cannot fix this using CSS in retarded rendering mode.
 */
ToolBarBodyBinding.prototype.refreshToolBarGroups = function () {

	var allGroups = this.getDescendantBindingsByLocalName ( "toolbargroup" );
	var groups = new List ();
	var isFirst = true;
	
	/*
	 * Only counting visible groups. 
	 * Not counting default content.
	 */
	allGroups.each ( function ( group ) {
		if ( group.isVisible && !group.isDefaultContent ) {
			groups.add ( group );
		}
	});
	
	while ( groups.hasNext ()) {
		var group = groups.getNext ();
		group.setLayout ( ToolBarGroupBinding.LAYOUT_DEFAULT );
		if ( isFirst ) {
			group.setLayout ( ToolBarGroupBinding.LAYOUT_FIRST );
			isFirst = false;
		}
		if ( !groups.hasNext ()) {
			group.setLayout ( ToolBarGroupBinding.LAYOUT_LAST );
		}
	};
	
	if ( this.getProperty ( "equalsize" )) {
		this.enforceEqualSize ();
	}
}

/**
 * TODO: cache max?
 * TODO: enable equalsize for toolbarbuttons (not just clickbuttons)? But we only use this in dialogs...
 */
ToolBarBodyBinding.prototype.enforceEqualSize = function () {
	
	var max = 0, list = this.getDescendantBindingsByLocalName ( "clickbutton" );
	
	while ( list.hasNext ()) {
		var button = list.getNext ();
		var width = button.getEqualSizeWidth ();
		if ( width > max ) {
			max = width;
		}
	}
	if ( max != 0 ) {
		list.reset ();
		while ( list.hasNext ()) {
			var button = list.getNext ();
			button.setEqualSizeWidth ( max );		
		}
	}
}

/**
 * Dispose toolbarbody content.
 */
ToolBarBodyBinding.prototype.empty = function () {
	
	this.detachRecursive ();
	this.bindingElement.innerHTML = "";
}

/**
 * Update layout when new toolbargroup is added. 
 * @overwrites {Binding#add}
 * @param {Binding} binding
 * @param {boolean} isBulkAdd Minimize css engine work
 * @return {Binding}
 */
ToolBarBodyBinding.prototype.add = function ( binding, isBulkAdd ) {

	var returnable = ToolBarBinding.superclass.add.call ( this, binding );
	if ( !isBulkAdd ) {
		if ( binding instanceof ToolBarGroupBinding && this.isAttached ) {
			this.refreshToolBarGroups ();
		}
	}
	return returnable;
}

/**
 * Update layout when new toolbargroup is added.
 * @overwrites {Binding#addFirst}
 * @param {Binding} binding
 * @param {boolean} isBulkAdd
 * @return {Binding}
 */
ToolBarBodyBinding.prototype.addFirst = function ( binding, isBulkAdd ) {

	var returnable = ToolBarBinding.superclass.addFirst.call ( this, binding );
	if ( !isBulkAdd ) {
		if ( binding instanceof ToolBarGroupBinding && this.isAttached ) {
			this.refreshToolBarGroups ();
		}
	}
	return returnable;
}

/**
 * This will enable or disable ALL contained bindings that implement IFocusable.
 * TODO: THIS IS NOT USED NOWHERE...
 * @param {boolean} isDisabled
 *
ToolBarBodyBinding.prototype.setDisabled = function ( isDisabled ) {
	
	var bindings = this.getDescendantBindingsByLocalName ( "*" );
	while ( bindings.hasNext ()) {
		var binding = bindings.getNext ();
		if ( Interfaces.isImplemented ( IFocusable, binding )) {
			if ( typeof binding.setDisabled != Types.UNDEFINED ) {
				binding.setDisabled ( isDisabled );
			} else {
				throw "Could not disable focusable " + binding.toString ();
			}
		}
	}
}
*/

/**
 * ToolBarBodyBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {ToolBarBodyBinding}
 */
ToolBarBodyBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:toolbarbody", ownerDocument );
	return UserInterface.registerBinding ( element, ToolBarBodyBinding );
}

ToolBarGroupBinding.prototype= new RadioGroupBinding;
ToolBarGroupBinding.prototype.constructor = ToolBarGroupBinding;
ToolBarGroupBinding.superclass = RadioGroupBinding.prototype;

ToolBarGroupBinding.LAYOUT_DEFAULT = 0;
ToolBarGroupBinding.LAYOUT_FIRST = 1;
ToolBarGroupBinding.LAYOUT_LAST = 2;

ToolBarGroupBinding.CLASSNAME_DEFAULTCONTENT = "defaultcontent";

/**
 * @class
 */
function ToolBarGroupBinding () {

	/** 
	 * @type {SystemLogger} 
	 */
	this.logger = SystemLogger.getLogger ( "ToolBarGroupBinding" );
	
	/** 
	 * @type {boolean}
	 */
	this.isDefaultContent = false;
}

/**
 * Identifies binding.
 */
ToolBarGroupBinding.prototype.toString = function () {

	return "[ToolBarGroupBinding]";
}

/**
 * Assign special classname to defaultcontent toolbargroup. 
 * Overloads {Binding#onBindingAttach}
 * @see {ToolBarBinding#addDefaultContent}
 */
ToolBarGroupBinding.prototype.onBindingAttach = function () {
	
	ToolBarGroupBinding.superclass.onBindingAttach.call ( this );
	
	this.addMembers (
		this.getDescendantBindingsByLocalName ( "toolbarbutton" )
	);
	this.addMembers (
		this.getDescendantBindingsByLocalName ( "toolbarlabel" )
	);
	this.addMembers (
		this.getDescendantBindingsByLocalName ( "clickbutton" )
	);
	if ( this.isDefaultContent == true ) {
		this.attachClassName ( ToolBarGroupBinding.CLASSNAME_DEFAULTCONTENT );
	}
}

/**
 * Set layout. This method is invoked by the {@link ToolBarBodyBinding}.
 * @param {int} layout
 */
ToolBarGroupBinding.prototype.setLayout = function ( layout ) {

	switch ( layout ) {
		case ToolBarGroupBinding.LAYOUT_DEFAULT :
			this.detachClassName ( "first" );
			this.detachClassName ( "last" );
			break;
		case ToolBarGroupBinding.LAYOUT_FIRST :
			this.attachClassName ( "first" );
			break;	
		case ToolBarGroupBinding.LAYOUT_LAST :
			this.attachClassName ( "last" );
			break;
	}
}

/**
 * Refresh toolbar layout when a group gets shown.
 * @overloads {Binding#show}
 */
ToolBarGroupBinding.prototype.show = function () {
	
	ToolBarGroupBinding.superclass.show.call ( this );
	var parent = this.bindingElement.parentNode;
	if ( DOMUtil.getLocalName ( parent ) == "toolbarbody" ) {
		UserInterface.getBinding ( parent ).refreshToolBarGroups ();		
	}
}

/**
 * Refresh toolbar layout when a group gets hidden.
 * @overloads {Binding#hide}
 */
ToolBarGroupBinding.prototype.hide = function () {
	
	ToolBarGroupBinding.superclass.hide.call ( this );
	var parent = this.bindingElement.parentNode;
	if ( DOMUtil.getLocalName ( parent ) == "toolbarbody" ) {
		UserInterface.getBinding ( parent ).refreshToolBarGroups ();		
	}
}

/**
 * ToolBarGroupBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {ToolBarGroupBinding}
 */
ToolBarGroupBinding.newInstance = function ( ownerDocument ) {

	var toolbargroup = DOMUtil.createElementNS ( Constants.NS_UI, "ui:toolbargroup", ownerDocument );
	return UserInterface.registerBinding ( toolbargroup, ToolBarGroupBinding );
}

ToolBarButtonBinding.prototype = new ButtonBinding;
ToolBarButtonBinding.prototype.constructor = ToolBarButtonBinding;
ToolBarButtonBinding.superclass = ButtonBinding.prototype;

/**
 * @class
 */
function ToolBarButtonBinding () {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ToolBarButtonBinding" );
}

/**
 * Identifies binding.
 */
ToolBarButtonBinding.prototype.toString = function () {

	return "[ToolBarButtonBinding]";
}

/**
 * ToolBarButtonBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {ToolBarButtonBinding}
 */
ToolBarButtonBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:toolbarbutton", ownerDocument );
	return UserInterface.registerBinding ( element, ToolBarButtonBinding );
}

ToolBarLabelBinding.prototype = new Binding;
ToolBarLabelBinding.prototype.constructor = ToolBarLabelBinding;
ToolBarLabelBinding.superclass = Binding.prototype;

/**
 * @class
 * Simple text (and possibly an image) on the toolbar.
 */
function ToolBarLabelBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ToolBarLabelBinding" );
}

/**
 * Identifies binding.
 */
ToolBarLabelBinding.prototype.toString = function () {
	
	return "[ToolBarLabelBinding]";
}

/**
 * @overloads {Binding#onBindingAttach}
 */
ToolBarLabelBinding.prototype.onBindingAttach = function () {
	
	ToolBarLabelBinding.superclass.onBindingAttach.call ( this );
	
	this._labelBinding = this.add ( LabelBinding.newInstance ( this.bindingDocument ));
	this.shadowTree.label = this._labelBinding;
	
	var label = this.getProperty ( "label" );
	var image = this.getProperty ( "image" );
	
	if ( label ) {
		this.setLabel ( label );
	}
	
	if ( image ) {
		this.setImage ( image );
	}
}

/**
 * Set label.
 * @param {string} label
 * @param {boolean} isNotBuildingClassName Set to true for faster screen update.
 */
ToolBarLabelBinding.prototype.setLabel = function ( label, isNotBuildingClassName ) {
	
	if ( this.isAttached ) {
		this._labelBinding.setLabel ( label, isNotBuildingClassName );
	}
	this.setProperty ( "label", label );
}

/**
 * Set image.
 * @param {string} image
 * @param {boolean} isNotBuildingClassName Set to true for faster screen update.
 */
ToolBarLabelBinding.prototype.setImage = function ( image, isNotBuildingClassName ) {
	
	if ( this.isAttached ) {
		this._labelBinding.setImage ( image, isNotBuildingClassName );
	}
	this.setProperty ( "image", image );
}

/**
 * ToolBarLabelBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {ToolBarLabelBinding}
 */
ToolBarLabelBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:toolbarlabel", ownerDocument );
	return UserInterface.registerBinding ( element, ToolBarLabelBinding );
}

DialogToolBarBinding.prototype = new ToolBarBinding;
DialogToolBarBinding.prototype.constructor = DialogToolBarBinding;
DialogToolBarBinding.superclass = ToolBarBinding.prototype;

/**
 * @class
 * TODO: move this file somewhere else...
 */
function DialogToolBarBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DialogToolBarBinding" );
	
	/**
	 * @type {List<ClickButtonBinding>}
	 */
	this._buttons = null;
	
	/**
	 * @type {ClickButtonBinding}
	 */
	this._defaultButton = null;
	
	/**
	 * @type {ClickButtonBinding}
	 */
	this._focusedButton = null;
	
	/** 
	 * Listening for ENTER keypress?
	 * @type {boolean}
	 */
	this._isListening = false;
	
	/**
	 * ALLOW focuscrawler! It was blocked by super class.
	 * @overwrites {ToolBarBinding#crawlerFilters}
	 * @type {List<string>}
	 */
	this.crawlerFilters	= new List ([ FlexBoxCrawler.ID ]);
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
DialogToolBarBinding.prototype.toString = function () {
	
	return "[DialogToolBarBinding]";
}

/**
 * @overloads {ToolBarBinding#onBindingRegister}
 */
DialogToolBarBinding.prototype.onBindingRegister = function () {
	
	DialogToolBarBinding.superclass.onBindingRegister.call ( this );
	
	this.addActionListener ( Binding.ACTION_FOCUSED );
	this.addActionListener ( Binding.ACTION_BLURRED );
}

/**
 * @overloads {ToolBarBinding#onBindingDispose}
 */
DialogToolBarBinding.prototype.onBindingDispose = function () {

	DialogToolBarBinding.superclass.onBindingDispose.call ( this );
	if ( this._isListening == true ) {
		this.unsubscribe ( BroadcastMessages.KEY_ENTER );
	}
}

/**
 * @overloads {ToolBarBinding#onBindingInitialize}
 */
DialogToolBarBinding.prototype.onBindingInitialize = function () {
	
	this.indexDialogButtons ();
	DialogToolBarBinding.superclass.onBindingInitialize.call ( this );
}

/**
 * Index dialog buttons. Invoke this manually when adding new buttons.
 */
DialogToolBarBinding.prototype.indexDialogButtons = function () {

	var buttons = this.getDescendantBindingsByLocalName ( "clickbutton" );
	
	if ( buttons.hasEntries ()) {
		while ( buttons.hasNext ()) {
			var button = buttons.getNext ();
			if ( button.isDefault ) {
				this._defaultButton = button;
				button.attachClassName ( ButtonBinding.CLASSNAME_DEFAULT );
			}
			if ( !this._isListening && button.isFocusable ) {
				this.subscribe ( BroadcastMessages.KEY_ENTER );
				this._isListening = true;
			}
		}
		this._buttons = buttons;
	}
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
DialogToolBarBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	DialogToolBarBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		case BroadcastMessages.KEY_ENTER :
			
			/*
			 * Don't close the dialog while a popup is handled!
			 */
			if ( !PopupBinding.hasActiveInstances ()) {
				
				/*
				 * Only close active dialogs (don't close a chain of dialogs)!
				 */
				var dialog = this.getAncestorBindingByType ( DialogBinding, true );
				if ( dialog && dialog.isActive ) {
					if ( this._focusedButton ) {
						if ( !this._focusedButton.isDisabled ) {
							this.unsubscribe ( BroadcastMessages.KEY_ENTER );
							this._focusedButton.fireCommand ();
						}
					} else {
						if ( !this._defaultButton.isDisabled ) {
							this.unsubscribe ( BroadcastMessages.KEY_ENTER );
							this._defaultButton.fireCommand ();
						}
					}
				}
			}
			break;
	}
}

/**
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
DialogToolBarBinding.prototype.handleAction = function ( action ) {
	
	DialogToolBarBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	var isFocused = false;
	var buttons = this._buttons.reset ();
	
	if ( binding instanceof ClickButtonBinding ) {
		switch ( action.type ) {
			case Binding.ACTION_FOCUSED :
				binding.attachClassName ( ButtonBinding.CLASSNAME_FOCUSED );
				this._focusedButton = binding;
				if ( this._defaultButton ) {
					this._defaultButton.detachClassName ( ButtonBinding.CLASSNAME_DEFAULT );
				}
				break;
			case Binding.ACTION_BLURRED :
				binding.detachClassName ( ButtonBinding.CLASSNAME_FOCUSED );
				break;
		}
	}
	
	/*
	 * When focus leaves the toolbar, restore default focus.
	 */
	if ( this._defaultButton ) {
		while ( !isFocused && buttons.hasNext ()) {
			var button = buttons.getNext ();
			isFocused = button.isFocused;
		}
		if ( !isFocused ) {
			this._defaultButton.attachClassName ( ButtonBinding.CLASSNAME_DEFAULT );
			this._focusedButton = null;
		}
	}
}

ToolBoxToolBarButtonBinding.prototype = new ToolBarButtonBinding;
ToolBoxToolBarButtonBinding.prototype.constructor = ToolBoxToolBarButtonBinding;
ToolBoxToolBarButtonBinding.superclass = ToolBarButtonBinding.prototype;

/**
 * @class
 */
function ToolBoxToolBarButtonBinding () {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ToolBoxToolBarButtonBinding" );
	
	/**
	 * Associates viewdefinitions to perspective tags. 
	 * @type {Map<string><List<<ViewDefinition>>}
	 */
	this._views = new Map ();
	
	/**
	 * Avoid excessive popup building.
	 * @type {string}
	 */
	this._lastGeneratedPerspective = null;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
ToolBoxToolBarButtonBinding.prototype.toString = function () {

	return "[ToolBoxToolBarButtonBinding]";
}

/**
 * @overloads {ButtonBinding#onBindingAttach}
 */
ToolBoxToolBarButtonBinding.prototype.onBindingAttach = function () {
	
	ToolBoxToolBarButtonBinding.superclass.onBindingAttach.call ( this );
	
	if ( System.hasActivePerspectives ) {
	
		this.subscribe ( BroadcastMessages.PERSPECTIVE_CHANGED );
		
		/**
		 * Scan ViewDefinitions, indexing definitions associated  
		 * to a perspective (by the "perspective" property no less).
		 */
		var views = this._views;
		for ( var handle in ViewDefinitions ) {
			var def = ViewDefinitions [ handle ];
			var key = def.perspective; 
			if ( key != null ) {
				if ( !views.has ( key )) {
					views.set ( key, new List ());
				}
				var list = views.get ( key );
				list.add ( def );
			}
		}
	} else {
		this.hide ();
	}
};

/**
 * Build popup when perspective changes. If no 
 * views are associated, the button will disable.
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
ToolBoxToolBarButtonBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	ToolBoxToolBarButtonBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		case BroadcastMessages.PERSPECTIVE_CHANGED :
			var tag = arg;
			if ( this._views.has ( tag )) {
				
				if ( tag != this._lastGeneratedPerspective ) {
					
					this._lastGeneratedPerspective = tag;
					var list = this._views.get ( tag );
					var popup = this.bindingWindow.bindingMap.toolboxpopup;
					popup.empty ();
					
					list.each ( function ( def ) {
						var item = popup.add ( StageViewMenuItemBinding.newInstance ( popup.bindingDocument ));
						item.setType ( MenuItemBinding.TYPE_CHECKBOX );
						item.setHandle ( def.handle );
						item.setLabel ( def.label );
						item.setImage ( def.image );
						item.setToolTip ( def.toolTip );
						item.attach ();
					});
				}				
				this.enable ();
			} else {
				this.disable ();
			}
			break;
	}
}

TreeBinding.prototype = new FlexBoxBinding;
TreeBinding.prototype.constructor = TreeBinding;
TreeBinding.superclass = FlexBoxBinding.prototype;

TreeBinding.ACTION_SELECTIONCHANGED 	= "tree selection changed";
TreeBinding.ACTION_NOSELECTION 			= "tree selection none";
TreeBinding.SELECTIONTYPE_SINGLE 		= "single";
TreeBinding.SELECTIONTYPE_MULTIPLE 		= "multiple";

/**
 * Snap to nearest treenode position.
 * @param {int} value
 */
TreeBinding.grid = function ( value ) {
	
	var number = TreeNodeBinding.HEIGHT;
	var ceil = Math.ceil ( value ); // TODO: Aren't we forgetting to use this?
	var remainder = value % number;
	if ( remainder > 0 ) {
		value = value - remainder + number;
	}
  	return value + TreeBodyBinding.PADDING_TOP;
}



/**
 * @class
 * @implements {IFocusable}
 */
function TreeBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "TreeBinding" );
	
	/**
	 * Disabled!!!
	 * @implements {IFocusable}
	 * @type {boolean}
	 */
	this.isFocusable = true;
	
	/**
	 * Disabled!!!
	 * @implements {IFocusable}
	 * @type {boolean}
	 */
	this.isFocused = false;
	
	/**
	 * @type {TreeBodyBinding}
	 */
	this._treeBodyBinding = null;
	
	/**
	 * @type {TreePositionIndicatorBinding}
	 */
	this._positionIndicatorBinding = null;
	
	/**
	 * Added TreeNodes will be stored in this buffer 
	 * until the onBindingAttach method is called  
	 * so that we can buld trees in off-DOM memory.
	 */
	this._treeNodeBuffer = null;
	
	/**
	 * Tracking all treenodes present in the tree.
	 * @param {Map<string><TreeNodeBinding>}
	 */
	this._treeNodeBindings = null;

	/**
	 * TODO: Refactor this to a Map, maintaining a List is stressed out!
	 * @type {List<TreeNodeBinding>}
	 */
	this._focusedTreeNodeBindings = null;
	
	/**
	 * Are treenodes focusable?
	 * @type {boolean}
	 */
	this._isFocusable = true;
	
	/**
	 * Special for tree selection stuff in dialogs. 
	 * Not to be confused with focusable stuff!
	 * @type {boolean}
	 */
	this._isSelectable = false;
	
	/**
	 * Special for tree selection stuff in dialogs.
	 * @type {string>
	 */
	this._selectionProperty = null;
	
	/** 
	 * Special for tree selection stuff in dialogs.
	 * @type {HashMap<string><boolean>}
	 */
	this._selectonValue = null;
	
	/**
	 * @type {HashMap<string><TreeNodeBinding>}
	 */
	this._selectedTreeNodeBindings = null;
	
	/**
	 * @type {string}
	 */
	this._selectionType = TreeBinding.SELECTIONTYPE_SINGLE;
	
	/**
	 * @type {Position}
	 */
	this._acceptingPosition = null;
	
	/**
	 * @type {Dimension}
	 */
	this._acceptingDimension = null;
	
	/**
	 * @type {TreeNodeBinding}
	 */
	this._acceptingTreeNodeBinding = null;
	
	/**
	 * @type {HashMap<int><boolean>}
	 */
	this._acceptingPositions = null;
	
	/**
	 * Block common crawlers.
	 * @overwrites {Binding#crawlerFilters}
	 * @type {List<string>}
	 */
	this.crawlerFilters	= new List ([ FlexBoxCrawler.ID, FocusCrawler.ID, FitnessCrawler.ID ]);
	
	/**
	 * Intercepting keys for navigation?
	 * @type {boolean}
	 */
	this._hasKeyboard = false;
	
	/**
	 * @type {int}
	 */
	this._yposition = 0;
	
	/**
	 * TEMP solution to backup treenodes open-state on UpdateManager refreshes.
	 * @type {Map<String>}
	 */
	this._openTreeNodesBackupMap = null;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
TreeBinding.prototype.toString = function () {

	return "[TreeBinding]";
}

/**
 * @overloads {FlexBoxBinding#onBindingRegister}
 */
TreeBinding.prototype.onBindingRegister = function () {

	TreeBinding.superclass.onBindingRegister.call ( this );
	
	this._treeNodeBindings = new Map ();
	this._treeNodeBuffer = new List ();
	this._focusedTreeNodeBindings = new List ();
}

/**
 * @overloads {Binding#onBindingAttach}
 */
TreeBinding.prototype.onBindingAttach = function () {
	
	TreeBinding.superclass.onBindingAttach.call ( this );
	
	var focusable = this.getProperty ( "focusable" );
	if ( focusable != null ) {
		this._isFocusable = focusable;
	}
	
	if ( !this._treeBodyBinding ) {
		this._treeBodyBinding = this.addMember ( 
			this.getChildBindingByLocalName ( "treebody" )
		);
	}
	if ( !this._treeBodyBinding ) {
		
		var cry = "TreeBinding structure invalid. Missing TreeBodyBinding.";
		this.logger.error ( cry );
		if ( Application.isDeveloperMode ) {
			alert ( cry );
		}
		
	} else {
		
		this.addActionListener ( Binding.ACTION_ACTIVATED );
		this.addActionListener ( TreeNodeBinding.ACTION_OPEN );
		this.addActionListener ( TreeNodeBinding.ACTION_CLOSE );
		this.addActionListener ( TreeNodeBinding.ACTION_DISPOSE );
		
		if ( this._isFocusable ) {
			this.addActionListener ( TreeNodeBinding.ACTION_ONFOCUS );
			this.addActionListener ( TreeNodeBinding.ACTION_ONMULTIFOCUS );
			this.addActionListener ( TreeNodeBinding.ACTION_BLUR );
		}

		// TODO: only if we contain typedraggable treenodes...
		this.subscribe ( BroadcastMessages.TYPEDRAG_START );
		this.subscribe ( BroadcastMessages.TYPEDRAG_STOP );
		
		this.addEventListener ( DOMEvents.BEFOREUPDATE );
		this.addEventListener ( DOMEvents.AFTERUPDATE );
	}
}

/**
 * Flush treenode buffer when the treebody is initalized. 
 * Alternatively, populate tree from updatepanel builder.
 * @overloads {Binding#onBindingInitialize}
 */
TreeBinding.prototype.onBindingInitialize = function () {
	
	TreeBinding.superclass.onBindingInitialize.call ( this );
	
	this._setupTreeSelection ();
	
	var builder = this.getProperty ( "builder" );
	if ( builder ) {
		this._buildFromTextArea ( builder );
	} else if ( this._treeNodeBuffer.hasEntries ()) {
		while ( this._treeNodeBuffer.hasNext ()) {
			this.add ( this._treeNodeBuffer.getNext ());
		}
	}
}

/**
 * Setup selection.
 */
TreeBinding.prototype._setupTreeSelection = function () {

	var isSelectable = this.getProperty ( "selectable" );
	var selectionProperty = this.getProperty ( "selectionproperty" );
	var selectionValue = this.getProperty ( "selectionvalue" );
	
	if ( isSelectable ) {
		this.setSelectable ( true );
		if ( selectionProperty ) {
			this.setSelectionProperty ( selectionProperty );
		}
		if ( selectionValue ) {
			this.setSelectionValue ( selectionValue );
		}
	}
	
	/*
	 * This actually handles dragging, not selection. 
	 * TODO: only do this when treenodes are draggable.
	 */
	this._positionIndicatorBinding = this.add (
		TreePositionIndicatorBinding.newInstance ( 
			this.bindingDocument 
		)
	)
	this.shadowTree.positionIndicator = this._positionIndicatorBinding;
	this._positionIndicatorBinding.attach ();
}

/**
 * Build tree content from textarea value. The value 
 * value will be parsed into treenodes on each update.
 * TODO: Build an interface if we copy this setup...
 * @param {String} arg
 */
TreeBinding.prototype._buildFromTextArea = function ( id ) {
	
	var area = this.bindingDocument.getElementById ( id );
	
	if ( area != null ) {
		
		var binding = UserInterface.getBinding ( area );
		var treebody = this._treeBodyBinding;
		function build () {
			treebody.subTreeFromString ( area.value );
		}
		binding.addActionListener ( Binding.ACTION_UPDATED, {
			handleAction : function () {
				build ();
			}
		});
		setTimeout ( build, 0 ); // timeout should really not be needed here...
	}
}

/**
 * Register treenode.
 * @param {TreeNodeBinding} treeNodeBinding
 */
TreeBinding.prototype.registerTreeNodeBinding = function ( treeNodeBinding ) {
	
	var handle = treeNodeBinding.getHandle ();
	if ( this._treeNodeBindings.has ( handle )) {
		throw "Duplicate treenodehandles registered: " + treeNodeBinding.getLabel ();
	} else {
		this._treeNodeBindings.set ( handle, treeNodeBinding );
		var map = this._openTreeNodesBackupMap;
		if ( map != null && map.has ( handle )) {
			treeNodeBinding.open ();
		}
	}
}

/** 
 * Unregister treenode.
 * @param {TreeNodeBinding} treeNodeBinding
 */
TreeBinding.prototype.unRegisterTreeNodeBinding = function ( treeNodeBinding ) {
	
	this._treeNodeBindings.del ( treeNodeBinding.getHandle ());
}

/**
 * @param {string} handle
 * @return {TreeNodeBinding}
 */
TreeBinding.prototype.getTreeNodeBindingByHandle = function ( handle ) {
	
	var result = null;
	if ( this._treeNodeBindings.has ( handle )) {
		result = this._treeNodeBindings.get ( handle );
	} else {
		throw "No such treenode: " + handle;
	}
	return result;
}

/**
 * Carefully engineered to blur any focused treenodes *before* a new focus is invoked. 
 * @implements {IActionListener}
 * @overloads {FlexBoxBinding#handleAction}
 * @param {Action} action
 */
TreeBinding.prototype.handleAction = function ( action ) {

	TreeBinding.superclass.handleAction.call ( this, action );

	var binding = action.target;

	switch ( action.type ) {
		
		case TreeNodeBinding.ACTION_OPEN :
			action.consume ();
			break;
			
		case TreeNodeBinding.ACTION_CLOSE :
			this._blurDescendantBindings ( binding ); 
			action.consume ();
			break;
	
		case TreeNodeBinding.ACTION_ONFOCUS : 
			this._nodePrimary = binding;
			this.focusSingleTreeNodeBinding ( binding );
			if ( !this.isFocused ) {
				this.focus ();
			}
			action.consume ();
			break;
			
		case TreeNodeBinding.ACTION_ONMULTIFOCUS :
			switch ( this._selectionType ) {
				case TreeBinding.SELECTIONTYPE_SINGLE :
					this._nodePrimary = binding;
					this.focusSingleTreeNodeBinding ( binding );
					break;
					
				case TreeBinding.SELECTIONTYPE_SINGLE :
					this._nodeSecondary = binding;
					if ( !this._nodePrimary || this._nodeSecondary == this._nodePrimary ) {
						this._nodePrimary = binding;
						this.focusSingleTreeNodeBinding ( binding );
					} else {
						this.focusMultipeTreeNodeBindings (
							this._getVisibleTreeNodeBindingsInRange ( 
								this._nodePrimary, 
								this._nodeSecondary 
							)
						);
					}
					break;
			}
			if ( !this.isFocused ) {
				this.focus ();
			}
			action.consume ();
			break;
			
		case TreeNodeBinding.ACTION_DISPOSE :
			
			if ( binding.isFocused ) {
				this.blurSelectedTreeNodes (); // TODO: handle multiple selections!!!!!
			}
			/*
			var i = 0;
			this._focusedTreeNodeBindings.reset ();
			while ( this._focusedTreeNodeBindings.hasNext ()) {
				var item = this._focusedTreeNodeBindings.getNext ();
				if ( item == binding ) {
					this.blurSelectedTreeNodes (); // TODO: handle multiple selections!
					
					// blurSelected... will also clear this._focusedTreeNodeBindings!!! 
					// REFACTOR THIS SOME DAY!
					//this._focusedTreeNodeBindings.del ( i );
				}
				i++;
			}
			*/
			
			action.consume ();
			break;
			
		case TreeNodeBinding.ACTION_BLUR :
			// TODO: this should update the _focusedTreeNodeBindings index 
			// along with ACTION_DISPOSE - skip all manual bookkeeping!
			break;
			
		case Binding.ACTION_ACTIVATED :
			if ( !this.isFocused ) {
				this.focus ();
			}
			break;
	}
}

/**
 * Collecting all *visible* treenodes between two 
 * treenodes. The two treenodes are included in result.
 * @param {TreeNodeBinding} binding1
 * @param {TreeNodeBinding} binding2
 * @return {List<TreeNodeBinding>}
 */
TreeBinding.prototype._getVisibleTreeNodeBindingsInRange = function ( binding1, binding2 ) {
	
	// TODO: move this stuff to TreeCrawler once we need it... 
	alert ( "TreeBinding#_getVisibleTreeNodeBindingsInRange" );
	
	/*
	var ElementIterator = this.bindingWindow.ElementIterator;
	var list = new List ();
	var isCollecting = false;
	var firstBinding = null;
	
	/**
	 * @param {DOMElement} element
	 * @ignore
	 *
	function elementIteratorfilter ( element ) {
	
		var returnable = true;
		var binding = UserInterface.getBinding ( element );
		if ( binding && binding instanceof TreeNodeBinding ) {
			if ( binding == binding1 || binding == binding2 ) {
				isCollecting = !isCollecting;
				if ( !firstBinding ) {
					firstBinding = binding;
				}
			}
			if ( isCollecting ) {
				if ( binding.isContainer && !binding.isOpen ) {
					returnable = ElementIterator.SKIP_CHILDREN;
				}
				list.add ( binding );
			} else if ( firstBinding ) {
				list.add ( binding );
				firstBinding = null;
				returnable = ElementIterator.STOP_ITERATION;
			}
		}
		return returnable;
	}
	
	ElementIterator.iterate ( 
		this._treeBodyBinding.getBindingElement (), 
		elementIteratorfilter
	);
	return list;
	
	*/
}

/**
 * @param {TreeNodeBinding} binding;
 */
TreeBinding.prototype.focusSingleTreeNodeBinding = function ( binding ) {
	
	if ( binding != null && !binding.isFocused ) {
		
		this.blurSelectedTreeNodes ();
		this._focusedTreeNodeBindings.add ( binding );
		binding.invokeManagedFocus ();
		
		if ( this._isSelectable ) {
			this._manageSelections ();
		}
	}
}

/**
 * TODO: THIS HAS BEEN OUT OF USE, MAY NEED UPDATING...
 * @param {List} bindings;
 */
TreeBinding.prototype.focusMultipeTreeNodeBindings = function ( bindings ) {
	
	this.blurSelectedTreeNodes ();
	while ( bindings.hasNext ()) {
		var binding = bindings.getNext ();
		this._focusedTreeNodeBindings.add ( binding );
		binding.invokeManagedFocus ();
	}
	
	if ( this._isSelectable ) {
		this._manageSelections ();
	}
}

/**
 * Manage selections. Compare focused treenodes to selection criterias, 
 * determine whether or not to dispatch a selectionchange action.
 */
TreeBinding.prototype._manageSelections = function () {
	
	var previous = this._selectedTreeNodeBindings;
	this._selectedTreeNodeBindings = {};
	var isSelectionChanged = false;
	var newEntry = null;
	
	this._focusedTreeNodeBindings.reset ();
	
	while ( this._focusedTreeNodeBindings.hasNext ()) {
		var binding = this._focusedTreeNodeBindings.getNext ();
		var value = binding.getProperty ( this._selectionProperty );
		if ( value != null ) {
			if ( !this._selectionValue || this._selectionValue [ value ]) {
				newEntry = ( 
					this._selectedTreeNodeBindings [ binding.key ] = binding 
				);
				var oldEntry = previous [ binding.key ];
				if ( !oldEntry || oldEntry != newEntry ) {
					isSelectionChanged = true;
				}
			}
		}
	}
	if ( newEntry ) {
		if ( isSelectionChanged ) {
			this.dispatchAction ( TreeBinding.ACTION_SELECTIONCHANGED );
		}
	} else if ( previous ) {
		for ( var key in previous ) {
			this.dispatchAction ( TreeBinding.ACTION_NOSELECTION );
			break;
		}
	}
}

/**
 * Get selected treenode bindings.
 * @return {List<TreeNodeBinding>}
 */
TreeBinding.prototype.getSelectedTreeNodeBindings = function () {
	
	var result = new List ();
	for ( var key in this._selectedTreeNodeBindings ) {
		result.add ( this._selectedTreeNodeBindings [ key ]);
	}
	return result;
}

/**
 * Blur focused bindings and clear the list.
 */
TreeBinding.prototype.blurSelectedTreeNodes = function () {

	this._focusedTreeNodeBindings.reset ().each (
		function ( binding ) {
			binding.blur ();
		}
	);
	this._focusedTreeNodeBindings.clear ();
}

/**
 * Blur treenodes descending from a give treenode.
 * @param {TreeNodeBinding} treenode
 */
TreeBinding.prototype._blurDescendantBindings = function ( treenode ) {
	
	var descendants = treenode.getDescendantBindingsByLocalName ( "treenode" );
	
	/*
	 * TODO: Multiple selections - what happens?
	 */
	var result = true;
	var self = this;
	descendants.each ( function ( desc ) {
		if ( desc.isFocused ) {
			desc.blur ();
			self._focusedTreeNodeBindings.del (
				self._focusedTreeNodeBindings.getIndex ( desc ) // the horror... 
			);
		}
		return result;
	});
}

/**
 * @return {List}
 */
TreeBinding.prototype.getFocusedTreeNodeBindings = function () {

	return this._focusedTreeNodeBindings.reset ();
}

/**
 * @implements {IFocusable}
 */
TreeBinding.prototype.focus = function () {
	
	if ( !this.isFocused ) {
		
		this.isFocused = true;
		FocusBinding.focusElement ( this.bindingElement );
		this.attachClassName ( Binding.CLASSNAME_FOCUSED );
		this.dispatchAction ( Binding.ACTION_FOCUSED );
		
		if ( !this.getFocusedTreeNodeBindings ().hasEntries ()) {
			if ( this.isFocusable ) {
				this._focusDefault ();
			}
		}
		
		this._grabKeyboard ();
	}
};

/**
 * Default focus action - focus first node in tree.
 */
TreeBinding.prototype._focusDefault = function () {
	
	var first = this._treeBodyBinding.getChildBindingByLocalName ( "treenode" );
	if ( first != null ) {
		this.focusSingleTreeNodeBinding ( first );
		first.callback ();
	}
};

/**
 * @implements {IFocusable}
 */
TreeBinding.prototype.blur = function () {
	
	if ( this.isFocused ) {
		this.isFocused = false;
		this.detachClassName ( Binding.CLASSNAME_FOCUSED );
		this.dispatchAction ( Binding.ACTION_BLURRED );
		this._releaseKeyboard ();
	}
};

/**
 * Grab keyboard.
 */
TreeBinding.prototype._grabKeyboard = function () {
	
	this.subscribe ( BroadcastMessages.KEY_ARROW );
	this.subscribe ( BroadcastMessages.KEY_ENTER );
	this._hasKeyboard = true;
};

/**
 * Release keyboard.
 */
TreeBinding.prototype._releaseKeyboard = function () {
	
	this.unsubscribe ( BroadcastMessages.KEY_ARROW );
	this.unsubscribe ( BroadcastMessages.KEY_ENTER );
	this._hasKeyboard = false;
	
};

/** 
 * While initializing, added treenodes gets appended to a buffer.
 * @overwrites {Binding#add}
 * @param {Binding} binding
 * @return {Binding}
 */
TreeBinding.prototype.add = function ( binding ) {
	
	var returnable = null;
	if ( this._treeBodyBinding ) {
		 returnable = this._treeBodyBinding.add ( binding );
	} else {
		this._treeNodeBuffer.add ( binding );
		returnable = binding;
	}
	return returnable;
};

/**
 * @overwrites {Binding#addFirst}
 * @param {Binding} binding
 * @return {Binding}
 */
TreeBinding.prototype.addFirst = function ( binding ) {

	throw new Error ( "Not implemented" );
}

/**
 * Empty all treenodes and reset stuff. 
 */
TreeBinding.prototype.empty = function () {

	this._treeBodyBinding.detachRecursive ();
	var element = this._treeBodyBinding.bindingElement;
	element.innerHTML = "";
}

/**
 * Is tree empty?
 * @return {boolean}
 */
TreeBinding.prototype.isEmpty = function () {
    
    return this._treeNodeBindings.hasEntries () == false;
}

/**
 * Collapse all treenodes.
 */
TreeBinding.prototype.collapse = function () {
	
	this.blurSelectedTreeNodes ();
	this._treeNodeBindings.each ( function ( handle, treenode ) {
		if ( treenode.isContainer && treenode.isOpen ) {
			treenode.close ();
		}
	});
}

/**
 * Activate tree selection.
 * @param {boolean} isSelectable;
 */
TreeBinding.prototype.setSelectable = function ( isSelectable ) {
	
	this._isSelectable = isSelectable;
	
	if ( isSelectable ) {
		this._selectedTreeNodeBindings = {};
	} else {
		this._selectedTreeNodeBindings = null;
		this._selectionProperty = null;
		this._selectionValue = null;
	}
}
	
/**
 * Define selection property.
 * @param {string} property
 */
TreeBinding.prototype.setSelectionProperty = function ( property ) {
	
	this._selectionProperty = property;
}

/**
 * Define selection value(s).
 * @param {string} value White-space separated string
 */
TreeBinding.prototype.setSelectionValue = function ( value ) {
	
	if ( value ) {
		var list = new List ( value.split ( " " ));
		this._selectionValue = {};
		while ( list.hasNext ()) {
			this._selectionValue [ list.getNext ()] = true;
		}
	}
}

/**
 * Setup drop when a drag is instantiated.
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
TreeBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	TreeBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		
		case BroadcastMessages.TYPEDRAG_START :
			this.addEventListener ( DOMEvents.MOUSEMOVE );
			this._yposition = this.boxObject.getGlobalPosition ().y;
			break;
			
		case BroadcastMessages.TYPEDRAG_STOP :
			this.removeEventListener ( DOMEvents.MOUSEMOVE );
			this._positionIndicatorBinding.hide ();
			this._yposition = -1;
			break;
			
		case BroadcastMessages.KEY_ARROW :
			this._navigateByKey ( arg );
			break;
			
		case BroadcastMessages.KEY_ENTER :
			var focused = this.getFocusedTreeNodeBindings ()
			if ( focused.hasEntries ()) {
				var node = focused.getFirst ();
				if ( node.isContainer ) {
					if ( node.isOpen ) { 
						node.close ();
					} else {
						node.open ();
					}
				} else {
					node.fireCommand ();
				}
			}
			break;
	}
}

/**
 * Keyboard navigation studio.
 * @param {int} key
 */
TreeBinding.prototype._navigateByKey = function ( key ) {
	
	var focused = this.getFocusedTreeNodeBindings ()
	
	if ( focused.hasEntries ()) {
		
		var node = focused.getFirst ();
		var next = null;
		
		switch ( key ) {
			case KeyEventCodes.VK_UP :
				next = node.getPreviousBindingByLocalName ( "treenode" );
				if ( next != null ) { 
					while ( next.isContainer && next.hasChildren () && next.isOpen ) {
						next = next.getChildBindingsByLocalName ( "treenode" ).getLast ();
					}
				}
				if ( next == null ) {
					next = node.getAncestorBindingByLocalName ( "treenode" );
				}
				break;
				
			case KeyEventCodes.VK_DOWN :
				if ( node.isContainer && node.hasChildren () && node.isOpen ) {
					next = node.getChildBindingByLocalName ( "treenode" );
				} else {
					next = node.getNextBindingByLocalName ( "treenode" );
					if ( next == null ) {
						var parent = null;
						while ( next == null && ( parent = node.getAncestorBindingByLocalName ( "treenode" )) != null ) {
							if ( parent != null ) {
								next = parent.getNextBindingByLocalName ( "treenode" );
							}
							node = parent;
						}
					}
				}
				break;
			
			case KeyEventCodes.VK_RIGHT :
				if ( node.isContainer ) {
					if ( !node.isOpen ) {
						node.open ();
					} else if ( node.hasChildren ()) {
						next = node.getChildBindingByLocalName ( "treenode" );
					}
				}
				break;
			
			case KeyEventCodes.VK_LEFT :
				if ( node.isContainer && node.isOpen ) {
					node.close ();
				}
				break;
		}
		
		if ( next != null ) {
			this.focusSingleTreeNodeBinding ( next );
		}
	}
}

/**
 * @implements {IEventListener}
 * @overloads {Binding#handleEvent}
 * @param {MouseEvent} e
 */
TreeBinding.prototype.handleEvent = function ( e ) {
	
	TreeBinding.superclass.handleEvent.call ( this, e );
	
	var target = DOMEvents.getTarget ( e );
	
	switch ( e.type ) {
	
		case DOMEvents.MOUSEMOVE :
			
			try {
				this._updatePositionIndicator ( e );
			} catch ( exception ) {
				this.removeEventListener ( DOMEvents.MOUSEMOVE );
				throw ( exception );
			}
			break;
			
		case DOMEvents.BEFOREUPDATE :
			var crawler = new TreeCrawler ();
			var list = new List ();
			crawler.mode = TreeCrawler.MODE_GETOPEN;
			crawler.crawl ( this.bindingElement, list );
			var map = new Map ();
			if ( list.hasEntries ()) {
				while ( list.hasNext ()) {
					var treenode = list.getNext ();
					map.set ( treenode.getHandle (), true );
				}
				this._openTreeNodesBackupMap = map;
			}
			break;
			
		case DOMEvents.AFTERUPDATE :
			this._openTreeNodesBackupMap = null;
			break;
	}
}

/**
 * Position indicator while dragging.
 * @param {MouseEvent} e
 */
TreeBinding.prototype._updatePositionIndicator = function ( e ) {
	
	var y = e.clientY - this._yposition;
	var pos = this._acceptingPosition;
	var dim = this._acceptingDimension;
	var indicator = this._positionIndicatorBinding;
	
	if ( this._acceptingTreeNodeBinding ) {
	
		var miny = pos.y;
		var maxy = pos.y + dim.h;
		
		if ( y >= miny && y <= maxy ) {
		
			// snap position to nearest tree grid
			y = y < miny + TreeNodeBinding.HEIGHT ? miny + TreeNodeBinding.HEIGHT : y;
			y = y - TreeNodeBinding.HEIGHT;
			y = TreeBinding.grid ( y );
			
			// snap to nearest *accepted* tree grid
			while ( !this._acceptingPositions [ y ]) {
				y += TreeNodeBinding.HEIGHT
			}
			
			// position indicator
			if ( y != indicator.getPosition ().y ) {
				indicator.setPosition ( 
					new Point ( 
						this._acceptingPosition.x + TreeNodeBinding.INDENT,
						y
					)
				);
			}
			if ( !indicator.isVisible ) {
				indicator.show ();
			}
		} else if ( indicator.isVisible ) {
			indicator.hide ();
		}
	} else if ( indicator.isVisible ) {
		indicator.hide ();
	}
}

/**
 * Invoked by an accepting treenode.
 * @param {TreeNodeBinding} binding
 */
TreeBinding.prototype.enablePositionIndicator = function ( binding ) {
	
	this._acceptingTreeNodeBinding = binding;
	this._acceptingPosition = binding.boxObject.getLocalPosition ();
	this._acceptingDimension = binding.boxObject.getDimension ();
	this._acceptingPositions = this._getChildPositions ( binding );
}

/**
 * Invoked by an accepting treenode.
 */
TreeBinding.prototype.disablePositionIndicator = function () {
	
	this._acceptingTreeNodeBinding = null;
	this._acceptingPosition = null;
	this._acceptingDimension = null;
}

/**
 * Index position of folder children (or something equivaltent to position).
 * @param {TreeNodeBinding} binding
 * @return {HashMap<int><boolean>}
 */
TreeBinding.prototype._getChildPositions = function ( binding ) {

	var map = {};
	var children = binding.getChildBindingsByLocalName ( "treenode" );
	var child, pos, dim, y;
	
	y = TreeBinding.grid ( binding.boxObject.getLocalPosition ().y );
	map [ y ] = true;
	
	while ( children.hasNext ()) {
		child = children.getNext ();		
		pos = child.boxObject.getLocalPosition ();
		dim = child.boxObject.getDimension ();
		y = TreeBinding.grid ( pos.y + dim.h ) - TreeNodeBinding.HEIGHT;
		map [ y ] = true;
	}
	
	return map;
}

/**
 * Returns the index of latest treenode drag-drop session. A value of zero 
 * indicates that the treenode was inserted as the first folder child.
 * @return {int]
 */
TreeBinding.prototype.getDropIndex = function () {

	var y = this._positionIndicatorBinding.getPosition ().y;
	
	var drop = 0;
	for ( var index in this._acceptingPositions ) {
		if ( index == y ) {
			break;
		} else {
			drop++;
		}
	}
	return Number ( drop );
}

/**
 * Get the root (first-level) treenodes.
 * @return {List<TreeNodeBinding>}
 */
TreeBinding.prototype.getRootTreeNodeBindings = function () {
	
	return this._treeBodyBinding.getChildBindingsByLocalName ( "treenode" );
}

/**
 * TreeBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {TreeBinding}
 */
TreeBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:tree", ownerDocument );
	var binding = UserInterface.registerBinding ( element, TreeBinding );
	binding.treeBodyBinding = TreeBodyBinding.newInstance ( ownerDocument );
	return binding;
}

TreeBodyBinding.prototype = new FlexBoxBinding;
TreeBodyBinding.prototype.constructor = TreeBodyBinding;
TreeBodyBinding.superclass = FlexBoxBinding.prototype;

TreeBodyBinding.PADDING_TOP = 8;

/**
 * @class
 */
function TreeBodyBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "TreeBodyBinding" );
	
	/**
	 * @type {TreeBinding}
	 */
	this.containingTreeBinding = null;

	/*
	 * Returnable.
	 */
	return this;
}


/**
 * Identifies binding.
 */
TreeBodyBinding.prototype.toString = function () {

	return "[TreeBodyBinding]";
}

/**
 * @overloads {Binding#onBindingAttach}
 */
TreeBodyBinding.prototype.onBindingAttach = function () {

	TreeBodyBinding.superclass.onBindingAttach.call ( this );
	this.addActionListener ( TreeNodeBinding.ACTION_FOCUSED );
	this.containingTreeBinding = UserInterface.getBinding ( 
		this.bindingElement.parentNode
	);
}

/**
 * @implements {IAcceptable}
 * @param {Binding} binding
 */
TreeBodyBinding.prototype.accept = function ( binding ) {

	if ( binding instanceof TreeNodeBinding ) {
		this.logger.debug ( binding );
	}
}

/**
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
TreeBodyBinding.prototype.handleAction = function ( action ) {
	
	TreeBodyBinding.superclass.handleAction.call ( this, action );
	
	switch ( action.type ) {
		case TreeNodeBinding.ACTION_FOCUSED :
			this._scrollIntoView ( action.target );
			action.consume ();
			break;
	}
}

/**
 * Adjust scroll position so that focused treenodes are always visible.
 * @param {TreeNodeBinding} treenode
 */
TreeBodyBinding.prototype._scrollIntoView = function ( treenode ) {
	
	var a = this.boxObject.getDimension ().h;
	var y = treenode.boxObject.getLocalPosition ().y;
	var h = treenode.boxObject.getDimension ().h;
	var t = this.bindingElement.scrollTop;
	var l = this.bindingElement.scrollLeft;
	
	/*
	 * Scroll into view.
	 */
	var label = treenode.labelBinding.bindingElement;
	if ( y - t < 0 ) {
		label.scrollIntoView ( true );
	} else if ( y - t + h > a ) {
		label.scrollIntoView ( false );
	}
	
	/*
	 * IE may present an extreme horizontal scroll. 
	 * We hack it by locking scrollLeft completely. 
	 * Tough luck for deeply nested tree structures.
	 */
	if ( Client.isExplorer ) {
		this.bindingElement.scrollLeft = l;
	}
}

/**
 * @implements {IAcceptable}
 *
TreeBodyBinding.prototype.showAcceptance = function () {
	
	this.bindingElement.style.backgroundColor = "yellow";	
}

/**
 * @implements {IAcceptable}
 *
TreeBodyBinding.prototype.hideAcceptance = function () {
	
	this.bindingElement.style.backgroundColor = "Window";	
}
*/

/**
 * TreeBodyBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {TreeBodyBinding}
 */
TreeBodyBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:treebody", ownerDocument );
	return UserInterface.registerBinding ( element, TreeBodyBinding );
}

TreeNodeBinding.prototype = new Binding;
TreeNodeBinding.prototype.constructor = TreeNodeBinding;
TreeNodeBinding.superclass = Binding.prototype;

TreeNodeBinding.DEFAULT_FOLDER_CLOSED 		= "${icon:folder}";
TreeNodeBinding.DEFAULT_FOLDER_OPEN			= "${icon:folder_active}";
TreeNodeBinding.DEFAULT_FOLDER_DISABLED 	= "${icon:default}";
TreeNodeBinding.DEFAULT_ITEM 				= "${root}/images/icons/harmony/composite/default_16.png";
TreeNodeBinding.DEFAULT_ITEM_DISABLED		= "${icon:default}";

TreeNodeBinding.ACTION_OPEN					= "treenodeopen";
TreeNodeBinding.ACTION_CLOSE				= "treenodeclose";
TreeNodeBinding.ACTION_ONFOCUS				= "treenodeonfocus";
TreeNodeBinding.ACTION_ONMULTIFOCUS			= "treenodeonmultifocus";
TreeNodeBinding.ACTION_FOCUSED				= "treenodefocused";
TreeNodeBinding.ACTION_BLUR					= "treenodeblur";
TreeNodeBinding.ACTION_COMMAND				= "treenodecommand";
TreeNodeBinding.ACTION_DISPOSE				= "treenodedisposed";

TreeNodeBinding.CLASSNAME_DRAGGED = "dragged";
TreeNodeBinding.HEIGHT = 19; /* TODO: doublecheck - was 16 */
TreeNodeBinding.INDENT = 16 + 18;

/**
 * @class
 * TreeNodeBinding.
 * @param {DOMElement} bindingElement
 */
function TreeNodeBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "TreeNodeBinding" );
	
	/**
	 * @type {boolean}
	 */
	this.hasBeenOpened = false;
	
	/**
	 * @type {boolean}
	 */
	this.isDisabled	= false;
	
	/**
	 * @type {boolean}
	 */
	this.isFocused = false;
	
	/**
	 * @type {boolean}
	 */
	this.isOpen = false;
	
	/**
	 * @type {boolean}
	 */
	this.isContainer = false;
	
	/**
	 * @type {ImageProfile}
	 */
	this.imageProfile = null;
	
	/**
	 * @type {string}
	 */
	this.image = null;
	
	/**
	 * @type {string}
	 */
	this.imageHover = null;
	
	/**
	 * @type {string}
	 */
	this.imageActive = null;
	
	/**
	 * @type {string}
	 */
	this.imageDisabled = null;
	
	/**
	 * The ancestor TreeBinding.
	 * @type {TreeBinding}
	 */
	this.containingTreeBinding = null;
	
	/*
	 * Return this.
	 */
	return this;
}

/**
 * Identifies binding.
 */
TreeNodeBinding.prototype.toString = function () {

	return "[TreeNodeBinding]";
}

/**
 * Serialize binding.
 */
TreeNodeBinding.prototype.serialize = function () {

	var result = TreeNodeBinding.superclass.serialize.call ( this );
	if ( result ) {
	
		result.label = this.getLabel ();
		result.image = this.getImage ();
		
		var handle = this.getHandle ();
		if ( handle && handle != this.key ) {
			result.handle = handle;
		}
		if ( this.isOpen ) {
			result.open = true;
		}
		if ( this.isDisabled ) {
			result.disabled = true;
		}
		if ( this.dragType ) {
			result.dragtype = this.dragType;
		}
		if ( this.dragAccept ) {
			result.dragaccept = this.dragAccept;
		}
	}
	return result;
}

/**
 * @overloads {Binding#onBindingRegister}
 */
TreeNodeBinding.prototype.onBindingRegister = function () {
	
	TreeNodeBinding.superclass.onBindingRegister.call ( this );
	
	this.propertyMethodMap [ "label" ] = this.setLabel;
	this.propertyMethodMap [ "image" ] = this.setImage;
	this.propertyMethodMap [ "tooltip" ] = this.setToolTip;
	// this.propertyMethodMap [ "focus" ] is handled by method handleElement...

}

/**
 * Overloads {Binding#onBindingAttach}
 */
TreeNodeBinding.prototype.onBindingAttach = function () {

	TreeBinding.superclass.onBindingAttach.call ( this );
	
	this.isOpen	= this.isOpen ? true : this.getProperty ( "open" );
	if ( !this.isContainer ) {
		this.isContainer = this.hasChildren ();
	}
	this.buildDOMContent ();
	this.assignDOMEvents ();
	if ( this.isDisabled ) {
		this.labelBinding.attachClassName ( LabelBinding.CLASSNAME_GRAYTEXT );
	}
	this.addActionListener ( TreeNodeBinding.ACTION_FOCUSED );
	this.addEventListener ( UpdateManager.EVENT_AFTERUPDATE );
	
	/*
	 * We do this last so that the tree may at this point change label etc.
	 */
	this._registerWithAncestorTreeBinding ();
}
	
/**
 * Overloads {Binding#onBindingDispose}
 */
TreeNodeBinding.prototype.onBindingDispose = function () {

	if ( this.isAttached ) {
		if ( this.dragger != null ) { // TODO: is this needed?
			this.labelBinding.removeEventListener ( DOMEvents.MOUSEDOWN, this.dragger );
			this.labelBinding.removeEventListener ( DOMEvents.MOUSEMOVE, this.dragger );
			this.labelBinding.removeEventListener ( DOMEvents.MOUSEUP, this.dragger );
			this.disableDragging ();
			this.dragger.dispose ();
		}
		this.dispatchAction ( TreeNodeBinding.ACTION_DISPOSE );
		this.containingTreeBinding.unRegisterTreeNodeBinding ( this );
		this.labelBinding.dispose ();
	}
	TreeNodeBinding.superclass.onBindingDispose.call ( this );
}

/**
 * Register with containing {@link TreeBinding}. 
 * To conserve computations, a pointer to the tree 
 * is copied from the nearest parent tree member. 
 * We cannot simply target the parent element 
 * since this could be a {@link UpdatePanelBinding}.
 */
TreeNodeBinding.prototype._registerWithAncestorTreeBinding = function () {

	var node = this.bindingElement;
	while (( node = node.parentNode ) != null && !this.containingTreeBinding ) {
		var binding = UserInterface.getBinding ( node );
		if ( binding && binding.containingTreeBinding ) {
			this.containingTreeBinding = binding.containingTreeBinding;
		}
	}
	if ( this.containingTreeBinding ) {
		this.containingTreeBinding.registerTreeNodeBinding ( this );
	} else  {
		alert ( this.bindingElement.parentNode.nodeName );
		throw "TreeNodeBinding attached outside TreeBodyBinding";
	}
}

/**
 * The treenode will get registered by this index. 
 * Subclasses can overwrite this method for added pleasure.
 * @return {string}
 */
TreeNodeBinding.prototype.getHandle = function () {
	
	var result = this.key;
	var handle = this.getProperty ( "handle" );
	if ( handle ) {
		result = handle;
	}
	return result;
}

/**
 * Set handle.
 * @param {string} handle
 */
TreeNodeBinding.prototype.setHandle = function ( handle ) {
	
	this.setProperty ( "handle", handle );
}

/**
 * Build DOM content.
 */
TreeNodeBinding.prototype.buildDOMContent = function () {
	
	var url				= this.getProperty ( "url" );
	var label 			= this.getProperty ( "label" );
	var tooltip 		= this.getProperty ( "tooltip" );
	var oncommand 		= this.getProperty ( "oncommand" );
	var onfocus 		= this.getProperty ( "onbindingfocus" );
	var onblur 			= this.getProperty ( "onbindingblur" );
	var focused 		= this.getProperty ( "focused" );
	var callbackid 		= this.getProperty ( "callbackid" );
	
	/*
	 * Build URL
	 */
	if ( url ) {
		var link = DOMUtil.createElementNS ( Constants.NS_XHTML, "a", this.bindingDocument );
		link.href = url;
		this.bindingElement.appendChild ( link );
		this.shadowTree.link = link;
	}
	
	/*
	 * Build label
	 */
	this.labelBinding = LabelBinding.newInstance ( this.bindingDocument )
	if ( url ) {
		this.shadowTree.link.appendChild ( this.labelBinding.bindingElement );
	} else {
		this.addFirst ( this.labelBinding );
	}
	this.shadowTree.label = this.labelBinding; // in order to exclude from serialization!
	
	if ( this.dragger != null ) { // have to transfer listeners to make the setup work!
	
		this.removeEventListener ( DOMEvents.MOUSEDOWN, this.dragger );
		this.removeEventListener ( DOMEvents.MOUSEMOVE, this.dragger );
		this.removeEventListener ( DOMEvents.MOUSEUP, this.dragger );
		
		this.labelBinding.addEventListener ( DOMEvents.MOUSEDOWN, this.dragger );
		this.labelBinding.addEventListener ( DOMEvents.MOUSEMOVE, this.dragger );
		this.labelBinding.addEventListener ( DOMEvents.MOUSEUP, this.dragger );
		
	}
	
	// TEMP!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	// Binding.prototype._initializeBindingDragAndDropFeatures overload??? DRAGREJECT!
	if ( this.isContainer && !this.dragAccept ) {
		this.acceptor = new BindingAcceptor ( this );
	}
	
	if ( label != null ) {
		this.setLabel ( label );
	}
	if ( tooltip != null ) {
		this.setToolTip ( tooltip );
	}
	if ( !this.imageProfile ) {
		this._computeImageProfile ();
	}
	this.setImage ( 
		this.computeImage ()
	);
	if ( this.isContainer ) {
		this.updateClassNames ();
	}
	
	var manager = this.bindingWindow.WindowManager;
	
	if ( oncommand != null ) {
		this.oncommand = function () {
			Binding.evaluate ( oncommand, this );
		};
	}
	if ( onfocus != null ) {
		this.onfocus = function () {
			Binding.evaluate ( onfocus, this );
		};
	}
	if ( onblur != null ) {
		this.onblur = function () {
			Binding.evaluate ( onblur, this );
		};
	}
	
	if ( focused == true ) {
		this.focus ();
	}
	
	/*
	 * Setup ASP.NET callback. One can only wonder why we need a 
	 * hidden field in order to communicate with the server...
	 */
	if ( callbackid != null ) {
		Binding.dotnetify ( this, callbackid );
	}
}

/**
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
TreeNodeBinding.prototype.handleAction = function ( action ) {
	
	TreeNodeBinding.superclass.handleAction.call ( this, action );
	
	switch ( action.type ) {
		
		/*
		 * Make sure that a focused treenode is always  
		 * visible by opening ancestor treenodes.
		 */
		case TreeNodeBinding.ACTION_FOCUSED :
			if ( action.target != this ) {
				if ( this.isContainer && !this.isOpen ) {
					this.open ();
				}
			}
			break;
	}
}

/**
 * Enable dragging. Special setup, adding event listeners to 
 * label, because treenodes consume the onmousedown event.
 * @overwrites {Binding#enableDragging}
 */
TreeNodeBinding.prototype.enableDragging = function () {
	
	/* 
	 * DISABLED!
	 *
	this.isDraggable = true;
	if ( this.dragger == null ) {
		this.dragger = new BindingDragger ( this );
	}
	*/
}

/**
 * Disable dragging.
 * @overwrites {Binding#disableDragging}
 */
TreeNodeBinding.prototype.disableDragging = function () {

	this.isDraggable = false;
	/*
	if ( this.dragger != null ) { handled by method onBindingDispose!
		this.dragger = null;
	}
	*/
}

/**
 * Accept dragged binding. 
 * @implements {IAcceptable}
 * @param {Binding} binding
 * @param @optional {int} index
 * @return {boolean}
 */
TreeNodeBinding.prototype.accept = function ( binding, index ) {
	
	var isAccept = true;
	
	if ( binding instanceof TreeNodeBinding ) {
		
		var isAncestor = false;
		var element = this.bindingElement;
		var treeElement = this.containingTreeBinding.bindingElement;
		
		while ( !isAncestor && element != treeElement ) {
			if ( element == binding.getBindingElement ()) {
				isAncestor = true;
			} else {
				element = element.parentNode;
			}
		}
		
		if ( isAncestor ) {
			Dialog.error ( "Not Allowed", "You cannot move a folder into itself." );
			isAccept = false;
		} else {
			this.acceptTreeNodeBinding ( binding, index );
		}
	} else {
		isAccept = false;
	}
	
	return isAccept;
}

/**
 * Accept treenode.If properties get lost in transfer, remember 
 * to update the {@link TreeNodeBinding#serialize} method.
 * @param {Binding} binding
 * @param @optional {int}
 */
TreeNodeBinding.prototype.acceptTreeNodeBinding = function ( binding, index ) {
	
	var serial = binding.serializeToString ();
	var parser = new BindingParser ( this.bindingDocument );
	var element	= parser.parseFromString ( serial ).getFirst ();
	
	index = index ? index : this.containingTreeBinding.getDropIndex ();
	var children = this.getChildElementsByLocalName ( "treenode" );
	this.bindingElement.insertBefore ( element, children.get ( index ));
	this.bindingWindow.DocumentManager.attachBindings ( 
		this.bindingElement 
	);
	
	/*
	 * This part does not work because the "image" attribute
	 * has been set on bindingElement opon binding attach. 
	 * Fortunately we don't need it just now.
	 *
	if ( !this.isContainer ) {
		this.isContainer = true;
		this.isOpen = true;
		this.updateClassNames ();
		this._computeImageProfile ();
		alert ( this.imageProfile.getDefaultImage ());
		this.setImage ( 
			this.computeImage ()
		);
	}
	*/
	
	binding.dispose ();
}

/**
 * Show acceptance.
 * @implements {IAcceptable}
 */
TreeNodeBinding.prototype.showAcceptance = function () {
	
	this.containingTreeBinding.enablePositionIndicator ( this );
}

/**
 * Show acceptance.
 * @implements {IAcceptable}
 */
TreeNodeBinding.prototype.hideAcceptance = function () {
	
	this.containingTreeBinding.disablePositionIndicator ();
}

/**
 * Compute ImageProfile.
 */
TreeNodeBinding.prototype._computeImageProfile = function () {

	var image 			= this.getProperty ( "image" );
	var imageActive 	= this.getProperty ( "image-active" );
	var imageDisabled 	= this.getProperty ( "image-disabled" );
		
	imageActive = imageActive ? imageActive : this.isContainer ? 
		image ? image : TreeNodeBinding.DEFAULT_FOLDER_OPEN : 
		image ? image : TreeNodeBinding.DEFAULT_ITEM;
	
	imageDisabled = imageDisabled ? imageDisabled : this.isContainer ? 
		image ? image : TreeNodeBinding.DEFAULT_FOLDER_DISABLED : 
		image ? image : TreeNodeBinding.DEFAULT_ITEM_DISABLED;
	
	image = image ? image : this.isContainer ? 
		TreeNodeBinding.DEFAULT_FOLDER_CLOSED : TreeNodeBinding.DEFAULT_ITEM;
	
	this.imageProfile = new ImageProfile ({
		image 			: image,
		imageHover 		: null,
		imageActive 	: imageActive,
		imageDisabled 	: imageDisabled
	});
}

/**
 * Assign DOM events.
 * @private
 */
TreeNodeBinding.prototype.assignDOMEvents = function () {

	/*
	 * Note that mouseover and mouseout are only relevant for folders.
	 * TODO: erect a "converttofolder" method to handle this?
	 */
	this.labelBinding.addEventListener ( DOMEvents.DOUBLECLICK, this );
	this.labelBinding.addEventListener ( DOMEvents.MOUSEDOWN, this );
	this.labelBinding.addEventListener ( DOMEvents.MOUSEOVER, this );
	this.labelBinding.addEventListener ( DOMEvents.MOUSEOUT, this );
}

/**
 * Set image.
 * @param {string} url
 */
TreeNodeBinding.prototype.setImage = function ( url ) {

	this.setProperty ( "image", url );
	if ( this.isAttached ) {
		this.labelBinding.setImage ( url );
	}
}

/**
 * Set label.
 * @param {string} label
 */
TreeNodeBinding.prototype.setLabel = function ( label ) {

	this.setProperty ( "label", String ( label ));
	if ( this.isAttached ) {
		this.labelBinding.setLabel ( String ( label ));
	}
}

/**
 * Set tooltip.
 * @param {string} tooltip
 */
TreeNodeBinding.prototype.setToolTip = function ( tooltip ) {

	this.setProperty ( "tooltip", String ( tooltip ));
	if ( this.isAttached ) {
		this.labelBinding.setToolTip ( String ( tooltip ));
	}
}

/**
 * Get image.
 * @return {string}
 */
TreeNodeBinding.prototype.getImage = function () {

	return this.getProperty ( "image" );
}

/**
 * Get label.
 * @return {string}
 */
TreeNodeBinding.prototype.getLabel = function () {

	return this.getProperty ( "label" );
}


/**
 * Get tooltip.
 * @return {string}
 */
TreeNodeBinding.prototype.getToolTip = function () {

	return this.getProperty ( "tooltip" );
}

/**
 * Compute image.
 * @return {string}
 */
TreeNodeBinding.prototype.computeImage = function () {
	
	var defaultImage = this.imageProfile.getDefaultImage ();
	var activeImage = this.imageProfile.getActiveImage ();
	activeImage = activeImage ? activeImage : defaultImage;
	
	return this.isOpen ? activeImage : defaultImage;
}

/**
 * @implements {IEventListener}
 * @overloads {Binding#handleEvent}
 * @param {MouseEvent} e
 */
TreeNodeBinding.prototype.handleEvent = function ( e ) {
	
	TreeNodeBinding.superclass.handleEvent.call ( this, e );
	
	var target 		= DOMEvents.getTarget ( e );
	var label		= this.labelBinding.bindingElement;
	var labelBody 	= this.labelBinding.shadowTree.labelBody;
	var labelText	= this.labelBinding.shadowTree.labelText;
	
	/*
	 * Tree navigation.
	 */
	switch ( e.type ) {
	
		case DOMEvents.MOUSEDOWN : 
			switch ( target ) {
				case label :
					this._onAction ( e );
					break;
				case labelBody :
				case labelText :
					if ( !this.isDisabled ) {
						this._onFocus ( e );
					}
					break;
			}
			break;
			
		case DOMEvents.DOUBLECLICK :
			this._onAction ( e );
			break;
			
		case UpdateManager.EVENT_AFTERUPDATE :
			
			/*
			 * Hack a glitch where UpdateManager would  
			 * insert treenodes before our label.
			 */
			if ( target.parentNode == this.bindingElement && target.__updateType == Update.TYPE_INSERT ) {
				var label = this.labelBinding.bindingElement;
				if ( DOMUtil.getLocalName ( target ) == "treenode" ) {
					if ( target == this.bindingElement.firstChild ) {
						this.bindingElement.insertBefore ( target, label.nextSibling );
					}
				}
				break;
			}
			break;
	}
	
	/*
	 * Drag session timeouts.
	 */
	if ( BindingDragger.isDragging && this.isContainer && !this.isOpen ) {
		switch ( e.type ) {
			case DOMEvents.MOUSEOVER :
			case DOMEvents.MOUSEOUT : 
			 	switch ( target ) {
					case label :
					case labelBody :
					case labelText :
						this._folderDragOverTimeout ( e );
						break;
				}
				break;
		}
	}
}

/**
 * When dragging over a closed folder, the folder should open. 
 * Let's do it by setting and clearing a timeout.
 * @param {MouseEvent} e
 */
TreeNodeBinding.prototype._folderDragOverTimeout = function ( e ) {
	
	var self = this;
	switch ( e.type ) {
		case DOMEvents.MOUSEOVER :
			this._dragTimeout = this.bindingWindow.setTimeout ( function () {
				self.open ();
			}, 500 );
			break;
		case DOMEvents.MOUSEOUT :
			this.bindingWindow.clearTimeout ( this._dragTimeout );
			break;
	}
}

/**
 * Treenode action.
 * @param {MouseEvent} e
 * @private
 */
TreeNodeBinding.prototype._onAction = function ( e ) {
	
	var isAction = true;
	
	if ( e.type == "mousedown" ) {
		var isLeftButton = e.button == ( e.target ? 0 : 1 );
		if ( !isLeftButton ) {
			isAction = false;
		}
	}
	if ( isAction ) {
		if ( this.isContainer ) {
			if ( !this.isOpen ) {
				this.open ();
			} else {
				this.close ();
			}
		} else {
			this.fireCommand ();
		}
	}
}

/**
 * Fire treenode command.
 */
TreeNodeBinding.prototype.fireCommand = function () {

	if ( this.oncommand ) {
		this.oncommand ();
	}
	this.dispatchAction ( TreeNodeBinding.ACTION_COMMAND );
}

/**
 * This will dispatch an event to the containing TreeBinding 
 * which in turn will invoke the focus method below. 
 * @param {MouseEvent}
 */
TreeNodeBinding.prototype._onFocus = function ( e ) {

	var isMultiSelection = false;
	if ( e != null ) {
		isMultiSelection = e.shiftKey;
	}
	this.dispatchAction ( isMultiSelection ? 
		TreeNodeBinding.ACTION_ONMULTIFOCUS : 
		TreeNodeBinding.ACTION_ONFOCUS 
	);
	if ( e != null ) {
		this.stopPropagation ( e );
	}
	if ( this.onfocus != null ) {
		this.onfocus ();
	}
	if ( e != null ) {
		if ( this.hasCallBackID ()) {
			this.callback ();
		}
	}
}

/**
 * Call the server. This must be done whenever the client is 
 * setting the focus; it should not be done when the server 
 * is setting the focus. Also invoked by the TreeBinding!
 * @see {TreeBinding#_focusDefault}
 * @returns
 */
TreeNodeBinding.prototype.callback = function () {
	
	if ( this.hasCallBackID ()) {
		var self = this;
		setTimeout ( function () { // minimize freezing sensation
			self.dispatchAction ( PageBinding.ACTION_DOPOSTBACK );
		}, 0 );
	}
}

/**
 * Focus the treenode managed. This method should only be invoked by the {@link TreeBinding}.
 */
TreeNodeBinding.prototype.invokeManagedFocus = function () {
	
	if ( !this.isFocused ) {
		this.isFocused = true;
		this.setProperty ( "focused", true );
		this.labelBinding.attachClassName ( "focused" );
		this.dispatchAction ( TreeNodeBinding.ACTION_FOCUSED );
	}
}

/**
 * Focus the treenode (public access point).
 */
TreeNodeBinding.prototype.focus = function () {
	
	this.setProperty ( "focused", true );
	if ( this.isAttached ) {
		this._onFocus ();
	}
}

/**
 * Blur the treenode. This method is invoked by the {@link TreeBinding}.
 */
TreeNodeBinding.prototype.blur = function () {

	if ( this.isFocused ) {
		this.isFocused = false;
		this.deleteProperty ( "focused" );
		this.labelBinding.detachClassName ( "focused" );
		if ( this.onblur ) {
			this.onblur ();
		}
		this.dispatchAction ( TreeNodeBinding.ACTION_BLUR );
	}
}

/**
 * Preventing event propagation internally in the tree 
 * while still broadcasting a global mousedown event.
 * @param {MouseEvent} e
 * @private
 */
TreeNodeBinding.prototype.stopPropagation = function ( e ) {

	if ( e.type == "mousedown" ) {
		EventBroadcaster.broadcast ( BroadcastMessages.MOUSEEVENT_MOUSEDOWN, e );
		this.dispatchAction ( Binding.ACTION_ACTIVATED );
	}
	DOMEvents.stopPropagation ( e );
}

/**
 * Open container.
 */
TreeNodeBinding.prototype.open = function () {

	if ( this.isContainer && !this.isOpen ) {
		this.isOpen = true;
		this.setProperty ( "open", true );
		this.dispatchAction ( TreeNodeBinding.ACTION_OPEN	);
		this.setImage ( this.computeImage ());
		this.updateClassNames ();
		this.hasBeenOpened = true;
	}
}

/**
 * Close container.
 */
TreeNodeBinding.prototype.close = function () {

	if ( this.isContainer && this.isOpen ) {
		this.isOpen = false;
		this.setProperty ( "open", false );
		this.dispatchAction ( TreeNodeBinding.ACTION_CLOSE );
		this.setImage ( this.computeImage ());
		this.updateClassNames ();
	}
}

/**
 * Updates treenode classnames when a container type node is handled.
 */
TreeNodeBinding.prototype.updateClassNames = function () {
		
	if ( this.isContainer ) {
		if ( !this.hasClassName ( "container" )) {
			this.attachClassName ( "container" );
		}
		if ( this.isOpen ) {
			this.detachClassName ( "closed" );
			this.attachClassName ( "open" );
			this.labelBinding.detachClassName ( "closed" );
			this.labelBinding.attachClassName ( "open" );
		} else {
			this.detachClassName ( "open" );
			this.attachClassName ( "closed" );
			this.labelBinding.detachClassName ( "open" );
			this.labelBinding.attachClassName ( "closed" );
		}
	} else {
		if ( this.hasClassName ( "container" )) {
			this.detachClassName ( "container" );
			this.labelBinding.detachClassName ( "closed" );
			this.labelBinding.detachClassName ( "open" );
			// TODO: modify this.isOpen property?
		}
	}
}

/**
 * Dispose descendant treenodes.
 */
TreeNodeBinding.prototype.empty = function () {
	
	var descendants = this.getDescendantBindingsByLocalName ( "treenode" );
	descendants.each ( function ( treenode ) {
		treenode.dispose ();
	});
}

/**
 * Show dragged status.
 * TODO: implement some interface around here!
 */
TreeNodeBinding.prototype.showDrag = function () {
	
	this.attachClassName ( TreeNodeBinding.CLASSNAME_DRAGGED );
}

/**
 * Hide dragged status.
 * TODO: implement some interface around here!
 */
TreeNodeBinding.prototype.hideDrag = function () {
	
	this.detachClassName ( TreeNodeBinding.CLASSNAME_DRAGGED );
}

/**
 * Has children?
 * @return {boolean}
 */
TreeNodeBinding.prototype.hasChildren = function () {
	
	return this.bindingElement.hasChildNodes ();
}

/**
 * Server trying to maintain focus on this treenode?
 * @overwrites {Binding#handleElement}
 * @param {Element} element
 */
TreeNodeBinding.prototype.handleElement = function ( element ) {
	
	/*
	 * The problem here is that the server may move focus to 
	 * this treenode in one postback response, but if the 
	 * next response KEEPS he focus there are no CHANGES 
	 * to the response. This way, user may be allowed to 
	 * change focus in second attempt. Always nice to have 
	 * the UI state on both the client and the server...
	 */
	var focused = element.getAttribute ( "focused" );
	if ( focused == "true" ) {
		if ( !this.isFocused ) {
			this.focus ();
		}
	}
	
	return false; // continue updates as normally!
}

/**
 * TreeNodeBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {TreeNodeBinding}
 */
TreeNodeBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:treenode", ownerDocument );
	return UserInterface.registerBinding ( element, TreeNodeBinding );
}

TreeContentBinding.prototype = new Binding;
TreeContentBinding.prototype.constructor = TreeContentBinding;
TreeContentBinding.superclass = Binding.prototype;

/**
 * @class
 */
function TreeContentBinding () {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "TreeContentBinding" );
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
TreeContentBinding.prototype.toString = function () {

	return "[TreeContentBinding]";
}

/**
 * TreeContentBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {TreeContentBinding}
 */
TreeContentBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:treecontent", ownerDocument );
	return UserInterface.registerBinding ( element, TreeContentBinding );
}

TreePositionIndicatorBinding.prototype = new Binding;
TreePositionIndicatorBinding.prototype.constructor = TreePositionIndicatorBinding;
TreePositionIndicatorBinding.superclass = Binding.prototype;

/**
 * @class
 */
function TreePositionIndicatorBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "TreePositionIndicatorBinding" );
	
	/**
	 * TODO: REFACTOR TO POINT!
	 * @type {object}
	 */
	this._geometry = {
		x : 0,
		y : 0
	}
}

/**
 * Identifies binding.
 */
TreePositionIndicatorBinding.prototype.toString = function () {
	
	return "[TreePositionIndicatorBinding]";
}

/**
 * @overloads {Binding#onBindingAttach}
 */
TreePositionIndicatorBinding.prototype.onBindingAttach = function () {
	
	TreePositionIndicatorBinding.superclass.onBindingAttach.call ( this );
	this.hide ();
}

/**
 * @param {Point} point
 */
TreePositionIndicatorBinding.prototype.setPosition = function ( point ) {
	
	this.bindingElement.style.left = point.x + "px";
	this.bindingElement.style.top = point.y + "px";
	
	this._geometry.x = point.x;
	this._geometry.y = point.y;
}

/**
 * @return {Point}
 */
TreePositionIndicatorBinding.prototype.getPosition = function () {

	return new Point ( 
		this._geometry.x,
		this._geometry.y
	);
}

/**
 * TreePositionIndicatorBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {TreePositionIndicatorBinding}
 */
TreePositionIndicatorBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:treepositionindicator", ownerDocument );
	return UserInterface.registerBinding ( element, TreePositionIndicatorBinding );
}

TreeCrawler.prototype = new BindingCrawler;
TreeCrawler.prototype.constructor = TreeCrawler;
TreeCrawler.superclass = BindingCrawler.prototype;

TreeCrawler.ID = "treecrawler";
TreeCrawler.MODE_GETOPEN = "get open treenodes";

/**
 * @class
 * The TreeCrawler sees only TreeNodeBindings.
 */
function TreeCrawler () {
	
	this.mode = TreeCrawler.MODE_GETOPEN;
	this.id = TreeCrawler.ID;
	this._construct ();
	return this;
}

/**
 * * Filter all but Binding elements.
 * @overloads {ElementCrawler#_construct} 
 */
TreeCrawler.prototype._construct = function () {
	
	TreeCrawler.superclass._construct.call ( this );
	
	var self = this;
	
	/*
	 * See only treenodes.
	 */
	this.addFilter ( function ( element ) {
		
		var binding = UserInterface.getBinding ( element );
		var result = null;var result = null;
		
		if ( !binding instanceof TreeNodeBinding ) {
			result = NodeCrawler.SKIP_NODE;
		}
		
		return result;
	});
	
	/*
	 * Analyze treenode. 
	 */
	this.addFilter ( function ( element, list ) {
		
		var binding = UserInterface.getBinding ( element );
		var result = null;
		
		switch ( self.mode ) {
			case TreeCrawler.MODE_GETOPEN :
				if ( binding.isOpen ) {
					list.add ( binding );
				}
				break;
		}
		return result;
	});
}

ShadowBinding.prototype = new MatrixBinding;
ShadowBinding.prototype.constructor = ShadowBinding;
ShadowBinding.superclass = MatrixBinding.prototype;

/**
 * @class
 */
function ShadowBinding () {
 	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ShadowBinding" );
	
	/**
	 * @type {Binding}
	 */
	this.targetBinding = null;
	
	/**
	 * @type {int}
	 */
	this.offset = 4;
	
	/**
	 * @type {int}
	 */
	this.expand = 14;
	
	/**
	 * @type {boolean}
	 */
	this.isVisible = true;
	
	/**
	 * Block common crawlers.
	 * @type {Map<string><boolean>}
	 * @overwrites {Binding#crawlerFilters}
	 */
	this.crawlerFilters	= new List ([ DocumentCrawler.ID, FlexBoxCrawler.ID, FocusCrawler.ID ]);
}

/**
 * Identifies binding.
 */
ShadowBinding.prototype.toString = function () {

	return "[ShadowBinding]";
}

/**
 * Hide quickly - otherwise Firefox may show the shaodow in a flash.
 * @overloads {Binding#onBindingRegister}
 */
ShadowBinding.prototype.onBindingRegister = function () {

	ShadowBinding.superclass.onBindingRegister.call ( this );
	this.hide ();
}

/**
 * TODO: Interfacecheck for IFloating or something?
 * @param {Binding} binding
 */
ShadowBinding.prototype.shadow = function ( binding ) {
		
	this.targetBinding = binding;
	
	binding.addActionListener ( Binding.ACTION_POSITIONCHANGED, this );
	binding.addActionListener ( Binding.ACTION_DIMENSIONCHANGED, this );
	binding.addActionListener ( Binding.ACTION_VISIBILITYCHANGED, this );
	binding.bindingElement.parentNode.appendChild ( this.bindingElement );
	
	if ( binding.isVisible ) {
		this.show ();
		this.setPosition ( binding.getPosition ());
		this.setDimension ( binding.getDimension ());
	} else {
		this.hide ();
	}
}

/**
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
ShadowBinding.prototype.handleAction = function ( action ) {
	
	ShadowBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	
	if ( binding == this.targetBinding ) {
		switch ( action.type ) {
			case Binding.ACTION_POSITIONCHANGED :
				this.setPosition ( this.targetBinding.getPosition ());
				action.consume ();
				break;
			case Binding.ACTION_DIMENSIONCHANGED :
				this.setDimension ( this.targetBinding.getDimension ());
				// don't consume - MenyBodyBinding could be listening!
				break;
			case Binding.ACTION_VISIBILITYCHANGED :
				if ( binding.isVisible ) {
					this.show ();
					this.setPosition ( binding.getPosition ());
					this.setDimension ( binding.getDimension ());
				} else {
					this.hide ();
				}
				break;
		}
	}
}

/**
 * @param {Point} point
 */
ShadowBinding.prototype.setPosition = function ( point ) {
	
	/* 
	 * This adjustment cannot be performed because the CSSComputer doesn't 
	 * update fast enough! The targetBinding must correct position manually.
	 *
	if ( this.targetBinding ) {
		var margin = CSSComputer.getMargin ( this.targetBinding.getBindingElement ());
		if ( margin.top && margin.top != 0 ) {
			point.y += margin.top;
		}
	}
	*/
	
	var adjust = this.offset - this.expand;
	this.bindingElement.style.left = new String ( point.x + adjust ) + "px";
	this.bindingElement.style.top = new String ( point.y + adjust ) + "px";
}

/**
 * @param {Dimension} dim
 */
ShadowBinding.prototype.setDimension = function ( dim ) {
	
	this.bindingElement.style.width = new String ( dim.w + 2 * this.expand ) + "px";
	this.bindingElement.style.height = new String ( dim.h + 2 * this.expand ) + "px";
}

/**
 * ShadowBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {ShadowBinding}
 */
ShadowBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:shadow", ownerDocument );
	return UserInterface.registerBinding ( element, ShadowBinding );
}

DockControlImageProfile.prototype = new ControlImageProfile;
DockControlImageProfile.prototype.constructor = DockControlImageProfile;
DockControlImageProfile.superclass = ControlImageProfile.prototype;

DockControlImageProfile.IMAGE_MINIMIZE = Resolver.resolve ( "${skin}/docks/control-minimize-${string}.png" );
DockControlImageProfile.IMAGE_MAXIMIZE = Resolver.resolve ( "${skin}/docks/control-maximize-${string}.png" );
DockControlImageProfile.IMAGE_RESTORE = Resolver.resolve ( "${skin}/docks/control-restore-${string}.png" ); 
DockControlImageProfile.IMAGE_CLOSE = null;

/**
 * This functionality can be implemented in pure CSS when we ditch IE6.0!
 * @param {ControlBinding} binding
 */
function DockControlImageProfile ( binding ) {
	
	this.binding = binding;
}

/**
 * @overwrites {ControlImageProfile#getHoverImage}
 * @return {string}
 */
DockControlImageProfile.prototype.getHoverImage = function () {

	return null;
}

/**
 * @overwrites {ControlImageProfile#getActiveImage}
 * @return {string}
 */
DockControlImageProfile.prototype.getActiveImage = function () {

	return null;
}

DockTabsButtonBinding.prototype = new TabsButtonBinding;
DockTabsButtonBinding.prototype.constructor = DockTabsButtonBinding;
DockTabsButtonBinding.superclass = TabsButtonBinding.prototype;
DockTabsButtonBinding.RESERVED_SPACE = 50;
DockTabsButtonBinding.NODENAME_TABBOX = "dock";

/**
 * @class
 */
function DockTabsButtonBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DockTabsButtonBinding" );
}

/**
 * Identifies binding.
 */
DockTabsButtonBinding.prototype.toString = function () {

	return "[DockTabsButtonBinding]";
}

/**
 * DockTabsButtonBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {DockTabsButtonBinding}
 */
DockTabsButtonBinding.newInstance = function ( ownerDocument ) {

	var toolbarbutton = DOMUtil.createElementNS ( Constants.NS_UI, "ui:toolbarbutton", ownerDocument );
	toolbarbutton.setAttribute ( "type", "checkbox" );
	toolbarbutton.setAttribute ( "popup", "app.bindingMap.tabsbuttonpopup" );
	toolbarbutton.className = "tabbutton";	
	return UserInterface.registerBinding ( toolbarbutton, DockTabsButtonBinding );
}

DockBinding.prototype = new TabBoxBinding;
DockBinding.prototype.constructor = DockBinding;
DockBinding.superclass = TabBoxBinding.prototype;

DockBinding.START					= "start";
DockBinding.EXPLORER				= "explorer";
DockBinding.MAIN					= "main";
DockBinding.BOTTOMLEFT				= "bottomleft";
DockBinding.BOTTOMRIGHT				= "bottomright";
DockBinding.RIGHTTOP				= "righttop";
DockBinding.RIGHTBOTTOM				= "rightbottom";
DockBinding.ABSBOTTOMLEFT			= "absbottomleft";
DockBinding.ABSBOTTOMRIGHT			= "absbottomright";
DockBinding.ABSRIGHTTOP				= "absrighttop";
DockBinding.ABSRIGHTBOTTOM			= "absrightbottom";

DockBinding.TYPE_START				= "start";
DockBinding.TYPE_EXPLORER			= "explorer";
DockBinding.TYPE_EDITORS			= "editors";
DockBinding.TYPE_TOOLS				= "tools";

DockBinding.ACTION_OPENED			= "dockopened";
DockBinding.ACTION_EMPTIED 			= "dockemptied";

DockBinding.CLASSNAME_ACTIVE 		= "active";


/**
 * @class
 * @implements {IActivatable}
 */
function DockBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DockBinding" );
	
	/**
	 * @type {boolean}
	 */
	this.isActive = false;
	
	/**
	 * @type {boolean}
	 */
	this.isActivatable = true;
	
	/**
	 * @type {string}
	 */
	this.type = null;
	
	/**
	 * @type {string}
	 */
	this.reference = null;
	
	/**
	 * @type {boolean}
	 */
	this.isCollapsed = false;
	
	/**
	 * @type {boolean}
	 */
	this.isEmpty = true;
	
	/**
	 * @type {StageSplitPanelBinding}
	 */
	this._containingSplitPanelBinding = null;
	
	/**
	 * List of all open views associated to this dock. 
	 * Chages must be synched with {@link DialogStageBinding}
	 * @type {List<ViewBinding>}
	 */
	this._viewBindingList = null;
	
	/**
	 * Associates the deck to the selected perspective (area). 
	 * This property is set by the {@link StageDeckBinding}.
	 * @type {SystemNode}
	 */
	this.perspectiveNode = null;
	
	/*
	 * Overwrite TabBoxBinding element names.
	 */
	this._nodename_tab = "docktab";
	this._nodename_tabs = "docktabs";
	this._nodename_tabpanel = "dockpanel";
	this._nodename_tabpanels = "dockpanels";
	
	/*
	 * Overwrite TabBoxBinding binding implementations.
	 */
	this._impl_tab = DockTabBinding;
	this._impl_tabs = DockTabsBinding;
	this._impl_tabpanel = DockPanelBinding;
	this._impl_tabpanels = DockPanelsBinding;
}

/**
 * Identifies binding.
 */
DockBinding.prototype.toString = function () {

	return "[DockBinding]";
}

/**
 * Serialize binding.
 * @return {HashMap<string><object>}
 */
DockBinding.prototype.serialize = function () {
	
	var result = DockBinding.superclass.serialize.call ( this );
	if ( result ) {
		result.active = this.isActive ? true : null;
		result.collapsed = this.isCollapsed ? true : null;
	}
	return result;
}

/**
 * @overloads {TabBoxBinding#onBindingRegsister}
 */
DockBinding.prototype.onBindingRegister = function () {

	DockBinding.superclass.onBindingRegister.call ( this );
	
	this.addActionListener ( Binding.ACTION_ACTIVATED, this );
	this.addActionListener ( TabBoxBinding.ACTION_UPDATED, this );
	this.addActionListener ( ViewBinding.ACTION_LOADED );
	this.addActionListener ( ViewBinding.ACTION_CLOSED )
	
	this.subscribe ( BroadcastMessages.SYSTEMTREENODEBINDING_FOCUS );
	
	this._viewBindingList = new List ();
	
	this.reference = this.getProperty ( "reference" );
}

/**
 * @overloads {TabBoxBinding#onBindingAttach}
 */
DockBinding.prototype.onBindingAttach = function () {

	DockBinding.superclass.onBindingAttach.call ( this );
	
	this._containingSplitPanelBinding = this.getAncestorBindingByLocalName ( "splitpanel" );
	
	if ( this.getTabBindings ().hasEntries ()) {
		this.isEmpty = false;
		this.isActivatable = true;
	} else {
		this.dispatchAction ( DockBinding.ACTION_EMPTIED );
	}
}

/**
 * Hide editorsdock dockcontrols.
 * @overloads {TabBoxBinding#onBindingAttach}
 */
DockBinding.prototype.onBindingInitialize = function () {
	
	if ( this.type == DockBinding.TYPE_EDITORS ) {
		this.showControls ( false );
	}
	
	DockBinding.superclass.onBindingInitialize.call ( this );
}

/**
 * Hide editorsdock dockcontrols.
 * @overloads {TabBoxBinding#onMembersAttached}
 *
DockBinding.prototype.onMembersAttached = function () {

	DockBinding.superclass.onMembersAttached.call ( this );
	if ( this.type == DockBinding.TYPE_EDITORS ) {
		this.showControls ( false );
	}
}
*/

/**
 * A graphic accessory element is appended to the *parentnode* of the dock element.
 * Notice that this method overwrites the super method (no need for docktabs below).
 * @overwrites {TabBoxBinding#buildDOMContent}
 */
DockBinding.prototype.buildDOMContent = function () {
	
	var parentBinding = UserInterface.getBinding ( this.bindingElement.parentNode );
	var matrixBinding = MatrixBinding.newInstance ( this.bindingDocument );
	matrixBinding.attachClassName ( "dockliner" );
	this.shadowTree.dockLiner = matrixBinding;
	parentBinding.add ( matrixBinding );
	matrixBinding.attach ();
	matrixBinding.manifest ();
	
	var type = this.getProperty ( "type" );
	this.type = type ? type : DockBinding.TYPE_TOOLS;;
	this.attachClassName ( this.type );
	if ( this.getProperty ( "active" ) == true ) {
		this.activate ();
	}
}

/**
 * Lots of stuff can affect the apparent visibility of docks. But since 
 * the {@link ViewBinding} is not contained within the dock (it floats in a 
 * separate layber above everything else} you should always call this method 
 * to make sure that it gets properly notified of visibility changes.
 * TODO: Consider deprecating this in favour of traditional action system.
 * @param {boolean} Should be set to true if the dock is now visible.
 */
DockBinding.prototype.interceptDisplayChange = function ( wasDisplayed ) {
	
	var dockPanelBinding = this.getSelectedTabPanelBinding ();
	if ( dockPanelBinding ) {
		dockPanelBinding.isVisible = wasDisplayed;
		dockPanelBinding.dispatchAction ( 
			Binding.ACTION_VISIBILITYCHANGED
		);
		
		//dockPanelBinding.updateVisibility ( wasDisplayed );
	}
}

/**
 * Prepare new view.
 * @param {ViewDefinition} definition
 */
DockBinding.prototype.prepareNewView = function ( definition ) {
	
	// reate and append ViewBinding. 
	var viewBinding = this._getBindingForDefinition ( definition );
	
	// create and append DockTabBinding.
	// notice setup with tab label
	var tabBinding = DockTabBinding.newInstance ( this.bindingDocument );
	tabBinding.setHandle ( definition.handle );
	tabBinding.setLabel ( this.type == DockBinding.TYPE_EDITORS ? null : definition.label );
	tabBinding.setImage ( definition.image );
	tabBinding.setToolTip ( definition.toolTip );
	tabBinding.setEntityToken ( definition.entityToken );
	tabBinding.setAssociatedView ( viewBinding );
	this.appendTabByBindings ( tabBinding, null );
	
	// listen for dirty events and loaded pages
	this._setupPageBindingListeners ( tabBinding );
	
	// snap view to tabpanel position
	var tabPanelBinding = this.getTabPanelBinding ( tabBinding );
	viewBinding.snapToBinding ( tabPanelBinding );
	
	// TODO: construct a viewset binding for hosting this fellow?
	/*
	var bodyBinding = UserInterface.getBinding ( this.bindingDocument.body );
	bodyBinding.add ( viewBinding );
	*/
	var viewset = this.bindingWindow.bindingMap.views;
	viewset.add ( viewBinding );
	
	if ( !this.isActive ) {
		this.activate ();
	}
	
	/*
	 * Odd fact: if this is done on a timeout, mozilla will 
	 * summon a bug that hides the dock after a few seconds.
	 */
	viewBinding.attach ();
}

/**
 * Prepare open ViewBinding.
 * TODO: _setupDirtyStuff???? (only if open views contains editors!)
 * @param {ViewDefinition} definition
 * @param {DockTabBinding} tabBinding
 */
DockBinding.prototype.prepareOpenView = function ( definition, tabBinding ) {
	
	this.logger.debug ( "DockBinding.prototype.prepareOpenView: _setupDirtyStuff required?" );
	
	// initially, set tab appearance from definition
	tabBinding.setLabel ( definition.label );
	tabBinding.setImage ( definition.image );
	tabBinding.setToolTip ( definition.toolTip );
	
	// secondly, setup tab to grab appearance from loaded page
	this._setupPageBindingListeners ( tabBinding );
	
	var tabPanelBinding = this.getTabPanelBinding ( tabBinding );
	var viewBinding = this._getBindingForDefinition ( definition );
	tabBinding.setAssociatedView ( viewBinding );
	
	//tabPanelBinding.add ( viewBinding ); // this would create a non-floating view

	viewBinding.snapToBinding ( tabPanelBinding );
	UserInterface.getBinding ( this.bindingDocument.body ).add ( viewBinding );
	viewBinding.attach ();
	
}

/**
 * Create ViewBinding to match ViewDefinition.
 * @param {ViewDefinition} definition
 * @return {ViewBinding}
 */
DockBinding.prototype._getBindingForDefinition = function ( definition ) {
	
	var viewset = this.bindingWindow.bindingMap.views;
	var view = ViewBinding.newInstance ( viewset.bindingDocument ); // this.bindingDocument 
	view.setDefinition ( definition );
	
	return view;	
}

/**
 * Attach actionlisteners to the tabpanel associated to a given tab.
 * @param {DockTabBinding} tabBinding
 */
DockBinding.prototype._setupPageBindingListeners = function ( tabBinding ) {
	
	var tabPanelBinding = this.getTabPanelBinding ( tabBinding );
	
	var self = this;
	
	/*
	 * Declare action handler for tabBinding.
	 */
	var handler = {
		handleAction : function ( action ) {
		
			var binding = action.target;
		
			switch ( action.type ) {
				
				case PageBinding.ACTION_ATTACHED :
					TabBoxBinding.currentActiveInstance = self;
					break;
				
				case PageBinding.ACTION_INITIALIZED :
					
					/*
					 * Page reflex phase starts here!
					 */
					binding.reflex ( true );
					
					/*
					 * Page label and image transferred to docktab. Notice the 
					 * Eventbroadcaster transmission! For dialogs, this gets
					 * broadcasted by this StageDialogBinding.
					 */
					var view = tabBinding.getAssociatedView ();
					if ( binding.bindingWindow == view.getContentWindow ()) {
						tabBinding.updateDisplay ( binding );
						EventBroadcaster.broadcast ( BroadcastMessages.VIEW_COMPLETED, view.getHandle ());
						if ( StatusBar.state == StatusBar.BUSY ) {
							StatusBar.clear ();
						}
					}
					
					/*
					 * Final stuff handled by the docktab.
					 */
					tabBinding.onPageInitialize ( binding );
					action.consume ();
					break;
					
				case DockTabBinding.ACTION_UPDATE_VISUAL :
					tabBinding.updateDisplay ( binding );
					action.consume ();
					break;
					
				case DockTabBinding.ACTION_UPDATE_TOKEN :
					tabBinding.updateEntityToken ( binding );
					action.consume ();
					break;
					
				case EditorPageBinding.ACTION_DIRTY :
					tabBinding.setDirty ( true );
					// TODO: dont consume - top app menu should listen here!
					break;
					
				case EditorPageBinding.ACTION_SAVE :
					tabBinding.onSaveStart ();
					break;
					
				case ViewBinding.ACTION_ONCLOSE :
					self.closeTab ( tabBinding );
					action.consume ();
					break;
					
				case ViewBinding.ACTION_ONCLOSE_FORCE :
					self.closeTab ( tabBinding, true );
					action.consume ();
					break;
					
				case DockPanelBinding.ACTION_FORCE_SELECT :
					self.select ( tabBinding );
					break;
					
				case Binding.ACTION_FORCE_REFLEX :
					tabPanelBinding.reflex ( true );
					action.consume ();
					break;
					
				case DockTabBinding.ACTION_FORCE_CLEAN :
				case EditorPageBinding.ACTION_CLEAN :
					if ( tabBinding.isDirty ) {
						tabBinding.setDirty ( false );
					}
					break;
					
				case WindowBinding.ACTION_ONLOAD :
					alert ( "HWEJ" );
					break;
			}
		}
	};
	
	/*
	 * Attach action listeners to tabBinding.
	 */
	new List ([
	           DockTabBinding.ACTION_UPDATE_VISUAL,
	           DockTabBinding.ACTION_UPDATE_TOKEN,
	           PageBinding.ACTION_ATTACHED,
	           PageBinding.ACTION_INITIALIZED,
	           EditorPageBinding.ACTION_DIRTY,
	           EditorPageBinding.ACTION_CLEAN,
	           EditorPageBinding.ACTION_SAVE,
	           ViewBinding.ACTION_ONCLOSE,
	           ViewBinding.ACTION_ONCLOSE_FORCE,
	           DockPanelBinding.ACTION_FORCE_SELECT,
	           Binding.ACTION_FORCE_REFLEX,
	           DockTabBinding.ACTION_FORCE_CLEAN,
	           WindowBinding.ACTION_ONLOAD
	]).each ( 
		function ( action ) {
			tabPanelBinding.addActionListener ( action, handler );
		}
	);
}

/** 
 * Creates a new DockTabBinding instance.
 * @overwrites {TabBoxBinding#summonTabBinding}
 * @return {DockTabBinding}
 *
DockBinding.prototype.summonTabBinding = function () {
	
	return DockTabBinding.newInstance ( this.bindingDocument );
}
*/

/**
 * Creates a new DockPanelBinding instance.
 * @overwrites {TabBoxBinding#summonTabPanelBinding}
 * @return {DockPanelBinding}
 */
DockBinding.prototype.summonTabPanelBinding = function () {
	
	return DockPanelBinding.newInstance ( this.bindingDocument );
}

/**
 * @overloads {TabBoxBinding#handleAction}
 * @param {Action} action 
 */
DockBinding.prototype.handleAction = function ( action ) {
	
	DockBinding.superclass.handleAction.call ( this, action );

	var binding = action.target;

	switch ( action.type ) {
		
		case Binding.ACTION_ACTIVATED :
			if ( !this.isActive ) {
				this.activate ();
			}
			action.consume ();
			break;
			
		case TabBoxBinding.ACTION_UPDATED :
			if ( binding instanceof DockBinding ) {
				if ( binding.updateType == TabBoxBinding.UPDATE_DETACH ) {
					if ( !this.getTabElements ().hasEntries ()) {
						this.isEmpty = true;
						this.isActivatable = false;
						if ( this.isActive == true ) {
							this.deActivate ();
						}
						this.dispatchAction ( DockBinding.ACTION_EMPTIED );
					}
				}
			}
			// dont consume
			break;
			
		case ViewBinding.ACTION_LOADED :
			this._viewBindingList.add ( binding );
			if ( this.isActive ) {
				binding.onActivate ();
			}
			break;
		
		case ViewBinding.ACTION_CLOSED :
			this._viewBindingList.del ( binding );
			break;
	}
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
DockBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	DockBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		case BroadcastMessages.SYSTEMTREENODEBINDING_FOCUS :
			var treenode = arg;
			if ( treenode.perspectiveNode == this.perspectiveNode ) {
				this._selectTabByEntityToken ( treenode.node.getEntityToken ());
			}
			break;
	}
}

/**
 * Find a (more or less random) tab with a given entityToken and select it.
 * @param {string} entityToken
 */
DockBinding.prototype._selectTabByEntityToken = function ( entityToken ) {
	
	var tabs = this.getTabBindings (); 
	var hasSelected = false;
	
	while ( tabs.hasNext () && !hasSelected ) {
		var tab = tabs.getNext ();
		var token = tab.getEntityToken ();
		if ( token != null && token == entityToken ) {
			if ( !tab.isSelected ) {
				this.select ( tab, true );
				hasSelected = true;
			}
		}
	}
}

/**
 * Collapse tabpanels. Invoked by the {@link StageSplitPanelBinding}
 * @param {boolean} isHorizontal
 */
DockBinding.prototype.collapse = function ( isHorizontal ) {
	
	this._handleCollapse ( true, isHorizontal );
}

/**
 * Uncollapse tabpanels. Invoked by the {@link StageSplitPanelBinding}
 */
DockBinding.prototype.unCollapse = function ( isHorizontal ) {
	
	this._handleCollapse ( false, isHorizontal );
}

/**
 * Notice that flex and activation is handled by containing @link StageSplitPanelBinding}
 * @param {boolean} isCollapse
 * @param {boolean} isHorizontal
 */
DockBinding.prototype._handleCollapse = function ( isCollapse, isHorizontal ) {
	
	var dockPanelsBinding = this.getChildBindingByLocalName ( "dockpanels" );
	var containingSplitBoxBinding = this.getAncestorBindingByLocalName ( "splitbox" );
	
	if ( isCollapse ) {
		dockPanelsBinding.hide ();
		this.bindingElement.style.height = "auto";
		this.isFlexible = false;
		this.isActivatable = false;
		this.setProperty ( "collapsed", true );
		if ( isHorizontal && containingSplitBoxBinding.hasBothPanelsVisible ()) { /***/
			this.setWidth ( 200 );
		}
	} else {
		dockPanelsBinding.show ();
		this.isFlexible = true;
		this.isActivatable = true;
		this.deleteProperty ( "collapsed" );
		if ( isHorizontal ) { /***/
			this.setWidth ( false );
		}
	}
	this.interceptDisplayChange ( !isCollapse );
	this.isCollapsed = isCollapse;
}

/**
 * Activate.
 * @implements {IActivatable}
 */
DockBinding.prototype.activate = function () {
	
	if ( !this.isActive ) {
		
		this.isActive = true;
		this.attachClassName ( DockBinding.CLASSNAME_ACTIVE );
		this.setProperty ( "active", true );
		
		if ( this._containingSplitPanelBinding ) {
			this._containingSplitPanelBinding.isActive = true;
		}
		
		this.getTabBindings ().each ( function ( tab ) {
			tab.onActivate ();
		});
		
		this._viewBindingList.each ( function ( view ) {
			view.onActivate ();
		});
	
		Application.activate ( this );
	}
}

/**
 * Deactivate.
 * @implements {IActivatable}
 */
DockBinding.prototype.deActivate = function () {

	if ( this.isActive == true ) {
	
		this.isActive = false;
		this.detachClassName ( DockBinding.CLASSNAME_ACTIVE );
		this.deleteProperty ( "active" );
		
		if ( this._containingSplitPanelBinding ) {
			this._containingSplitPanelBinding.isActive = false;
		}
		
		// this and views activation should be combined!
		this.getTabBindings ().each ( function ( tab ) {
			tab.onDeactivate ();
		});
		
		this._viewBindingList.each ( function ( view ) {
			view.onDeactivate ();
		});
		
		Application.deActivate ( this );
	}
}

/**
 * Close tab.
 * @param {DockTabBinding} tabBinding
 * @param {boolean} isForce
 */
DockBinding.prototype.closeTab = function ( tabBinding, isForce ) {
	
	if ( tabBinding.isDirty && !isForce ) { 
		var resourcename = Resolver.resolve ( tabBinding.getLabel ());
		var self = this;
		Dialog.question ( 
			StringBundle.getString ( "ui", "WebSite.Application.DialogSaveResource.Title" ), 
			StringBundle.getString ( "ui", "WebSite.Application.DialogSaveResource.Text" ).replace ( "${resourcename}", resourcename ),
			Dialog.BUTTONS_YES_NO_CANCEL, {
			handleDialogResponse : function ( response ) {
				switch ( response ) {
					case Dialog.RESPONSE_YES :
						setTimeout ( function () {
							self.saveContainedEditor ( tabBinding );
						}, 0 );
						break;
					case Dialog.RESPONSE_NO :
						self.removeTab ( tabBinding );
						break;
				}
			}
		});
	} else {
		this.removeTab ( tabBinding );
	}
}

/**
 * Close tabs except.
 * @param {DockTabBinding} tabBinding
 */
DockBinding.prototype.closeTabsExcept = function ( tabBinding ) {
	
	var tabs = this.getTabBindings ();
	while ( tabs.hasNext ()) {
		var tab = tabs.getNext ();
		if ( tab != tabBinding ) {
			this.closeTab ( tab );
		}
	}
}

/**
 * Save editor associated to a give tab. A success will trigger tab close.
 * @param {DockTabBinding} tabBinding
 */ 
DockBinding.prototype.saveContainedEditor = function ( tabBinding ) {
	
	var viewBinding = tabBinding.getAssociatedView ();
	viewBinding.saveContainedEditor ();
	
	var self = this; 
	var handler = {
		handleBroadcast : function ( broadcast, arg ) {
			switch ( broadcast ) {
				case BroadcastMessages.CURRENT_SAVED :
					if ( arg.handle == viewBinding.getHandle ()) {
						EventBroadcaster.unsubscribe ( BroadcastMessages.CURRENT_SAVED, handler );
						if ( arg.isSuccess ) {
							self.removeTab ( tabBinding );
						}
					}
					break;
			}
		}
	}
	
	EventBroadcaster.subscribe ( BroadcastMessages.CURRENT_SAVED, handler );
}

/**
 * @overloads {TabBoxBinding#appendTabByBindings}
 * @param {TabBinding} tabBinding
 * @param {object} tabPanelContent This can be either a Binding or a DOMElement
 */
DockBinding.prototype.appendTabByBindings = function ( tabBinding, tabPanelContent ) {
	
	if ( this.isEmpty ) {
		
		this.isEmpty = false;
		this.isActivatable = true;
		this.setWidth ( false ); // check for collapsed first?
		this.dispatchAction ( DockBinding.ACTION_OPENED );
	}
	DockBinding.superclass.appendTabByBindings.call ( this, tabBinding, tabPanelContent );
}

/**
 * This is queried by the containing splitpanel when minimized
 * @see {StageSplitPanelBinding#minimize}
 * return {int}
 */
DockBinding.prototype.getHeight = function () {
	
	return this.bindingElement.offsetHeight;
}

/**
 * This is queried by Internet Explorer in the (@link DockTabsBinding} 
 * in order to fix a rendering engine bug.
 * @see {DockTabsBinding#flex}
  * return {int}
 */
DockBinding.prototype.getWidth = function () {
	
	return this.bindingElement.offsetWidth;
}

/**
  * @param {int} width
 */
DockBinding.prototype.setWidth = function ( width ) {
	
	width = width ? width + "px" : "100%";
	this.bindingElement.style.width = width;
}

/**
 * @overloads {Binding#show}
 */
DockBinding.prototype.show = function () {
	
	if ( this.isVisible ) {
		DockBinding.superclass.show.call ( this );
		this.isFlexible = true;
		this.shadowTree.dockLiner.style.display = "block";
	}
}

/**
 * This is probably only used for the Start Dock...
 * @overloads {Binding#hide}
 */
DockBinding.prototype.hide = function () {
	
	if ( !this.isVisible ) {
		DockBinding.superclass.hide.call ( this );
		this.shadowTree.dockLiner.style.display = "none";
		this.isFlexible = false;
		if ( this.isActive ) {
			this.deActivate ();
		}
	}
}

/**
 * Showhide the dockcontrols. They are hidden when the stagedeck 
 * presents the main editorsdock as the single open dock.
 * @param {boolean} isShow
 */
DockBinding.prototype.showControls = function ( isShow ) {
	
	var tabs = this.getChildBindingByLocalName ( this._nodename_tabs );
	if ( isShow ) {
		tabs.controlGroupBinding.show ();
	} else {
		tabs.controlGroupBinding.hide ();
	}
}


DockTabsBinding.prototype = new TabsBinding;
DockTabsBinding.prototype.constructor = DockTabsBinding;
DockTabsBinding.superclass = TabsBinding.prototype;
DockTabsBinding.NODENAME_TABBOX = "dock";
DockTabsBinding.TABBUTTON_IMPLEMENTATION = DockTabsButtonBinding;

/**
 * @class
 */
function DockTabsBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DockTabsBinding" );
}

/**
 * Identifies binding.
 */
DockTabsBinding.prototype.toString = function () {

	return "[DockTabsBinding]";
}


/**
 * @overloads {TabsBinding#buildDOMContent}
 */
DockTabsBinding.prototype.buildDOMContent = function () {

	DockTabsBinding.superclass.buildDOMContent.call ( this );
	
	if ( this.containingTabBoxBinding.type != DockBinding.TYPE_EXPLORER ) {
		this.controlGroupBinding = this.add (
			ControlGroupBinding.newInstance ( this.bindingDocument ) 
		);
		this.controlGroupBinding.attachClassName ( "docktabscontrolgroup" );
		// this.controlGroupBinding.add ( this.getControlBinding ( ControlBinding.TYPE_MINIMIZE ));
		this.controlGroupBinding.add ( this.getControlBinding ( ControlBinding.TYPE_MAXIMIZE ));
		this.controlGroupBinding.attachRecursive ();
	}
}

/**
 * Build DockControlBinding.
 * @param {string} type
 * @return {ControlBinding}
 */
DockTabsBinding.prototype.getControlBinding = function ( type ) {

	var controlBinding = DockControlBinding.newInstance ( this.bindingDocument );
	controlBinding.setControlType ( type );
	return controlBinding;
}

/**
 * @overloads {TabsBinding#flex}
 * @implements {IFlexible}
 */
DockTabsBinding.prototype.flex = function () {

	/*
	 * This fixes a horrendous rendering engine malfunction in Explorer.
	 * Notice that a borderwidth (or whatever) has been hardcoded into this!
	 */
	if ( Client.isExplorer && this.containingTabBoxBinding != null ) {
	
		var self = this;
		function fix () {
			var width = self.containingTabBoxBinding.getWidth ();
			if ( !isNaN ( width )) {
				width = width > 0 ? width - 1 : 0; // hardcode!
				self.bindingElement.style.width = new String ( width ) + "px";
			}
		}
		setTimeout ( fix, 250 );
		fix ();
	}
	
	DockTabsBinding.superclass.flex.call ( this );
}

/**
 * Handle crawler.
 * @implements {ICrawlerHandler}
 * @param {Crawler} crawler
 */
DockTabsBinding.prototype.handleCrawler = function ( crawler ) {
	
	DockTabsBinding.superclass.handleCrawler.call ( this, crawler );
	
	switch ( crawler.id ) {	
		case FlexBoxCrawler.ID :
			this._explorerFlexHack ();
			break;
	}
}

/*
 * This fixes a horrendous rendering engine malfunction in Explorer.
 * Notice that a borderwidth (or whatever) has been hardcoded into this!
 */
DockTabsBinding.prototype._explorerFlexHack = function () {
	
	if ( Client.isExplorer && this.containingTabBoxBinding != null ) {
	
		var self = this;
		function fix () {
			var width = self.containingTabBoxBinding.getWidth ();
			if ( !isNaN ( width )) {
				width = width > 0 ? width - 1 : 0; // hardcode!
				self.bindingElement.style.width = new String ( width ) + "px";
			}
		}
		setTimeout ( fix, 250 );
		fix ();
	}
}

/**
 * DockTabsBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {DockTabsBinding}
 */
DockTabsBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:docktabs", ownerDocument );
	return UserInterface.registerBinding ( element, DockTabsBinding );
}

DockTabBinding.prototype = new TabBinding;
DockTabBinding.prototype.constructor = DockTabBinding;
DockTabBinding.superclass = TabBinding.prototype;

DockTabBinding.ACTION_FORCE_CLEAN = "docktab force clean";
DockTabBinding.ACTION_UPDATE_VISUAL = "docktab update visual";
DockTabBinding.ACTION_UPDATE_TOKEN = "docktab update token";

DockTabBinding.NODENAME_TABBOX = "dock";

DockTabBinding.LABEL_TABLOADING = "${string:Website.App.LabelLoading}";
DockTabBinding.LABEL_TABDEFAULT = "${string:Website.App.LabelLoaded}";
DockTabBinding.LABEL_TABSAVED = "${string:Website.App.LabelSaved}";

DockTabBinding.IMG_TABLOADING = "${icon:loading}";
DockTabBinding.IMG_TABDEFAULT = "${icon:default}";

/**
 * @class
 */
function DockTabBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DockTabBinding" );
	
	/**
	 * Associates the deck to the selected perspective. 
	 * @type {SystemNode}
	 */
	this.perspectiveNode = null;
	
	/**
	 * @type {ControlGroupBinding}
	 */
	this._controlGroupBinding = null;
	
	/**
	 * EXPLAIN!
	 * @type {Binding}
	 */
	this._viewBinding = null;
	
	/**
	 * Relevant for docks containing editors.
	 * @type {boolean}
	 */
	this.isDirty = false;
	
	/**
	 * Flipped when DockTabs have invoked the "manage" routine.
	 * @type {boolean}
	 */
	this.isInitiallyHidden = true;
	
	/**
	 * Associates the tab to a tree item.
	 * @type {string}
	 */
	this._entityToken = null;
	
	/**
	 * When a tree update is triggered by the tab, this flag  
	 * is flipped to lock further updates for a short time. 
	 * @type {boolean}
	 */
	this._canUpdateTree = true;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
DockTabBinding.prototype.toString = function () {

	return "[DockTabBinding]";
}

/**
 * Set contextmenu on startup.
 * @overloads {TabBinding#onBindingAttach}
 */
DockTabBinding.prototype.onBindingAttach = function () {
	
	DockTabBinding.superclass.onBindingAttach.call ( this );
	this.subscribe ( BroadcastMessages.BIND_TOKEN_TO_VIEW );
	this.perspectiveNode = this.containingTabBoxBinding.perspectiveNode;
	this.addActionListener ( ControlBinding.ACTION_COMMAND, this );
	if ( this.containingTabBoxBinding.type != DockBinding.EXPLORER ) {
		this.setContextMenu ( 
			top.app.bindingMap.docktabpopup 
		);
	}
}

/**
 * Set associated ViewBinding.
 * @param {Binding} viewBinding
 */
DockTabBinding.prototype.setAssociatedView = function ( viewBinding ) {

	this._viewBinding = viewBinding;
}

/**
 * Get associated ViewBinding.
 * @return {Binding}
 */
DockTabBinding.prototype.getAssociatedView = function () {
	
	return this._viewBinding;
}

/**
 * Serialize binding.
 * @overloads {TabBinding#serialize}
 * @return {HashMap<string><object>}
 */
DockTabBinding.prototype.serialize = function () {
	
	var result = DockTabBinding.superclass.serialize.call ( this );
	if ( result ) {
		result.label = null;
		result.image = null;
		result.handle = this.getHandle ();
	}
	return result;
}

/**
 * Set handle.
 * @param {string} handle
 */
DockTabBinding.prototype.setHandle = function ( handle ) {
	
	this.setProperty ( "handle", handle );
}

/**
 * Get handle.
 * @return {string}
 */
DockTabBinding.prototype.getHandle = function () {
	
	return this.getProperty ( "handle" );
}

/**
 * Set entityToken, associating the tab to a tree item.
 * @return
 */
DockTabBinding.prototype.setEntityToken = function ( token ) {
	
	if ( this._entityToken == null ) {
		this.subscribe ( BroadcastMessages.SYSTEMTREEBINDING_LOCKTOEDITOR );
	}
	this._entityToken = token;
	
	/*
	 * During initialization, _updateTree is invoked other places. After  
	 * initialization, setting the entityToken will FORCE an _updateTree. 
	 */
	if ( this.isAttached ) {
		if ( this.isSelected ) { // hmm... and activated...
			this._updateTree ( true ); // force by boolean arg
		}
	}
}

/**
 * Get entityToken.
 * @return {string}
 */
DockTabBinding.prototype.getEntityToken = function () {
	
	return this._entityToken;
}

/**
 * @overloads {TabBinding#buildDOMContent}
 */
DockTabBinding.prototype.buildDOMContent = function () {

	DockTabBinding.superclass.buildDOMContent.call ( this );

	this._controlGroupBinding = this.labelBinding.add (
		ControlGroupBinding.newInstance ( this.bindingDocument ) 
	);
	var controlBinding = DialogControlBinding.newInstance ( this.bindingDocument );
	controlBinding.setControlType ( ControlBinding.TYPE_CLOSE );
	this._controlGroupBinding.add ( controlBinding );
	this._controlGroupBinding.attachRecursive ();
}

/**
 * Invoked by actionlisteners setup in DockBinding.
 * @see {DockBinding#_setupPageBindingListeners}
 * @param {boolean} isDirty
 */
DockTabBinding.prototype.setDirty = function ( isDirty ) {
	
	if ( this.containingTabBoxBinding.type == DockBinding.TYPE_EDITORS ) {
		if ( this.isDirty != isDirty ) {
			this.isDirty = isDirty;
			if ( Binding.exists ( this.labelBinding )) { // happens while closing the tab...
				var label = this.labelBinding.getLabel ();
				if ( label != null ) {
					this.labelBinding.setLabel ( 
						isDirty ? "*" + label : label.slice ( 1, label.length )		
					);
				} else {
					this.labelBinding.setLabel ( isDirty ? "*" : "" );
				}
			}
		}
		var broadcaster = top.app.bindingMap.broadcasterCurrentTabDirty;
		if ( this.isDirty == true ) {
			this.subscribe ( BroadcastMessages.SAVE_CURRENT );
			EventBroadcaster.broadcast ( BroadcastMessages.DOCKTAB_DIRTY, this );
			broadcaster.enable ();
		} else {
			this.unsubscribe ( BroadcastMessages.SAVE_CURRENT  );
			EventBroadcaster.broadcast ( BroadcastMessages.DOCKTAB_CLEAN, this );
			broadcaster.disable ();
		}
	} else {
		Dialog.warning ( "Dirty denied", "Only editor docks should invoke the dirty state!" );
	}
}

/**
 * Grab label, image and tooltip from another binding (presumably a loaded PageBinding).
 * @see {DockBinding_setupPageBindingListeners}
 * @param {Binding} binding
 */
DockTabBinding.prototype.updateDisplay = function ( binding ) {
	
	this.setLabel ( binding.getLabel ());
	this.setImage ( binding.getImage ());
	this.setToolTip ( binding.getToolTip ());
}

/**
 * Update entityToken.
 * @see {DockBinding_setupPageBindingListeners}
 */
DockTabBinding.prototype.updateEntityToken = function ( binding ) {
	
	this.setEntityToken ( binding.getEntityToken ());
}

/**
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
DockTabBinding.prototype.handleAction = function ( action ) {
	
	DockTabBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	
	switch ( action.type ) {
		case ControlBinding.ACTION_COMMAND :
			if ( binding.controlType == ControlBinding.TYPE_CLOSE ) {
				this.close ()
			}
			break;
		case MenuItemBinding.ACTION_COMMAND :
		 	if ( action.listener == this.contextMenuBinding ) {
		 		this._handleContextMenuItemBinding ( binding );
		 	}
			break;
	}
}

/**
 * @param {MenuItemBinding} menuItemBinding
 */
DockTabBinding.prototype._handleContextMenuItemBinding = function ( menuItemBinding ) {
	
	var cmd = menuItemBinding.getProperty ( "cmd" );
	
	switch ( cmd ) {
		case DockTabPopupBinding.CMD_REFRESH :
			if ( this.containingTabBoxBinding.type != DockBinding.TYPE_TOOLS ) {
				this.setLabel ( DockTabBinding.LABEL_TABLOADING );
			}
			this.setImage ( DockTabBinding.IMG_TABLOADING );
			this._viewBinding.reload ( Application.isDeveloperMode );
			this.isDirty = false;
			break;
		case DockTabPopupBinding.CMD_MAKEDIRTY :
			this.setDirty ( true );
			break;
		case DockTabPopupBinding.CMD_VIEWSOURCE :
		case DockTabPopupBinding.CMD_VIEWGENERATED :
		case DockTabPopupBinding.CMD_VIEWSERIALIZED :
			this._viewSource ( cmd );
			break;
		case DockTabPopupBinding.CMD_CLOSETAB :
			this.close ()
			break;
		case DockTabPopupBinding.CMD_CLOSEOTHERS :
			this.containingTabBoxBinding.closeTabsExcept ( this );
			break;
		default :
			alert ( "TODO!" );
			break;
	}
}

/** 
 * Rigged up for default tab labels. Always invoked at least twice: 
 * 1) When the tab is constructed (by DockBinding) 
 * 2) When the PageBinding is inititlized (in associated tab panel).
 * @overloads {TabBinding#setLabel}
 * @param {string} label
 */
DockTabBinding.prototype.setLabel = function ( label ) {

	if ( !label ) {
		if ( !this.getLabel ()) {
			label = DockTabBinding.LABEL_TABLOADING;
		} else if ( this.getLabel () == DockTabBinding.LABEL_TABLOADING ) {
			label = DockTabBinding.LABEL_TABDEFAULT;
		}
	}
	DockTabBinding.superclass.setLabel.call ( this, label );
}

/** 
 * Rigged up for default tab images. Always invoked at least twice: 
 * 1) When the tab is constructed (by DockBinding) 
 * 2) When the PageBinding is inititlized (in associated tab panel).
 * @overloads {TabBinding#setImage}
 * @param {string} image
 */
DockTabBinding.prototype.setImage = function ( image ) {

	if ( !image ) {
		if ( !this.getImage ()) {
			image = DockTabBinding.IMG_TABLOADING;
		} else if ( this.getImage () == DockTabBinding.IMG_TABLOADING ) {
			image = DockTabBinding.IMG_TABDEFAULT;
		}
	}
	DockTabBinding.superclass.setImage.call ( this, image );
}

/**
 * View contained source.
 * @param {string} cmd
 */
DockTabBinding.prototype._viewSource = function ( cmd ) {

	var def = ViewDefinitions [ "Composite.Management.SourceCodeViewer" ];
	def.argument = { 
		action: cmd, 
		doc : this._viewBinding.windowBinding.getContentDocument ()
	};
	var label = Resolver.resolve ( this.getLabel ());
	switch ( cmd ) {
		case DockTabPopupBinding.CMD_VIEWSOURCE :
			def.label = "Source: " + label;
			break;
		case DockTabPopupBinding.CMD_VIEWGENERATED :
			def.label = "Generated: "  + label;
			break;
		case DockTabPopupBinding.CMD_VIEWSERIALIZED :
			def.label = "Serialized: " + label;
			break;
	}
	StageBinding.presentViewDefinition ( def );
}

/**
 * Invoked by the DockBinding on activation.
 */
DockTabBinding.prototype.onActivate = function () {
	
	this._updateBroadcasters ();
	if ( this.isSelected ) {
		this._updateTree ();
	}
	if ( this._controlGroupBinding ) {
		this._controlGroupBinding.onActivate ();
	}
	if ( this.isSelected ) {
		this._updateGlobalEntityToken ();
	}
}

/**
 * Invoked by the DockBinding on deactivation.
 */
DockTabBinding.prototype.onDeactivate = function () {
	
	if ( this._controlGroupBinding ) {
		this._controlGroupBinding.onDeactivate ();
	}
}

/**
 * Invoked when associated page initializes.
 * @see {DockBinding#_setupPageBindingListeners}
 */
DockTabBinding.prototype.onPageInitialize = function ( page ) {
	
	this._updateBroadcasters ();
	if ( this._isEditorDockTab ()) {
		if ( !this.hasSubscription ( BroadcastMessages.CLOSE_ALL )) { // reload tab!
			this.subscribe ( BroadcastMessages.CLOSE_CURRENT );
			this.subscribe ( BroadcastMessages.CLOSE_ALL );
		}
	}
}

/**
 * Save contained editor.
 * @see {ViewBinding#handleAction}
 */
DockTabBinding.prototype.saveContainedEditor = function () {
	
	if ( this._isEditorDockTab () && this.isDirty == true ) {
		this._viewBinding.saveContainedEditor ();
	}
}

/**
 * Dock tabs are initially hidden by CSS in order to prevent jumping tabs. It's a 
 * timeout issue (takes browser a millisecond to compute tab width exactly).
 * TODO: This should in theory be backported to super class.
 * @see {TabsBinding#manage}
 * @overloads {TabBinding#show}
 */
DockTabBinding.prototype.show = function () {
	
	DockTabBinding.superclass.show.call ( this );
	
	if ( this.isVisible && this.isInitiallyHidden && Binding.exists ( this )) {
		
		this.isInitiallyHidden = false;
		
		/*
		 * Timeout to completely stabilize.
		 */
		var element = this.bindingElement;
		setTimeout ( function () {
			element.style.bottom = "auto";
		}, 25 );
	}
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {
 */
DockTabBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	DockTabBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	var body = this._viewBinding.getContentDocument ().body;
	var root = UserInterface.getBinding ( body );
	
	switch ( broadcast ) {
		
		case BroadcastMessages.SAVE_CURRENT :
			if ( this.isDirty && this.isSelected && root.isActivated ) {
				this.saveContainedEditor ();
			}
			break;
			
		case BroadcastMessages.CURRENT_SAVED :
			if ( arg.handle == this.getAssociatedView ().getHandle ()) {
				this.unsubscribe ( BroadcastMessages.CURRENT_SAVED );
				if ( arg.isSuccess ) {
					this._onSaveSuccess ();
				} else {
					this._onSaveFailure ();	
				}
			}
			break;
		
		case BroadcastMessages.CLOSE_CURRENT :
			if ( this._isEditorDockTab ()) {
				if ( this.isSelected && root.isActivated ) {
					this.close ();
				}
			}
			break;
		
		case BroadcastMessages.CLOSE_ALL :
			if ( this._isEditorDockTab ()) {
				this.close ();
			}
			break;
			
		case BroadcastMessages.SYSTEMTREEBINDING_LOCKTOEDITOR :
			if ( this.isSelected ) {
				if ( UserInterface.isBindingVisible ( this )) {
					this._updateTree ();
				}
			}
			break;
			
		case BroadcastMessages.BIND_TOKEN_TO_VIEW :
			if ( arg.handle == this._viewBinding.getDefinition ().handle ) {
				this.setEntityToken ( arg.entityToken );
				if ( this.isSelected ) {
					this._updateTree ();
				}
			}
			break;
	}
}

/**
 * Invoked by the TabPanelBinding - but the code for 
 * the actionlistener is found somewhere in DockBinding.
 * @see {DockBinding#_setupPageBindingListeners}
 * @return
 */
DockTabBinding.prototype.onSaveStart = function () {
	
	this.subscribe ( BroadcastMessages.CURRENT_SAVED );
}

/**
 * Invoked on successful save.
 */
DockTabBinding.prototype._onSaveSuccess = function () {
	
	/*
	 * If you are here looking for a resetting of property 
	 * this.isDirty, note that it will be flipped by 
	 * interception of EditorPageBinding.ACTION_CLEAN ...
	 */
	
	/*
	 * Update associated page.
	 */
	var page = this._viewBinding.getPageBinding ();
	if ( page != null && page instanceof EditorPageBinding ) {
		page.onSaveSuccess ();
	}
}

/**
 * Invoked on failed save.
 */
DockTabBinding.prototype._onSaveFailure = function () {
	
	// TODO!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}

/**
 * @overwrites {TabBinding#select}
 */
DockTabBinding.prototype.select = function ( isManaged ) {
	
	DockTabBinding.superclass.select.call ( this, isManaged );
	
	/* 
	 * Update top level broadcaster to enable the main menu "save" command.
	 */
	this._updateBroadcasters ();
	
	/*
	 * Update tree focus.
	 */
	if ( isManaged != true ) {
		this._updateTree ();
	}
	
	/*
	 * TODO: Technically this should only be done when the dock is activated...
	 */
	this._updateGlobalEntityToken ();
}


/**
 * Close the tab. Does not check for dirty content - use with caution!
 */
DockTabBinding.prototype.close = function () {
	
	this.containingTabBoxBinding.closeTab ( this );
}

/**
 * Update broadcasters.
 */
DockTabBinding.prototype._updateBroadcasters = function () {
	
	if ( this.isSelected ) {
		
		var dirtyBroadcaster = top.app.bindingMap.broadcasterCurrentTabDirty;
		var editorBroadcaster = top.app.bindingMap.broadcasterCurrentIsEditor;
		
		if ( this._isEditorDockTab ()) {	
			editorBroadcaster.enable ();
			if ( this.isDirty ) {
				dirtyBroadcaster.enable ();
			} else {
				dirtyBroadcaster.disable ();
			}
		} else {
			editorBroadcaster.disable ();
			dirtyBroadcaster.disable ();
		}
	}
}

/**
 * Update tree (if locked to editor). Note that this is done at three distinct 
 * points in a DockTabBinding lifecycle: When entityToken is updated, when 
 * the tab is selected and when the tab is activated (and selected). This may 
 * happen all at once, for example during tab creation, so the operation has 
 * been fitted with a short timeout to prevent multiple webservice invokations.
 * @param {boolean} isForce 
 */
DockTabBinding.prototype._updateTree = function ( isForce ) {
	
	if ( this._canUpdateTree || isForce ) {
		
		EventBroadcaster.broadcast ( 
			BroadcastMessages.DOCKTABBINDING_SELECT, 
			this
		);
		
		/*
		 * Eh. This seems to habe been disabled for some reason... 
		 *
		//this._canUpdateTree = false;
		
		// ... so we disabled this also!
		var self = this;
		setTimeout ( function () {
			self._canUpdateTree = true;
		}, 250 );
		*/
	}
}

/**
 * Hacked method to determine if we are an editor tab: 
 * Simply look for a save-button inside the document.
 * @return {boolean}
 */
DockTabBinding.prototype._isEditorDockTab = function () {
	
	var result = false;
	if ( this._viewBinding != null ) {
		var win = this._viewBinding.getContentWindow ();
		if ( win != null && win.bindingMap != null ) {
			var button = win.bindingMap.savebutton;
			if ( button != null ) {
				result = true;
			}
		}
	}
	return result;
}

/**
 * Update a global reference to the currently selected tabs associated 
 * serializedEntityToken. This is used to restore focus in trees when refreshed. 
 * @return
 */
DockTabBinding.prototype._updateGlobalEntityToken = function () {
	
	StageBinding.entityToken = this._entityToken;
}

/**
 * DockTabBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {DockTabBinding}
 */
DockTabBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:docktab", ownerDocument );
	return UserInterface.registerBinding ( element, DockTabBinding );
}

DockPanelsBinding.prototype = new TabPanelsBinding;
DockPanelsBinding.prototype.constructor = DockPanelsBinding;
DockPanelsBinding.superclass = TabPanelsBinding.prototype;
//DockPanelsBinding.NODENAME_TABBOX = "tabbox";

/**
 * @class
 */
function DockPanelsBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DockPanelsBinding" );
	
	/**
	 * @type {boolean}
	 */
	this.isVisible = true;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
DockPanelsBinding.prototype.toString = function () {

	return "[DockPanelsBinding]";
}

/**
 * DockPanelsBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {DockPanelsBinding}
 */
DockPanelsBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:dockpanels", ownerDocument );
	return UserInterface.registerBinding ( element, DockPanelsBinding );
}

DockPanelBinding.prototype = new TabPanelBinding;
DockPanelBinding.prototype.constructor = DockPanelBinding;
DockPanelBinding.superclass = TabPanelBinding.prototype;

/*
 * Descendant bindings may dispatch this  
 * action to select the associated tab.
 */
DockPanelBinding.ACTION_FORCE_SELECT = "dockpanel force select";

/**
 * @class
 */
function DockPanelBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DockPanelBinding" );
	
	/**
	 * The ViewBinding currently snapped to this  
	 * dockpanel. This property is set by the view. 
	 * @see {ViewBinding#snapToBinding}
	 * @type {ViewBinding}
	 */
	this.viewBinding = null;
	
	/*
	 * Returnable.
	 */
	return this;
}


/**
 * Identifies binding.
 */
DockPanelBinding.prototype.toString = function () {

	return "[DockPanelBinding]";
}

/**
 * When closing, dispose associated view.
 */
DockPanelBinding.prototype.onBindingDispose = function () {

	DockPanelBinding.superclass.onBindingDispose.call ( this );
	this.dispatchAction ( Binding.ACTION_DISPOSED );
}

/**
 * @overloads {TabPanelBinding#select}.
 * @param {boolean} isManaged If set to true, application focus will not be updated.
 */
DockPanelBinding.prototype.select = function ( isManaged ) {
	
	DockPanelBinding.superclass.select.call ( this, isManaged );
	this.dispatchAction ( Binding.ACTION_VISIBILITYCHANGED );
}

/**
 * @overloads {TabPanelBinding#unselect}.
 */
DockPanelBinding.prototype.unselect = function () {
	
	DockPanelBinding.superclass.unselect.call ( this );
	this.dispatchAction ( Binding.ACTION_VISIBILITYCHANGED );
}

/**
 * Action dispatched to be intercepted by the {@link ViewBinding}.
 * @implements {IFlexible} 
 */
DockPanelBinding.prototype.flex = function () {
	
	this.dispatchAction ( Binding.ACTION_DIMENSIONCHANGED );
} 


/**
 * Handle crawler. 
 * @implements {ICrawlerHandler}
 * @overloads {Binding#handleCrawler}
 * @param {Crawler} crawler
 */
DockPanelBinding.prototype.handleCrawler = function ( crawler ) {

	DockPanelBinding.superclass.handleCrawler.call ( this, crawler );
	
	/*
	 * Relay descending crawlers to view. The view has been rigged 
	 * up to return the crawler back here when it has been crawled.
	 * @see {ViewBinding#handleCrawler}
	 */
	if ( crawler.response == null ) {
		if ( crawler.type == NodeCrawler.TYPE_DESCENDING ) {
			if ( this.viewBinding != null ) {
				if ( crawler.id == FocusCrawler.ID ) {
					crawler.nextNode = this.viewBinding.bindingElement;
				}
			}
		}
	}
}

/**
 * DockPanelBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {DockPanelBinding}
 */
DockPanelBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:dockpanel", ownerDocument );
	return UserInterface.registerBinding ( element, DockPanelBinding );
}

DockControlBinding.prototype = new ControlBinding;
DockControlBinding.prototype.constructor = DockControlBinding;
DockControlBinding.superclass = ControlBinding.prototype;

/**
 * @class
 */
function DockControlBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DockControlBinding" );
}

/**
 * Identifies binding.
 */
DockControlBinding.prototype.toString = function () {

	return "[DockControlBinding]";
}

/**
 * @overloads {Binding#onBindingRegister}
 */
DockControlBinding.prototype.onBindingRegister = function () {

	DockControlBinding.superclass.onBindingRegister.call ( this );
	this.setImageProfile ( DockControlImageProfile );
}


/**
 * ControlBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {MYBinding}
 */
DockControlBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:toolbarbutton", ownerDocument );
	return UserInterface.registerBinding ( element, DockControlBinding );
}

DockTabPopupBinding.prototype = new PopupBinding;
DockTabPopupBinding.prototype.constructor = DockTabPopupBinding;
DockTabPopupBinding.superclass = PopupBinding.prototype;

DockTabPopupBinding.CMD_RESTORE 		= "restore";
DockTabPopupBinding.CMD_MINIMIZE 		= "minimize";
DockTabPopupBinding.CMD_MAXIMIZE 		= "maximize";
DockTabPopupBinding.CMD_REFRESH 		= "refreshview";
DockTabPopupBinding.CMD_MAKEDIRTY 		= "makedirty";
DockTabPopupBinding.CMD_CLOSETAB 		= "closetab";
DockTabPopupBinding.CMD_CLOSEOTHERS 	= "closeothers";
DockTabPopupBinding.CMD_CLOSEALL 		= "closeall";
DockTabPopupBinding.CMD_VIEWSOURCE 		= "viewsource";
DockTabPopupBinding.CMD_VIEWGENERATED 	= "viewgenerated";
DockTabPopupBinding.CMD_VIEWSERIALIZED 	= "viewserialized";

function DockTabPopupBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DockTabPopupBinding" );
}

/**
 * Identifies binding.
 */
DockTabPopupBinding.prototype.toString = function () {

	return "[DockTabPopupBinding]";
}

/**
 * @overloads {PopupBinding#onBindingAttach}
 */
DockTabPopupBinding.prototype.onBindingAttach = function () {
	
	DockTabPopupBinding.superclass.onBindingAttach.call ( this );
	this._indexMenuContent ();
}

ViewSetBinding.prototype = new Binding;
ViewSetBinding.prototype.constructor = ViewSetBinding;
ViewSetBinding.superclass = Binding.prototype;

/**
 * @class
 */
function ViewSetBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ViewSetBinding" );
	
	/**
	 * Block common crawlers. Although views are children of this 
	 * binding, they APPEAR to be positioned elsewhere in the tree, 
	 * so this list should plausibly be extended for future crawlers. 
	 * Note: The crawler will be directed into view from the dockpanel.
	 * @see {DockPanelBinding#handleCrawler}
	 * @overwrites {Binding#crawlerFilters}
	 * @type {List<string>}
	 */
	this.crawlerFilters	= new List ([ FlexBoxCrawler.ID, FocusCrawler.ID ]);
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
ViewSetBinding.prototype.toString = function () {

	return "[ViewSetBinding]";
}

ViewBinding.prototype = new FlexBoxBinding;
ViewBinding.prototype.constructor = ViewBinding;
ViewBinding.superclass = FlexBoxBinding.prototype;

ViewBinding.ACTION_LOADED = "view loaded";
ViewBinding.ACTION_ONCLOSE = "view onclose";
ViewBinding.ACTION_ONCLOSE_FORCE = "view onclose force";
ViewBinding.ACTION_CLOSED = "view closed";
ViewBinding.ACTION_DETACH = "view detach";

ViewBinding.HORIZONTAL_ADJUST = 1;
ViewBinding.VERTICAL_ADJUST = 1;

/*
 * These strings get attached to 
 * respective views as classnames.
 */
ViewBinding.TYPE_EXPLORERVIEW = "explorerview";
ViewBinding.TYPE_DOCKVIEW = "dockview";
ViewBinding.TYPE_DIALOGVIEW = "dialogview";

/*
 * Classname activated.
 */
ViewBinding.CLASSNAME_ACTIVE = "active";

 /** 
  * Timeout in seconds before assuming an ASPX error.
  * @type {int}
  */
ViewBinding.TIMEOUT = 15;

/**
 * Considered private, see below.
 * @type {Map<string><ViewBinding>}
 */
ViewBinding._instances = new Map ();

/**
 * Get instance by handle.
 * @param {string} handle
 * @return {ViewBinding}ViewBinding._instances.set ( this._viewDefinition.handle, this );
 */
ViewBinding.getInstance = function ( handle ) {
	
	var result = ViewBinding._instances.get ( handle );
	if ( !result ) {
		var cry = "ViewBinding.getInstance: No such instance: " + handle;
		SystemLogger.getLogger ( "ViewBinding [static]" ).error ( cry );
		SystemDebug.stack ( arguments );
		if ( Application.isDeveloperMode ) {
			alert ( cry );
		}
	}
	return result;
}

/**
 * @class
 */
function ViewBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ViewBinding" );
	
	/**
	 * @type {ViewDefinition}
	 */
	this._viewDefinition = null;
	
	/**
	 * @type {boolean}
	 */
	this.isVisible = false;
	
	/**
	 * @type {boolean}
	 */
	this._isViewBindingInitialized = false;
	
	/**
	 * @type {Binding}
	 */ 
	this._snapBinding = null;
	
	/**
	 * @type {boolean}
	 */
	this.isFreeFloating = false;
	
	/**
	 * Remember that the window is hidden while attaching due to CSS.
	 * @type {WindowBinding}
	 */
	this.windowBinding = null;
	
	/**
	 * @type {CoverBinding}
	 */
	this._coverBinding = null;
		
	/**
	 * @type {boolean}
	 */
	this._isLoaded = false;
	
	/**
	 * Patches a strange bug in mozilla.
	 */
	this._isFirstShow = true;
	
	/**
	 * Defaults to dockview.
	 * @type {string);
	 */
	this._type = ViewBinding.TYPE_DOCKVIEW;
	
	/**
	 * Points to the currently hosted PageBinding.
	 * @type {PageBinding);
	 */
	this._pageBinding = null;
	
	/**
	 * Backup position to minimize updates.
	 * @type {Point}
	 */
	this._lastknownposition = null;
	
	/**
	 * Backup dimension to minimize updates.
	 * @type {Dimension}
	 */
	this._lastknowndimension = null;
	
	/**
	 * @type {boolean}
	 */
	this.isActivated = false;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
ViewBinding.prototype.toString = function () {

	return "[ViewBinding]";
}

/**
 * @overloads {FlexBoxBinding#onBindingRegister}
 */
ViewBinding.prototype.onBindingRegister = function () {

	ViewBinding.superclass.onBindingRegister.call ( this );

	this.addActionListener ( RootBinding.ACTION_PHASE_1 );
	this.addActionListener ( RootBinding.ACTION_PHASE_2 );
	this.addActionListener ( RootBinding.ACTION_PHASE_3 );
	this.addActionListener ( WindowBinding.ACTION_LOADED );
	this.addActionListener ( WindowBinding.ACTION_ONLOAD );
	this.addActionListener ( PageBinding.ACTION_ATTACHED );
	this.addActionListener ( PageBinding.ACTION_INITIALIZED );
	this.addActionListener ( ViewBinding.ACTION_DETACH );
	
	/*
	 * Performance timing related.
	 */
	this.addActionListener ( WizardPageBinding.ACTION_NAVIGATE_NEXT );
	this.addActionListener ( WizardPageBinding.ACTION_NAVIGATE_PREVIOUS );
	this.addActionListener ( WizardPageBinding.ACTION_FINISH );
	
	/*
	 * Tune in on broadcasted closing statements.
	 */
	this.subscribe ( BroadcastMessages.CLOSE_VIEW );
	this.subscribe ( BroadcastMessages.APPLICATION_SHUTDOWN );
}

/**
 * Attach special classname depending on type.
 * @overloads {Binding#onBindingAttach}
 */
ViewBinding.prototype.onBindingAttach = function () {

	ViewBinding.superclass.onBindingAttach.call ( this );
	this.attachClassName ( this._type );
	
	/*
	 * Explorer shows a brief flash of white sometimes. Build cover 
	 * for smoother page transitions when window is loaded and unloaded. 
	 */
	if ( Client.isExplorer == true ) {
		this._coverBinding = this.add (
			CoverBinding.newInstance ( this.bindingDocument ) 
		);
		this._coverBinding.attach ();
	}
	
	/*
	 * Attach window.
	 */
	this.windowBinding.attach ();
}

/**
 * @overwrites {FlexBoxBinding#flex}
 * @return
 */
ViewBinding.prototype.updatePositionDimension = function () {
		
	var snap = this._snapBinding;
	
	/*
	 * For some reason, IE enters here when the user has 
	 * no perspectives. This should be considered a hack. 
	 * TODO: Mozilla is allowed to pass because he doesn't 
	 * fail. IE is blocked. But now the difference is that 
	 * IE is allowed to see the Start-screen. Synch this!
	 */
	var isAbort = !System.hasActivePerspectives && Client.isExplorer;
	
	if ( this.isFreeFloating == true && !isAbort ) {
		if ( snap.isVisible == true ) {
			if ( snap.isAttached == true ) {
			
				var position = snap.boxObject.getGlobalPosition ();
				var dimension = snap.boxObject.getDimension ();
			
				/*
				 * Update position.
				 */
				if ( !Point.isEqual ( position, this._lastknownposition )) {
					
					this.setPosition ( position );
					this._lastknownposition = position;
				}
				
				
				/*
				 * Update dimension.
				 */
				if ( !Dimension.isEqual ( dimension, this._lastknowndimension )) {
					
					this.setDimension ( dimension );
					this._lastknowndimension = dimension;
					
					var result = dimension.h - ViewBinding.VERTICAL_ADJUST;
					result = result < 0 ? 0 : result;
					
					this.windowBinding.getBindingElement ().style.height = new String ( result ) + "px";
					this.windowBinding.reflex ();
					
				} else {
					
					throw "Could not snap to unattached binding!";
				}
			}
		}
	}
}

/**
 * @overloads {Binding#onBindingDispose}
 */
ViewBinding.prototype.onBindingDispose = function () {
	
	ViewBinding.superclass.onBindingDispose.call ( this );
	
	/*
	 * Cancel the serverside flow in case dispose 
	 * was instantiated by a clientside action.
	 */
	if ( this._viewDefinition != null ) {
		var flowhandle = this._viewDefinition.flowHandle;
		if ( flowhandle != null ) {
			FlowControllerService.CancelFlow ( flowhandle );
		}
	}
	
	if ( this._viewDefinition != null ) {
		
		var handle = this._viewDefinition.handle;
		EventBroadcaster.broadcast ( BroadcastMessages.VIEW_CLOSED, handle );
		this.logger.fine ( "ViewBinding closed: \"" + handle + "\"" );
		/*
		 * Odd fact: Mozilla will evaluate this twice unless 
		 * wrapped in a timeout. You can also make it evaluate it   
		 * once by alerting just bofore, but that wont help us. 
		 *
		var handle = this._viewDefinition.handle;
		setTimeout ( function () {
			EventBroadcaster.broadcast ( BroadcastMessages.VIEW_CLOSED, handle );
			SystemLogger.getLogger ( "FISSE" ).fatal ( handle );
		}, 0 );
		*/
	}
	
	this.dispatchAction ( ViewBinding.ACTION_CLOSED );
}

/**
 * Set type.
 * @param {string} type
 */
ViewBinding.prototype.setType = function ( type ) {
	
	this._type = type;
	//this.attachClassName ( type );
	
	if ( type == ViewBinding.TYPE_DIALOGVIEW ) {
		this.windowBinding.isFlexible = true;
	} else {
		this.windowBinding.isFlexible = false;
	}
}

/**
 * Get type.
 * @return {string}
 */
ViewBinding.prototype.getType = function () {
	
	return this._type;
}

/**
 * Get handle. Technically, handle of the associated ViewDefinition.
 * @return {string} 
 */
ViewBinding.prototype.getHandle = function () {
	
	var result = null;
	if ( this._viewDefinition != null ) {
		result = this._viewDefinition.handle;
	}
	return result;
}

/**
 * TODO: update this method description.
 * Initialize when associated tab is selected. 
 * This method is called by the {@link StageBinding}.
 * SNAPTARGET views initialize when snapToBinding is invoked!!!
 */
ViewBinding.prototype.initialize = function () {

	if ( !this._isViewBindingInitialized ) {
		this._isViewBindingInitialized = true;
		this.windowBinding.setURL ( 
			this._viewDefinition.url 
		);
		EventBroadcaster.broadcast ( BroadcastMessages.VIEW_OPENING, this.getHandle ());
	} else {
		throw ( "Somehow ViewBinding got initialized twice: " + this.getHandle ());
	}
}

/**
 * Set associated ViewDefinition.
 * @param {ViewDefinition} definition
 */
ViewBinding.prototype.setDefinition = function ( definition ) {
	
	this._viewDefinition = definition;
	if ( definition.flowHandle != null ) {
		this.subscribe ( BroadcastMessages.CLOSE_VIEWS );
	}
}

/**
 * Get associated ViewDefinition.
 * @return {ViewDefinition}
 */
ViewBinding.prototype.getDefinition = function () {
	
	return this._viewDefinition;
}

/**
 * Implements (@link IActionListener} 
 * @param {Action} action
 */
ViewBinding.prototype.handleAction = function ( action ) {

	ViewBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;

	switch ( action.type ) {
	
		case RootBinding.ACTION_PHASE_1 :
		case RootBinding.ACTION_PHASE_2 :
		case RootBinding.ACTION_PHASE_3 :
			
			/*
			 * Activate the root binding?
			 */
			if ( action.type == RootBinding.ACTION_PHASE_1 ) {
				if ( this.isActivated && !binding.isActivated ) {
					binding.onActivate ();
				}
			}
			
			/*
			 * Consume these events. They are 
			 * intended for ViewBinding content.
			 */
			action.consume ();
			break;
	
		case Binding.ACTION_DIMENSIONCHANGED :
		//case Binding.ACTION_POSITIONCHANGED :
			if ( this.isFreeFloating == true ) {
				if ( binding == this._snapBinding ) {
				 	if ( this.isVisible == true ) {
						this.updatePositionDimension ();
						action.consume ();
					}
				}
			}
			break;
		
		case Binding.ACTION_VISIBILITYCHANGED : // see {DockBinding#interceptDisplayChange}
			if ( this.isFreeFloating == true ) {
				if ( binding == this._snapBinding ) {
					if ( binding.isVisible == true ) {
						this.show ();
					} else {
						this.hide ();
					}
				}
			}
			// can we consume this?
			break;
		
		case WindowBinding.ACTION_LOADED :
		case WindowBinding.ACTION_ONLOAD :
			
			if ( binding.getContentWindow ().isPostBackDocument ) {
				// @see {MessageQueue#openView}
				if ( action.type == WindowBinding.ACTION_ONLOAD ) {
					var arg = this._viewDefinition.argument;
					if ( arg != null && arg.list != null && arg.url != null ) {
						binding.post ( arg.list, arg.url ); 
						arg.list = null;
						arg.url = null;
						// note that this prevents a repeat! Otherwise, 
						// the previewwindow would fire this stuff...
						// TODO: hack this elsehow...
					}
				}
			} else {
				if ( Client.isExplorer == true ) {
					if ( binding == this.windowBinding ) {
						var self = this;
						DOMEvents.addEventListener ( 
							binding.getContentWindow (), 
							DOMEvents.UNLOAD, { // beforeunload invoked at random in exploder!
								handleEvent : function ( e ) {
									if ( Binding.exists ( self._coverBinding ) == true ) {
										self._coverBinding.show ();
									}
								}
							});
					}
					if ( action.type == WindowBinding.ACTION_ONLOAD ) {
						if ( this._coverBinding ) {
							this._coverBinding.hide ();
						}
					}
				}
			}
			
			/*
			 * Show non-framework document now. Otherwise  
			 * we wait for the PageBinding to initialize.
			 */
			if ( action.type == WindowBinding.ACTION_ONLOAD ) {
				var win = binding.getContentWindow ();
				if ( win.WindowManager == null ) {
					if ( !this._isLoaded ) {
						this._onLoadingCompleted ( binding );
					}
				}
			}
			action.consume ();
			break;
		
		case PageBinding.ACTION_ATTACHED :
			
			// reload scenario - PLEASE REFACTOR!
			if ( !binding.label && this._viewDefinition.label ) {
				binding.label = this._viewDefinition.label;
			}
			if ( !binding.image && this._viewDefinition.image ) {
				binding.image = this._viewDefinition.image;
			}
			
			/*
			 * Pin a reference to the currently mounted PageBinding 
			 * and set the page argument. Notice that all loaded pages 
			 * get served the same argument (although not subpages).
			 */
			if ( binding.bindingWindow == this.getContentWindow ()) {
				this._pageBinding = binding;
				this._injectPageArgument ();
			}

		case PageBinding.ACTION_INITIALIZED :
			
			/*
			 * Show myself when the root page initializes.
			 */
			if ( binding.bindingWindow == this.getContentWindow ()) {
				if ( Client.isExplorer && this._coverBinding ) {
					this._coverBinding.hide ();
				}
				if ( !this._isLoaded ) {
					this._onLoadingCompleted ();
				}
			}
			// dont consume - DockBinding and StageDialogBinding are listening!
			break;
		

		case Binding.ACTION_DISPOSED :
			
			if ( this.isFreeFloating && binding == this._snapBinding ) {
				this.removeActionListener ( Binding.ACTION_DISPOSED );
				this.dispose ();
				action.consume ();
			}
			break;
		
		/*
		 * 
		 */
		case WizardPageBinding.ACTION_NAVIGATE_NEXT :
		case WizardPageBinding.ACTION_NAVIGATE_PREVIOUS :
		case WizardPageBinding.ACTION_FINISH :
			EventBroadcaster.broadcast ( BroadcastMessages.VIEW_OPENING, this.getHandle ());
			action.consume ();
			break;
		
		/*
		 * Detach view from server control. This happens when the server error page 
		 * is shown (since workflow termination will automatically close the view). 
		 * Detach is done simply by switching the associated {@link ViewDefinition}.
		 * TODO: Something more elegant?
		 */
		case ViewBinding.ACTION_DETACH :
			this.setDefinition ( ViewDefinitions [ "Composite.Management.Null" ]);
			ViewBinding._instances.set ( this._viewDefinition.handle, this );
			// don't consume - TabPanelBinding is listening (waiting to un-dirty the tab).
			break;
	}
}

/**
 * Implements (@link IBroadcastListener}
 * @param {string} broadcast 
 * @param {object} arg
 */
ViewBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	ViewBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		
		case BroadcastMessages.CLOSE_VIEW :
			if ( arg == this._viewDefinition.handle ) {
				this.dispatchAction ( ViewBinding.ACTION_ONCLOSE );
			}
			break;
			
		case BroadcastMessages.CLOSE_VIEWS :
			if ( this._viewDefinition.flowHandle != null ) {
				this.dispatchAction ( ViewBinding.ACTION_ONCLOSE_FORCE );
			}
			break;
			
		case BroadcastMessages.APPLICATION_SHUTDOWN :
			this.dispose (); // this should happen automatically, but no...
			break;
	}
}

/**
 * On loading completed.
 */
ViewBinding.prototype._onLoadingCompleted = function () {
	
	if ( !this._isLoaded ) {
		this._open ();
		this._isLoaded = true;
	}
}

/**
 * Do stuff when opened.
 * @see {ViewBinding#onBindingDispose}
 */
ViewBinding.prototype._open = function () {
	
	ViewBinding._instances.set ( this._viewDefinition.handle, this );
	this.dispatchAction ( ViewBinding.ACTION_LOADED );
	EventBroadcaster.broadcast ( BroadcastMessages.VIEW_OPENED, this._viewDefinition.handle );
	this.show ();
	
	this.logger.fine ( "ViewBinding opened: \"" + this._viewDefinition.handle + "\"" );
}

/**
 * This method is invoked by the StageBinding when an already open ViewBinding 
 * gets re-opened. The associated ViewDefinition argument is yet again relayed 
 * to the contained PageBinding (if changed since last).
 * @see {StageBinding#_view}
 */
ViewBinding.prototype.update = function () {
	
	this.dispatchAction ( Binding.ACTION_ACTIVATED );
	this._injectPageArgument ();
}

/**
 * Relay ViewDefinition argument to contained PageBinding. 
 */
ViewBinding.prototype._injectPageArgument = function () {
	
	var page = this._pageBinding;
	var def = this._viewDefinition;
	
	if ( page != null ) {
		
		var argument = def.argument;
		if ( argument != null ) {
			page.setPageArgument ( argument );
		}
		var width = def.width;
		if ( width != null ) {
			page.width = width;
		}
		var height = def.height;
		if ( height != null ) {
			page.height = height;
		}
	}
}

/**
 * Handle crawler.
 * @implements {ICrawlerHandler}
 * @param {Crawler} crawler
 */
ViewBinding.prototype.handleCrawler = function ( crawler ) {
	
	ViewBinding.superclass.handleCrawler.call ( this, crawler );
	
	switch ( crawler.type ) {
		
		/*
		 * Redirect descending crawlers back to DockPanelBinding. 
		 * Otherwise the crawler would continue straight to the 
		 * next view (because it is now crawling the viewset).  
		 */
		case NodeCrawler.TYPE_DESCENDING :
			if ( this.isFreeFloating == true ) {
				if ( crawler.id == FocusCrawler.ID ) {
					if ( crawler.previousNode != this._snapBinding.bindingElement ) {
						crawler.response = NodeCrawler.SKIP_NODE;
					}
				}
			}
			break;
		
		/*
		 * Relay ascending crawlers to DockPanelBinding.
		 */
		case NodeCrawler.TYPE_ASCENDING :
			
			if ( this.isFreeFloating == true ) {
				crawler.nextNode = this._snapBinding.bindingElement;
			}
			break;
	}
}

/**
 * Show. Specialized setup for free-floating views.
 * @overwrites {Binding#show}
 */
ViewBinding.prototype.show = function () {
	
	if ( !this.isVisible ) {
		if ( this.isFreeFloating == true ) {
			if ( this._type == ViewBinding.TYPE_DOCKVIEW && this.windowBinding != null ) {
				this.windowBinding.getBindingElement ().style.position = "static";
			}
			this.updatePositionDimension ();
			this.isVisible = true;
		} else {
			ViewBinding.superclass.show.call ( this );
		}
	}
}

/**
 * Hide. Specialized setup for free-floating views.
 * @overwrites {Binding#hide}
 */
ViewBinding.prototype.hide = function () {
	
	if ( this.isVisible == true ) {
		if ( this.isFreeFloating == true ) {
			if ( this.windowBinding ) {
				this.windowBinding.getBindingElement ().style.position = "absolute";
			}
			this.bindingElement.style.top = "-10000px";
			this.isVisible = false;
		} else {
			ViewBinding.superclass.hide.call ( this );
		}
	}
}

/**
 * @param {Point} point
 */  
ViewBinding.prototype.setPosition = function ( point ) {

	point.x += ViewBinding.HORIZONTAL_ADJUST;
	
	this.bindingElement.style.left = point.x + "px";
	this.bindingElement.style.top = point.y + "px";
}

/**
 * @param {Dimension} dimension
 */  
ViewBinding.prototype.setDimension = function ( dimension ) {

	dimension.h -= ViewBinding.VERTICAL_ADJUST;
	dimension.w -= ViewBinding.HORIZONTAL_ADJUST;
	
	/*
	 * Something hardcoded here...
	 */
	dimension.w -= 1;
	
	if ( dimension.h < 0 ) { // not sure why this happens...
		dimension.h = 0;
	}
	if ( dimension.w < 0 ) {
		dimension.w = 0;
	}
	this.bindingElement.style.width = String ( dimension.w ) + "px";
	this.bindingElement.style.height = String ( dimension.h ) + "px";
}

/**
 * TODO: create an interface to check for.
 * @param {Binding} binding
 */
ViewBinding.prototype.snapToBinding = function ( binding ) {
	
	// Disable standard flexbox behavior. 
	// TODO: enable for floating docks????????????????????????????????????????????
	this.isFlexBoxBehavior = false;

	// Listen for these events instead... 
	binding.addActionListener ( Binding.ACTION_DIMENSIONCHANGED, this );
	binding.addActionListener ( Binding.ACTION_POSITIONCHANGED, this );
	binding.addActionListener ( Binding.ACTION_VISIBILITYCHANGED, this );
	binding.addActionListener ( Binding.ACTION_DISPOSED, this );
	
	// Unregister any previous snap target.
	if ( this._snapBinding ) {
		this._snapBinding.removeActionListener ( Binding.ACTION_DIMENSIONCHANGED, this );
		this._snapBinding.removeActionListener ( Binding.ACTION_POSITIONCHANGED, this );
		this._snapBinding.removeActionListener ( Binding.ACTION_VISIBILITYCHANGED, this );
		this._snapBinding.removeActionListener ( Binding.ACTION_DISPOSED, this );
		this._snapBinding.viewBinding = null;
	}
	this._snapBinding = binding;
	this._snapBinding.viewBinding = this;
	this.isFreeFloating = true;
	
	// Initialize when first shown, creating and loading the WindowBinding
	if ( !this._isViewBindingInitialized ) {
		this.initialize ();
	}
}

/**
 * Very special setup: Migrate all Actions to the snaptarget 
 * binding! Please note that this breaks the convention of 
 * Actions travelling upwards in the structural hierarchy.
 * @overwrites {Binding#getMigrationParent}.
 */
ViewBinding.prototype.getMigrationParent = function () {

	var result = null;
	if ( this.isFreeFloating == true ) {
		result = this._snapBinding.getBindingElement ();
	} else {
		result = ViewBinding.superclass.getMigrationParent.call ( this );
	}
	return result;
}

/**
 * Get the window object hosted by this ViewBinding. 
 * During startup, this may be undefined. 
 * @return {DOMDocumentView}
 */
ViewBinding.prototype.getContentWindow = function () {
	
	return this.windowBinding.getContentWindow ();
}

/**
 * Get the document object hosted by this ViewBinding. 
 * During startup, this may be undefined. 
 * @return {DOMDocument}
 */
ViewBinding.prototype.getContentDocument = function () {
	
	return this.windowBinding.getContentDocument ();
}

/**
 * Get the {@link RootBinding} hosted by this ViewBinding. 
 * During startup, this may be undefined. 
 * @return {RootBinding}
 */
ViewBinding.prototype.getRootBinding = function () {
	
	return this.windowBinding.getRootBinding ();
}

/**
 * Get the {@link RootBinding} hosted by this ViewBinding. 
 * During startup, this may be undefined. 
 * @return {PageBinding}
 */
ViewBinding.prototype.getPageBinding = function () {
	
	return this._pageBinding;
}

/**
 * Reload view. For now, this is only a developer feature.
 * @param {boolean} isClearCache Clear the cache in Prism.
 */
ViewBinding.prototype.reload = function ( isClearCache ) {
	
	this._isLoaded = false;
	this.windowBinding.reload ( isClearCache );
	EventBroadcaster.broadcast ( BroadcastMessages.VIEW_OPENING, this.getHandle ());
}

/**
 * Save contained editor. Probably invoked by DockBinding.
 * @see {DockBinding#saveContainedEditor}
 */
ViewBinding.prototype.saveContainedEditor = function () {
	
	var isSuccess = false;
	var page = this._pageBinding;
	if ( page != null && page instanceof EditorPageBinding ) {
		if ( page.canSave ()) {
			page.doSave ();
			isSuccess = true;
		}
	}
	if ( !isSuccess ) {
		this.logger.error ( "saveContainedEditor failed" );
	}
}

/**
 * Invoked be ancestor {IActivatable} when activated. 
 * Invokes similar method on root binding, igniting a 
 * chain reaction on all descendant root bindings.
 */
ViewBinding.prototype.onActivate = function () {
	
	if ( !this.isActivated ) {
		this.isActivated = true;
		var root = this.getRootBinding ();
		if ( root != null ) {
			root.onActivate ();
		}
	}
}

/**
 * Invoked be ancestor {IActivatable} when deactivated. 
 * See comment above.
 */
ViewBinding.prototype.onDeactivate = function () {
	
	if ( this.isActivated == true ) {
		this.isActivated = false;
		var root = this.getRootBinding ();
		if ( root != null ) {
			this.getRootBinding ().onDeactivate ();
		}
	}
}

/**
 * ViewBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {ViewBinding}
 */
ViewBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:view", ownerDocument );
	var binding = UserInterface.registerBinding ( element, ViewBinding );
	binding.windowBinding = binding.add ( WindowBinding.newInstance ( ownerDocument ));
	binding.windowBinding.isFlexible = false;
	return binding;
}

PageBinding.prototype = new FocusBinding;
PageBinding.prototype.constructor = Binding;
PageBinding.superclass = FocusBinding.prototype;

PageBinding.ACTION_ATTACHED 				= "page attached";
PageBinding.ACTION_DETACHED				 	= "page detached";
PageBinding.ACTION_INITIALIZED				= "page initialized";
PageBinding.ACTION_DOPOSTBACK 				= "page do postback";
PageBinding.ACTION_VALIDATE 				= "page validate";
PageBinding.ACTION_DOVALIDATEDPOSTBACK 		= "page do validated postback";
PageBinding.ACTION_BLOCK_INIT				= "page block init";
PageBinding.ACTION_UNBLOCK_INIT				= "page unblock init";
PageBinding.ACTION_UPDATING					= "page updating";
PageBinding.ACTION_UPDATED					= "page updated";
PageBinding.ACTION_GETMESSAGES				= "page poll messagequeue";

/**
 * Classname to be attached when page is framed inside a dialog.
 * @type {String} 
 */
PageBinding.CLASSNAME_SUBPAGE = "dialogsubpage";

/**
 * Timeout in milliseconds before an initialized page is made 
 * interactive. Prevents flex malfunctions and stabilizes layout.
 */
PageBinding.TIMEOUT = 250;

/**
 * Remeber that the page has visibility set to "hidden" while initializing!
 * @see {PageBinding#onPageInitialize}
 * @class
 */
function PageBinding () { // Note to self: This class can safely descend from FlexBoxBinding if required.

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "PageBinding" );
	
	/**
	 * @type {string}
	 */
	this.label = null;
	
	/**
	 * @type {string}
	 */
	this.image = null;
	
	/**
	 * @type {string}
	 */
	this.toolTip = null;
	
	/**
	 * Flippen on inititalization.
	 * @type {boolean} 
	 */
	this._isPageBindingInitialized = false;
	
	/**
	 * Stuff can set this property so that the  
	 * PageBinding doesn't have to go look for it.
	 * @type {object}
	 */
	this.pageArgument = null;
	
	/**
	 * When loaded inside a dialog, this property will be switched 
	 * by the containing {@link DialogPageBinding} in ancestor frame.
	 * @see {DialogPageBinding#handleAction}
	 * @see {PageBinding#makeDialogSubPage}
	 * @type {boolean}
	 */
	this.isDialogSubPage = false;
	
	/**
	 * This will override the setup mentioned above. 
	 * Please consider how to refactor this stuff!
	 * @type {boolean}
	 */
	this.isFitAsDialogSubPage = true;
	
	/** 
	 * Collecting complex bindings while page initializes. 
	 * Won't show the the page until this map is empty.
	 * @type {Map<Binding><boolean>}
	 */
	this._initBlockers = null;
	
	/**Binding.ACTION_UPDATED
	 * Flipped when the page is ready to initialize.
	 * @type {boolean}
	 */
	this._isReadyForInitialize = false;
	
	/**
	 * The PageBinding WILL be made activation aware,  
	 * but not until all content is loaded.
	 * @see {PageBinding#onAfterPageInitialize}
	 * @implements {IActivationAware}
	 * @overwrites {Binding#isActivationAware}
	 * @type {boolean}
	 */
	this.isActivationAware = false;
	
	/**
	 * @implements {IActivationAware}
	 * @overwrites {Binding#isActivationAware}
	 * @type {boolean}
	 */
	this.isActivated = false;
	
	/**
	 * When a server postback is fired, this flag will be reversed to 
	 * prevent further postback. The flag is reversed again as soon as  
	 * the MesssageQueue is updated manually (not on timed interval).
	 */
	this._canPostBack = true;
	
	/**
	 * Dissecting a simulated postback response.
	 * @type {XPathResolver} 
	 */
	this._responseResolver = null;
	
	/**
	 * True while the UpdateManager is busy doing updates.
	 * @type {boolean}
	 */
	this._isUpdating = false;
};

/**
 * Identifies binding.
 */
PageBinding.prototype.toString = function () {

	return "[PageBinding]";
};

/**
 * @overloads {FocusManagerBinding#onBindingRegister}
 */
PageBinding.prototype.onBindingRegister = function () {

	PageBinding.superclass.onBindingRegister.call ( this );
	
	var root = UserInterface.getBinding ( this.bindingDocument.body );
	root.addActionListener ( RootBinding.ACTION_PHASE_3, this );
	
	this.addActionListener ( PageBinding.ACTION_DOPOSTBACK );
	this.addActionListener ( PageBinding.ACTION_DOVALIDATEDPOSTBACK );
	this.addActionListener ( BalloonBinding.ACTION_INITIALIZE );
	this.addActionListener ( PageBinding.ACTION_BLOCK_INIT );
	this.addActionListener ( PageBinding.ACTION_UNBLOCK_INIT );
	this.addActionListener ( PageBinding.ACTION_GETMESSAGES );
	this.subscribe ( BroadcastMessages.MESSAGEQUEUE_REQUESTED );
};

/**
 * @overloads {FocusManagerBinding#onBindingAttach}
 */
PageBinding.prototype.onBindingAttach = function () {

	PageBinding.superclass.onBindingAttach.call ( this );
	
	Application.lock ( this ); // unlocked onAfterPageInitialize
	this.parseDOMProperties ();
	this.dispatchAction ( PageBinding.ACTION_ATTACHED ); // for ViewBinding!
};

/**
 * Cleanup on dispose.
 * @overloads {FocusBinding#onBindingDispose}
 */
PageBinding.prototype.onBindingDispose = function () {
	
	var root = UserInterface.getBinding ( this.bindingDocument.body );
	root.removeActionListener ( RootBinding.ACTION_PHASE_3, this );
	
	/*
	 * Unlock GUI before we die!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	 *
	if ( this._hasLock ) {
		Application.unlock ( this );
	}
	*/
	
	/*
	 * Die.
	 */
	this.dispatchAction ( PageBinding.ACTION_DETACHED );
};

/**
 * Parse DOM properties.
 */
PageBinding.prototype.parseDOMProperties = function () {
	
	/*
	 * These values may have been defined already, 
	 * for example in the setPageArgument method.
	 */
	this.label = this.getProperty ( "label" );
	this.image = this.getProperty ( "image" );
	this.toolTip = this.getProperty ( "tooltip" );
	
	/*
	 * Hacked setup. Please consider how to refactor this!
	 */
	if ( this.getProperty ( "fitasdialogsubpage" ) == false ) {
		this.isFitAsDialogSubPage = false;
	}
}

/** 
 * Stuff can provide this property so that the PageBinding doesn't have to 
 * go look for it. Note that bindings *may not* have been attached when 
 * this method is invoked.
 * @param {object} arg
 */
PageBinding.prototype.setPageArgument = function ( arg ) {
	
	/*
	 * Note that any associated dock-tab is automatically selected  
	 * by this. This is usually desired, but who knows...
	 */
	if ( Application.isOperational ) {
		this.dispatchAction ( DockPanelBinding.ACTION_FORCE_SELECT );
	}
	this.pageArgument = arg;
};

/** 
 * For subclasses to overload. Primarily with the intention of 
 * prolonging the invocation of <code>onPageInitialize</code> 
 * for some reason (waiting for iframes to load and stuff).
 * Note that all bindings (in this bindingWindow) has been 
 * fully attached when this method is invoked.
 * @param {object} arg
 */
PageBinding.prototype.onBeforePageInitialize = function () {
	
	/*
	 * When overloading, place your code around 
	 * here and invoke the super method lastly.
	 */
	this._isReadyForInitialize = true;
	if ( this._initBlockers == null ) {
		this.onPageInitialize ();
	}
};

/** 
 * Invoked when everything is loaded satisfactorily. 
 * @see {StageDialogBinding#_handleInitializedPageBinding}
 * @see {DockBinding#_setupPageBindingListeners}
 */
PageBinding.prototype.onPageInitialize = function () {
	
	if ( !this._isPageBindingInitialized ) {
	
		/*
		 * Flag initialized.
		 */
		this._isPageBindingInitialized = true;
		
		/*
		 * Modify dot net setup.
		 */
		if ( this._isDotNet ()) {
			this._setupDotNet ();
		}
		
		/*
		 * Populate DataBindings from DataBindingMap.
		 * TODO: move this to separate method?
		 */
		if ( this.pageArgument && this.pageArgument instanceof DataBindingMap ) {
			this.bindingWindow.DataManager.populateDataBindings ( this.pageArgument );
		}
		
		/*
		 * Dispatching an Action to be intercepted by ancestor bindings. 
		 * The ancestor will then invoke the reflex method on the page. 
		 * Timeouts stabilize the layout while page initializes. Be careful 
		 * not to dispose the PageBinding during timeouts!
		 * TODO: move to special method so that DialogPageBinding can handle itself!
		 */
		var self = this;
		setTimeout ( function () {
			try {
				if ( Binding.exists ( self ) == true ) {
					self.bindingElement.style.visibility = "visible";
					self.dispatchAction ( PageBinding.ACTION_INITIALIZED );
					self.onAfterPageInitialize ();
				} else {
					Application.unlock ( Application, true ); // something wrong - force unlock
					SystemLogger.getLogger ( "PageBinding" ).warn ( 
						"Premature PageBinding dispose? Please consult your developer." 
					);
				}
			} catch ( exception ) {
				self.logger.error ( exception );
				SystemDebug.stack ( arguments );
				throw exception;
			}
		}, PageBinding.TIMEOUT );
		
	} else {
		
		if ( Client.isExplorer == true ) {
			this.logger.error ( "PageBinding: Somehow initialized twice" );
			this.logger.error ( arguments.caller.callee.toString ());
		} else {
			throw "PageBinding: Somehow initialized twice";
		}
	}
};

/** 
 * After page initialize. Focus first focusable binding and unlock Application.
 * @see {FocusBinding#_initializeFocus}
 */
PageBinding.prototype.onAfterPageInitialize = function () {
	
	this.removeActionListener ( PageBinding.ACTION_BLOCK_INIT );
	this.removeActionListener ( PageBinding.ACTION_UNBLOCK_INIT );
	
	/*
	 * Must unlock first so that Explorer can handle focus properly.
	 */
	Application.unlock ( this );
	
	/*
	 * Enable activation awareness.
	 */
	this.isActivationAware = true;
	var root = UserInterface.getBinding ( this.bindingDocument.body );
	root.makeActivationAware ( this );
	
	/*
	 * When loaded, this will force any ancestor FocusBinding to move focus 
	 * to us. For this to make sense, this PageBinding should be loaded inside 
	 * a WindowBinding occupying ALL visible space. This may need rethinking.
	 */
	if ( UserInterface.isBindingVisible ( this )) {
		this.dispatchAction ( FocusBinding.ACTION_FOCUS );
	}
};

/**
 * Invoked by the DocumentUpdatePlugin before any updates are applied.
 */
PageBinding.prototype.onBeforeUpdates = function () {
	
	this._isUpdating = true;
	this.dispatchAction ( PageBinding.ACTION_UPDATING );
};

/**
 * Invoked by the DocumentUpdatePlugin after all updates are applied.
 */
PageBinding.prototype.onAfterUpdates = function () {
	
	this._isUpdating = false;
	this.dispatchAction ( PageBinding.ACTION_UPDATED );
};

/**
 * Invoked when a page gets iframed inside a dialog.
 * Invoked by the {@link DialogPageBinding}.
 */
PageBinding.prototype.makeDialogSubPage = function () {
	
	if ( this.isFitAsDialogSubPage ) {
		if ( Client.isExplorer ) {
			this.setFlexibility ( true ); // since IE has no min-height...
		}
		this.attachClassName ( PageBinding.CLASSNAME_SUBPAGE );
		this.isDialogSubPage = true;
	}
};

/**
 * The global function "doPostBack" is overloaded in order 
 * to manifest databindings reliably on every scripted submit.
 */
PageBinding.prototype._setupDotNet = function () {

	var self = this;
	var form = this.bindingDocument.forms [ 0 ];
	var oldPostBack = this.bindingWindow.__doPostBack;
	var isLocked = false;
	
	/*
	 * Unlock UI when page unloads (see below). 
	 * TODO: Remove this when dialogs go AJAX.
	 * form.__isSetup was set by UpdateManager.
	 */
	if ( !form.__isSetup ) {
		DOMEvents.addEventListener ( this.bindingWindow, DOMEvents.UNLOAD, {
			handleEvent : function () {
				if ( isLocked ) {
					Application.unlock ( self );
				}
			}
		});
	}
	
	/*
	 * Setup postback.
	 * @param {string} eventTarget
	 * @param {string} eventArgument
	 */
	this.bindingWindow.__doPostBack = function ( eventTarget, eventArgument ) {
		
		/*
		 * For non-AJAX pages (dialogs and wizards),  
		 * this stunt will lock the UI on form submit.
		 */
		if ( !form.__isSetup ) {
			Application.lock ( self );
			isLocked = true;
		}
		
		self.manifestAllDataBindings ();
		oldPostBack ( eventTarget, eventArgument );
		if ( Application.isDeveloperMode ) {
			self._debugDotNetPostback ();
		}
	}
};

/**
 * Post message in this window.
 * @param {String} message The message to post
 * @param {List<Binding>} list Collected by the EditorPageBinding.
 */
PageBinding.prototype.postMessage = function ( message, list ) {
	
	var postback = this.bindingWindow.bindingMap.__REQUEST;
		
	if ( postback != null && this._isDotNet ()) {
		
		switch ( message ) {
			case EditorPageBinding.MESSAGE_SAVE :
			case EditorPageBinding.MESSAGE_PERSIST :
				if ( this.bindingWindow.DataManager.isDirty ) {
					if ( this.validateAllDataBindings ()) {
						if ( list != null ) {
							/*
							if ( Application.isDeveloperMode ) {
								var action = message == EditorPageBinding.MESSAGE_SAVE ? "SAVING " : "PERSISTING ";  
								alert ( action + this.bindingDocument.title );
							}
							*/
							list.add ( this );
						}
						postback.postback ( message );
					}
				}
				break;
			default :
				postback.postback ( message );
				break;
			
		}
	}
	
	/*
	 * If the List was contained in argument, the post was 
	 * initiated by the EditorPageBinding, in which case 
	 * we must repost the message to descendant windows...
	 */
	if ( list != null ) {
		this._postMessageToDescendants ( message, list );
	}
}

/**
 * Post message in descendant windows recursively ad infinitum and for ever.
 * @param {String} message The message to post
 * @param {List<Binding>} list Collected by the EditorPageBinding.
 */
PageBinding.prototype._postMessageToDescendants = function ( message, list ) {
	
	// TODO: getElementsByTagName ( "iframe" ).parentNode to improve performance?
	var windows = this.getDescendantBindingsByType ( WindowBinding );
	windows.each ( function ( win ) {
		var page = win.getPageBinding (); 
		if ( page != null ) {
			page.postMessage ( message, list );
		}
	});
}


/**
 * Log postback entries.
 */
PageBinding.prototype._debugDotNetPostback = function () {
	
	var list = new List ();
	new List ( this.bindingDocument.forms [ 0 ].elements ).each ( 
		function ( element ) {
			list.add ({
				name : element.name,
				value : element.value
			});
		}
	);
	var out = "";
	list.each ( function ( entry ) {
		out += entry.name + ": " + entry.value + "\n";
	});
	this.logger.debug ( out );
};

/**
 * @implements {IActionListener}
 * @overloads {FocusBinding#handleAction}
 * @param {Action} action
 */
PageBinding.prototype.handleAction = function ( action ) {
	
	PageBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	switch ( action.type ) {
	
		case RootBinding.ACTION_PHASE_3 :
			if ( binding == UserInterface.getBinding ( this.bindingDocument.body )) {
				binding.removeActionListener ( RootBinding.ACTION_PHASE_3, this );
				if ( !this._isPageBindingInitialized ) {
					try {
						this.onBeforePageInitialize ();
					} catch ( exception ) {
						alert ( exception );
						SystemDebug.stack ( arguments );
						throw exception;
					}
				}
			}
			break;
			
		case PageBinding.ACTION_DOPOSTBACK :
			
		 	if ( this._isDotNet ()) {
				this.doPostBack ( binding );
			}
			action.consume ();
			break;
			
		case PageBinding.ACTION_DOVALIDATEDPOSTBACK :
			
			if ( this._isDotNet ()) {
				var isValid = this.validateAllDataBindings ();
				if ( isValid ) {
					this.doPostBack ( binding );
				}
			}
			action.consume ();
			break;
			
		case BalloonBinding.ACTION_INITIALIZE :
			
			// TODO: note here...
			action.consume ();
			break;
		
		case PageBinding.ACTION_BLOCK_INIT :
			if ( this._initBlockers == null ) {
				this._initBlockers = new Map ();
			}
			this._initBlockers.set ( binding.key, true );
			break;
			
		case PageBinding.ACTION_UNBLOCK_INIT :
			
			if ( this._initBlockers != null ) {
				if ( this._initBlockers.has ( binding.key )) {
					this._initBlockers.del ( binding.key );
					if ( !this._initBlockers.hasEntries ()) {
						this._initBlockers = null;
						if ( this._isReadyForInitialize == true ) {
							var self = this;
							setTimeout ( function () {
								self.onBeforePageInitialize (); // push thread to completely stabilize
							}, 0 );
						}
					}
				}
			}
			
			/*
			 * WAS THIS
			 * 
			if ( this._initBlockers.has ( binding.key )) {
				this._initBlockers.del ( binding.key );
			}
			if ( !this._initBlockers.hasEntries ()) {
				this._initBlockers = null;
				if ( this._isReadyForInitialize == true ) {
					var self = this;
					setTimeout ( function () {
						self.onBeforePageInitialize (); // push thread to completely stabilize
					}, 0 );
				}
			}
			*/
			break;
		
		/*
		 * TODO: move this stuff into proper methods.
		 */
		case PageBinding.ACTION_GETMESSAGES :
			if ( UpdateMananger.isUpdating ) {
				var self = this;
				var handler = {
					handleAction : function ( action ) {
						if ( action.target == self ) {
							self.removeActionListener ( PageBinding.ACTION_UPDATED, handler );
							MessageQueue.udpdate ();
						}
					}
				}
				this.addActionListener ( PageBinding.ACTION_UPDATED, handler );
			} else {
				MessageQueue.udpdate ();
			}
			action.consume ();
			break;
	}
};

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
PageBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	PageBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		
		/*
		 * This broadcast means that we can unlock a  
		 * page that was performing a postback.
		 */
		case BroadcastMessages.MESSAGEQUEUE_REQUESTED :
			var isAutoUpdate = arg;
			if ( !this._canPostBack && !isAutoUpdate ) {
				this._canPostBack = true;
				Application.unlock ( this );
			}
			break;
	}
};

/** 
 * To dot or not dot net.
 * @return {boolean}
 */
PageBinding.prototype._isDotNet = function () {
	
	var form = this.bindingDocument.forms [ 0 ];
	
	return ( 
		form != null && 
		typeof this.bindingWindow.__doPostBack != "undefined"
	);
};

/**
 * Do postback.
 * @param {binding} binding This lucky bindings callbackid will be transmitted to server.
 */
PageBinding.prototype.doPostBack = function ( binding ) {
	
	if ( this._canPostBack ) {
		if ( binding != null && this._isDotNet ()) {
			
			var callbackid = binding.getCallBackID ();
			var callbackarg = binding.getCallBackArg ();
			
			/*
			 * Did some guy use ClientID instead of UniqueID?
			 */
			if ( callbackid != null ) {
				callbackid = callbackid.replace ( /_/g, "$" );
			} else {
				callbackid = "";
			}
			
			if ( callbackarg == null ) {
				callbackarg = "";
			}
			
			this.bindingWindow.__doPostBack ( callbackid, callbackarg );
		}
	}
};

/**
 * Validate all attached DataBindings. Discontinue validation 
 * as soon as the first invalid binding is encountered.
 * @return {boolean}
 */
PageBinding.prototype.validateAllDataBindings = function () {

	var isValid = true;
	var dataBindings = this.bindingWindow.DataManager.getAllDataBindings ();
	
	while ( dataBindings.hasNext () && isValid ) {
		var dataBinding = dataBindings.getNext ();
		if ( dataBinding.isAttached ) { // could be nested in lazy binding
			var isBindingValid = dataBinding.validate ();
			if ( isValid && !isBindingValid ) {
				isValid = false;
				this.logger.debug ( "Invalid DataBinding: " + dataBinding.toString () + " (" + dataBinding.getName () + ")" );
				break;
			}
		}
		
	}
	return isValid;
};

/**
 * Manifest all attached DataBindings. 
 * This should always be invoked preceding server postback.
 * @return {List}
 */
PageBinding.prototype.manifestAllDataBindings = function () {

	var list = new List ();
	var dataBindings = this.bindingWindow.DataManager.getAllDataBindings ();
	
	while ( dataBindings.hasNext ()) {
		var dataBinding = dataBindings.getNext ();
		if ( dataBinding.isAttached ) { // could be nested in lazy binding
			var result = dataBinding.manifest ();
			if ( result != null ) {
				list.add ( result );
			}
		}
	}
	return list;
};

/**
 * Clean all DataBindings.
 */
PageBinding.prototype.cleanAllDataBindings = function () {
	
	// this.bindingWindow.DataManager.isDirty = false;
	
	var dataBindings = this.bindingWindow.DataManager.getAllDataBindings ();
	while ( dataBindings.hasNext ()) {
		var dataBinding = dataBindings.getNext ();
		if ( dataBinding.isAttached ) { // otherwise still clean
			dataBinding.clean ();
		}
	}
};

/**
 * Implements {ILabel}
 * @return {string}
 */
PageBinding.prototype.getLabel = function () {
	
	return this.label;
};

/**
 * Implements {ILabel}
 * @return {string}
 */
PageBinding.prototype.getImage = function () {
	
	return this.image;
};

/**
 * Implements {ILabel}
 * @return {string}
 */
PageBinding.prototype.getToolTip = function () {
	
	return this.toolTip;
};

/**
 * Relevant for dialog sub pages??????????????????????
 * @return {int}
 */
PageBinding.prototype.getHeight = function () {

	return this.bindingElement.offsetHeight;
};

/**
 * Focus last focused binding when the containing {@link IActivatable} gets activated.
 * @see {DockBinding#activate}
 * @see {DialogBinding#activate}
 * @see {FocusBinding#setActiveInstance}
 */
PageBinding.prototype.onActivate = function () {
	
	if ( Binding.exists ( this )) { // the devils!
		if ( !this.isActivated ) {
			this.isActivated = true;
			if ( this._isFocusManager ) {
				if ( UserInterface.isBindingVisible ( this )) {
					if ( this._cachedFocus != null ) {
						/*
						 * Timeout allows any mouse-targetted 
						 * focusable to focus first.
						 */
						var self = this;
						setTimeout ( function () {
							if ( FocusBinding.focusedBinding == null ) {
								self._focusPreviouslyFocused ();
							}
						}, 0 );
					} else {
						this._focusFirstFocusable ();
					}
				}
			}
		}
	}
};

/**
 * Blur last focused binding when the containing {@link IActivatable} gets deactivated.
 * @see {DockBinding#deactivate}
 * @see {DialogBinding#deactivate}
 * @see {FocusBinding#setActiveInstance}
 */
PageBinding.prototype.onDeactivate = function () {
	
	if ( this.isActivated == true ) {
		this.isActivated = false;
		if ( this._cachedFocus != null ) {
			var binding = this._cachedFocus.getBinding ();
			if ( binding ) {
				binding.blur ();
			}
		}
		if ( FocusBinding.activeInstance == this ) {
			FocusBinding.activeInstance = null;
		}
	}
};

DialogPageBinding.prototype = new PageBinding;
DialogPageBinding.prototype.constructor = DialogPageBinding;
DialogPageBinding.superclass = PageBinding.prototype;

DialogPageBinding.DEFAULT_WIDTH = 443;
DialogPageBinding.DEFAULT_TABBOXED_WIDTH = 476;
DialogPageBinding.DEFAULT_HEIGHT = "auto";
DialogPageBinding.DEFAULT_CONTROLS = "close";
DialogPageBinding.DEFAULT_RESIZABLE = false;
DialogPageBinding.ACTION_RESPONSE = "dialogpageresponse";
DialogPageBinding.ACTION_LAYOUT_D = "dialoglayoutd";
DialogPageBinding.CLASSNAME_TABBOXED = "tabboxed";

/**
 * @class
 * Note that a this fellow only has effect when loaded inside the {@link StageDialogBinding}.
 */
function DialogPageBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DialogPageBinding" );
	
	/**
	 * The dialog will always return this property 
	 * to an instance of (@link IDialogResponseHandler}.
	 * @type {object}
	 */
	this.response = null;
	
	/**
	 * If this property is specified, usually when the dialog is accepted, 
	 * it will be returned to an instance of (@link IDialogResponseHandler}. 
	 * If the subclass doesn't handle it specifically, the response will 
	 * default to an instance of {@link DataBindingMap}.
	 * @see {DialogPageBinding#onDialogAccept}
	 * @type {object}
	 */
	this.result = null;
	
	/**
	 * @type {int}
	 */
	this.width = null;
	
	/**
	 * @type {int}
	 */
	this.height = null;
	
	/**
	 * @type {int}
	 */
	this.minheight = null;
	
	/**
	 * @type {string}
	 */
	this.controls = null;

	/**
	 * @type {boolean}
	 */
	this.isResizable = null;
	
	/**
	 * @type {boolean}
	 */
	this.isAutoHeightLayoutMode = false;
}

/**
 * Identifies binding.
 */
DialogPageBinding.prototype.toString = function () {

	return "[DialogPageBinding]";
}

/**
 *
 */
DialogPageBinding.prototype.onBindingRegister = function () {
	
	DialogPageBinding.superclass.onBindingRegister.call ( this );
	
	this.addActionListener ( PageBinding.ACTION_ATTACHED );
	this.addActionListener ( Binding.ACTION_DIRTY );
	this.addActionListener ( Binding.ACTION_VALID );
	this.addActionListener ( Binding.ACTION_INVALID );
	this.addActionListener ( ButtonBinding.ACTION_COMMAND );
}

/**
 * Parse DOM properties.
 */
DialogPageBinding.prototype.parseDOMProperties = function () {

	/*
	 * This elaborate setup takes into consideration that some 
	 * properties may have been defined by stuff going on eg. 
	 * in the setPageArgument method.
	 */

	DialogPageBinding.superclass.parseDOMProperties.call ( this );
	
	if ( this.width == null ) {
		var width = this.getProperty ( "width" );
		if ( !width ) {
			width = this.hasClassName ( DialogPageBinding.CLASSNAME_TABBOXED ) ? 
				DialogPageBinding.DEFAULT_TABBOXED_WIDTH :
				DialogPageBinding.DEFAULT_WIDTH;
		}
		this.width = width;
	}
	if ( this.height == null ) {
		var height = this.getProperty ( "height" );
		this.height = height ? height : DialogPageBinding.DEFAULT_HEIGHT;
	}
	if ( this.minheight == null ) {
		var minheight = this.getProperty ( "minheight" );
		if ( minheight != null ) {
			this.minheight = minheight;
		}
	}
	if ( this.controls == null ) {
		var controls = this.getProperty ( "controls" );
		this.controls = controls ? controls : DialogPageBinding.DEFAULT_CONTROLS;
	}
	if ( !this.isResizable ) {
		var isResizable = this.getProperty ( "resizable" );
		this.isResizable = isResizable ? isResizable : DialogPageBinding.DEFAULT_RESIZABLE;
	}
	
	/*
	 * Comment here please!
	 */
	if ( this.height == "auto" ) {
		this.enableAutoHeightLayoutMode ( true );
	}
}

/**
 * Check the MessageQueue after page load.
 * TODO: Remove this! Should be handled by ResponseBinding!!!
 * @overloads {PageBinding#onAfterPageInitialize}
 *
DialogPageBinding.prototype.onAfterPageInitialize = function () {
	
	DialogPageBinding.superclass.onAfterPageInitialize.call ( this );
	
	if ( this._isDotNet ()) {
		
		/*
		 * TODO: This should be handled by ResponseBinding!!!
		 * Update: ResponseBinding is now supposed to work...
		 * "AJAX!" - this is just a keyword we can sarch for :)
		 *
		MessageQueue.update ();
	}
}
*/

/**
 * @see {StageDialogBinding}
 * @param {boolean} isMode
 */
DialogPageBinding.prototype.enableAutoHeightLayoutMode = function ( isMode ) {
	
	if ( isMode != this.isAutoHeightLayoutMode ) {
		if ( isMode ) {
			this.attachClassName ( "auto" );
		} else {
			this.detachClassName ( "auto" );
		}
		this.isAutoHeightLayoutMode = isMode;
	}
}

/**
 * @implements {IActionListener}
 * @overloads {PageBinding#handleAction}
 * @param {Action} action
 */
DialogPageBinding.prototype.handleAction = function ( action ) {

	DialogPageBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	
	switch ( action.type ) {
	
		case PageBinding.ACTION_ATTACHED :
		
			/*
			 * TODO: check for this.height == "auto"?
			 */
			if ( binding != this && binding.isFitAsDialogSubPage ) {
				binding.makeDialogSubPage ();
			}
			// don't consume - ViewBinding is listening!
			break;
	
		case ButtonBinding.ACTION_COMMAND : 
			
			// no need to relay button commands to containing dialog
			action.consume ();
			
			// special handling of buttons with a "response" property set
			if ( binding.response != null ) {
				
				/* 
				 * Hide while handling response.
				 *
				this.bindingElement.style.visibility = "hidden";
				*/
				
				/*
				 * By default, dialog response is identical to 
				 * button response. This can be changed later.
				 */
				this.response = binding.response;
				
				switch ( binding.response ) {
					
					/*
					 * The dialog ACCEPT button will validate the dialog  
					 * before being accepted as a dialog response. If content  
					 * is validated correctly, "onDialogAccept" is invoked.
					 */
					case Dialog.RESPONSE_ACCEPT :
						if ( this.validateAllDataBindings () == true ) {
							this.onDialogAccept ();
						} else {
							this.onDialogInvalid ();
						}
						break;
						
					/*
					 * The dialog CANCEL button invokes another special method.
					 */
					case Dialog.RESPONSE_CANCEL :
						this.onDialogCancel ();
						break;
					
					/*
					 * All other buttons (with a specified response) invoke this method.
					 */
					default :
						this.onDialogResponse ();
						break;
				}
			}
			break;
		
		case Binding.ACTION_INVALID :
			this._disableAcceptButton ( true );
			break;
			
		case Binding.ACTION_VALID :
			this._disableAcceptButton ( false );
			break;
	}
}

/**
 * Disable or enable accept button.
 * @param {boolean} isDisable
 */
DialogPageBinding.prototype._disableAcceptButton = function ( isDisable ) {
	
	var acceptButton = this.bindingWindow.bindingMap.buttonAccept;
	if ( acceptButton != null ) {
		acceptButton.setDisabled ( isDisable );
	}
}

/**
 * Subclasses should overload this method if a special dialog result  
 * is required. Result defaults to the local dataBindingResultMap.
 * @see {DataManager#getDataBindingResultMap}
 */
DialogPageBinding.prototype.onDialogAccept = function () {
	
	/*
	 * Define your result around here. Otherwise 
	 * the default result will be set, see below.
	 */
	if ( this.result === null ) {
		try {
			this.result = this.bindingWindow.DataManager.getDataBindingResultMap ();
		} catch ( exception ) {
			alert ( exception );
			throw exception;
		}
	}
	this.onDialogResponse ();
}

/**
 * Subclasses should overwrite this method to setup invalid content scenario.
 */
DialogPageBinding.prototype.onDialogInvalid = function () {
	
	// do nothing by default
}

/**
 * Subclasses should overload this method to perform  
 * cleanup before the dialog is closed.
 * @param {object} response
 */
DialogPageBinding.prototype.onDialogCancel = function () {
	
	this.onDialogResponse ();
}

/**
 * If response was neither accept nor cancel, this method will be invoked directly. 
 * Otherwise, the corresponding methods will be invoked first, for you to hook into. 
 * Remember that any relayed response will close the dialog automatically.
 * @param {object} response
 */
DialogPageBinding.prototype.onDialogResponse = function () {
	
	this.dispatchAction ( DialogPageBinding.ACTION_RESPONSE );
}

DialogPageBodyBinding.prototype = new FlexBoxBinding;
DialogPageBodyBinding.prototype.constructor = DialogPageBodyBinding;
DialogPageBodyBinding.superclass = FlexBoxBinding.prototype;

/**
 * @class
 */
function DialogPageBodyBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "DialogPageBodyBinding" );
}

/**
 * Identifies binding.
 */
DialogPageBodyBinding.prototype.toString = function () {
	
	return "[DialogPageBodyBinding]";
};

/**
 * Hardwired for method fit.
 * @overwrites {FlexBoxBinding#_setFitnessHeight} 
 * @param {int} height
 */
DialogPageBodyBinding.prototype._setFitnessHeight = function ( height ) {
	
	var padding	= CSSComputer.getPadding ( this.bindingElement );
	var border	= CSSComputer.getBorder ( this.bindingElement );
	
	height += padding.top + padding.bottom;
	height += border.top + border.bottom;
	
	if ( height > this.bindingElement.offsetHeight ) {
		this.bindingElement.style.height = height + "px";
	}
}

EditorPageBinding.prototype = new PageBinding;
EditorPageBinding.prototype.constructor = EditorPageBinding;
EditorPageBinding.superclass = PageBinding.prototype;

EditorPageBinding.ACTION_ATTACHED 	= "editorpage attached";
EditorPageBinding.ACTION_DIRTY		= "editorpage dirty";
EditorPageBinding.ACTION_CLEAN		= "editorpage clean";
EditorPageBinding.ACTION_SAVE 		= "editorpage save";

/* 
 * Special binding IDs, hardcoded by the server goo.
 */
EditorPageBinding.ID_SAVEASBUTTON 	= "saveasbutton";
EditorPageBinding.ID_PREVIEWTAB		= "previewtab";
EditorPageBinding.ID_MAINTABBOX		= "maintabbox";
EditorPageBinding.ID_PREVIEWWINDOW 	= "previewwindow";

/*
 * Postback directives. Matched serverside, don't change!
 */
EditorPageBinding.MESSAGE_SAVE 		= "save";
EditorPageBinding.MESSAGE_PERSIST 	= "persist";
EditorPageBinding.MESSAGE_REFRESH 	= "refresh";

/**
 * Magic message.
 * @type {String}
 */
EditorPageBinding.message = null;

/**
 * True while tabbing.
 * @type {boolean}
 */
EditorPageBinding.isTabbing = false;

/**
 * Register open editorpages. Considered private.
 * @type {Map<string><EditorPageBinding>}
 */
EditorPageBinding._registry = new Map ();

/**
 * Register open editor.
 * @param {EditorPagebinding}
 */
EditorPageBinding.register = function ( page ) {
	
	var map = EditorPageBinding._registry;
	if ( !map.hasEntries ()) {
		top.app.bindingMap.broadcasterHasOpenEditors.enable ();
	}
	map.set ( page.key, page );
}

/**
 * Unregister open editor.
 * @param {EditorPagebinding}
 */
EditorPageBinding.unregister = function ( page ) {
	
	var map = EditorPageBinding._registry;
	map.del ( page.key );
	if ( !map.hasEntries ()) {
		top.app.bindingMap.broadcasterHasOpenEditors.disable ();
	}
}

/**
 * @class
 */
function EditorPageBinding () {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "EditorPageBinding" );
	
	/**
	 * @type {boolean}
	 */
	this.isDirty = false;
	
	/** The main tabbox!
	 * @type {TabBoxBinding}
	 */
	this._tabBoxBinding = null;
	
	/**
	 * The preview tab!
	 * @type {TabBinding}
	 */
	this._tabBinding = null;
	
	/**
	 * The preview window!
	 * @type {WindowBinding}
	 */
	this._windowBinding = null;
	
	/**
	 * @type {boolean}
	 */
	this._isGeneratingPreview = false;
	
	/**
	 * @type {boolean}
	 */
	this._isPreviewWindowVisible = false;
	
	/**
	 * The current postMessage string matching "save" or "persist". 
	 */
	this._message = null;
	
	/**
	 * Messages waiting to be executed as soon 
	 * as this._messengers has been emptied.
	 * @deprecated
	 * @type {List<String>}
	 */
	this._messages = null;
	
	/**
	 * While not empty, incoming postMessages 
	 * will be collected in this._messages. 
	 * @type {List<PageBinding>}
	 */
	this._messengers = null;
	
	/**
	 * Hack the preview setup - don't instigate preview while persisting.
	 * @type {boolean}
	 */
	this._isWaitingForPreview = false;
	
	/**
	 * True while the preview tab is selected. Note that there may not 
	 * be a preview window in editor, but only the backend knows this.
	 * @type {boolean}
	 */
	this._isPreviewing = false;
}

/**
 * Identifies binding.
 */
EditorPageBinding.prototype.toString = function () {

	return "[EditorPageBinding]";
}

/**
 * @overloads {PageBinding#onBindingRegister} 
 */
EditorPageBinding.prototype.onBindingRegister = function () {

	EditorPageBinding.superclass.onBindingRegister.call ( this );
	
	this.addActionListener ( Binding.ACTION_DIRTY );
	this.addActionListener ( Binding.ACTION_VALID );
	this.addActionListener ( Binding.ACTION_INVALID );
	this.addActionListener ( EditorPageBinding.ACTION_SAVE );
	
	this.addActionListener ( ResponseBinding.ACTION_SUCCESS );
	this.addActionListener ( ResponseBinding.ACTION_FAILURE );
	this.addActionListener ( ResponseBinding.ACTION_OOOOKAY );
	
	EditorPageBinding.register ( this );
	
	this._invalidBindings = new Map ();
	this._messengers = new List ();
	this._messages = new List ();
}

/** 
 * 
 * @overloads {FocusBinding#onBindingDispose}
 */
EditorPageBinding.prototype.onBindingDispose = function () {
	
	/*
	 * If editor documents gets replaced for whatever reason, this will make 
	 * sure that the tab can be closed without prompting a save dialog.
	 */
	this.dispatchAction ( EditorPageBinding.ACTION_CLEAN );
	
	/*
	 * Cleaning up for various XHTML-aware panels.
	 */
	if ( this._isPreviewWindowVisible == true ) {
		setTimeout ( function () {
			EventBroadcaster.broadcast ( BroadcastMessages.XHTML_MARKUP_OFF );
		}, 250 );
	}
	
	EditorPageBinding.unregister ( this );
	EditorPageBinding.superclass.onBindingDispose.call ( this );
}

/**
 * @overwrites {PageBinding#onPageInitialize}
 */
EditorPageBinding.prototype.onBeforePageInitialize = function () {
	
	this._setupPreviewListeners ();
	EditorPageBinding.superclass.onBeforePageInitialize.call ( this );
}

/**
 * Inititalize save buttons.
 * @overloads {PageBinding#onPageInitialize}
 */
EditorPageBinding.prototype.onPageInitialize = function () {
	
	EditorPageBinding.superclass.onPageInitialize.call ( this );
	this.enableSaveAs ();
}

/**
 * Setup stuff to generate a preview when the related tab is selected. 
 * This should really not be done on a general EditorPageBinding... 
 * but we are trapped by the DocumentExecutionContainer.aspx hardcode.
 */
EditorPageBinding.prototype._setupPreviewListeners = function () {
	
	var box = this.bindingDocument.getElementById ( EditorPageBinding.ID_MAINTABBOX );
	var tab = this.bindingDocument.getElementById ( EditorPageBinding.ID_PREVIEWTAB );
	var win = this.bindingDocument.getElementById ( EditorPageBinding.ID_PREVIEWWINDOW );

	if ( box != null ) {
	
		this._tabBoxBinding = UserInterface.getBinding ( box );
		this._tabBoxBinding.addActionListener ( TabBoxBinding.ACTION_SELECTED, this );
		this._tabBoxBinding.addActionListener ( TabBoxBinding.ACTION_UNSELECTED, this );
		
		if ( tab != null && win != null ) { // preview generating stuff
			
			this._tabBinding	= UserInterface.getBinding ( tab );
			this._windowBinding = UserInterface.getBinding ( win );
			
			this._windowBinding.addActionListener ( WindowBinding.ACTION_LOADED, this );
			this._windowBinding.addActionListener ( WindowBinding.ACTION_ONLOAD, this );
			
			this.subscribe ( BroadcastMessages.HIGHLIGHT_KEYWORDS );
			
			if ( this._tabBinding.isSelected ) {
				this._startPreview ();
			}
		}
	}
}

/**
 * This gets invoked by the associated {@link DockTabBinding} 
 * when a save was successfull. This is probably determined by a 
 * message on the {@link MessageQueue}.
 */
EditorPageBinding.prototype.onSaveSuccess = function () {
	
	this.enableSave ( false );
	this.enableSaveAs ();
	this.cleanAllDataBindings ();
	this.isDirty = false;
	EditorPageBinding.message = null; // could have been flipped by PageBinding!
	this.dispatchAction ( EditorPageBinding.ACTION_CLEAN );
}

/**
 * When a dirty event is registered, update the relevant {@link BroadcasterBinding}. 
 * A specialized dirty event is passed on to the containing {@link DockBinding}.
 * @implements {IActionListener}
 * @overloads {PageBinding#handleAction}
 * @param {Action} action
 */
EditorPageBinding.prototype.handleAction = function ( action ) {
	
	EditorPageBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	
	switch ( action.type ) {
	
		case EditorPageBinding.ACTION_SAVE :
			this.postMessage ( EditorPageBinding.MESSAGE_SAVE );
			// don't consume - DockTabBinding is listening!
			break;
			
		/*
		case EditorPageBinding.ACTION_PERSIST : // not currently in use!
			this.postMessage ( EditorPageBinding.MESSAGE_PERSIST );
			action.consume ();
			break;
			
		case EditorPageBinding.ACTION_REFRESH : // not currently in use!
			this.postMessage ( EditorPageBinding.MESSAGE_REFRESH );
			action.consume (); 
			break;
		*/
			
		case ResponseBinding.ACTION_OOOOKAY :
			if ( Application.isDeveloperMode ) {
				// alert ( "OOOOKAY "  + binding.bindingDocument.title );
			}
			
			break;
		
		case ResponseBinding.ACTION_SUCCESS :
			
			if ( Application.isDeveloperMode ) {
				// alert ( "SUCCESS " + binding.bindingDocument.title );
			}
			
			if ( this._messengers.hasEntries ()) {
				
				var index = -1;
				this._messengers.each ( function ( page ) {
					var res = page.bindingWindow == binding.bindingWindow;
					if ( res ) {
						page.bindingWindow.DataManager.isDirty = false;
						if ( index == -1 ) {
							index = 0;
						}
					} else {
						index ++;
					}
					return res;
				});
				if ( index >-1 ) {
					this._messengers.del ( index );
				}
				if ( !this._messengers.hasEntries ()) {
					switch ( this._message ) {
						case EditorPageBinding.MESSAGE_SAVE :
							this._saveEditorPage ();
							break;
						case EditorPageBinding.MESSAGE_PERSIST :
							this._refresh (); // refresh after "persist"
							this._message = null;
							if ( this._isWaitingForPreview ) { // please unhack this!
								this._isWaitingForPreview = false;
								this._startPreview ();
							}
							break;
					}
				}
				
			} else {
				this._refresh (); // refresh after "save"
				this._message = null;
			}
			break;
			
		case ResponseBinding.ACTION_FAILURE :
			if ( Application.isDeveloperMode ) {
				// alert ( "FAILURE " + binding.bindingDocument.title );
			}
			this._message = null;
			this._messengers = new List ();
			break;
			
		case Binding.ACTION_DIRTY :
			if ( this.canSave ()) {
				if ( !this.isDirty ) {
					this.enableSave ( true );
					this.isDirty = true;
					this.dispatchAction ( EditorPageBinding.ACTION_DIRTY );
				}
			}
			action.consume ();
			break;
			
		case Binding.ACTION_INVALID :
			this.enableSave ( false );
			this._invalidBindings.set ( binding.key, binding );
			if ( binding instanceof FieldsBinding ) {
				this._updateStatusBar ();
			}
			break;
			
		case Binding.ACTION_VALID :
			this._invalidBindings.del ( binding.key );
			if ( binding instanceof FieldsBinding ) {
				this._updateStatusBar ();
			}
			if ( !this._invalidBindings.hasEntries ()) {
				this.enableSave ( true );
			}
			break;
			
		case TabBoxBinding.ACTION_SELECTED : 
			if ( binding == this._tabBoxBinding ) {
				if ( this._windowBinding != null ) { // preview stuff
					var tab = binding.getSelectedTabBinding ();
					if ( tab.getID () == EditorPageBinding.ID_PREVIEWTAB ) {
						this._isPreviewing = true;
						if ( this._messengers.hasEntries ()) {
							this._isWaitingForPreview = true;	
						} else {
							this._startPreview ();
						}
					} else if ( this._isPreviewing ) {
						this._isPreviewing = false;
						this._stopPreview ();
					}
				}
			}
			action.consume ();
			break;
			
		case TabBoxBinding.ACTION_UNSELECTED :
			if ( binding == this._tabBoxBinding ) {
				this.postMessage ( EditorPageBinding.MESSAGE_PERSIST );
			}
			action.consume ();
			break;
			
		case WindowBinding.ACTION_LOADED : // preview
			
			if ( binding == this._windowBinding ) {
				if ( this._isGeneratingPreview == true ) {
					this._generatePreview ();
					this._isGeneratingPreview = false;
				}
				action.consume ();
			}
			break;
		
		case WindowBinding.ACTION_ONLOAD : // preview
			
			/*
			 * TODO: Consider how this might impact focus in layout...
			 */
			if ( binding == this._windowBinding ) {
				
				/*
				 * First hit is the postback document. This is neglected.
				 */
				if ( binding.getContentWindow ().isPostBackDocument != true ) {
					
					/*
					 * Disable new-version lookup. Cache enabled by 
					 * {@link EditorPageBinding#_startPreview}
					 */
					if ( Client.isPrism ) {
						Prism.enableCache ();
					}
					
					/*
					 * Note that this here code is invoked twice 
					 * when the preview is first generated!
					 */
					var self = this;
					setTimeout ( function () { // COPYPASTED ABOVE!
						Application.unlock ( self );
					}, 100 );
					
					/*
					 * Broadcast contained markup for 
					 * various panels to intercept.
					 */
					if ( EventBroadcaster.hasSubscribers ( BroadcastMessages.XHTML_MARKUP_ON )) {
						var markup = WindowBinding.getMarkup ( this._windowBinding );
						if ( markup != null ) {
							EventBroadcaster.broadcast ( BroadcastMessages.XHTML_MARKUP_ON, markup );
						}
					}
				}
			}
			break;
	}
}

/**
 * Can we save? This question has been made dependant on 
 * the existance of a save-button inside the document. 
 * TODO: should this reflect thie buttons isDisabled state?
 * @return {boolean}
 */
EditorPageBinding.prototype.canSave = function () {
	
	return this.bindingWindow.bindingMap.savebutton != null;
}

/**
 * Ignite the save routine. For reasons of NET postback drama, 
 * this must be delegated by emulating a click on the save button.
 */
EditorPageBinding.prototype.doSave = function () {
	
	var button = this.bindingWindow.bindingMap.savebutton;
	if ( button != null && !button.isDisabled ) {
		button.fireCommand ();
	}
}

/**
 * Performs the final save transaction.
 */
EditorPageBinding.prototype._saveEditorPage = function () {
	
	if ( Application.isDeveloperMode ) {
		// alert ( "SAVING " + this.bindingDocument.title );
	}
	if ( this.validateAllDataBindings ()) {
		this.bindingWindow.DataManager.isDirty = false;
		var postback = this.bindingWindow.bindingMap.__REQUEST;
		if ( postback != null ) {
			postback.postback ( EditorPageBinding.MESSAGE_SAVE );
		} else {
			this.logger.error ( "Save aborted: Could not locate RequestBinding" );
		}
	}
};

/**
 * Refresh page!
 */
EditorPageBinding.prototype._refresh = function () {

	if ( Application.isDeveloperMode ) {
		// alert ( "REFRESHING ALL" );
	}
	this.postMessage ( EditorPageBinding.MESSAGE_REFRESH );
}

/**
 * Post message to this frame and descendant frames.
 * TODO: collect messages added while messaging?
 * @overwrites {PageBinding#postMessage}
 * @param {String} message
 * @param {List<Binding>} list
 */
EditorPageBinding.prototype.postMessage = function ( message ) {
	
	this._message = null;
	
	switch ( message ) {
		
		case EditorPageBinding.MESSAGE_SAVE :
			this._postMessageToDescendants ( message, this._messengers );
			if ( !this._messengers.hasEntries ()) {
				this._saveEditorPage ();
			} else {
				this._message = message;
			}
			break;
			
		case EditorPageBinding.MESSAGE_PERSIST :
			this._message = message;
			EditorPageBinding.superclass.postMessage.call ( this, message, this._messengers );
			break;
			
		case EditorPageBinding.MESSAGE_REFRESH :
			EditorPageBinding.superclass.postMessage.call ( this, message, this._messengers );
			break;	
	}
};

/**
 * @implements {IBroadcastListener}
 * @overloads {PageBinding#handleBroadcast}
 * @param {string} broadcast
 * @param {object} arg
 */
EditorPageBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	EditorPageBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		case BroadcastMessages.HIGHLIGHT_KEYWORDS :
			var keywords = arg;
			if ( UserInterface.isBindingVisible ( this._windowBinding )) {
				WindowBinding.highlightKeywords ( this._windowBinding, keywords );
			}
			break;
	}
}

/**
 * Invoked be ancestor {IActivatable} when activated. 
 * @overloads {FocusBinding#onActivate}
 */
EditorPageBinding.prototype.onActivate = function () {
	
	EditorPageBinding.superclass.onActivate.call ( this );
	
	if ( this._isPreviewWindowVisible == true ) {
		EventBroadcaster.broadcast ( BroadcastMessages.XHTML_MARKUP_ACTIVATE );
	}
}

/**
 * Invoked be ancestor {IActivatable} when deactivated. 
 * @overloads {FocusBinding#onDectivate}
 */
EditorPageBinding.prototype.onDeactivate = function () {
	
	EditorPageBinding.superclass.onDeactivate.call ( this );
	
	if ( this._isPreviewWindowVisible == true ) {
		EventBroadcaster.broadcast ( BroadcastMessages.XHTML_MARKUP_DEACTIVATE );
	}
}

/**
 * Display invalid labels in statusbar. The backend spawns a FieldsBinding 
 * for each FieldGroupBinding, so this has been made slightly complicated. 
 * This method is invoked whenever a FieldsBinding reports invalid or valid.
 * @param {boolean} isShow
 */
EditorPageBinding.prototype._updateStatusBar = function () {
	
	var labels = new List ();
	this._invalidBindings.each ( function ( key, binding ) {
		var list = binding.getInvalidLabels ();
		if ( list ) {
			list.each ( function ( label ) {
				labels.add ( label );
			});
		}
	}); 
	if ( labels.hasEntries ()) {
		var output = "";
		while ( labels.hasNext ()) {
			output += labels.getNext ().toLowerCase ();
			if ( labels.hasNext ()) {
				output += ", ";
			} else {
				output += ".";
			}
		}
		var string = StringBundle.getString ( "ui", "Website.App.StatusBar.ErrorInField" );
		StatusBar.error ( string + " " + output );
	} else {
		StatusBar.clear ();
	}
}

/**
 * Start preview process. This can be invoked by either a tab selection 
 * or when the page inititalizes (if the tab is preselected).
 */
EditorPageBinding.prototype._startPreview = function () {
	
	Application.lock ( this ); // unlocked when preview is loaded
	this._isGeneratingPreview = true;
	
	if ( Client.isPrism ) {
		Prism.disableCache (); // enable new-version lookup!
	}
	
	this._windowBinding.setURL ( WindowBinding.POSTBACK_URL );
}

/**
 * Stop preview.
 */
EditorPageBinding.prototype._stopPreview = function () {
	
	this._windowBinding.reset ();
	if ( Application.isLocked ) { // occurs on rapid tabshift using keyboard
		Application.unlock ( this );
	}
}

/**
 * Enable-disable save button.
 * @param {boolean} isEnable
 */
EditorPageBinding.prototype.enableSave = function ( isEnable ) {
	
	var broadcasterElement = this.bindingDocument.getElementById ( "broadcasterCanSave" );
	if ( broadcasterElement ) {
		var broadcasterBinding = UserInterface.getBinding ( broadcasterElement );
		if ( isEnable ) {
			broadcasterBinding.enable ();
		} else {
			broadcasterBinding.disable ();
		}
	} else {
		throw new Error ( "A required BroadcasterBinding could not be located." );
	}
}

/**
 * Manually enable saveas button (observes same broadcaster as save button).
 */
EditorPageBinding.prototype.enableSaveAs = function () {
	
	var button = this.bindingDocument.getElementById ( 
		EditorPageBinding.ID_SAVEASBUTTON 
	);
	if ( button != null ) {
		UserInterface.getBinding ( button ).enable ();
	}
}

/**
 * Handle invalid data.
 * TODO: Something intelligent.
 */
EditorPageBinding.prototype.handleInvalidData = function () {
	
	this.logger.error ( "INVALID DATA :(" );
	if ( this._isGeneratingPreview ) {
		this._isGeneratingPreview = false;
		this._windowBinding.error ();
		this._message = null;
		this._messengers = new List ();
		Application.unlock ( this );
	}
}

/**
 * Generate preview.
 */
EditorPageBinding.prototype._generatePreview = function () {
	
	var title = this._windowBinding.getContentDocument ().title;
	
	if ( title == WindowBinding.POSTBACK_TITLE ) {
		
		if ( this.validateAllDataBindings ()) {
			
			this.manifestAllDataBindings ();
			
			/*
			 * Collect form data for postback into alien document. 
			 * Notice that __EVENTTARGET data is handled manually.
			 */
			var callbackid = this._tabBinding.getCallBackID ();
			
			var list = new List ();
			new List ( this.bindingDocument.forms [ 0 ].elements ).each ( 
				function ( element ) {
					if ( element.name == "__EVENTTARGET" && callbackid ) {
						element.value = callbackid;
					}
					list.add ({
						name : element.name,
						value : element.value
					});
				}
			);
			
			/*
			 * Submit to iframe. Note that we store the 
			 * list in a variable for later use.
			 */
			var url = String ( this.bindingDocument.location );
			this._windowBinding.getContentWindow ().submit ( list, url );
			this._latestPostbackList = list.reset ();
			
		} else {
			
			this.handleInvalidData ();
		}
	}
}

WizardPageBinding.prototype = new DialogPageBinding;
WizardPageBinding.prototype.constructor = WizardPageBinding;
WizardPageBinding.superclass = DialogPageBinding.prototype;

WizardPageBinding.ID_NEXTBUTTON 				= "nextbutton";
WizardPageBinding.ID_PREVIOUSBUTTON 			= "previousbutton";
WizardPageBinding.ID_FINISHBUTTON 				= "finishbutton";
WizardPageBinding.ACTION_NAVIGATE_NEXT 			= "wizardnavigatenext";
WizardPageBinding.ACTION_NAVIGATE_PREVIOUS		= "wizardnavigateprevious";
WizardPageBinding.ACTION_FINISH 				= "wizardfinish";

/**
 * @class
 */
function WizardPageBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "WizardPageBinding" );
	
	/**
	 * Used to fix GUI lock while navigating between wizard pages.
	 * @type {boolean}
	 *
	this._isNavigating = false;
	*/
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
WizardPageBinding.prototype.toString = function () {

	return "[WizardPageBinding]";
}

/**
 * @overloads {DialogPageBinding#onPageInitialize}
 */
WizardPageBinding.prototype.onPageInitialize = function () {
	
	WizardPageBinding.superclass.onPageInitialize.call ( this );
	
	this.addActionListener ( WizardPageBinding.ACTION_NAVIGATE_NEXT, this );
	this.addActionListener ( WizardPageBinding.ACTION_NAVIGATE_PREVIOUS, this );
	this.addActionListener ( WizardPageBinding.ACTION_FINISH, this );
	
	/*
	 * TODO: These are not currently used!
	 *
	this.subscribe ( BroadcastMessages.WIZARD_NAVIGATE_NEXT );
	this.subscribe ( BroadcastMessages.WIZARD_NAVIGATE_PREVIOUS );
	this.subscribe ( BroadcastMessages.WIZARD_FINISH );
	*/
}

/**
 * @implements {IActionListener}
 * @overlods {PageBinding#handleAction}
 * @param {Action} action
 */
WizardPageBinding.prototype.handleAction = function ( action ) {

	WizardPageBinding.superclass.handleAction.call ( this, action );

	var binding = action.target;

	switch ( action.type ) {
		
		/*
		 * Moving forward will validate all databindings.
		 */
		case WizardPageBinding.ACTION_NAVIGATE_NEXT :
		case WizardPageBinding.ACTION_FINISH :
			if ( this.validateAllDataBindings () == true ) {
				this.doPostBack ( binding );
			} else {
				action.consume ();
			}
			break;
			
		/*
		 * Moving backwards allowed without validation.
		 */
		case WizardPageBinding.ACTION_NAVIGATE_PREVIOUS :
			this.doPostBack ( binding );
			// dont consume - ViewBinding is listening
			break;
			
		case Binding.ACTION_INVALID :
			this._enableNextAndFinish ( false );
			action.consume ();
			break;
			
		case Binding.ACTION_VALID :
			this._enableNextAndFinish ( true );
			action.consume ();
			break;
	}
}

/**
 * Enable-disable next and finish buttons.
 * @param {boolean} isEnable
 */
WizardPageBinding.prototype._enableNextAndFinish = function ( isEnable ) {
	
	var next = this.bindingWindow.bindingMap.nextbutton;
	var finish = this.bindingWindow.bindingMap.finishbutton;
	
	if ( next ) {
		next.setDisabled ( !isEnable );
	}
	if ( finish ) {
		finish.setDisabled ( !isEnable );
	}
}

/**
 * Some wizard page transitions may take a looooong time, so we lock the interface  
 * whenever a transition is instigated. The GUI is unlocked when the page dets disposed.
 * @overwrites {PageBinding#doPostBack}
 * @see {WizardPageBinding#onBindingDispose}
 * @param {Binding} binding
 *
WizardPageBinding.prototype.doPostBack = function ( binding ) {
	
	if ( this._canPostBack ) {
	
		WizardPageBinding.superclass.doPostBack.call ( this, binding );
		
		switch ( binding ) {
			case this.bindingWindow.bindingMap.nextbutton :
			case this.bindingWindow.bindingMap.previousbutton :
			case this.bindingWindow.bindingMap.finishbutton :
				this._isNavigating = true;
				Application.lock ( this ); // unlocked on dispose...
				break;
		}
	}
}
*/

MarkupAwarePageBinding.prototype = new PageBinding;
MarkupAwarePageBinding.prototype.constructor = MarkupAwarePageBinding;
MarkupAwarePageBinding.superclass = PageBinding.prototype;

/**
 * @class
 */
function MarkupAwarePageBinding () {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "MarkupAwarePageBinding" );
	
	/*
	 * @type {boolean}
	 */
	this._isActivated = false;
	
	/*
	 * @type {boolean}
	 */
	this._isWaiting = false;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
MarkupAwarePageBinding.prototype.toString = function () {

	return "[MarkupAwarePageBinding]";
}

/**
 * @overloads {PageBinding#onBeforePageInitialize}
 */
MarkupAwarePageBinding.prototype.onBeforePageInitialize = function () {
	
	MarkupAwarePageBinding.superclass.onBeforePageInitialize.call ( this );
	
	this.subscribe ( BroadcastMessages.XHTML_MARKUP_ON );
	this.subscribe ( BroadcastMessages.XHTML_MARKUP_OFF );
	this.subscribe ( BroadcastMessages.XHTML_MARKUP_ACTIVATE );
	this.subscribe ( BroadcastMessages.XHTML_MARKUP_DEACTIVATE );
}

/**
 * @implements {IBroadcastListener}
 * @overloads {PageBinding#handleBroadcast}
 * @param {string} broadcast
 * @param {object} arg
 */
MarkupAwarePageBinding.prototype.handleBroadcast = function ( broadcast, arg ) {

	MarkupAwarePageBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	var self = this;
	
	switch ( broadcast ) {
		case BroadcastMessages.XHTML_MARKUP_ON :
			this._activate ( true );
			if ( arg != null ) {
				this._handleMarkup ( arg );
			}
			break;
		case BroadcastMessages.XHTML_MARKUP_OFF :
			this._activate ( false );
			break;
		case BroadcastMessages.XHTML_MARKUP_ACTIVATE :
			this._isWaiting = true;
			this._activate ( true );
			setTimeout ( function () {
				self._isWaiting = false;
			}, 20 );
			break;
		case BroadcastMessages.XHTML_MARKUP_DEACTIVATE :
			setTimeout ( function () {
				if ( !self._isActivated ) {
					self._activate ( false );
				}
			}, 0 );
			break;
	}
}

/**
 * Mark panel activated.
 * @overloads {PageBinding#onActivate}
 */
MarkupAwarePageBinding.prototype.onActivate = function () {
	
	MarkupAwarePageBinding.superclass.onActivate.call ( this );
	
	this._activate ( true );
	this._isActivated = true;
}

/**
 * Unmark panel activated.
 * @overloads {PageBinding#onDeactivate}
 */
MarkupAwarePageBinding.prototype.onDeactivate = function () {
	
	MarkupAwarePageBinding.superclass.onDeactivate.call ( this );
	
	this._isActivated = false;
	var self = this;
	setTimeout ( function () {
		if ( !self._isWaiting ) {
			self._activate ( false );
		}
	}, 0 );
}

/**
 * Handle markup. Subclass should define this.
 * @param {string} markup
 */
MarkupAwarePageBinding.prototype._handleMarkup = function ( markup ) {}

/**
 * Activate and deactivate whenever markup is available. Subclass should define this.
 * @param {boolean} isActivate
 */
MarkupAwarePageBinding.prototype._activate = function ( isActivate ) {}

SystemToolBarBinding.prototype = new ToolBarBinding;
SystemToolBarBinding.prototype.constructor = SystemToolBarBinding;
SystemToolBarBinding.superclass = ToolBarBinding.prototype;

/**
 * @class
 * This would be the giant toolbar at the top of the main window.
 */
function SystemToolBarBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SystemToolBarBinding" );
	
	/**
	 * @type {string}
	 */
	this._currentProfileKey = null;
	
	/**
	 * @type {HashMap<string><ButtonBinding>}
	 */
	this._actionFolderNames = {};
	
	/**
	 * @type {Map<string><List<SystemAction>>}
	 */
	this._actionProfile = null;
	
	/**
	 * @type {int}
	 */
	this._moreActionsWidth = 0;
	
	/**
	 * Actions that wouldn't fit on the toolbar.
	 * @type {List<SystemAction>}
	 */
	this._moreActions = null;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
SystemToolBarBinding.prototype.toString = function () {

	return "[SystemToolBarBinding]";
}

/**
 * Setup toolbar rebuild when an actionProfile is published.
 * @overloads {ToolBarBinding#onBindingAttach}
 */
SystemToolBarBinding.prototype.onBindingAttach = function () {
	
	SystemToolBarBinding.superclass.onBindingAttach.call ( this );
	
	if ( System.hasActivePerspectives ) {
		this.subscribe ( BroadcastMessages.SYSTEM_ACTIONPROFILE_PUBLISHED );
		this.subscribe ( this.bindingWindow.WindowManager.WINDOW_RESIZED_BROADCAST );
		this.subscribe ( BroadcastMessages.INVOKE_DEFAULT_ACTION );
		this.addActionListener ( ButtonBinding.ACTION_COMMAND );
	} else {
		this.hide ();
	}
}

/**
 * Do stuff with dimensions on startup (handles too many actions on toolbar). 
 * @overloads {ToolBarBinding#onBindingInitialize}
 */
SystemToolBarBinding.prototype.onBindingInitialize = function () {
	
	// lookup more-actions toolbarbody width - then hide it
	var moreActionsBody = this.bindingWindow.bindingMap.moreactionstoolbargroup;
	this._moreActionsWidth = moreActionsBody.boxObject.getDimension ().w;
	moreActionsBody.hide ();
	
	// lock toolbar height to fix overflow issues.
	var height = this.boxObject.getDimension ().h;
	this.bindingElement.style.height = height + "px";
	
	// rigup more-actions button.
	var self = this;
	var button = this.bindingWindow.bindingMap.moreactionsbutton;
	button.addActionListener ( ButtonBinding.ACTION_COMMAND, {
		handleAction : function ( action ) {
			self._showMoreActions ();
			action.consume ();
		}
	});
	
	// rigup more-actions popup
	var popup = this.bindingWindow.bindingMap.moreactionspopup;
	popup.addActionListener ( MenuItemBinding.ACTION_COMMAND, {
		handleAction : function ( action ) {
			var item = action.target;
			self._handleSystemAction ( item.associatedSystemAction );
		}
	});
	
	SystemToolBarBinding.superclass.onBindingInitialize.call ( this );
}

/**
 * Handle EventBroadcaster transmissions. In particular, watch out for actionprofiles. 
 * @see {SystemTreeBinding#_publishCompiledActionProfile}
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
SystemToolBarBinding.prototype.handleBroadcast = function ( broadcast, arg ) {

	SystemToolBarBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		case BroadcastMessages.SYSTEM_ACTIONPROFILE_PUBLISHED :
		
			var self = this;
		
			if ( arg != null ) {
				this._actionProfile = arg;
				var key = this._getProfileKey ();
				if ( key != this._currentProfileKey ) {
					
					// Uncomment to debug if toolbar starts redrawing on apparently similar actions...
					// this.logger.debug ( Math.random () + "\n" + key + "\n" + this._currentProfileKey );
					
					/*
					 * Timeout prevents "freezing" tree selection.
					 */
					setTimeout ( function () {	
						self.emptyLeft ();
						self._actionFolderNames = {};
						self.buildLeft ();
						self._currentProfileKey = key;
					}, 0 );
				}
			} else {
				setTimeout ( function () {
					self.emptyLeft ();
					self._actionFolderNames = {};
					self._currentProfileKey = null;
					var mores = self.bindingWindow.bindingMap.moreactionstoolbargroup;
					if ( mores != null ) {
						mores.hide ();
					}
				}, 0 );
			}
			break;
			
		case this.bindingWindow.WindowManager.WINDOW_RESIZED_BROADCAST :
			
			var manager = this.bindingWindow.WindowManager;
			this._toolBarBodyLeft.refreshToolBarGroups ();
			this._containAllButtons ();
			break;
			
		case BroadcastMessages.INVOKE_DEFAULT_ACTION :
			var self = this;
			setTimeout ( function () { // timeout because binding attachment may happen now
				self._invokeDefaultAction ();
			}, 0 );
			break;
	}
}

/**
 * @see {SystemTreePopupBinding#_getProfileKey}
 * @return {string}
 */
SystemToolBarBinding.prototype._getProfileKey = function () {

	var result = new String ( "" );
	this._actionProfile.each ( function ( groupid, list ) {
		list.each ( function ( systemAction ) {
			result += systemAction.getHandle () + ";";
		});
	});
	
	return result;
}

/**
 * Invoke actions when toolbarbuttons gets clicked.
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
SystemToolBarBinding.prototype.handleAction = function ( action ) {

	SystemToolBarBinding.superclass.handleAction.call ( this, action );
	
	switch ( action.type ) {
		case ButtonBinding.ACTION_COMMAND :
			var button = action.target;
			this._handleSystemAction ( button.associatedSystemAction );
			break;
	}
}

/**
 * Handle system-action.
 * @param (SystemAction} action
 */
SystemToolBarBinding.prototype._handleSystemAction = function ( action ) {
	
	if ( action != null ) {
		var list = ExplorerBinding.getFocusedTreeNodeBindings ();
		if ( list.hasEntries ()) {
			var treeNodeBinding = list.getFirst ();
			var systemNode = treeNodeBinding.node;
		}
		SystemAction.invoke ( action, systemNode );
	}
}

/**
 * Build left-aligned toolbar content based on last published actionProfile.
 */
SystemToolBarBinding.prototype.buildLeft = function () {
	
	if ( this.isInitialized && this._actionProfile != null && this._actionProfile.hasEntries ()) {
		
		var doc = this.bindingDocument; 
		var self = this;
		
		this._actionProfile.each ( function ( groupid, list ) {
			
			var buttons = new List ();
			
			list.reset ();
			while ( list.hasNext ()) {
				var action = list.getNext ();
				var buttonBinding = null;
				if ( action.isInToolBar ()) {
					if ( action.isInFolder ()) {
						alert ( "IsInFolder not implemented!" );
						//buttonBinding = this.getPossibleButtonBinding ( action );
					} else {
						buttonBinding = self.getToolBarButtonBinding ( action );
					}
				}
				if ( buttonBinding != null ) {
					buttons.add ( buttonBinding );
				}
			}
			
			if ( buttons.hasEntries ()) {
				var groupBinding = ToolBarGroupBinding.newInstance ( doc );
				buttons.each ( function ( buttonBinding ) {
					groupBinding.add ( buttonBinding );
				});
				self.addLeft ( groupBinding ); // TODO: BOOLEAN ARGUMENT HERE!
			}
		});
		
		this.attachRecursive ();
		this._containAllButtons ();
	}
}

/**
 * Contain all buttons. Overflowing buttons are moved to a popup. 
 * The margin between buttons and groups are not accounted for...
 */
SystemToolBarBinding.prototype._containAllButtons = function () {
	
	var tools = this.bindingWindow.bindingMap.toolsbutton;
	var mores = this.bindingWindow.bindingMap.moreactionstoolbargroup;
	var avail = tools.bindingElement.offsetLeft - this._moreActionsWidth;
	var total = 0;
	var hides = new List ();
	
	var button, buttons = this._toolBarBodyLeft.getDescendantBindingsByLocalName ( "toolbarbutton" );
	while (( button = buttons.getNext ()) != null ) {
		if ( !button.isVisible ) {
			button.show ();
		}
		total += button.boxObject.getDimension ().w;
		if ( total >= avail ) {
			hides.add ( button );
			button.hide ();
		}
	}
	
	if ( hides.hasEntries ()) {
		
		var group = hides.getFirst ().bindingElement.parentNode;
		UserInterface.getBinding ( group ).setLayout ( ToolBarGroupBinding.LAYOUT_LAST );
		
		this._moreActions = new List ();
		while (( button = hides.getNext ()) != null ) {
			this._moreActions.add ( button.associatedSystemAction );
		}
		mores.show ();
		
	} else {
		this._moreActions = null;
		mores.hide ();
	}
}

/**
 * Show more actions.
 */
SystemToolBarBinding.prototype._showMoreActions = function () {
	
	if ( this._moreActions != null ) {
		var popup = this.bindingWindow.bindingMap.moreactionspopup;
		popup.empty ();
		while (( action = this._moreActions.getNext ()) != null ) {
			var item = MenuItemBinding.newInstance ( popup.bindingDocument );
			item.setLabel ( action.getLabel ());
			item.setToolTip ( action.getToolTip ());
			item.imageProfile = new ImageProfile ({ 
				image : action.getImage (),
				imageDisabled : action.getDisabledImage ()
			});
			if ( action.isDisabled ()) {
				item.disable ();
			}
			item.associatedSystemAction = action;
			popup.add ( item );
		}
		popup.attachRecursive ();
		this._moreActions = null;
	}
}

/**
 * This method is mirrored by the explorer popupmenu - please coordinate changes.
 * @see {SystemPopupBinding#getMenuItemBinding}
 * @param {SystemAction} action
 * @return {ToolBarButtonBinding}
 *
SystemToolBarBinding.prototype.getPossibleButtonBinding = function ( action ) {

	this.logger.debug ( "TODO: SystemToolBarBinding.getPossibleButtonBinding" );

	var result		= null;
	var binding		= ButtonBinding.newInstance ( this.bindingDocument );
	var label 		= action.getLabel ();
	var tooltip		= action.getToolTip ();
	var image 		= action.getImage ();
	var isDisabled	= action.isDisabled ();
	var folderName	= action.getFolderName ();
	
	if ( this._actionFolderNames [ folderName ]) {
	
	} else {
		this._actionFolderNames [ folderName ] = SelectorBinding.newInstance ( this.bindingDocument );
		result = this._actionFolderNames [ folderName ];
	}
	return result;
}
*/

/**
 * This method is mirrored by the explorer popupmenu - please coordinate changes.
 * @see {SystemPopupBinding#getMenuItemBinding}
 * @param {SystemAction} action
 * @return {ToolBarButtonBinding}
 */
SystemToolBarBinding.prototype.getToolBarButtonBinding = function ( action ) {

	var binding		= ToolBarButtonBinding.newInstance ( this.bindingDocument );
	var label 		= action.getLabel ();
	var tooltip		= action.getToolTip ();
	var image 		= action.getImage ();
	var isDisabled	= action.isDisabled ();
	
	if ( image && image.indexOf ( "size=" ) ==-1 ) {
		image = image + "&size=" + this.getImageSize ();
		binding.imageProfile = new ImageProfile ({ 
			image : image
		});
	}
	if ( label ) {
		binding.setLabel ( label );
	}
	if ( tooltip ) {
		binding.setToolTip ( tooltip );
	}
	if ( action.isDisabled ()) {
		binding.disable ();
	}
	
	/*
	 * Stamp the action as a property on the buttonbinding 
	 * so that we can retrieve it when the button is clicked.
	 */
	binding.associatedSystemAction = action;
	
	return binding;
};

/**
 * Invoke default action. Currently, this is the action 
 * associated to the first toolbarbutton on display.
 * @return
 */
SystemToolBarBinding.prototype._invokeDefaultAction = function () {
	
	var button = this.getDescendantBindingByLocalName ( "toolbarbutton" );
	if ( button != null ) {
		button.fireCommand ();
	}
};

/**
 * SystemToolBarBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {SystemToolBarBinding}
 */
SystemToolBarBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:toolbar", ownerDocument );
	return UserInterface.registerBinding ( element, SystemToolBarBinding );
}

SystemTreeBinding.prototype = new TreeBinding;
SystemTreeBinding.prototype.constructor = SystemTreeBinding;
SystemTreeBinding.superclass = TreeBinding.prototype;

/**
 * Flag determines whether or not treebranches should always
 * refresh when the parent folder is closed and reopened.
 * @type {boolean}
 */
SystemTreeBinding.HAS_NO_MEMORY = false;

/**
 * @type {SystemTreeNodeBinding}
 */
SystemTreeBinding.clipboard = null;

/**
 * @type {string}
 */
SystemTreeBinding.clipboardOperation = null;

/*
 * Detailed paste dialog.
 */
SystemTreeBinding.URL_DIALOG_DETAILEDPASTE = "${root}/content/dialogs/systemtrees/detailedpaste.aspx";

/**
 * @class
 */
function SystemTreeBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SystemTreeBinding" );
	
	/**
	 * Associates the tree to the selected perspective.
	 * @type {SystemNode}
	 */
	this.perspectiveNode = null;
	
	/**
	 * @type {SystemTreeNodeBinding}
	 */
	this._defaultTreeNode = null;
	
	/**
	 * Publishing actionprofiles when treenodes get selected? 
	 * If set to false, no commands will be relayed to main toolbar.
	 * TODO: Filter commands on server instead!
	 * @type {boolean}
	 */
	this._isActionProfileAware = true;
	
	/**
	 * This can be deprecated if we implement serverside treenode selection.
	 * @type {string}
	 */
	this._backupfocushandle = null;
	
	/**
	 * This can be deprecated if we implement serverside treenode selection.
	 * @type {SystemTreeNodeBinding}
	 */
	this._tempSelectedNode = null;
	
	/**
	 * This can be deprecated if we implement serverside treenode selection.
	 * @type {boolean}
	 */
	this._tempSelectionTimeout = false;
	
	/**
	 * While this._treeNodeBindings index treenodes by unique handle (ElementKey), 
	 * this will index groups of treenodes sharing the same EntityToken.
	 * @type {Map<string><List<SystemTreeNodeBinding>>}
	 */
	this._entityTokenRegistry = null;
	
	/**
	 * Counting refreshing treenodes so that we may poke the MessageQueue 
	 * once all nodes are finished (some timeouts involved here).
	 * @type {Map<string><boolean>}
	 */
	this._refreshingTreeNodes = null;
	
	/**
	 * When the tree is refreshed by MessageQueue, this stores the refreshtoken.
	 * @type {string}
	 */
	this._refreshToken = null;
	
	/**
	 * Lock tree to editor?
	 * @type {boolean}
	 */
	this.isLockedToEditor = true;

	/**
	 * Because we execute lock-tree focus on a timeout, 
	 * this flag will instruct the treenode no to init 
	 * an eternal selection loop.
	 * @type {boolean}
	 */
	this.isLockFeatureFocus = false;

	/**
	 * Points to the last treenode that was blurred in an   
	 * attempt, always to offer a sensible treenode focus.
	 * @type {string}
	 */
	this._restorableFocusHandle = null;
}

/**
 * Identifies binding.
 */
SystemTreeBinding.prototype.toString = function () {
	
	return "[SystemTreeBinding]";
}

/**
 * @overloads {TreeBinding#onBindingRegister}
 */
SystemTreeBinding.prototype.onBindingRegister = function () {

	SystemTreeBinding.superclass.onBindingRegister.call ( this );
	
	/*
	 * Mark the tree as resident on the currently selected perspective.
	 */
	this.perspectiveNode = StageBinding.perspectiveNode;
	
	/*
	 * File subscriptions.
	 */
	this.subscribe ( BroadcastMessages.SYSTEMTREEBINDING_REFRESH );
	this.subscribe ( BroadcastMessages.SYSTEMTREEBINDING_CUT );
	this.subscribe ( BroadcastMessages.SYSTEMTREEBINDING_COPY );
	this.subscribe ( BroadcastMessages.SYSTEMTREEBINDING_PASTE );
	this.subscribe ( BroadcastMessages.SYSTEMTREEBINDING_COLLAPSEALL );
	this.subscribe ( BroadcastMessages.DOCKTABBINDING_SELECT );
	this.subscribe ( BroadcastMessages.STAGEDIALOG_OPENED );
	
	/*
	 * Init stuff.
	 */
	this.addActionListener ( SystemTreeNodeBinding.ACTION_REFRESHED_YEAH );
	this.addActionListener ( TreeNodeBinding.ACTION_COMMAND );
	this._entityTokenRegistry = new Map ();
	this._refreshingTreeNodes = new Map ();
	
	/*
	 * Should tree selection update top toolbar?
	 */
	if ( this.getProperty ( "actionaware" ) == false ) {
		this._isActionProfileAware = false;
	} else {
		this.setContextMenu ( top.app.bindingMap.systemtreepopup );
	}
	
	/*
	 * Setup lock-to-editor.
	 */
	if ( this.getProperty ( "locktoeditor" ) != null ) {
		this.isLockedToEditor = this.getProperty ( "locktoeditor" );
	}
}

/**
 * Register the first added treenode so that we can focus it when tree is ready.
 * @overloads {TreeBinding#add}
 * @param {Binding} binding
 * @return {Binding}
 */
SystemTreeBinding.prototype.add = function ( binding ) {
	
	var returnable = SystemTreeBinding.superclass.add.call ( this, binding );
	if ( !this._defaultTreeNode ) {
		if ( binding instanceof SystemTreeNodeBinding ) {
			this._defaultTreeNode = binding;
		}
	}
	return returnable;
}

/**
 * @implements {IActionListener}
 * @overloads {TreeBinding#handleAction}
 * @param {Action} action
 */
SystemTreeBinding.prototype.handleAction = function ( action ) {

	SystemTreeBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	
	switch ( action.type ) {
		
		/*
		 * Publish actionprofile when selection changes.
		 */
		case TreeNodeBinding.ACTION_ONFOCUS :
		case TreeNodeBinding.ACTION_ONMULTIFOCUS :
			this._restorableFocusHandle = null;
			this._handleSystemTreeFocus ();
			break;
		
		/**
		 * Broadcast when treenodes are finished refreshing.
		 * This is intercepted by the MessageQueue.
		 */
		case SystemTreeNodeBinding.ACTION_REFRESHED_YEAH :
			
			this._updateRefreshingTrees ( binding.key );
			action.consume ();
			break;
		
		case TreeNodeBinding.ACTION_DISPOSE :
		case TreeNodeBinding.ACTION_BLUR :
			
			/*
			 * This should probably be refactored along with the whole 
			 * _focusedTreeNodeBindings setup, but at least we clear 
			 * the toolbar when tree has no focused nodes... 
			 */
			var self = this;
			setTimeout ( function () {
				if ( !self._focusedTreeNodeBindings.hasEntries ()) {
					EventBroadcaster.broadcast ( 
						BroadcastMessages.SYSTEM_ACTIONPROFILE_PUBLISHED, 
						null
					);
				}
			}, 0 );
			
			/*
			 * Backup the node that blurred. This will allow us to 
			 * focus an appropriate treenode on tree focus, even 
			 * when some feature destroyed all tree selection.
			 * @see {SystemTreeBinding#focus}
			 */
			if ( action.type == TreeNodeBinding.ACTION_BLUR ) {
				this._restorableFocusHandle = binding.getHandle ();
			}
			break;
			
		case TreeNodeBinding.ACTION_COMMAND :
			EventBroadcaster.broadcast ( BroadcastMessages.INVOKE_DEFAULT_ACTION ); 
			action.consume ();
			break;
	}
}

/**
 * @overloads {TreeBinding#focus}
 */
SystemTreeBinding.prototype.focus = function () {
	
	SystemTreeBinding.superclass.focus.call ( this );
	if ( this.isFocused ) {
		this._handleSystemTreeFocus ();
	}
}

/**
 * Default focus action - focus LAST FOCUSED node in tree.
 * @overwrites {TreeBinding#_focusDefault}
 */
SystemTreeBinding.prototype._focusDefault = function () {
	
	this._attemptRestorableFocus ();
	if ( !this.getFocusedTreeNodeBindings ().hasEntries ()) {
		SystemTreeBinding.superclass._focusDefault.call ( this );
	}
}

/**
 * By now, something has probably eliminated all tree focus. But since   
 * we back up the last blurred node, we can restore a sensible focus. 
 */
SystemTreeBinding.prototype._attemptRestorableFocus = function () {
	
	if ( this._treeNodeBindings.has ( this._restorableFocusHandle )) {
		var treenode = this._treeNodeBindings.get ( this._restorableFocusHandle );
		this.focusSingleTreeNodeBinding ( treenode );
	}
	this._restorableFocusHandle = null;
}

/**
 * Invoked when tree focus changes AND when tree itself recieves the focus  
 * AND when lock-tree-to-editor feature updates the treenode focus.
 */
SystemTreeBinding.prototype._handleSystemTreeFocus = function () {
	
	if ( this.getFocusedTreeNodeBindings ().hasEntries ()) {
		this._computeClipboardSetup ();
		this._computeRefreshSetup ();
		if ( this._isActionProfileAware ) {
			EventBroadcaster.broadcast ( 
				BroadcastMessages.SYSTEM_ACTIONPROFILE_PUBLISHED, 
				this.getCompiledActionProfile ()
			);
		}
	}
}

/**
 * Register treenode.
 * @param {SystemTreeNodeBinding} treenode
 */
SystemTreeBinding.prototype.registerTreeNodeBinding = function ( treenode ) {
	
	SystemTreeBinding.superclass.registerTreeNodeBinding.call ( this, treenode );
	
	/*
	 * Update entityToken registry so that we may quickly 
	 * find the treenode(s) based on this property.
	 */
	var reg = this._entityTokenRegistry;
	var token = treenode.node.getEntityToken ();
	
	if ( reg.has ( token )) {
		reg.get ( token ).add ( treenode );	
	} else {
		reg.set ( token, new List ([ treenode ]));
	}
	
	/*
	 * This will attempt to restore treenode selection when tree is refreshed.
	 */
	var focusnode = null;
	if ( this.isLockedToEditor ) {
		
		/* 
		 * Treenode re-focus should be determined by the 
		 * entityToken of the selected DockTabBinding. 
		 * Note that unlike the handle (the ElementKey), an 
		 * entityToken may occur multiple times in the same tree.
		 */
		if ( token == StageBinding.entityToken ) {
			if ( treenode.node.isTreeLockEnabled ()) {
				focusnode = treenode;
			}
		}
		
	} else {
		
		/*
		 * Treenode gets focused when it matches a previously 
		 * unregistered, focused treenode.
		 * @see {SystemTreeBinding#unRegisterTreeNodeBinding}
		 */
		if ( this._backupfocushandle != null ) {
			if ( this._backupfocushandle == treenode.node.getHandle ()) {
				focusnode = treenode;
			}
		}
	}
	
	/*
	 * If found, focus the treenode.
	 */
	if ( focusnode != null ) {
		this.focusSingleTreeNodeBinding ( focusnode );
	}
}

/** 
 * Unregister treenode. If no selected treenodes are left after whatever operation 
 * occured, we empty the toolbar and contextmenu. This should be considered a 
 * temporary hack until we implement serverside treeselection.
 * @overloads {TreeBinding#unRegisterTreeNodeBinding}
 * @param {SystemTreeNodeBinding} treeNodeBinding
 */
SystemTreeBinding.prototype.unRegisterTreeNodeBinding = function ( treenode ) {
	
	SystemTreeBinding.superclass.unRegisterTreeNodeBinding.call ( this, treenode );
	
	/*
	 * Unregister from entityToken registry.
	 */
	var reg = this._entityTokenRegistry;
	var token = treenode.node.getEntityToken ();
	
	if ( reg.has ( token )) {
		var list = reg.get ( token );
		list.del ( treenode );
		if ( !list.hasEntries ()) {
			reg.del ( token );
		} 
	} else {
		this.logger.fatal ( "SystemTreeBinding out of synch: unRegisterTreeNodeBinding" );
		if ( Application.isDeveloperMode ) {
			Dialog.error ( "Attention Developer", "Tree is out of synch. Please reproduce this bug and file a report." );
		}
	}
	
	/*
	 * Was the treenode deleted while refreshing?
	 */
	if ( treenode.isRefreshing ) {
		this._updateRefreshingTrees ( binding.key );
	}
	
	/*
	 * This relates to the treenode re-selection hack.
	 * @see {SystemTreeBinding#registerTreeNodeBinding}
	 */
	if ( !this.isLockedToEditor ) {
		if ( treenode.isFocused && this._backupfocushandle == null ) {
			this._backupfocushandle = treenode.node.getHandle ();
			var self = this;
			setTimeout ( function () {
				self._backupfocushandle = null;
			}, 200 );
		}
	}
}

/**
 * Refreshing treenodes count at zero?
 * @param {String} key
 */
SystemTreeBinding.prototype._updateRefreshingTrees = function ( key ) {
	
	var trees = this._refreshingTreeNodes;
	
	if ( trees.hasEntries () && trees.has ( key )) {
		trees.del ( key );
		if ( !trees.hasEntries ()) {
			EventBroadcaster.broadcast ( 
				BroadcastMessages.SYSTEMTREEBINDING_REFRESHED, this._refreshToken 
			);
			this._refreshToken = null;
			this._attemptRestorableFocus ();
		}
	}
};

/**
 * Enable contextmenu cut and paste?
 */
SystemTreeBinding.prototype._computeClipboardSetup = function () {
	
	var isCutAllowed = false;
	var focusedBindings = this.getFocusedTreeNodeBindings ();
	
	if ( focusedBindings.hasEntries ()) {
		isCutAllowed = true;
		while ( isCutAllowed && focusedBindings.hasNext ()) {
			var binding = focusedBindings.getNext ();
			if ( !binding.isDraggable ) {
				isCutAllowed = false;
			}
		}
	}
	SystemTreePopupBinding.isCutAllowed = isCutAllowed;
}

/**
 * Disabling refresh when clipboard is full. Otherwise, a refresh may cause tests   
 * for treenode nesting to be corrupted; and parents can be moved to children nodes.
 * TODO: Fix nesting test instead?
 */
SystemTreeBinding.prototype._computeRefreshSetup = function () {
	
	SystemTreePopupBinding.isRefreshAllowed = SystemTreeBinding.clipboard === null;
}

/**
 * Implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
SystemTreeBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	SystemTreeBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	/**
	 * Doublecheck that this tree is actually focused. Although if 
	 * the server transmits a refresh signal, this is not required.
	 */
	switch ( broadcast ) {
		
		case BroadcastMessages.SYSTEMTREEBINDING_REFRESH :
			if ( arg != null || this.isFocused ) { // arg is only provided when server is refreshing!
				this._handleCommandBroadcast ( broadcast, arg );
			}
			break;
			
		case BroadcastMessages.SYSTEMTREEBINDING_CUT :
		case BroadcastMessages.SYSTEMTREEBINDING_COPY :
		case BroadcastMessages.SYSTEMTREEBINDING_PASTE :
			if ( this.isFocused ) {
				this._handleCommandBroadcast ( broadcast );
			}
			break;
			
		case BroadcastMessages.SYSTEMTREEBINDING_COLLAPSEALL :
			this.collapse ( true );
			break;
			
		case BroadcastMessages.DOCKTABBINDING_SELECT :
			if ( this.isLockedToEditor ) {
				var tab = arg;
				if ( tab.getHandle () != "Composite.Management.Explorer" ) { // the tree dock!
					this._handleDockTabSelect ( tab );
				}
				// TODO: Othwise attempt restore focus!!!!!!!!!!!!!!!!!!!!!
			}
			break;
			
		case BroadcastMessages.STAGEDIALOG_OPENED :
			if ( this.isLockedToEditor ) {
				this.blurSelectedTreeNodes ();
				EventBroadcaster.broadcast ( BroadcastMessages.SYSTEM_ACTIONPROFILE_PUBLISHED, null );
			}
			break;
	}
}

/**
 * A tab was activated somewhere on screen. This should  
 * update tree selection and thus toolbar actions.
 * @param {DockTabBinding} tab
 */
SystemTreeBinding.prototype._handleDockTabSelect = function ( tab ) {
	
	/*
	 * Is the activated tab visible on screen?
	 */
	var isVisible = tab.perspectiveNode == null;
	if ( !isVisible ) {
		isVisible = tab.perspectiveNode == this.perspectiveNode;
	}
	
	/*
	 * If the tab was launched by the server, there is a chance we might 
	 * find a matching treenode. Otherwise, we blur any selected treenode.
	 */
	if ( isVisible ) {
		var self = this, token = tab.getEntityToken ();
		setTimeout ( function () { // timeout to minimize freezing sensation
			if ( token == null ) {
				self.blurSelectedTreeNodes ();
			} else {
				self._focusTreeNodeByEntityToken ( token );
			}
		}, 250 ); // zero not always enough...
	}
}

/**
 * Focus the first encountered treenode with a given entityToken 
 * in support of the lock-tree-to-editor feature.
 * @param {string} entityToken
 * @param {boolean} isSecondAttempt Discourage endless looping
 * @return
 */
SystemTreeBinding.prototype._focusTreeNodeByEntityToken = function ( entityToken, isSecondAttempt ) {
	
	/*
	 * Mark this focus so that it won't trigger a new tab  
	 * focus in some kind of eternal feedback process.
	 */
	this.isLockFeatureFocus = true;
	
	/*
	 * Let's find the treenode to focues...
	 */
	var treenode = null;
	
	/*
	 * Note that we simply select the first available treenode with the given   
	 * entityToken MARKED AS FOCUSABLE. This may not be the best, though...
	 */
	if ( this._entityTokenRegistry.has ( entityToken )) {
		var list = this._entityTokenRegistry.get ( entityToken );
		list.each ( function ( tn ) {
			var result = true;
			if ( tn.node.isTreeLockEnabled ()) {
				treenode = tn;
				result = false;
			}
			return result;
		});
		if ( treenode != null ) {
			if ( !treenode.isFocused ) {
				this.focusSingleTreeNodeBinding ( treenode, true );
			} else {
				treenode.dispatchAction ( TreeNodeBinding.ACTION_FOCUSED ); // to reveal it!
			}
		}
	}
	
	/*
	 * Re-enable normal focus.
	 */
	this.isLockFeatureFocus = false;
	
	/*
	 * But if no focusable treenode was found, we ask the server for more treenodes.
	 */
	if ( treenode == null && isSecondAttempt != true ) {
		
		Application.lock ( this );
		StatusBar.busy ();
		
		/*
		 * We timeout to lock the GUI while tree is refreshed; this can take some time. 
		 */
		var self = this;
		setTimeout ( function () {
			if ( Binding.exists ( self )) {
				self._fetchTreeForEntityToken ( entityToken );
				self._focusTreeNodeByEntityToken ( entityToken, true ); // do it again!
			}
			Application.unlock ( self );
			StatusBar.clear ();
		}, 0 );
	}
}

/**
 * Query the TreeService for a structure that exposes a given entityToken.
 * @param {string} entityToken
 */
SystemTreeBinding.prototype._fetchTreeForEntityToken = function ( entityToken ) {
	
	/*
	 * Summon fresh nodes from server. 
	 */
	var perspectiveEntityToken = StageBinding.perspectiveNode.getEntityToken ();
	var openSystemNodes = this.getOpenSystemNodes (); 
	var map = System.getInvisibleBranch ( 
		perspectiveEntityToken,
		entityToken,
		openSystemNodes
	);
	
	/*
	 * If server goofed up, we quickly disable the lock-tree-to-editor feature.
	 */
	if ( map == null ) {
		this.isLockedToEditor = false;
		if ( Application.isDeveloperMode ) {
			Dialog.warning ( "Ouch!", 
				"Because the web service failed, tree has disabled the lock-tree-to-editor " +
				"feature. Otherwise, re-focus would fire the error indefinitely. Please try again."
			);
		}
	}
	
	/*
	 * Controversially, the TreeService exposes no nested tree   
	 * structure, so the parsing code can get a little complicated.
	 */
	else if ( map.hasEntries ()) {
		
		var self = this;
		var oldnodes = this._treeNodeBindings;
		var newnodes = new Map ();
		
		/* 
		 * Handy treenodebuilder function.
		 * @param {TreeNodeBinding} treenode
		 * @param {List<SystemNode>} list
		 */
		function fix ( treenode, list ) {
			
			if ( !treenode.hasBeenOpened ) { // true when a refresh is needed, even for old nodes...
				if ( list.hasEntries ()) {
					
					/*
					 * TODO: Since the oldnodes check is needed here, 
					 * do we risk fogging up the display order of nodes?
					 */
					list.each ( function ( node ) {
						if ( !oldnodes.has ( node.getHandle ())) {
							var newnode = SystemTreeNodeBinding.newInstance ( node, self.bindingDocument );
							newnodes.set ( node.getHandle (), newnode );
							treenode.add ( newnode );
						}
					});
					treenode.attachRecursive ();
				}
			}
			treenode.open ( true ); // open node (without causing a new refresh!)
		}
		
		/*
		 * Iterate map, building treenodes. Fortunately, 
		 * each sequential entry in the map lists nodes that  
		 * must be appended to a *previously* build node... 
		 */
		map.each ( function ( handle, list ) {
			if ( oldnodes.has ( handle )) {
				var oldnode = oldnodes.get ( handle );
				fix ( oldnode, list );
			} else {
				if ( newnodes.has ( handle )) {
					var newnode = newnodes.get ( handle );
					fix ( newnode, list );
				} else {
					 // we seem to have encountered a strange hole in the structure
				}
			}
		});
	}
}

/**
 * Handle tree command.
 * @param {string} broadcast
 * @param {object} arg
 */
SystemTreeBinding.prototype._handleCommandBroadcast = function ( broadcast, arg ) {
	
	switch ( broadcast ) {
			
		/*
		 * Note that this broadcast can also be intercepted by the 
		 * {@link SystemPageBinding} in order to refresh the tree root.
		 */
		case BroadcastMessages.SYSTEMTREEBINDING_REFRESH :
			
			/* 
			 * If arg is present, it implies that MessageQueue invoked the refresh.
			 * Otherwise the action was instantiated by the user (eg contextmenu).
			 */
			var token = arg;
			if ( token != null ) {
				this._invokeServerRefresh ( token );
			} else {
				this._invokeManualRefresh ();
			}
			break;
		
		/*
		 * TODO: support multiple selections!
		 */
		case BroadcastMessages.SYSTEMTREEBINDING_CUT :
			if ( SystemTreeBinding.clipboard != null ) {
				SystemTreeBinding.clipboard.hideDrag ();
			}
			var treenode = this.getFocusedTreeNodeBindings ().getFirst ();
			SystemTreeBinding.clipboardOperation = SystemTreePopupBinding.CMD_CUT;
			SystemTreeBinding.clipboard = treenode;		
			treenode.showDrag ();
			break;
		
		/*
		 * TODO: support multiple selections!
		 */
		case BroadcastMessages.SYSTEMTREEBINDING_COPY :
			var treenode = this.getFocusedTreeNodeBindings ().getFirst ();
			SystemTreeBinding.clipboardOperation = SystemTreePopupBinding.CMD_COPY;
			SystemTreeBinding.clipboard = treenode;
			break;		
			
		case BroadcastMessages.SYSTEMTREEBINDING_PASTE :
			this._handlePaste ();
			break;
	}
}

/**
 * Invoke server refresh. This was probably caused by the MessageQueue.
 * @param {string} token
 */
SystemTreeBinding.prototype._invokeServerRefresh = function ( token ) {
	
	if ( token != null && token == "null" ) {
		if ( Application.isDeveloperMode ) {
			alert ( "Saa har vi balladen." );
		}
	}
	
	if ( this._entityTokenRegistry.has ( token )) {
		
		var list = this._entityTokenRegistry.get ( token ).reset ();
		
		/*
		 * Broadcast instructs the MessageQueue to delay 
	 	 * action execution until tree is refreshed. 
	 	 */
		this._refreshToken = token;
		EventBroadcaster.broadcast ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHING, this._refreshToken );
		
		while ( list.hasNext ()) {
			var treenode = list.getNext ();
			this._refreshingTreeNodes.set ( treenode.key, true );
			
			/*
			 * Push to next thread in order to give MessageQueue a chance 
			 * to detect whether or not any trees are actually refreshing 
			 * (because if not, it needs to execute the next action now). 
			 */
			setTimeout ( function () {
				treenode.refresh ( true );
			}, 0 );
		}
	}
}


/**
 * Invoke manual refresh. This was probably caused 
 * by user clicking the contextmenu refresh item. 
 * Note that we actually refresh the PARENT treenode.
 * @param {string} token
 */
SystemTreeBinding.prototype._invokeManualRefresh = function () {
	
	var treenode = this.getFocusedTreeNodeBindings ().getFirst ();
	if ( treenode ) {
		var label = treenode.getLabel ();
		var parent = treenode.getAncestorBindingByLocalName ( "treenode" );
		if ( parent ) {
			treenode = parent; // because the treenode itself may have changed!
		}
		this._refreshToken = null;
		this._refreshingTreeNodes.set ( treenode.key, true );
		EventBroadcaster.broadcast ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHING, null );
		if ( !StatusBar.state ) {
			var message = StringBundle.getString ( "ui", "Website.App.StatusBar.Refreshing" );
			StatusBar.busy ( message, [ label ]);
		}
		treenode.refresh ();
	}
}

/**
 * Handle paste.
 */
SystemTreeBinding.prototype._handlePaste = function () {
	
	var treenode = SystemTreeBinding.clipboard;
	
	if ( treenode ) {
		
		/*
		 * TODO: ALLOW MULTIPLE!!!!
		 */
		var type = treenode.dragType;
		var focused = this.getFocusedTreeNodeBindings ().getFirst ();
		if ( focused.dragAccept ) {
			if ( focused.acceptor.isAccepting ( type )) {
				this._performPaste ( focused );
			} else {
				Dialog.message (
					StringBundle.getString ( "ui", "Website.Misc.Trees.DialogTitle.PasteTypeNotAllowed" ),
					StringBundle.getString ( "ui", "Website.Misc.Trees.DialogText.PasteTypeNotAllowed" ) 
				);
			}
		} else {
			Dialog.message (
				StringBundle.getString ( "ui", "Website.Misc.Trees.DialogTitle.PasteNotAllowed" ),
				StringBundle.getString ( "ui", "Website.Misc.Trees.DialogText.PasteNotAllowed" ) 
			);
		}
	}
}

/**
 * Perform paste (then refresh the MessageQueue).
 * @param {SystemTreeNodeBinding} treenode
 */
SystemTreeBinding.prototype._performPaste = function ( treenode ) {

	var self = this;
	
	function update () {
		MessageQueue.update ();
		Application.unlock ( self );
	}

	if ( treenode.node.hasDetailedDropSupport ()) {
		if ( treenode.node.hasChildren ()) {
			var argument = treenode.node.getChildren ();
			Dialog.invokeModal ( SystemTreeBinding.URL_DIALOG_DETAILEDPASTE, {
				handleDialogResponse : function ( response, result ) {
					if ( response == Dialog.RESPONSE_ACCEPT ) {
						Application.lock ( self );
						var position = result.get ( "switch" );
						var index = result.get ( "sibling" );
						if ( position == "after" ) {
							index ++;
						}
						var isAccept = treenode.accept ( SystemTreeBinding.clipboard, index );
						if ( isAccept ) {
							SystemTreeBinding.clipboard = null;
							SystemTreeBinding.clipboardOperation = null;
							setTimeout ( update, 0 );
						} else {
							update ();
						}
					}
				}
			}, argument );
		} else {
			Application.lock ( self );
			var isAccept = treenode.accept ( SystemTreeBinding.clipboard, 0 );
			if ( isAccept ) {
				SystemTreeBinding.clipboard = null;
				SystemTreeBinding.clipboardOperation = null;
				setTimeout ( update, 0 );
			} else {
				update ();
			}
		}
	} else {
		Application.lock ( self );
		var isAccept = treenode.accept ( SystemTreeBinding.clipboard, 0 );
		if ( isAccept ) {
			SystemTreeBinding.clipboard = null;
			SystemTreeBinding.clipboardOperation = null;
		}
		update ();
	}
}

/**
 * Focus the first treenode. This should only be called once.
 */
SystemTreeBinding.prototype.selectDefault = function () {
	
	if ( this._defaultTreeNode ) {
		this._defaultTreeNode.focus ();
		this._defaultTreeNode = null;
	}
}

/**
 * Close tree (close root nodes and wipe their memory).
 * @overloads {TreeNodeBinding#collapse}
 * @param {boolean} isDestructive
 */
SystemTreeBinding.prototype.collapse = function ( isDestructive ) {
	
	EventBroadcaster.broadcast ( BroadcastMessages.SYSTEM_ACTIONPROFILE_PUBLISHED, null );
	
	if ( isDestructive ) {
		this.blurSelectedTreeNodes ();
		var treenodes = this.getRootTreeNodeBindings ();
		treenodes.each ( function ( treenode ) {
			if ( treenode.isContainer && treenode.isOpen ) {
				treenode.close ();
				treenode.hasBeenOpened = false;
				treenode.empty ();
			}
		});
	} else {
		SystemTreeBinding.superclass.collapse.call ( this );
	}
}

/**
 * Lock tree to editor?
 * @param {boolean} isLocked
 */
SystemTreeBinding.prototype.setLockToEditor = function ( isLocked ) {
	
	if ( isLocked != this.isLockedToEditor ) {
		this.isLockedToEditor = isLocked;
		if ( isLocked ) {
			EventBroadcaster.broadcast ( BroadcastMessages.SYSTEMTREEBINDING_LOCKTOEDITOR );
		}
	}
}

/**
 * Get the list of all open nodes in this tree PLUS this tree node itself.
 * @list {List<SystemNode>}
 */
SystemTreeBinding.prototype.getOpenSystemNodes = function () {
	
	/*
	 * Add perspective node, ie. this tree (since the 
	 * perspective corresponds to this tree in the hierarchy).
	 */
	var list = new List ([ StageBinding.perspectiveNode ]);
	
	/*
	 * Add open treenodes.
	 */
	var treenodes = this.getRootTreeNodeBindings ();
	treenodes.each ( function ( treenode ) {
		var opennodes = treenode.getOpenSystemNodes ();
		if ( opennodes != null && opennodes.hasEntries ()) {
			list.merge ( opennodes );
		}
	});
	
	return list;
};

/**
 * @overloads {TreeBinding#focusSingleTreeNodeBinding}
 * @param {TreeNodeBinding} binding;
 */
SystemTreeBinding.prototype.focusSingleTreeNodeBinding = function ( binding ) {
	
	SystemTreeBinding.superclass.focusSingleTreeNodeBinding.call ( this, binding );
	if ( binding != null ){
		this._handleSystemTreeFocus ();
	}
};

/**
 * Compile actionprofile based on the individual actionprofile of all focused treenodes.
 * In case of multiple focused treenodes, only SystemActions relevant for *all* focused 
 * treenodes will be included in the result.
 * @return {Map<string><List<SystemAction>>}
 */
SystemTreeBinding.prototype.getCompiledActionProfile = function () {

	var temp = {};
	var result = new Map ();
	
	var focusedBindings = this.getFocusedTreeNodeBindings ();
	result = focusedBindings.getFirst ().node.getActionProfile ();
	
	// THIS FAILS SOMEHOW!
	
	/*
	 * Build a temporary list of SystemAction keys.
	 *
	focusedBindings.each ( 
		function ( binding ) {
			var actionProfile = binding.node.getActionProfile ();	
			actionProfile.each ( function ( groupid, list ) {
				list.each ( function ( systemAction ) {
					var key = systemAction.getHandle ();
					if ( !temp [ key ]) {
						temp [ key ] = new List ();
					}
					temp [ key ].add ({
						groupid : groupid,
						systemAction : systemAction
					});
				});
			});
		}
	);
	
	/* 
	 * Delete entries that doesn't apply to *all* focused treenodes
	 *
	for ( var key in temp ) {
		var list = temp [ key ];
		if ( list.getLength () != focusedBindings.getLength ()) {
			delete temp [ key ];
		}
	}
	
	/*
	 * Build resulting actionprofile. The result should be comparable to a 
	 * single actionprofile as computed by {@link SystemNode#getActionProfile}
	 *
	for ( var key in temp ) {
		var list = temp [ key ];
		var entry = list.getFirst ();
		if ( !result.has ( entry.groupid )) {
			result.set ( 
				entry.groupid, 
				new List ()
			);
		}
		result.get ( entry.groupid ).add ( entry.systemAction );
	}
	*/
	
	return result;
}

SystemTreePopupBinding.prototype = new PopupBinding;
SystemTreePopupBinding.prototype.constructor = SystemTreePopupBinding;
SystemTreePopupBinding.superclass = PopupBinding.prototype;

SystemTreePopupBinding.CMD_CUT = "cut";
SystemTreePopupBinding.CMD_COPY = "copy";
SystemTreePopupBinding.CMD_PASTE = "paste";
SystemTreePopupBinding.CMD_REFRESH = "refresh";

/**
 * @type {boolean}
 */
SystemTreePopupBinding.isCutAllowed = false;
SystemTreePopupBinding.isRefreshAllowed = true;


/** 
 * @class
 */
function SystemTreePopupBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SystemTreePopupBinding" );
	
	/**
	 * @type {string}
	 */
	this._currentProfileKey = null;
	
	/**
	 * @type {object}
	 */
	this._actionProfile = null;
	
	/**
	 * @type {TreeNodeBinding}
	 */
	this.selectedTreeNodeBinding = null;
}

/**
 * @overloads {Binding#onBindingRegister}
 */
SystemTreePopupBinding.prototype.onBindingRegister = function () {

	SystemTreePopupBinding.superclass.onBindingRegister.call ( this );
	this.subscribe ( BroadcastMessages.SYSTEM_ACTIONPROFILE_PUBLISHED );
	this.addActionListener ( MenuItemBinding.ACTION_COMMAND, this );
}

/**
 * @overloads {Binding#onBindingAttach}
 */
SystemTreePopupBinding.prototype.onBindingAttach = function () {

	SystemTreePopupBinding.superclass.onBindingAttach.call ( this );
	this._indexMenuContent ();
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
SystemTreePopupBinding.prototype.handleBroadcast = function ( broadcast, arg ) {

	SystemTreePopupBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		case BroadcastMessages.SYSTEM_ACTIONPROFILE_PUBLISHED :
			if ( arg != null ) {
				this._actionProfile = arg;
			} else {
				this._currentProfileKey = null;
			}
			break;
	}
}

/**
 * @see {SystemToolbarBinding#_getProfileKey}
 * @return {string}
 */
SystemTreePopupBinding.prototype._getProfileKey = SystemToolBarBinding.prototype._getProfileKey

/**
 * @overloads {PopupBinding#show}
 */
SystemTreePopupBinding.prototype.show = function () {
	
	/*
	 * Build content
	 */
	var key = this._getProfileKey ();
	
	if ( key != this._currentProfileKey ) {
		this.disposeContent ();
		this.constructContent ();
		this._currentProfileKey = key;
	}
	
	this._setupClipboardItems ();
	this._setupRefreshItem ();
	
	/*
	 * Show.
	 */
	SystemTreePopupBinding.superclass.show.call ( this );
}

/**
 * Setup clipboard operation menuitems.
 */
SystemTreePopupBinding.prototype._setupClipboardItems = function () {
	
	var cut = this.getMenuItemForCommand ( SystemTreePopupBinding.CMD_CUT );
	var copy = this.getMenuItemForCommand ( SystemTreePopupBinding.CMD_COPY );
	var paste = this.getMenuItemForCommand ( SystemTreePopupBinding.CMD_PASTE );
	
	cut.setDisabled ( !SystemTreePopupBinding.isCutAllowed );
	copy.setDisabled ( !SystemTreePopupBinding.isCutAllowed );
	paste.setDisabled ( SystemTreeBinding.clipboard == null );
}

/**
 * Disable refresh on ghosted nodes.
 */
SystemTreePopupBinding.prototype._setupRefreshItem = function () {

	var refresh = this.getMenuItemForCommand ( SystemTreePopupBinding.CMD_REFRESH );
	refresh.setDisabled ( !SystemTreePopupBinding.isRefreshAllowed );
}

/**
 * @implements {IActionListener}
 * @overloads {PopupBinding#handleAction}
 * @param {Action} action
 */
SystemTreePopupBinding.prototype.handleAction = function ( action ) {

	SystemTreePopupBinding.superclass.handleAction.call ( this, action )

	switch ( action.type ) {
	
		/*
		 * Note to self: The first part is duplicated by SystemToolBarBinding!
		 */
		case MenuItemBinding.ACTION_COMMAND :
			var menuitemBinding = action.target;
			var systemAction = menuitemBinding.associatedSystemAction;
			if ( systemAction ) {
				var list = ExplorerBinding.getFocusedTreeNodeBindings ();
				if ( list.hasEntries ()) {
					var treeNodeBinding = list.getFirst ();
					var systemNode = treeNodeBinding.node;
				}
				SystemAction.invoke ( systemAction, systemNode );
			} else {
				var cmd = menuitemBinding.getProperty ( "cmd" );
				if ( cmd ) {
					this._handleCommand ( cmd );
				}
			}
			break;
	}
}

/**
 * Handle command.
 * @param {string} cmd
 */
SystemTreePopupBinding.prototype._handleCommand = function ( cmd ) {
	
	var broadcast = null;
	
	switch ( cmd ) {
		case SystemTreePopupBinding.CMD_CUT :
			broadcast = BroadcastMessages.SYSTEMTREEBINDING_CUT;
			break;
		case SystemTreePopupBinding.CMD_COPY :
			broadcast = BroadcastMessages.SYSTEMTREEBINDING_COPY;
			break;
		case SystemTreePopupBinding.CMD_PASTE :
			broadcast = BroadcastMessages.SYSTEMTREEBINDING_PASTE;
			break;
		case SystemTreePopupBinding.CMD_REFRESH :
			broadcast = BroadcastMessages.SYSTEMTREEBINDING_REFRESH;
			break;
	}
	
	if ( broadcast ) { // allows the popup to close
		setTimeout ( function () {
			EventBroadcaster.broadcast ( broadcast );
		}, 0 );
	}
}

/**
 * Dispose content; except clipboardoperations.
 */
SystemTreePopupBinding.prototype.disposeContent = function () {

	var members = new List ( 
		DOMUtil.getElementsByTagName ( this.bindingElement, "menugroup" )
	);
	while ( members.hasNext ()) {
		var binding = UserInterface.getBinding ( members.getNext ());
		if ( !binding.getProperty ( "rel" )) {
			binding.dispose ();
		}
	}
}

/**
 * Construct content.
 */
SystemTreePopupBinding.prototype.constructContent = function () {
	
	if ( this._actionProfile != null ) {
		
		var doc = this.bindingDocument;
		var groups = new List ();
		var self = this;
		
		this._actionProfile.each ( function ( group, list ) {
			var groupBinding = MenuGroupBinding.newInstance ( doc );
			list.each ( function ( action ) {
				var menuItemBinding = self.getMenuItemBinding ( action );
				groupBinding.add ( menuItemBinding );
			});
			groups.add ( groupBinding );
		});
		
		/*
		 * Build in reverse order, so that clipboardoperations appear last.
		 * Remember that clipboard menuitems has been hardcoded into menu.
		 */
		groups.reverse ();
		while ( groups.hasNext ()) {
			this._bodyBinding.addFirst ( groups.getNext ());
		}
		this._bodyBinding.attachRecursive ();
	}
}

/**
 * @see {NavigatorToolBarBinding#getToolBarButtonBinding}
 * @param {SystemAction} action
 * @return {MenuItemBinding}
 */
SystemTreePopupBinding.prototype.getMenuItemBinding = function ( action ) {
	
	var binding 	= MenuItemBinding.newInstance ( this.bindingDocument );
	var label 		= action.getLabel ();
	var tooltip		= action.getToolTip ();
	var image 		= action.getImage ();
	var ximage		= action.getDisabledImage ();
	var isCheckbox	= action.isCheckBox ();
	
	if ( label ) {
		binding.setLabel ( label );
	}
	if ( tooltip ) {
		binding.setToolTip ( tooltip );
	}
	if ( image ) {
		binding.imageProfile = new ImageProfile ({ 
			image : image,
			imageDisabled : ximage
		});
	}
	if ( isCheckbox ) {
		binding.setType ( MenuItemBinding.TYPE_CHECKBOX );
		if ( action.isChecked ()) {
			binding.check ( true );
		}
	}
	if ( action.isDisabled ()) {
		binding.disable ();
	}
	
	/*
	 * Stamp the action as a property on the menuitem
	 * so that we can retrieve it when the item is clicked.
	 */
	binding.associatedSystemAction = action;

	return binding;
}

/**
 * @overwrites {PopupBinding#snapToMouse}
 * @param {MouseEvent} e
 */
SystemTreePopupBinding.prototype.snapToMouse = function ( e ) {

	var node = e.target ? e.target : e.srcElement;
	var name = DOMUtil.getLocalName ( node );
	var binding = null;
	
	if ( name != "tree" ) {
		switch ( name ) {
			case "treenode" :
				// visually empty space - this should not open the popup!
				break;
			default :
				node = DOMUtil.getAncestorByLocalName ( "treenode", node );
				if ( node != null ) {
					binding = UserInterface.getBinding ( node );
					if ( binding.isDisabled ) { // no contextmenu for disabled treenodes
						binding = null;
					}
				}
				break;
		}
		if ( binding != null && binding.node != null && binding.node.getActionProfile () != null ) {
			
			/*
			 * This timeout will allow a right-click to focus the treenode, 
			 * triggering a NEW action profile publish, before we show the menu.
			 * OOPS: Internet Explorer looses track of the e argument... what to do?
			 *
			var self = this;
			setTimeout ( function () {
				SystemTreePopupBinding.superclass.snapToMouse.call ( self, e );
			}, 0 );
			*/
			
			SystemTreePopupBinding.superclass.snapToMouse.call ( this, e );
		}
	}
}


SystemTreeNodeBinding.prototype = new TreeNodeBinding;
SystemTreeNodeBinding.prototype.constructor = SystemTreeNodeBinding;
SystemTreeNodeBinding.superclass = TreeNodeBinding.prototype;

SystemTreeNodeBinding.ACTION_REFRESHED = "systemtreenoderefreshed";
SystemTreeNodeBinding.ACTION_REFRESHED_YEAH = "systemtreenoderefreshedyeah!";

/**
 * Max imported treenodes per request.
 * TODO: Implement this for real.
 * @type {int}
 */
SystemTreeNodeBinding.MAX_CHILD_IMPORT = 10000; /* because not implemented! */

/**
 * @extends {TreeNodeBinding}
 */
function SystemTreeNodeBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SystemTreeNodeBinding" );
	
	/**
	 * Associates the treenode to the selected perspective.
	 * @type {SystemNode}
	 */
	this.perspectiveNode = null;
	
	/**
	 * Flipped when the server opens the treenode.
	 * @type {boolean}
	 */
	this._isForcedOpen = false;
	
	/**
	 * @type {SystemNode}
	 */
	this.node = null;
}

/**
 * @overloads {TreeNodeBinding#onBindingAttach}
 */
SystemTreeNodeBinding.prototype.onBindingAttach = function () {
	
	this.addActionListener ( SystemTreeNodeBinding.ACTION_REFRESHED );
	this.subscribe ( BroadcastMessages.SYSTEMTREENODEBINDING_FORCE_OPEN );
	
	/*
	 * Is container?
	 *
	this.isContainer = this.node.hasChildren ();
	*/
	
	/*
	 * Is disabled?
	 */
	this.isDisabled = this.node.isDisabled ();
	
	/*
	 * Label.
	 */
	var label = this.node.getLabel ();
	if ( label ) {
		this.setLabel ( label );
	}
	
	/*
	 * Tooltip.
	 */
	var toolTip = this.node.getToolTip ();
	if ( toolTip ) {
		this.setToolTip ( toolTip );
	}
	
	/*
	 * Handle.
	 */
	var handle = this.node.getHandle ();
	if ( handle ) {
		this.setHandle ( handle );
	}
	
	/*
	 * Drag type and other stuff. All key-value pairs in the 
	 * propertybag object is assigned to element as attributes. 
	 */
	var bag = this.node.getPropertyBag ();
	if ( bag ) {
		for ( var key in bag ) {
			switch ( key.toLowerCase ()) {
				case "id" :
				case "key" :
					throw new Error ( "Illegal propertybag key: " + key );
					break;
				default :
					this.setProperty ( key, bag [ key ]);
					break;
			}
		}
	}
	
	/*
	 * Invoke super method.
	 */
	SystemTreeNodeBinding.superclass.onBindingAttach.call ( this );
	
	/*
	 * A sudden perspective awareness.
	 */
	this.perspectiveNode = this.containingTreeBinding.perspectiveNode;
}

/**
 * Initialize drag and drop.
 * @overloads {Binding#_initializeBindingDragAndDropFeatures}
 */
SystemTreeNodeBinding.prototype._initializeBindingDragAndDropFeatures = function () {
	
	// Drag type.
	if ( this.node.hasDragType ()) {
		this.setProperty ( 
			"dragtype", 
			this.node.getDragType ()
		);
	}
	
	// Drag accept.
	if ( this.node.hasDragAccept ()) {
		var dragaccept = "";
		var list = this.node.getDragAccept ();
		while ( list.hasNext ()) {
			dragaccept += list.getNext ();
			if ( list.hasNext ()) {
				dragaccept += " ";	
			}
		}
		this.setProperty ( 
			"dragaccept", 
			dragaccept
		);
	}
	
	SystemTreeNodeBinding.superclass._initializeBindingDragAndDropFeatures.call ( this );
}

/**
 * @implements {IActionListener}
 * @overloads {TreeNodeBinding#handleAction}
 * @param {Action} action
 */
SystemTreeNodeBinding.prototype.handleAction = function ( action ) {
	
	SystemTreeNodeBinding.superclass.handleAction.call ( this, action );
	
	switch ( action.type ) {
		
		/*
		 * TODO: consider this!..............................................
		 */	
		case SystemTreeNodeBinding.ACTION_REFRESHED :
			if ( action.target == this ) { // TODO: specifically this .......
				if ( !this.isOpen ) {
					this.hasBeenOpened = false;
					action.consume ();
				}
			}
			break;
	}
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
SystemTreeNodeBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	SystemTreeNodeBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		case BroadcastMessages.SYSTEMTREENODEBINDING_FORCE_OPEN :
			if ( arg == this.node.getEntityToken ()) {
				if ( this.isContainer && !this.isOpen ) {
					
					/*
					 * Mark as forced opening.
					 */
					this._isForcedOpen = true;
					EventBroadcaster.broadcast ( BroadcastMessages.SYSTEMTREENODEBINDING_FORCING_OPEN, this );
					
					/*
					 * Push to next thread in order to give MessageQueue a chance 
					 * to detect whether or not any nodes are actually opening 
					 * (because if not, it needs to execute the next action now). 
					 */
					var self = this;
					setTimeout ( function () {
						self.open ();
					}, 0 );
				}
			}
			break;
	}
}
 
/**
 * The imageprofile is provided by the SystemNode assigned to this treenode.
 * @overwrites {TreeNodeBinding#_computeImageProfile}
 */
SystemTreeNodeBinding.prototype._computeImageProfile = function () {}

/**
 * Overloading {@link TreeNodeBinding#computeImage}
 * @return {string}
 */
SystemTreeNodeBinding.prototype.computeImage = function () {
	
	var result = null;
	var profile = this.node.getImageProfile ();
	if ( profile ) {
		if ( this.isOpen ) {
			result = profile.getActiveImage ();
		} else {
			result = profile.getDefaultImage ();
		}
	}
	if ( !result ) {
		result = SystemTreeNodeBinding.superclass.computeImage.call ( this );
	}
	return result;
}

/**
 * Refresh when opened.
 * @overloads {TreeNodeBinding#open}
 * @param {boolean} isManaged If set to true, the tree will not refresh!
 */
SystemTreeNodeBinding.prototype.open = function ( isManaged ) {
	
	var wasOpened = this.isContainer && !this.isOpen;
	var wasFresh = !this.hasBeenOpened;
	
	SystemTreeNodeBinding.superclass.open.call ( this );
	
	if ( wasOpened && ( wasFresh || SystemTreeBinding.HAS_NO_MEMORY ) && isManaged != true ) {
		
		/*
		 * Fetch subtree from server.
		 */
		this.refresh ();
		
		/*
		 * If forced open by server, notify the waiting MessageQueue.
		 */
		if ( this._isForcedOpen ) {
			EventBroadcaster.broadcast ( BroadcastMessages.SYSTEMTREENODEBINDING_FORCED_OPEN, this );
			this._isForcedOpen = false;
		}
	}		
}

/**
 * Refreshing treenode content. This method is never executed for nodes 
 * with !HasChildren. Method can be invoked as part of treenode opening 
 * act, or when the server places a refresh signal on the MessageQueue.
 */
SystemTreeNodeBinding.prototype.refresh = function () {

	// descendant treenodes already opened?
	var branch = null;
	if ( this.isContainer ) {
		branch = this.getOpenSystemNodes ();
	}
	
	/*
	 * Begin refresh...
	 */
	this.isRefreshing = true;
	Application.lock ( this );
	StatusBar.busy ();
	
	/*
	 * We timeout to lock the GUI while tree 
	 * is refreshed; this can take some time. 
	 */
	var self = this;
	setTimeout ( function () {
		if ( Binding.exists ( self )) {
			self._performRefresh ( branch );
			Application.unlock ( self );
			StatusBar.clear ();
		}
	}, 0 );
}

/**
 * Perform refresh (isolated so that we can invoke on a timeout).
 * @param {List<SystemNode>} branch
 */
SystemTreeNodeBinding.prototype._performRefresh = function ( branch ) {
	
	//this.empty ();
	if ( branch != null ) {
		this._refreshBranch ( branch );
	} else {
		this._refreshChildren ();
	}
	
	this.isRefreshing = false;
	
	/*
	 * TODO: this is hacked! The ISCONTAINER state should be determined by the server!
	 */
	this.isContainer = DOMUtil.getElementsByTagName ( this.bindingElement, "treenode" ).item ( 0 ) != null;
	this.updateClassNames ();
	
	/*
	 * This will force any closed ancestor treenode to refresh when opened.
	 * The action will be consumed by ancestor, so we need to dispatch yet 
	 * another action.
	 */
	this.dispatchAction ( SystemTreeNodeBinding.ACTION_REFRESHED );
	
	/*
	 * This will inform the tree the we are finished, 
	 * which in turn will inform the MessageQueue. 
	 * TODO: Only on a MessageQueue-refresh?
	 */
	this.dispatchAction ( SystemTreeNodeBinding.ACTION_REFRESHED_YEAH );
}

/**
 * Import children only.
 */
SystemTreeNodeBinding.prototype._refreshChildren = function () {
	
	var buffer = new List ();
	var children = this.node.getChildren ();
	this.empty ();
	if ( children.hasEntries ()) {
		this._insertTreeNodesRegulated ( children );
	}
}

/**
 * Insert treenodes from a list of SystemNodes.
 * @param {List<SystemNode>} children
 */
SystemTreeNodeBinding.prototype._insertTreeNodesRegulated = function ( children ) {

	var count = 0;
		
	/*
	 * Constantly shortening the children list while 
	 * inserting treenodes. This will let us store 
	 * the remaining list in a buffer when max count 
	 * is reached.
	 */
	while ( children.hasEntries () && count <= SystemTreeNodeBinding.MAX_CHILD_IMPORT ) {
		var treenode = SystemTreeNodeBinding.newInstance ( 
			children.extractFirst (), 
			this.bindingDocument 
		);
		this.add ( treenode );
		treenode.attach ();
		count ++;
	}
	if ( children.hasEntries ()) {
		this._insertBufferTreeNode ( children );
	}
}

/**
 * Insert buffer node. This will expand to a number of treenodes when navigated.
 * @param {List<SystemNode>} children
 */
SystemTreeNodeBinding.prototype._insertBufferTreeNode = function ( children ) {
	
	alert ( "Max treenode count reached. This is not handled!" );
	alert ( "TODO: SystemTreeNodeBinding#._insertBufferTreeNode" );
}

/**
 * Import descendants with open parents. This is not regulated!
 * @param {List<SystemNode>} list A list of open SystemNodes...
 */
SystemTreeNodeBinding.prototype._refreshBranch = function ( list ) {
	
	var branch = this.node.getDescendantBranch ( list );
	if ( branch.hasEntries ()) {
		this.XXX ( branch );
	}
}

/**
 * TODO: Rename this!
 * @param {List<SystemNode>} branch
 */
SystemTreeNodeBinding.prototype.XXX = function ( branch ) {
	
	var self = this;
	var map = new Map ();
	
	/*
	 * Note that the parsed branch may have "holes" in the structure. This implies 
	 * that not all may be positioned in the tree. Also note that this is NOT 
	 * regulated according to max child import restrictions!
	 */	
	this.empty ();
	branch.each ( function ( key, nodes ) {
		if ( nodes.hasEntries ()) {
			nodes.each ( function ( node ) {
				var treenode = SystemTreeNodeBinding.newInstance ( node, self.bindingDocument );
				map.set ( node.getHandle (), treenode );
				if ( map.has ( key )) {
					var parent = map.get ( key );
					parent.add ( treenode );
					parent.isOpen = true;
					parent.hasBeenOpened = true;
				} else if ( key == self.node.getHandle ()) {
					self.add ( treenode );
				} else {
					/*
					 * Now there is a hole in the structure and the 
					 * SystemNode has no relevance in this context. 
					 * Maybe it was moved somewhere (cut paste scenario).
					 */
				}
			});
		}
	});
	
	this.attachRecursive ();
	branch.dispose ();
	map.dispose ();
}

/**
 * Get open descendants.
 * @list {List<SystemTreeNode>}
 */
SystemTreeNodeBinding.prototype.getOpenDescendants = function () {
	
	var crawler = new TreeCrawler ();
	var result = new List ();
	crawler.mode = TreeCrawler.MODE_GETOPEN;
	crawler.crawl ( this.bindingElement, result );
	if ( result.hasEntries ()) { // exclude myself!
		result.extractFirst ();
	}
	crawler.dispose ();
	return result;
}

/**
 * Get the list of SystemNodes from all descandants. Including 
 * myself in the result because the server needs to know me.
 * @list {List<SystemNode>}
 */
SystemTreeNodeBinding.prototype.getOpenSystemNodes = function () {
	
	var result = null;
	var list = this.getOpenDescendants ();
	
	if ( list.hasEntries ()) {
		result = new List ([ this.node ]); // include myself!
		list.each ( function ( treenode ) {
			result.add ( treenode.node );
		});
	}
	return result;
}

/**
 * Small trick to ensure that the treenode twisty will not 
 */
SystemTreeNodeBinding.prototype.updateClassNames = function () {
	
	if ( !this.isRefreshing ) {
		SystemTreeNodeBinding.superclass.updateClassNames.call ( this );
	}
}

/**
 * Accept dragged treenode. 
 * @overwrites {TreeNodeBinding#acceptTreeNodeBinding}
 * @param {SystemTreeNodeBinding} binding
 * @param {int} index Optional (omit for drag and drop setup)
 */
SystemTreeNodeBinding.prototype.acceptTreeNodeBinding = function ( binding, index ) {
	
	var isCopy = ( SystemTreeBinding.clipboardOperation == SystemTreePopupBinding.CMD_COPY );
	
	if ( binding instanceof SystemTreeNodeBinding ) {
		if ( TreeService.ExecuteDropElementAction ) {
			TreeService.ExecuteDropElementAction (
				binding.node.getData (),
				this.node.getData (),
				index ? index : this.containingTreeBinding.getDropIndex (),
				Application.CONSOLE_ID,
				isCopy
			);
		}
	}
}

/**
 * Broadcast entityToken on focus to support the "lock tree to editor" feature.
 * @overloads {TreeNodeBinding#invokeManagedFocus}
 */
SystemTreeNodeBinding.prototype.invokeManagedFocus = function ( e ) {
	
	if ( !this.isFocused ) {
		SystemTreeNodeBinding.superclass.invokeManagedFocus.call ( this );
		
		/*
		 * This broadcast is intercepted by the DockBinding  
		 * who then decides which corresponding tab to select.
		 * @see {DockBinding#handleBroadcast}
		 */
		var tree = this.containingTreeBinding;
		if ( tree.isLockedToEditor && !tree.isLockFeatureFocus ) {
			EventBroadcaster.broadcast ( 
				BroadcastMessages.SYSTEMTREENODEBINDING_FOCUS, 
				this
			);
		}
	}
}

/**
 * Has children?
 * @overwrites {TreeNodeBinding#hasChildren}
 * @return {boolean}
 */
SystemTreeNodeBinding.prototype.hasChildren = function () {
	
	return this.node.hasChildren ();
};

/**
 * SystemTreeNodeBinding factory. Notice that we supply a {@link SystemNode} as argument here!
 * @param {SystemNode} node
 * @param {DOMDocument} ownerDocument
 * @return {SystemTreeNodeBinding}
 */
SystemTreeNodeBinding.newInstance = function ( node, ownerDocument ) {

	var treenode = DOMUtil.createElementNS ( Constants.NS_UI, "ui:treenode", ownerDocument );
	var binding = UserInterface.registerBinding ( treenode, SystemTreeNodeBinding );
	binding.node = node;
	return binding;
}

SystemPageBinding.prototype = new PageBinding;
SystemPageBinding.prototype.constructor = SystemPageBinding;
SystemPageBinding.superclass = PageBinding.prototype;

/**
 * @class
 * This fellow runs a simple view on a system tree.
 */
function SystemPageBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SystemPageBinding" );
	
	/**
	 * Supplied as page argument.
	 * @type {SystemNode}
	 */
	this.node = null;
	
	/**
	 * @type {SystemTree}
	 */
	this._tree = null;
}

/**
 * Identifies binding.
 */
SystemPageBinding.prototype.toString = function () {
	
	return "[SystemPageBinding]";
}

/**
 * @overloads {PageBinding#onBindingRegister}
 */
SystemPageBinding.prototype.onBindingRegister = function () {
	
	SystemPageBinding.superclass.onBindingRegister.call ( this );
	this.subscribe ( BroadcastMessages.SYSTEMTREEBINDING_REFRESH );
	this.addActionListener ( ButtonBinding.ACTION_COMMAND );
}

/**
 * @overloads {PageBinding#setPageArgument}
 * @param {SystemNode} systemNode
 */
SystemPageBinding.prototype.setPageArgument = function ( systemNode ) {
	
	this.node = systemNode;
	SystemPageBinding.superclass.setPageArgument.call ( this, systemNode );
}

/**
 * @overloads {PageBinding#onBeforePageInitialize}
 */
SystemPageBinding.prototype.onBeforePageInitialize = function () {

	if ( this.node ) {
		this._tree = this.bindingWindow.bindingMap.tree;
		if ( this._tree ) {
			this._buildTree ();
		} else {
			throw "SystemPageBinding requires a SystemTreeBinding";
		}
	} else {
		throw "SystemPageBinding requires a SystemNode";
	}
	
	SystemPageBinding.superclass.onBeforePageInitialize.call ( this );
}

/**
 * Build tree.
 */
SystemPageBinding.prototype._buildTree = function () {

	var children = this.node.getChildren ();
	if ( children.hasEntries ()) {
		while ( children.hasNext ()) {
			var node = SystemTreeNodeBinding.newInstance ( 
				children.getNext (), 
				this.bindingDocument 
			)
			this._tree.add ( node ); 
			node.attach ();
		}
	}
}

/**
 * Refresh tree.
 */
SystemPageBinding.prototype._refreshTree = function () {
	
	/* 
	 * Preopen non-container root nodes. That aint right, 
	 * but they will get replaced by fresh nodes anyway. 
	 * This will let the user see a newly added treenode 
	 * without opening container, at least at root level.
	 */
	var roots = this._tree._treeBodyBinding.getChildBindingsByLocalName ( "treenode" );
	roots.each ( function ( root ) {
		if ( !root.isContainer ) {
			root.isOpen = true;
		}
	});
	
	
	// Collect open treenodes.
	var crawler = new TreeCrawler ();
	var opens = new List ();
	crawler.mode = TreeCrawler.MODE_GETOPEN;
	crawler.crawl ( this.bindingElement, opens );
	crawler.dispose ();
	
	// Extract open SystemNodes.
	var list = new List ([ this.node ]);
	opens.each ( function ( treenode ) {
		list.add ( treenode.node );
	});
	
	// Empty tree and build new.
	this._tree.empty ();
	var branch = this.node.getDescendantBranch ( list );

	if ( branch.hasEntries ()) {
	
		var self = this;
		var map = new Map ();
		
		/*
		 * Note that this is basically a copy-paste 
		 * of some stoff going on in SystemTreeNode.
		 */
		branch.each ( function ( key, nodes ) {
			nodes.each ( function ( node ) {
				
				var treenode = SystemTreeNodeBinding.newInstance ( node, self.bindingDocument );
				map.set ( node.getHandle (), treenode );
				if ( map.has ( key )) {
					var parent = map.get ( key );
					parent.add ( treenode );
					parent.isOpen = true;
				} else if ( key == self.node.getHandle ()) {
					self._tree.add ( treenode );
				}
			});
		});
		
		this._tree.attachRecursive ();
	}
}

/**
 * Executed when the page is shown. Select first treenode.
 */
SystemPageBinding.prototype.onAfterPageInitialize = function () {
	
	SystemPageBinding.superclass.onAfterPageInitialize.call ( this );
	this._tree.selectDefault ();
}

/**
 * @implements {IActionListener}
 * @overloads {PageBinding#handleAction}
 * @param {Action} action
 */
SystemPageBinding.prototype.handleAction = function ( action ) {
	
	SystemPageBinding.superclass.handleAction.call ( this, action )
	
	switch ( action.type ) {
		case ButtonBinding.ACTION_COMMAND :
			var button = action.target; 
			switch ( button.getID ()) {
				case "locktreebutton" :
					this._tree.setLockToEditor ( button.isChecked );
					break;
				case "collapsebutton" :
					this._tree.collapse ();
					break;
			}
			break;
	}
}

/**
 * Implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
SystemPageBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	SystemPageBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	/*
	 * This is basically a copy of the procedure instiaged 
	 * at SystemTreeNodeBinding method "refresh".
	 */
	switch ( broadcast ) {
		case BroadcastMessages.SYSTEMTREEBINDING_REFRESH :
		
			var token = arg;
			if ( this.node && this.node.getEntityToken () == token ) {
				try {
					EventBroadcaster.broadcast ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHING, token );
					var self = this;
					Application.lock ( this );
					setTimeout ( function () {
						self._refreshTree ();
						EventBroadcaster.broadcast ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHED, token );
						Application.unlock ( self );
					}, 0 );
				} catch ( exception ) {
					alert ( exception );
					SystemDebug.stack ( arguments );
				}
			}
			break;
	}
}

StageContainerBinding.prototype = new FlexBoxBinding;
StageContainerBinding.prototype.constructor = StageContainerBinding;
StageContainerBinding.superclass = FlexBoxBinding.prototype;

/**
 * @class
 * The stagecontainer is simply setup to flex all descendant bindings 
 * (including bindings in descendant iframes) when the window is resized.
 * The really interesting stuff can be found in the {@link StageBinding}
 */
function StageContainerBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "StageContainerBinding" );
}

/**
 * Identifies binding.
 */
StageContainerBinding.prototype.toString = function () {

	return "[StageContainerBinding]";
}

/**
 * Overloads {Binding#onBindingAttach}
 */
StageContainerBinding.prototype.onBindingAttach = function () {
	
	StageContainerBinding.superclass.onBindingAttach.call ( this );
	this.subscribe ( BroadcastMessages.APPLICATION_OPERATIONAL );
}

/** 
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
StageContainerBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	StageContainerBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	var winmanager = this.bindingWindow.WindowManager;
	
	switch ( broadcast ) {
		
		/*
		 * Flex on startup.
		 */
		case BroadcastMessages.APPLICATION_OPERATIONAL :
			this.subscribe ( winmanager.WINDOW_RESIZED_BROADCAST );
			this._fit ();
			this.reflex ();
			break;
			
		/*
		 * Flex on window resize.
		 */
		case winmanager.WINDOW_RESIZED_BROADCAST :		
			
			/*
			 * Explorer is slow, so for IE we lock the layout in    
			 * order to discourage UI interaction while resizing. 
			 */
			if ( Client.isMozilla == true ) {
				this._fit ();
				this.reflex ();
			} else {
				Application.lock ( this );
				var self = this;
				setTimeout ( function () {
					self._fit ();
					self.reflex ();
					Application.unlock ( self );
				}, 0 );
			}
			break;
	}
}

/**
 * Fit stage to window width. Doing this by   
 * script in order to tighten up the layout. 
 */
StageContainerBinding.prototype._fit = function () {
	
	var winmanager = this.bindingWindow.WindowManager;
	this.bindingElement.style.width = winmanager.getWindowDimensions ().w + "px";
}

StageBinding.prototype = new FocusBinding;
StageBinding.prototype.constructor = StageBinding;
StageBinding.superclass = FocusBinding.prototype;

/**
 * Static reference to the single StageBinding instance. Assigned on startup.
 * @type {StageBinding}
 */
StageBinding.bindingInstance = null;

/**
 * The {@link SystemNode} hat build the currently selected perspective.
 * Updated by method {@link StageDecksBinding#setSelectionByHandle} 
 * @type {SystemNode}
 */
StageBinding.perspectiveNode = null;

/**
 * The serializedEntityToken associated to the {@link DockTabBinding} 
 * that is selected AND activated on the current perspective. May be null.
 * Updated by method {@link DockTabBinding#_updateGlobalEntityToken}
 * @type {string}
 */
StageBinding.entityToken = null;

/**
 * Hide OR show a ViewDefinition on stage (dependant on its current status).
 * @param {string} handle
 */
StageBinding.handleViewPresentation = function ( handle ) {

	if ( StageBinding.isViewOpen ( handle )) {
		EventBroadcaster.broadcast ( BroadcastMessages.CLOSE_VIEW, handle );
	} else {
		var definition = ViewDefinitions [ handle ];
		StageBinding.presentViewDefinition ( definition );
	}
}

/**
 * Is view open?
 * @param {string} handle
 */
StageBinding.isViewOpen = function ( handle ) {
	
	return StageBinding.bindingInstance._activeViewDefinitions [ handle ] != null;
}

/**
 * Present ViewDefinition on stage.
 * @param {ViewDefinition} definition
 */
StageBinding.presentViewDefinition = function ( definition ) {
	
	if ( definition.label != null ) {
		var string = StringBundle.getString ( "ui", "Website.App.StatusBar.Opening" );
		StatusBar.busy ( string, [ definition.label ]);
	} else {
		StatusBar.busy ();
	}
	StageBinding.bindingInstance._presentViewDefinition ( definition );
}

/**
 * @class
 */
function StageBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "StageBinding" );

	/**
	 * Associating handles to presently active viewDefinitions.
	 * @type {HashMap<string><ViewDefinition>}
	 * @private
	 */
	this._activeViewDefinitions = {};

	/**
	 * @type {StageDecksBinding}
	 * @private
	 */
	this._decksBinding = null;
	
	/**
	 * @type {ExplorerBinding}
	 * @private
	 */
	this._explorerBinding = null;
	
	/**
	 * Flipped when both explorer and decks are loaded. 
	 * @type {boolean}
	 */
	this._isStageReady = false;
	
	/**
	 * Flipped when a "page" is loaded in {@link ExplorerBinding}. 
	 * @type {boolean}
	 */
	this._isExplorerReady = false;
	
	/**
	 * Flipped when a deck is loaded in the {@link StageDecksBinding}. 
	 * @type {boolean}
	 */
	this._isDecksReady = false;
	
	/**
	 * Indexing system docks by reference property.
	 * @type {Map<string><DockBinding>}
	 */
	this._dockBindings = new Map ();
	
	/**
	 * True when Start screen is visible.
	 * @type {boolean}
	 */
	this._isShowingStart = false;
	
	/**
	 * True when default start stuff is visible.
	 * @type {boolean}
	 */
	this._isShowingDefaultStart = false;
	
	/**
	 * Makes no sense to handle activation in the app root.
	 * @implements {IActivationAware}
	 * @overwrites {FocusBinding#isActivationAware}
	 * @type {boolean}
	 */
	this.isActivationAware = false;
	
	/* 
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
StageBinding.prototype.toString = function () {

	return "[StageBinding]";
}



// INITIALIZATION ................................................................

/**
 * Notice that we are simulating a {@link StageBoxHandlerAbstraction} in 
 * the inheritance chain. That's because the {@link StageDeckBinding} is 
 * interested in some of these functionalities as well.
 * Overloads {FlexBoxBinding#onBindingRegister}
 */
StageBinding.prototype.onBindingRegister = function () {
	
	StageBinding.superclass.onBindingRegister.call ( this );
	StageBinding.bindingInstance = this;
	
	/*
	 * This will add action listeners for:
	 * ControlBoxBinding.ACTION_MAXIMIZE
	 * ControlBoxBinding.ACTION_NORMALIZE
	 * StageBoxAbstraction.ACTION_HIDDENSTUFF_UPDATED
	 * StageSplitPanelBinding.ACTION_LAYOUTUPDATE
	 */
	StageBoxHandlerAbstraction.onBindingRegister.call ( this );
	
	/*
	 * Attach action listeners.
	 */
	this.addActionListener ( ExplorerBinding.ACTION_INITIALIZED );
	this.addActionListener ( StageDecksBinding.ACTION_INITIALIZED );
	this.addActionListener ( ExplorerMenuBinding.ACTION_SELECTIONCHANGED );
	this.addActionListener ( TabBoxBinding.ACTION_ATTACHED );
	this.addActionListener ( TabBoxBinding.ACTION_SELECTED );
	this.addActionListener ( WindowBinding.ACTION_LOADED );
	this.addActionListener ( ExplorerBinding.ACTION_DECK_LOADED );
	this.addActionListener ( StageDeckBinding.ACTION_LOADED );
	this.addActionListener ( ErrorBinding.ACTION_INITIALIZE );
	
	/*
	 * File EventBroadcaster subscriptions.
	 */
	this.subscribe ( BroadcastMessages.VIEW_CLOSED );
	this.subscribe ( BroadcastMessages.VIEW_OPENED );
	this.subscribe ( BroadcastMessages.COMPOSITE_START );
	this.subscribe ( BroadcastMessages.COMPOSITE_STOP );
	this.subscribe ( BroadcastMessages.DOCK_MAXIMIZED );
	this.subscribe ( BroadcastMessages.DOCK_NORMALIZED );
	
	/*
	 * Initialize root actions.
	 */
	var root = System.getRootNode ();
	this._initializeRootActions ( root );
	
	/*
	 * Hookup root refresh. The broadcast is intercepted by ExplorerDeckBinding. 
	 * The associated tree is refreshed when deck gets selected.
	 */
	EventBroadcaster.subscribe ( BroadcastMessages.SYSTEMTREEBINDING_REFRESH, {
		handleBroadcast : function ( broadcast, arg ) {
			if ( arg == root.getEntityToken ()) {
				EventBroadcaster.broadcast ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHALL );
			}
		}
	})
	
	/*
	 * Initialize perspectives (they may not be available for new user with no rights).
	 */
	var perspectives = System.getPerspectiveNodes ();
	if ( perspectives.hasEntries ()) {
		this._initializeSystemViewDefinitions ( perspectives );
	} else {
		top.app.bindingMap.stagecontainer.hide ();
		this._onStageReady ();
		Dialog.message ( 
			StringBundle.getString ( "ui", "Website.Dialogs.NoAccessTitle" ), 
			StringBundle.getString ( "ui", "Website.Dialogs.NoAccessText" )
		);
	}
	
	/*
	var self = this;
	setTimeout ( function () {
		var dock = self._toolDockBinding;
		var tab = UserInterface.getBinding ( dock.getTabElements().get ( 0 ));
		//self._editorDockBinding.importTabBinding ( tab );
		//tab  = UserInterface.getBinding ( document.getElementById ( "temp" ));
		//self._editorDockBinding.importTabBinding ( tab );
		//document.getElementById ( "john" ).appendChild ( document.getElementById ( "aage" ));
		
	}, 3500 );
	*/
}

/**
 * Fires when both members - ExplorerBinding and StageDecksBinding - are initialized. 
 * When no Flash is installed, the workbench is ready to be initialized right now. 
 * Otherwise we wait for the {@link LocalStore} to report readystate.
 */
StageBinding.prototype._renameThisMethod = function () {
	
	if ( LocalStore.isInitialized ) {
		this._initializeWorkbenchLayout ();
	} else {
		var self = this;
		EventBroadcaster.subscribe ( 
			BroadcastMessages.LOCALSTORE_INITIALIZED, {
				handleBroadcast : function () {
					self._initializeWorkbenchLayout ();
				}
			}
		);
	}
}

/**
 * Initialize workbench layout.
 */
StageBinding.prototype._initializeWorkbenchLayout = function () {
	
	/**
	 * If LocalStore is operative, attempt to default select last edited perspective.
	 */
	if ( this._explorerBinding ) {
		var persistedHandle = null;
		if ( LocalStore.isEnabled ) {
			persistedHandle = LocalStore.getProperty ( 
				LocalStore.SELECTED_PERSPECTIVE_HANDLE
			);
		}
		if ( persistedHandle && ViewDefinitions [ persistedHandle ]) { // perspective may be gone since last!
			alert ( "StageBinding#_initializeWorkbenchLayout !!!!" );
			this._explorerBinding.setSelectionByHandle ( 
				unescape ( persistedHandle )
			);
		} else {
			this._explorerBinding.setSelectionDefault ();
		}
	} else {
		this._onStageReady ();
	}
}

/**
 * Fires when the stage is ready.
 * TODO: The stage may not nescessarily be interactive here!
 */
StageBinding.prototype._onStageReady = function () {
	
	if ( !this._isStageReady ) {
	
		/*
		 * Broadcasting readystate. If no start 
		 * page, show default start splash. 
		 */	
		if ( !Application.hasStartPage || !Application.hasExternalConnection ) {
			top.app.bindingMap.defaultstartdeck.select ();
			this._isShowingDefaultStart = true;
		}
		EventBroadcaster.broadcast ( BroadcastMessages.STAGE_INITIALIZED );
		this._isStageReady = true;
	}
}

/**
 * Root actions relayed to Tools menu. At least for now...
 * @param {SystemNode} root 
 * @param {List<SystemNode>} perspectives
 */
StageBinding.prototype._initializeRootActions = function ( root ) {

	var actions = root.getActionProfile ();
	
	if ( actions && actions.hasEntries ()) {
		
		/*
		 * The default menugroup 
		 * for root actions.
		 */
		var menugroup = top.app.bindingMap.toolsmenugroup;
		
		if ( menugroup ) {
			actions.each ( function ( groupid, list ) {
				list.each ( function ( action ) {
					
					/*
					 * Build menuitem.
					 */
					var item = MenuItemBinding.newInstance ( menugroup.bindingDocument );
					item.setLabel ( action.getLabel ());
					item.setToolTip ( action.getToolTip ());
					item.setImage ( action.getImage ());
					item.setDisabled ( action.isDisabled ());
					
					/*
					 * Stamp action on menuitem.
					 */
					item.associatedSystemAction = action;
					
					/*
					 * Brialliant hardcoded setup for dispersing  
					 * root actions all over the main menubar.
					 */
					var group = menugroup;
					var tag = action.getTag ();
					if ( tag != null ) {
						switch ( tag ) {
							case SystemAction.TAG_CHANGEFROMLANGUAGE :
								group = top.app.bindingMap.translationsmenugroup;
								break;
						}
					}
					group.add ( item );
				});
			});
			menugroup.attachRecursive (); // TODO: lazy the entire menu!!!
		}
	}
}

/**
 * Initialize SystemViewDefinitions (the tree views!).
 * @param {List<SystemNode>} nodes
 */
StageBinding.prototype._initializeSystemViewDefinitions = function ( nodes ) {
	
	while ( nodes.hasNext ()) {
		var node = nodes.getNext ();
		var handle = node.getHandle ();
		ViewDefinitions [ handle ] = new SystemViewDefinition ( node );
	}
}

// STARTUP ................................................................

/**
 * @implements {IActionListener} 
 * @overloads {FocusBinding#handleAction}
 * @param {Action} action
 */
StageBinding.prototype.handleAction = function ( action ) {
	
	StageBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	
	switch ( action.type ) {
		
		/*
		 * See also next case.
		 */
		case StageDecksBinding.ACTION_INITIALIZED :
			if ( !Application.isOperational ) {
				ProgressBarBinding.notch ( 4 );
			}
			this._decksBinding = binding;
			this._inflateBinding ( binding );
			action.consume ();
			break;
			
		/*
		 * See also previous case.
		 */
		case ExplorerBinding.ACTION_INITIALIZED :
			if ( !Application.isOperational ) {
				ProgressBarBinding.notch ( 4 );
			}
			this._explorerBinding = binding;
			this._inflateBinding ( binding );
			action.consume ();
			break;
			
		case ExplorerMenuBinding.ACTION_SELECTIONCHANGED :
			if ( !Application.isOperational ) {
				ProgressBarBinding.notch ( 5 );
			}
			this.handlePerspectiveChange ( binding );
			action.consume ();
			break;
			
		case TabBoxBinding.ACTION_ATTACHED :
			if ( binding instanceof DockBinding ) {
				switch ( binding.reference ) {
					case DockBinding.START :
					case DockBinding.ABSBOTTOMLEFT :
					case DockBinding.ABSBOTTOMRIGHT :
					case DockBinding.ABSRIGHTTOP :
					case DockBinding.ABSRIGHTBOTTOM :
						this._dockBindings.set ( binding.reference, binding );
						break;
				}
				this.handleAttachedDock ( binding );
				action.consume ();
			}
			break;
			
		case TabBoxBinding.ACTION_SELECTED :
			if ( binding instanceof DockBinding ) {
				this.handleSelectedDockTab ( 
					binding.getSelectedTabBinding ()
				);
				action.consume ();
			}
			break;
			
		case WindowBinding.ACTION_LOADED :
			
			// this should really be handled on a lower level, but in case we forget...
			// this.logger.warn ( "window load intercepted by stage: " + binding.getURL ());
			break;
			
		case ExplorerBinding.ACTION_DECK_LOADED :
			this._isExplorerReady = true;
			if ( this._isDecksReady == true ) {
				if ( !this._isStageReady ) {
					if ( Client.isWebKit ) {
						alert ( "StageBinding 4 WEHEY!" );
					}
					ProgressBarBinding.notch ( 3 );
					this._onStageReady ();
				}
			}
			break;
		
		/**
		 * @see {StageBoxHandlerAbstraction#handleAction}
		 */
		case StageSplitPanelBinding.ACTION_LAYOUTUPDATE :
			
			/*
		 	 * Theoretically, this could be done at a much lower level.
		 	 * This should be considered if panel handling gets too slow.
		 	 * Explorer has some rendering update disabilities, though.
		 	 */
		 	if ( !this._isFlexAbort && Application.isOperational ) {
		 		
		 		this._isFlexAbort = true;
		 		this.reflex ( true );
		 		var self = this;
		 		setTimeout ( function () {
		 			if ( Client.isMozilla == true ) {
		 				self.reflex ( true ); // why?
		 			}
		 			self._isFlexAbort = false;
			 	}, 0 );
			}
			action.consume ();
			break;
			
		case StageDeckBinding.ACTION_LOADED :
			this._isDecksReady = true;
			if ( this._isExplorerReady == true ) {
				if ( !this._isStageReady ) {
					this._onStageReady ();
				}
			}
			break;
		
		/*
		 * The ErrorBinding needs a consumer.
		 */ 
		case ErrorBinding.ACTION_INITIALIZE :
			action.consume ();
			break;
	}
	
	/*
	 * Notice this hack!
	 */
	StageBoxHandlerAbstraction.handleAction.call ( this, action );
}

/**
 * @implements {IBroadcastListener}
 * @param {string} message
 * @param {object} arg
 */
StageBinding.prototype.handleBroadcast = function ( broadcast, arg ) {

	StageBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
	
		case BroadcastMessages.VIEW_OPENED :
			Application.unlock ( this );
			break;
			
		case BroadcastMessages.VIEW_CLOSED :
		 	var handle = arg;
			this._dontView ( handle );
			break;
			
		case BroadcastMessages.COMPOSITE_START :
			this._showStart ( true );
			break;
			
		case BroadcastMessages.COMPOSITE_STOP :
			this._showStart ( false );
			break;
			
		case BroadcastMessages.DOCK_MAXIMIZED :
			this._stabilizeExplorer ();
			if ( this._isShowingStart ) {
				EventBroadcaster.broadcast ( BroadcastMessages.STOP_COMPOSITE );
			}
			break;
		
		case BroadcastMessages.DOCK_NORMALIZED :
			this._stabilizeExplorer ();
			break;
	}
}

/**
 * Explorer may have difficulties computing stage layout 
 * when docks are maximized and normalized. Let's hack it. 
 */
StageBinding.prototype._stabilizeExplorer = function () {
	
	if ( Client.isExplorer == true ) {
		var self = this;
		if  ( Client.isExplorer == true ) {
			setTimeout ( function () {
				self.reflex ( true );
			}, 0 )
		}
	}
}

/**
 * Show start?
 * @param {boolean} isShow
 */
StageBinding.prototype._showStart = function ( isShow ) {

	if ( isShow != this._isShowingStart ) {
		
		var view = ViewBinding.getInstance ( "Composite.Management.Start" );
		var dock = this._dockBindings.get ( DockBinding.START );
		var decks = this.bindingWindow.bindingMap.maindecks;
		
		
		if ( isShow ) {
			decks.select ( "startdeck" );
			view.show ();
		} else {
			view.hide ();
			decks.select ( "stagedeck" );
			if ( dock != null && dock.isActive ) {
				dock.deActivate ();
			}
		}
		
		this._isShowingStart = isShow;
	}
}

/**
 * This will inflate either the {@link ExplorerBinding} or the {@link StageDecksBinding}
 * @param {Binding} binding
 */
StageBinding.prototype._inflateBinding = function ( binding ) {

	for ( var handle in ViewDefinitions ) {
		var definition = ViewDefinitions [ handle ];
		if ( definition instanceof SystemViewDefinition ) {
			binding.mountDefinition ( definition );
		}
	}
	var isReady = ( this._decksBinding && this._explorerBinding ); 
	if ( isReady ) {
		var self = this;
		setTimeout ( function () {
			self._renameThisMethod ();
		}, 0 );
	}
}

/**
 * Iterate stagebox bindings. This method is required by the StageBoxAbstractionHandler.
 * @see {StageBoxHandlerAbstraction#handleControlBoxAction}
 * @param {string} mode
 */
StageBinding.prototype.iterateContainedStageBoxBindings = function ( mode ) {
	
	var crawler = new StageCrawler ();
	crawler.mode = mode;
	crawler.crawl ( this.bindingElement );
	crawler.dispose ();
}

/**
 * Fires when the ExplorerBinding selection changes, selecting associated StageDeckBinding. 
 * @see {ExplorerBinding#handleSelectionChange}
 * @param {ExplorerMenuBinding} explorerMenuBinding
 */
StageBinding.prototype.handlePerspectiveChange = function ( explorerMenuBinding ) {

	var handle = explorerMenuBinding.getSelectionHandle ();
	this._decksBinding.setSelectionByHandle ( handle );
	if ( LocalStore.isEnabled ) {
		LocalStore.setProperty ( 
			LocalStore.SELECTED_PERSPECTIVE_HANDLE, 
			escape ( handle )
		);
	}
}

/**
 * Fires when a DockBinding gets attached during startup.
 * @param {DockBinding} dockBinding
 */
StageBinding.prototype.handleAttachedDock = function ( dockBinding ) {
	
	/*
	 * Initialize open views. Initialization of the 
	 * Start view is dependant on application settings.
	 */
	var tabBindings = dockBinding.getTabBindings ();
	if ( tabBindings.hasEntries ()) {
		while ( tabBindings.hasNext ()) {
			var tabBinding = tabBindings.getNext ();
			var handle = tabBinding.getHandle ();
			if ( handle ) {
				if ( handle == "Composite.Management.Start" && ( !Application.hasStartPage || !Application.hasExternalConnection )) {
					// do nothing - although maybe this check should not be performed here...
				} else {
					var viewDefinition = ViewDefinitions [ handle ];
					if ( viewDefinition ) {
						this._view ( dockBinding, tabBinding, viewDefinition, false );
					} else {
						alert ( "StageBinding: no such predefined viewdefinition (" + handle + ")" );
					}
				}
			}
		};
	}
}

/**
 * Please use the static method StageBinding.presentViewDefinition
 * Presenting the ViewDefinition on stage.
 * @param {ViewDefinition} viewDefinition
 */
StageBinding.prototype._presentViewDefinition = function ( viewDefinition ) {
	
	var target = null;
	var isAbort = false;
		
	switch ( viewDefinition.position ) {
		
		case Dialog.MODAL :
			target = app.bindingMap.masterdialogset.getModalInstance ();
			break;
		case Dialog.NON_MODAL :
			target = app.bindingMap.masterdialogset.getInstance ();
			break;
			
		default :
			if ( this._dockBindings.hasEntries ()) { // somehow no docks when user has no perspectives mounted...
				switch ( viewDefinition.position ) {
					
					case DockBinding.ABSBOTTOMLEFT :
					case DockBinding.ABSBOTTOMRIGHT :
					case DockBinding.ABSRIGHTTOP :
					case DockBinding.ABSRIGHTBOTTOM :
						
						// targetting the developer docks.
						target = this._dockBindings.get ( viewDefinition.position );
						break;
						
					default :
						
						// targetting the main stage.
						var selectedDeck = this._decksBinding.getSelectedDeckBinding ();
						target = selectedDeck.getDockBindingByReference ( 
							viewDefinition.position 
						);
						
						// hide start stuff if present.
						if ( this._isShowingStart ) {
							EventBroadcaster.broadcast ( BroadcastMessages.STOP_COMPOSITE );
						}  else if ( this._isShowingDefaultStart ) {
							var decks = this.bindingWindow.bindingMap.maindecks;
							decks.select ( "stagedeck" );
							this._isShowingDefaultStart = false;
						}
						break;
				}
			} else {
				isAbort = true;
			}
			break;
	}
	
	if ( !isAbort ) {
		if ( target != null ) {
			this._view ( target, null, viewDefinition, true );
		} else {
			throw "StageBinding: Could not position view: " + viewDefinition.handle;
		}
	}
}

/**
 * Launches the view on stage while indexing view as an active view.
 * @param {Binding} target
 * @param {DockTabBinding} dockTabBinding Required when launching open views.
 * @param {ViewDefinition} viewDefinition
 * @param {boolean} isNewView True for newly launched views, false for views opened at startup.
 */ 
StageBinding.prototype._view = function ( target, dockTabBinding, viewDefinition, isNewView ) {
	
	var handle = viewDefinition.handle;
	if ( viewDefinition.isMutable ) {
		handle += KeyMaster.getUniqueKey ();
	}
	
	if ( this._activeViewDefinitions [ handle ] ) {
		
		/*
		 * Update already open view.
		 */
		var viewBinding = ViewBinding.getInstance ( handle );
		if ( viewBinding != null ) {
			viewBinding.update ();
		} else {
			this.logger.error ( "Could not update ViewBinding (declared open): \n" + handle );
		}
		
	} else {
	
		/*
		 * Initialize new view.
		 */
		this._activeViewDefinitions [ handle ] = viewDefinition;
		
		/*
		 * Lock interface. Unlocked around method handleBroadcast.
		 */
		Application.lock ( this );
		
		switch ( target.constructor ) {
			case DockBinding :
				if ( isNewView ) {
					target.prepareNewView ( viewDefinition );
				} else {
					target.prepareOpenView ( viewDefinition, dockTabBinding );
				}
				break;
			case StageDialogBinding :
				if ( isNewView ) {
					target.prepareNewView ( viewDefinition );
				}
				break;
		}
	}
}

/**
 * Called whenever a view is disposed from stage, unregistering view as an active view.
 * @param {string} handle
 */
StageBinding.prototype._dontView = function ( handle ) {
	
	if ( this._activeViewDefinitions [ handle ] != null ) {
		delete this._activeViewDefinitions [ handle ];
	} else {
		this.logger.debug ( "Could not unregister active view: " + handle );
	}
}

/**
 * Fires when a DockTabBinding get's selected. During 
 * startup, the visible tab get's selected by default.
 * @param {DockTabBinding} tabBinding
 */
StageBinding.prototype.handleSelectedDockTab = function ( tabBinding ) {
	
	// this.logger.warn ( "TODO: StageBinding#handleSelectedDockTab" );
	/*
	var viewBinding = tabBinding.getAssociatedView ();
	if ( viewBinding && !viewBinding._isViewBindingInitialized ) {
		viewBinding.initialize ();
	}
	*/
}


StageCrawler.prototype = new BindingCrawler;
StageCrawler.prototype.constructor = StageCrawler;
StageCrawler.superclass = BindingCrawler.prototype;

StageCrawler.ID = "stagecrawler";
StageCrawler.MODE_MAXIMIZE = "maximize";
StageCrawler.MODE_UNMAXIMIZE = "minimize";

/**
 * @class
 * The ElementCrawler sees only elements with Bindings attached.
 */
function StageCrawler () {
	
	this.mode = StageCrawler.MODE_MAXIMIZE;
	this.id = StageCrawler.ID;
	this._construct ();
	return this;
}

/**
 * * Filter all but Binding elements.
 * @overloads {ElementCrawler#_construct} 
 */
StageCrawler.prototype._construct = function () {
	
	StageCrawler.superclass._construct.call ( this );
	
	var self = this;
	this.addFilter ( function ( element ) {
		
		var binding = UserInterface.getBinding ( element );
	 	var result = null;
		
		if ( binding ) {
			switch ( binding.constructor ) {
				case StageSplitBoxBinding :
				case StageSplitPanelBinding :
				case StageSplitterBinding :
					switch ( self.mode ) {
						case StageCrawler.MODE_MAXIMIZE :
							binding.handleMaximization ();
							break;
						case StageCrawler.MODE_UNMAXIMIZE :
							binding.handleUnMaximization ();
							break;
					}
					break;
				case DockBinding :
					result = NodeCrawler.SKIP_NODE;
					break;
			}
		}
		return result;
	});
}

StageDialogSetBinding.prototype = new DialogSetBinding;
StageDialogSetBinding.prototype.constructor = StageDialogSetBinding;
StageDialogSetBinding.superclass = DialogSetBinding.prototype;

/**
 * @class
 */
function StageDialogSetBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "StageDialogSetBinding" );
	
	/**
	 * @type {List<StageDialogBinding>}
	 */
	this._dialogs = new List ();
}

/**
 * Identifies binding.
 */
StageDialogSetBinding.prototype.toString = function () {
	
	return "[StageDialogSetBinding]";
}

/**
 * Get non-modal dialog.
 * @return {StageDialogBinding}
 */
StageDialogSetBinding.prototype.getInstance = function () {
	
	var dialog = null;
	
	this._dialogs.each ( function ( member ) {
		if ( !member.isVisible ) {
			dialog = member;
		}
		return dialog != null;
	});
	if ( !dialog ) {
		this._newInstance ();
		dialog = this._dialogs.getLast ();
	}
	dialog.setModal ( false );
	return dialog;
}

/**
 * Get modal dialog.
 * @return {StageDialogBinding}
 */
StageDialogSetBinding.prototype.getModalInstance = function () {
	
	var dialog = this.getInstance ();
	dialog.setModal ( true );
	return dialog;
}

/**
 * Construct new dialog (but don't return it!).
 */
StageDialogSetBinding.prototype._newInstance = function () {

	var dialog = this.add ( 
		StageDialogBinding.newInstance ( 
			this.bindingDocument 
		)
	);
	this._dialogs.add ( dialog );
	dialog.attach ();
}

StageDialogBinding.prototype = new DialogBinding;
StageDialogBinding.prototype.constructor = StageDialogBinding;
StageDialogBinding.superclass = DialogBinding.prototype;

/**
 * @class
 * The StageDialogBinding builds a bridge between dialogs and pages. 
 * TODO: Consider why and how some of this stuff can be moved to regular dialogs. 
 */
function StageDialogBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "StageDialogBinding" );
	
	/**
	 * @type {ViewBinding}
	 */
	this._viewBinding = null;
	
	/**
	 * @type {DialogPageBinding}
	 */
	this._pageBinding = null;
	
	/**
	 * @type {IDialogResponseHandler}
	 */
	this._dialogResponseHandler = null;
	
	/**
	 * First loaded PageBinding may set a width and height. 
	 * Subsequent PageBindings may only increase the height.
	 * @type {boolean}
	 */
	this._isFirstPage = true;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
StageDialogBinding.prototype.toString = function () {

	return "[StageDialogBinding]";
}

/**
 * @overloads {DialogBinding#onBindingRegister}
 */
StageDialogBinding.prototype.onBindingRegister = function () {
	
	StageDialogBinding.superclass.onBindingRegister.call ( this );	
	
	this.addActionListener ( PageBinding.ACTION_INITIALIZED );
	this.addActionListener ( PageBinding.ACTION_DETACHED );
	this.addActionListener ( DialogPageBinding.ACTION_RESPONSE );
	this.addActionListener ( Binding.ACTION_INVALID );
	this.addActionListener ( Binding.ACTION_VALID );
	this.addActionListener ( ViewBinding.ACTION_LOADED );
	this.addActionListener ( ViewBinding.ACTION_ONCLOSE );
	this.addActionListener ( ViewBinding.ACTION_CLOSED );
	this.addActionListener ( ErrorBinding.ACTION_INITIALIZE );
	this.addActionListener ( PageBinding.ACTION_UPDATING );
	this.addActionListener ( PageBinding.ACTION_UPDATED );
	this.addActionListener ( DialogBinding.ACTION_CLOSE );
	
	this.subscribe ( BroadcastMessages.KEY_ESCAPE );
}

/**
 * By default, show only the close control.
 * @overloads {DialogBinding#onBindingAttach}
 */
StageDialogBinding.prototype.onBindingAttach = function () {
	
	StageDialogBinding.superclass.onBindingAttach.call ( this );
	this.defaultSetup ();
}

/**
 * Prepare new ViewBinding.
 * @param {DialogViewDefinition} definition
 */
StageDialogBinding.prototype.prepareNewView = function ( definition ) {
	
	if ( definition instanceof DialogViewDefinition ) {
	
		var viewBinding = ViewBinding.newInstance ( this.bindingDocument );
		viewBinding.setDefinition ( definition );
		viewBinding.setType ( ViewBinding.TYPE_DIALOGVIEW );
		
		// TODO: move to method
		if ( definition.handler ) {
			if ( Interfaces.isImplemented ( IDialogResponseHandler, definition.handler )) {
				this._dialogResponseHandler = definition.handler;
			} else {
				throw "IDialogResponseHandler not implemented";
			}
		}
		
		/*
		FLOATING DOCKS!
		var setBinding = UserInterface.getBinding ( this.bindingElement.parentNode );
		viewBinding.snapToBinding ( this._body );
		setBinding.add ( viewBinding );
		*/
		
		this._viewBinding = viewBinding;
		this._body.add ( viewBinding );
		viewBinding.attach ();
		viewBinding.initialize ();
	}
}




/**
 * @implements {IActionListener}
 * @overloads {DialogBinding#handleAction}
 * @param {Action} action
 */
StageDialogBinding.prototype.handleAction = function ( action ) {
	
	StageDialogBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	
	switch ( action.type ) {
	
		case PageBinding.ACTION_INITIALIZED :
			this._handleInitializedPageBinding ( binding );
			action.consume ();
			break;
			
		case PageBinding.ACTION_DETACHED : 
			if ( binding.bindingDocument == this._viewBinding.getContentDocument ()) {
				this._pageBinding = null;
			}
			action.consume ();
			break;
			
		case DialogPageBinding.ACTION_RESPONSE :
			if ( binding.response ) {
				this._handleDialogPageResponse ( binding );
			}
			action.consume ();
			break;
			
		case Binding.ACTION_INVALID :
			this._disableDialogAcceptButton ( true );
			action.consume ();
			break;
			
		case Binding.ACTION_VALID :
			this._disableDialogAcceptButton ( false );
			action.consume ();
			break;
		
		case ViewBinding.ACTION_ONCLOSE :
			this.close (); 
			binding.dispose (); // WAS REVERSED!
			action.consume ();
			break;
			
		case ViewBinding.ACTION_CLOSED :
			this._isFirstPage = true;
			action.consume ();
			break;
			
		case ErrorBinding.ACTION_INITIALIZE :
			action.consume ();
			break;
			
		case PageBinding.ACTION_UPDATING :
			this._isUpdating = true;
			action.consume ();
			break;
		
		case PageBinding.ACTION_UPDATED :
			if ( this._isUpdating ) {
				this._isUpdating = false;
				this._fit ();
			}
			action.consume ();
			break;
		
		/*
		 * TODO: Are we adding this listener in the first place?
		 */
		case Binding.ACTION_UPDATED :
			if ( !this._isUpdating ) {
				this._fit ();
			}
			action.consume ();
			break;
			
		case DialogBinding.ACTION_CLOSE :
			if ( binding == this ) {
				this._viewBinding.dispose ();
				this.defaultSetup ();
			}
			break;
	}
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
StageDialogBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	StageDialogBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
			
		case BroadcastMessages.KEY_ESCAPE :
			if ( this.isVisible == true ) { // RENAME ISOPEN!
				if ( !PopupBinding.hasActiveInstances ()) {
					this._defaultClose ();
				}
			}
			break;
	}
}

/**
 * Release the FitnessCrawler. Fit all members.
 * @param {boolean} isForce
 */
StageDialogBinding.prototype._fit = function ( isForce ) {
	
	var crawler = new FitnessCrawler ();
	var list = new List ();
	if ( isForce ) {
		crawler.mode = FitnessCrawler.MODE_BRUTAL;
	}
	crawler.crawl ( this.bindingElement, list );
	crawler.dispose ();
	
	if ( list.hasEntries ()) {
		/*
		 * Fit all fitness members, starting from the innermost 
		 * location in the subtree. Then dispose the member list.
		 */
		list.reverse ();
		list.each ( function ( binding ) {
			binding.fit ( isForce );
		});
		list.dispose ();
		this._fitMe ();
	}
};

/**
 * Keeping myself fit.
 * @param {List<IFit>}
 */
StageDialogBinding.prototype._fitMe = function () {
	
	if ( this._pageBinding != null ) {
		
		this._pageBinding.enableAutoHeightLayoutMode ( true );
		this._fixAutoHeight ( this._pageBinding );
		this._pageBinding.enableAutoHeightLayoutMode ( false );
		
		var height = this.getDimension ().h;
		this.reflex ( true );
				
		// Still the same height? Explorer can mess it up here.
		var self = this;
		if ( this.getDimension ().h == height ) {
			var self = this;
			setTimeout ( function () {
				self.reflex ( true );
			}, 0 );
		}
	}
}

/**
 * @param {MenuItemBinding} menuItemBinding
 */
StageDialogBinding.prototype._handleContextMenuItemBinding = function ( menuItemBinding ) {
	
	var cmd = menuItemBinding.getProperty ( "cmd" );
	
	switch ( cmd ) {
		case DialogTitleBarPopupBinding.CMD_CLOSE :
			this._defaultClose ();
			break;
		case DialogTitleBarPopupBinding.CMD_REFRESH :
			this._titlebar.setLabel ( DockTabBinding.LABEL_TABLOADING );
			this._titlebar.setImage ( DockTabBinding.IMG_TABLOADING );
			this._pageBinding = null;
			this._viewBinding.reload ( Application.isDeveloperMode );
			break;
		case DialogTitleBarPopupBinding.CMD_VIEWSOURCE :
		case DialogTitleBarPopupBinding.CMD_VIEWGENERATED :
		case DialogTitleBarPopupBinding.CMD_VIEWSERIALIZED :
			this._viewSource ( cmd );
			break;
		default :
			alert ( "TODO!" );
			break;
	}
}

/**
 * View source.
 * @param {string} cmd
 */
StageDialogBinding.prototype._viewSource = DockTabBinding.prototype._viewSource;

/**
 * @param {PageBinding} pageBinding
 */
StageDialogBinding.prototype._handleInitializedPageBinding = function ( pageBinding ) {
	
	if ( pageBinding.bindingDocument == this._viewBinding.getContentDocument ()) {
		
		if ( pageBinding instanceof DialogPageBinding ) {
			if ( this._pageBinding == null ) { // grab image and label only from first page!
				this._parsePageBinding ( pageBinding );
			}
			this._pageBinding = pageBinding;
			if ( pageBinding.height == "auto" ) {
				pageBinding.enableAutoHeightLayoutMode ( true );
				this._fixAutoHeight ( pageBinding );
				pageBinding.enableAutoHeightLayoutMode ( false );
				this.reflex ( true );
			}
		}
		if ( StatusBar.state == StatusBar.BUSY ) {
			StatusBar.clear ();
		}
		if ( this._isFirstPage ) {
			EventBroadcaster.broadcast ( BroadcastMessages.VIEW_COMPLETED, this._viewBinding.getHandle ());
			EventBroadcaster.broadcast ( BroadcastMessages.STAGEDIALOG_OPENED );
		}
		
	} else if ( pageBinding.isDialogSubPage ) {
		
		this._pageBinding.enableAutoHeightLayoutMode ( true );
		this._fixAutoHeight ( pageBinding );
		this._pageBinding.enableAutoHeightLayoutMode ( false );
		
		this._fit ( true );
		this.reflex ( true );
	}
	
	/*
	 * Flip this flag!
	 */
	this._isFirstPage = false;
}

/**
 * TODO: store a local isValid variable and re-do this on wizard page load!
 * @param {boolean} isDisabled
 */
StageDialogBinding.prototype._disableDialogAcceptButton = function ( isDisabled ) {
	
	var buttonElement = this._viewBinding.getContentDocument ().getElementById ( "dialogacceptbutton" );
	if ( buttonElement ) {
		var buttonBinding = UserInterface.getBinding ( buttonElement );
		buttonBinding.setDisabled ( isDisabled );
	}
} 

/**
 * Handle DialogPage response.
 * @param {DialogPageBinding} binding
 */
StageDialogBinding.prototype._handleDialogPageResponse = function ( binding ) {
	
	// TODO: rig this up so that we close the dialog before handling the response!
	if ( this._dialogResponseHandler != null ) {
		this._dialogResponseHandler.handleDialogResponse (
			binding.response, binding.result != null ? binding.result : null
		);
	}
	
	this.close ();
} 

/**
 * Make sure that the close button fires a returnvalue of "cancel".
 * @overloads {DialogBinding#handleInvokedControl}
 * @param {ControlBinding} control
 */
StageDialogBinding.prototype.handleInvokedControl = function ( control ) {
	
	if ( control.controlType == ControlBinding.TYPE_CLOSE ) { 
		this._defaultClose ();
	}
	
	StageDialogBinding.superclass.handleInvokedControl.call ( this, control );
}

/**
 * Assinging contextmenu to titlebar.
 * @overloads {DialogBinding#buildDescendantBindings}
 */
StageDialogBinding.prototype.buildDescendantBindings = function () {
	
	StageDialogBinding.superclass.buildDescendantBindings.call ( this );
	this._titlebar.setContextMenu ( app.bindingMap.dialogtitlebarpopup );
	
	/*
	 * Note that this overwrites!
	 */
	var self = this;
	this._titlebar.handleAction = function ( action ) {
		switch ( action.type ) {
			case MenuItemBinding.ACTION_COMMAND :
				if ( action.listener == this.contextMenuBinding ) {
			 		self._handleContextMenuItemBinding ( action.target );
			 	}
			 	break;
		}
	}
}

/**
 * Parse contained DialogPageBinding. 
 * @param {DialogPageBinding} pageBinding
 */
StageDialogBinding.prototype._parsePageBinding = function ( pageBinding ) {
	
	var label		= pageBinding.label;
	var image 		= pageBinding.image;
	var width 		= pageBinding.width;
	var height		= pageBinding.height;
	var controls 	= pageBinding.controls;
	var isResizable = pageBinding.isResizable;
	
	if ( label ) {
		this.setLabel ( label );
	}
	if ( image ) {
		this.setImage ( image );
	}
	if ( width || height ) {
		
		var old = this.getDimension ();
		var nev = new Dimension ();
		
		if ( this._isFirstPage ) { // only set width on first page!
			nev.w = width ? width : old.w;
		} else {
			nev.w = old.w;
		}
		nev.h = ( height != null && height != "auto" ) ? height : old.h; // never set height on autoheight dialogs!
				
		this.setDimension ( nev );
	}
	if ( controls ) {
		this.controlBindings [ ControlBinding.TYPE_MAXIMIZE ].hide ();
		this.controlBindings [ ControlBinding.TYPE_MINIMIZE ].hide ();
		this.controlBindings [ ControlBinding.TYPE_CLOSE ].hide ();
		var type, types = new List ( controls.split ( " " ));
		while (( type = types.getNext ()) != null ) {
			this.controlBindings [ type ].show ();
		}
	}
	
	if ( isResizable != this._isResizable ) {
		this.setResizable ( isResizable ); 
	}
	if ( height == "auto" ) {
		this._fixAutoHeight ( pageBinding );
	}
	if ( pageBinding == this._pageBinding ) { // only on dialog open!
		this.centerOnScreen (); 
	}
	if ( !this.isOpen ) {
		this.reflex ( true );
		this.open ( true );
	}
}

/**
 * Fix auto height.
 * @param {PageBinding} pageBinding
 */
StageDialogBinding.prototype._fixAutoHeight = function ( pageBinding ) {
	
	var dim = this.getDimension ();
	var width = 0;
	var height = 0;
	
	if ( pageBinding.isDialogSubPage ) {
		pageBinding = this._pageBinding;
	}
	if ( this._isFirstPage ) {
		width = pageBinding.width != null ? pageBinding.width : dim.w; 
	} else {
		width = dim.w;
	}
	height = pageBinding.bindingElement.offsetHeight;
	height += this._titlebar.bindingElement.offsetHeight;
	height += 4; // HARDCODE WARNING! Compensates for border thickness
	
	if ( height < dim.h ) { // never shrink the dialog - only expand it.
		height = dim.h;
	}
	if ( pageBinding.minheight != null ) { // consider minheight!
		if ( height < pageBinding.minheight ) {
			height = pageBinding.minheight;
		}
	}
	this.setDimension ( new Dimension ( width, height ));
}

/**
 * Default close. This will return a "cancel" to any response handler.
 * TODO: rig this up so that we close the dialog before handling the response!
 */
StageDialogBinding.prototype._defaultClose = function () {
	
	if ( this._dialogResponseHandler != null ) {
		this._dialogResponseHandler.handleDialogResponse (
			Dialog.RESPONSE_CANCEL
		); 
	}
	this.close ();
}

/**
 * Focucs content when opened.
 */
StageDialogBinding.prototype.open = function () {
	
	StageDialogBinding.superclass.open.call ( this );
	if ( this.isVisible == true ) {
		this._viewBinding.onActivate ();
	}
}

/**
 * Revert to default setup on dialog exit.
 * @overloads {DialogBinding#close}
 *
StageDialogBinding.prototype.close = function () {

	StageDialogBinding.superclass.close.call ( this );
	
	if ( !Client.hasTransitions ) {
		this._viewBinding.dispose ();
		this.defaultSetup ();
	} else {
		var self = this;
		setTimeout ( function () { // wait for CSS transition fadeout
			self._viewBinding.dispose ();
			self.defaultSetup ();
		}, Animation.DEFAULT_TIME );
	}
}
*/

/**
 * Invoke default setup on dialog close.
 */
StageDialogBinding.prototype.defaultSetup = function () {
	
	this.setImage ( LabelBinding.DEFAULT_IMAGE );
	this.setLabel ( "" );
	this.setDimension ( new Dimension ( DialogBinding.DEFAULT_WIDTH, DialogBinding.DEFAULT_HEIGHT ));

	this.controlBindings [ ControlBinding.TYPE_MAXIMIZE ].hide ();
	this.controlBindings [ ControlBinding.TYPE_MINIMIZE ].hide ();
	this.controlBindings [ ControlBinding.TYPE_CLOSE ].show ();
	
	this._pageBinding = null;
	this._dialogResponseHandler = null;
	
	if ( !this._isResizable ) {
		this.setResizable ( true );
	}
}

/**
 * Set position.
 * @param {Point} p
 */
StageDialogBinding.prototype.setPosition = function ( p ) {
	
	StageDialogBinding.superclass.setPosition.call ( this, p );
	this._body.dispatchAction (
		Binding.ACTION_POSITIONCHANGED 
	);
}


/**
 * Set dimension.
 * @param {Dimension} dim
 */
StageDialogBinding.prototype.setDimension = function ( dim ) {
	
	// HARDCODE ALERT
	if ( !Client.isWindows ) { // OSX
		dim.w -= 6; // because of no window borders on mac...
	}
	
	StageDialogBinding.superclass.setDimension.call ( this, dim );
	this._body.dispatchAction (
		Binding.ACTION_DIMENSIONCHANGED 
	);
}

/**
 * Activate.
 * @implements {IActivatable}
 * @overloads {DialogBinding#activate}
 */
StageDialogBinding.prototype.activate = function () {

	if ( !this.isActive ) {
		StageDialogBinding.superclass.activate.call ( this );
		this._viewBinding.onActivate ();
	}
}

/**
 * Deactivate.
 * @implements {IActivatable}
 * @overloads {DialogBinding#activate}
 */
StageDialogBinding.prototype.deActivate = function () {

	if ( this.isActive == true ) {
		StageDialogBinding.superclass.deActivate.call ( this );
		this._viewBinding.onDeactivate ();
	}
}

/**
 * StageDialogBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {StageDialogBinding}
 */
StageDialogBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:dialog", ownerDocument );
	var binding = UserInterface.registerBinding ( element, StageDialogBinding );
	binding.setProperty ( "controls", "minimize maximize close" );
	return binding;
}

FitnessCrawler.prototype = new Crawler;
FitnessCrawler.prototype.constructor = FitnessCrawler;
FitnessCrawler.superclass = Crawler.prototype;

FitnessCrawler.ID = "fitnesscrawler";
FitnessCrawler.MODE_BRUTAL = "brutal fitness";
FitnessCrawler.MODE_TRAINING = "train fitness";

/**
 * This crawler handles focus and blur.
 * @class
 */
function FitnessCrawler () {
	 
	this.id = FitnessCrawler.ID;
	this.mode = FitnessCrawler.MODE_TRAINING; 
	this._construct ();
	return this;
}

/**
 * @overloads {Crawler#_construct} 
 */
FitnessCrawler.prototype._construct = function () {
	
	FitnessCrawler.superclass._construct.call ( this );
	
	this.addFilter ( function ( element, list ) {
		
		var result = null;
		var binding = UserInterface.getBinding ( element );
		
		if ( !binding.isVisible ) {
			result = NodeCrawler.SKIP_NODE + NodeCrawler.SKIP_CHILDREN; 
		}
		
		return result;
	});
	
	/*
	 * Collecting unfit members.
	 */
	this.addFilter ( function ( element, list ) {
		
		var result = null;
		var binding = UserInterface.getBinding ( element );
		
		if ( binding.isAttached ) {
			if ( Interfaces.isImplemented ( IFit, binding )) {
				if ( !binding.isFit || this.mode == FitnessCrawler.MODE_BRUTAL ) {
					list.add ( binding );
				}
			}
		}
		return null;
	});
};

StageDecksBinding.prototype = new DecksBinding;
StageDecksBinding.prototype.constructor = StageDecksBinding;
StageDecksBinding.superclass = DecksBinding.prototype;
StageDecksBinding.NODENAME_DECK = "stagedeck";
StageDecksBinding.ACTION_INITIALIZED = "stagedecks initialized";

/**
 * @class
 */
function StageDecksBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "StageDecksBinding" );
	
	/**
	 * Associating handles to decks.
	 * @type {HashMap<string><StageDeckBinding>} 
	 */
	this._decks = {};
}

/**
 * Identifies binding.
 */
StageDecksBinding.prototype.toString = function () {

	return "[StageDecksBinding]";
}

/**
 * @overloads {Binding#onBindingInitialize}
 */
StageDecksBinding.prototype.onBindingInitialize = function () {

	StageDecksBinding.superclass.onBindingInitialize.call ( this );
	this.dispatchAction ( StageDecksBinding.ACTION_INITIALIZED );
}

/**
 * Mount viewDefinition, building decks.
 * @param {SystemViewDefinition} definition
 */
StageDecksBinding.prototype.mountDefinition = function ( definition ) {

	var deckBinding = StageDeckBinding.newInstance ( this.bindingDocument );
	deckBinding.handle = definition.handle;
	deckBinding.perspectiveNode = definition.node;
	this._decks [ deckBinding.handle ] = deckBinding;
	this.add ( deckBinding );
	deckBinding.attach ();
}

/**
 * @param {string} handle
 */
StageDecksBinding.prototype.setSelectionByHandle = function ( handle ) {

	var deckBinding = this._decks [ handle ];
	StageBinding.perspectiveNode = deckBinding.perspectiveNode;
	this.select ( deckBinding );
}

StageDeckBinding.prototype = new DeckBinding;
StageDeckBinding.prototype.constructor = StageDeckBinding;
StageDeckBinding.superclass = DeckBinding.prototype;

StageDeckBinding.ACTION_LOADED = "stagedeck loaded";
StageDeckBinding.NODENAME_DECKS = "stagedecks";
StageDeckBinding.DEFAULT_URL = "${root}/content/misc/stage/stagedeck.aspx";
StageDeckBinding.CLASSNAME_TOOLS_OPEN = "toolsopen";

/**
 * @class
 * Please notice that some of these methods get evaluated in the 
 * context of the {@link StageBoxHandlerAbstraction} in order 
 * not to copy-paste code shared with the {@link StageBinding}.
 * @extends {StageBoxHandlerAbstraction}
 */
function StageDeckBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "StageDeckBinding" );
	
	/**
	 * This property is set by the {@link StageDecksBinding} 
	 * when the deck is constructed.
	 * @type {string}
	 */
	this.handle = null;
	
	/**
	 * Associates the deck to the selected perspective.
	 * This property is set by the {@link StageDecksBinding} while building.
	 * @type {SystemNode}
	 */
	this.perspectiveNode = null;
	
	/**
	 * This flag is flipped once the *initial* content is loaded.
	 * @type {boolean}
	 */
	this.isReady = false;	
	
	/**
	 * This flag is flipped once the *real* content is loaded.
	 * @type {boolean}
	 */
	this._isStageDeckBindingInitialized = false;
	
	/**
	 * Indexing docks by reference property.
	 * @type {Map<string><DockBinding>}
	 */
	this._dockBindings = null;
	
	/**
	 * Counting open docks in order 
	 * to show and hide dockcontrols.
	 * @type {int}
	 */
	this._dockBindingCount = 0;
	
	/**
	 * Gets assigned in the newInstance method.
	 * @type {WindowBinding}
	 */
	this.windowBinding = null;
	
	/**
	 * Flipped by the StageBoxHandlerAbstraction when a panel is maximized.
	 * @type {boolean}
	 */
	this.isSubPanelMaximized = false;
}

/**
 * Identifies binding.
 */
StageDeckBinding.prototype.toString = function () {

	return "[StageDeckBinding]";
}

/**
 * Notice that we are simulating a {@link StageBoxHandlerAbstraction} in 
 * the inheritance chain. That's because the {@link StageBinding} is 
 * interested in some of these functionalities as well.
 * @overloads {DecksBinding#onBindingRegister}
 */
StageDeckBinding.prototype.onBindingRegister = function () {
	
	StageDeckBinding.superclass.onBindingRegister.call ( this );
	StageBoxHandlerAbstraction.onBindingRegister.call ( this );
	
	this._dockBindings = new Map ();
	
	this.addActionListener ( WindowBinding.ACTION_LOADED );
	this.addActionListener ( TabBoxBinding.ACTION_ATTACHED );
}

/**
 * On first load event, the iframe is simply registered. On second load event, 
 * the actual deck content has been loaded and the deck gets selected. Setup 
 * ensures that there is no flash of white when Explorer loads deck content.
 * TODO: this url should probably be set already in the newInstance method  
 * to avoid window content loading twice...
 * @implements {IActionListener}
 * @overloads {DeckBinding#handleAction}
 * @param {Action} action 
 */
StageDeckBinding.prototype.handleAction = function ( action ) {
	
	StageDeckBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	
	switch ( action.type ) {
		
		/*
		 * Startup.
		 */
		case WindowBinding.ACTION_LOADED :
			if ( binding == this.windowBinding ) {
				top.app.bindingMap.stagedeckscover.hide ();
				this.removeActionListener ( WindowBinding.ACTION_LOADED );
				this.addActionListener ( StageSplitBoxBinding.ACTION_DOCK_EMPTIED );
				this.addActionListener ( StageSplitBoxBinding.ACTION_DOCK_OPENED );
				this.dispatchAction ( StageDeckBinding.ACTION_LOADED );
				action.consume ();
			}
			break;
		
		/*
		 * Indexing docks on startup.
		 */
		case TabBoxBinding.ACTION_ATTACHED :
			if ( binding instanceof DockBinding ) {
				this._dockBindings.set ( binding.reference, binding );
				binding.perspectiveNode = this.perspectiveNode;
			}
			break;
		
		/*
		 * Show dockcontrols when MORE than one dock is open. 
		 */
		case StageSplitBoxBinding.ACTION_DOCK_OPENED : 
			this._dockBindingCount ++;
			if ( this._dockBindingCount == 2 ) {
				this._dockBindings.get ( "main" ).showControls ( true );
			}
			action.consume (); // StageBinding is no longer listening!
			break;
		
		/*
		 * Hide dockcontrols only one deck is open.
		 */	
		case StageSplitBoxBinding.ACTION_DOCK_EMPTIED : 
			this._dockBindingCount --;
			if ( this._dockBindingCount == 1 ) {
				this._dockBindings.get ( "main" ).showControls ( false );
			}
			action.consume ();
			break;
	}
	
	/*
	 * Notice this hack!
	 */
	StageBoxHandlerAbstraction.handleAction.call ( this, action );
	StageDeckBinding.superclass.handleAction.call ( this, action );
}

/**
 * Iterate stagebox bindings, starting inside the contained WindowBinding.
 * This method is required by the StageBoxAbstractionHandler.
 * @see {StageBoxHandlerAbstraction#handleControlBoxAction}
 * @param {string} mode
 */
StageDeckBinding.prototype.iterateContainedStageBoxBindings = function ( mode ) {
	
	var crawler = new StageCrawler ();
	crawler.mode = mode;
	crawler.crawl ( this.windowBinding.getContentDocument ().body );
	crawler.dispose ();
}

/**
 * Load iframe content when first selected.
 * @overloads {DeckBinding#select}
 */
StageDeckBinding.prototype.select = function () {

	if ( !this._isStageDeckBindingInitialized ) {
		this.initialize ();
	}
	StageDeckBinding.superclass.select.call ( this );
}

/**
 * Get that DockBinding.
 * @param {string} reference
 * @return {DockBinding}
 */
StageDeckBinding.prototype.getDockBindingByReference = function ( reference ) {
	
	return this._dockBindings.get ( reference );
}

/**
 * Load default stagedeck to initialize. Cover is made visible to avoid 
 * flash of white in Explorer (hidden again by method handleActioEvent}.
 */
StageDeckBinding.prototype.initialize = function () {
	
	if ( !this._isStageDeckBindingInitialized ) {
		top.app.bindingMap.stagedeckscover.show ();
		this.windowBinding = this.add ( 
			WindowBinding.newInstance ( this.bindingDocument )
		);
		this.windowBinding.setURL ( 
			StageDeckBinding.DEFAULT_URL + "?handle=" + this.handle
		);
		this.windowBinding.attach ();
		this._isStageDeckBindingInitialized = true;
	}
}

/**
 * StageDeckBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {StageDeckBinding}
 */
StageDeckBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:stagedeck", ownerDocument )
	var binding = UserInterface.registerBinding ( element, StageDeckBinding );
	return binding;
}

StageDeckRootBinding.prototype = new RootBinding;
StageDeckRootBinding.prototype.constructor = StageDeckRootBinding;
StageDeckRootBinding.superclass = RootBinding.prototype;

/**
 * Default deck layout to be loaded from "templates" folder.
 * UPDATE: Remote loading has been disabled for now...
 */
StageDeckRootBinding.DEFAULT_TEMPLATE = "defaultstagedeck.xml";

/**
 * @class
 * The content of the deck is generated dynamically. Point being 
 * that we can easily persist deck layout between sessions. We 
 * still need to implement this feature, though. DISABLED NOW!
 */
function StageDeckRootBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "StageDeckRootBinding" );
}

/**
 * Identifies binding.
 */
StageDeckRootBinding.prototype.toString = function () {
	
	return "[StageDeckRootBinding]";
}

/**
 * @overloads {RootBinding#onBindingAttach}
 *
StageDeckRootBinding.prototype.onBindingAttach = function () {
	
	StageDeckRootBinding.superclass.onBindingAttach.call ( this );
	this._defaultLayout ();
}

/**
 * Setup default layout.
 *
StageDeckRootBinding.prototype._defaultLayout = function () {
	
	var markup = Templates.getTemplateElementText ( 
		StageDeckRootBinding.DEFAULT_TEMPLATE 
	)
	this.subTreeFromString ( markup );
}
*/

StageSplitBoxBinding.prototype = new SplitBoxBinding;
StageSplitBoxBinding.prototype.constructor = StageSplitBoxBinding;
StageSplitBoxBinding.superclass = SplitBoxBinding.prototype;

StageSplitBoxBinding.ACTION_HIDE = "stagesplitboxbinding hide";
StageSplitBoxBinding.ACTION_SHOW = "stagesplitboxbinding show";
StageSplitBoxBinding.ACTION_DOCK_EMPTIED = "stagesplitbox says dock emptied";
StageSplitBoxBinding.ACTION_DOCK_OPENED = "stagesplitbox says dock opened";

/**
 * @class
 */
function StageSplitBoxBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "StageSplitBoxBinding" );
	
	/**
	 * Flipped when a descendant panel gets maximized. This acts as preparation 
	 * for the actual maximization, which is handled by the StageCrawler.
	 * @see {StageDeckBinding#handleControlBoxAction}
	 * @type {boolean}
	 */
	this.isMaximizePrepared = false;
	
	/**
	 * Flipped when the StageCrawler calls the handleMaximization method.
	 * @see {StageDeckBinding#handleControlBoxAction}
	 * @type {boolean}
	 */
	this.isMaximizedForReal = null;
	
	/**
	 * Flipped when minimized.
	 * @see {StageDeckBinding#handleControlBoxAction}
	 * @type {boolean}
	 */
	this.isMinimizedForReal = null;
	
	/**
	 * Indicates that style.visibility is set to hidden.
	 * @type {boolean}
	 *
	this._isInvisibilized = false;
	*/
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
StageSplitBoxBinding.prototype.toString = function () {

	return "[StageSplitBoxBinding]";
}

/**
 * @see {StageBoxAbstraction#onBindingRegister}
 */
StageSplitBoxBinding.prototype.onBindingRegister = function () {
	
	StageSplitBoxBinding.superclass.onBindingRegister.call ( this );
	StageBoxAbstraction.onBindingRegister.call ( this );
	
	this.addActionListener ( DockBinding.ACTION_EMPTIED, this );
	this.addActionListener ( DockBinding.ACTION_OPENED, this );
	this.addActionListener ( StageSplitBoxBinding.ACTION_SHOW, this );
	this.addActionListener ( StageSplitBoxBinding.ACTION_HIDE, this );
}

/**
 * @see {StageBoxAbstraction#handleAction}
 * @implements {IActionListener}
 * @overloads {SplitBoxBinding#handleAction}
 * @param {Action} action
 */
StageSplitBoxBinding.prototype.handleAction = function ( action ) {
	
	StageSplitBoxBinding.superclass.handleAction.call ( this, action );
	StageBoxAbstraction.handleAction.call ( this, action );
	
	var binding = action.target;
	var docks = null;
	var splitter = null;
	
	switch ( action.type ) {
	
		/*
		 * DockBinding emptied
		 */
		case DockBinding.ACTION_EMPTIED :
			
			splitter = this.getChildBindingByLocalName ( "splitter" );
			if ( splitter.isVisible ) {
				splitter.hide ();
			}
			docks = this.getDescendantBindingsByLocalName ( "dock" );
			if ( docks.getFirst ().isEmpty && docks.getLast ().isEmpty ) {
				if ( docks.getFirst ().type != DockBinding.TYPE_EDITORS ) { /* ADDED */
					this.dispatchAction ( StageSplitBoxBinding.ACTION_HIDE );
					this.hide ();
				}
			} else {
				this.flex ();
				this.invokeLayout ();
			}
			
			/*
			 * We must consume this event, but the stagedeck needs to know.
			 */
			this.dispatchAction ( StageSplitBoxBinding.ACTION_DOCK_EMPTIED );
			action.consume ();
			break;
		
		/*
		 * DockBinding opened
		 */	
		case DockBinding.ACTION_OPENED :
		
			docks = this.getDescendantBindingsByLocalName ( "dock" );
			if ( !docks.getFirst ().isEmpty && !docks.getLast ().isEmpty ) {
				splitter = this.getChildBindingByLocalName ( "splitter" );
				if ( !splitter.isVisible ){
					splitter.show ();
				}
			}
			if ( !this.isVisible ) {
				this.show ();
				this.dispatchAction ( StageSplitBoxBinding.ACTION_SHOW );
			}
			this.flex ();
			this.invokeLayout ();
			
			/*
			 * We must consume this action in order to hide it  
			 * from the next StageSplitBoxBinding, but ancestor   
			 * bindings need to know that a dock was opened.
			 * @see {StageDeckBinding}
			 */
			this.dispatchAction ( StageSplitBoxBinding.ACTION_DOCK_OPENED );
			action.consume ();
			break;
		
		/*
		 * Sub-splitbox hiding
		 */
		case StageSplitBoxBinding.ACTION_HIDE :
		
			if ( binding != this ) {
				splitter = this.getChildBindingByLocalName ( "splitter" );
				if ( splitter.isVisible ) {
					splitter.hide ();
				}
				this.invokeLayout ();
				action.consume ();
			}
			break;
		
		/*
		 * Sub-splitbox showing
		 */	
		case StageSplitBoxBinding.ACTION_SHOW :
			
			if ( binding != this ) {
				var splitPanels = this.getChildBindingsByLocalName ( "splitpanel" );
				if ( splitPanels.getFirst ().isVisible && splitPanels.getLast ().isVisible ) {
					splitter = this.getChildBindingByLocalName ( "splitter" );
					if ( !splitter.isVisible ) {
						splitter.show ();
					}
				}
				this.invokeLayout ();
				action.consume ();
			}
			break;
	}
}

/**
 * Handle maximization. 
 */
StageSplitBoxBinding.prototype.handleMaximization = function () {
	
	StageBoxAbstraction.handleMaximization.call ( this );
}

/**
 * Handle unmaximization.
 */
StageSplitBoxBinding.prototype.handleUnMaximization = function () {
	
	StageBoxAbstraction.handleUnMaximization.call ( this );
}

/**
 * The outcome of the flex method depends heavily on the current state of the splitbox.
 * @overwrites {SplitBoxBinding#flex}
 * @implements {IFlexible}
 */
StageSplitBoxBinding.prototype.flex = function () {
	
	if ( this.isMaximizedForReal == null ) {
		
		StageSplitBoxBinding.superclass.flex.call ( this );
	}
}

/**
 * Handle crawler.
 * @implements {ICrawlerHandler}
 * @param {Crawler} crawler
 */
StageSplitBoxBinding.prototype.handleCrawler = function ( crawler ) {
	
	StageSplitBoxBinding.superclass.handleCrawler.call ( this, crawler );
	
	switch ( crawler.id ) {	
		case FlexBoxCrawler.ID :
			if ( this.isMaximizedForReal == false ) { // Huh? Shouldn't this be TRUE?
				crawler.response = NodeCrawler.SKIP_CHILDREN;
			}
			break;
	}
}

/**
 * @return {boolean}
 */
StageSplitBoxBinding.prototype.hasBothPanelsVisible = function () {
	
	var splitPanels = this.getChildBindingsByLocalName ( "splitpanel" );
	return splitPanels.getFirst ().isVisible && splitPanels.getLast ().isVisible;
}

/**
 * @return {boolean}
 */
StageSplitBoxBinding.prototype.hasBothPanelsFixed = function () {
	
	var splitPanels = this.getChildBindingsByLocalName ( "splitpanel" );
	return splitPanels.getFirst ().isFixed && splitPanels.getLast ().isFixed;
}

/**
 * Make splitbox invisible.
 * @param {boolean} isHide
 *
StageSplitBoxBinding.prototype.invisibilize = function ( isHide ) {
	
	if ( isHide != this._isInvisibilized ) {
		if ( isHide ) {
			this.bindingElement.style.visibility = "hidden";
		} else {
			this.bindingElement.style.visibility = "visible";
		}
		this._isInvisibilized = !this._isInvisibilized;
	}
}
*/

StageSplitPanelBinding.prototype = new SplitPanelBinding;
StageSplitPanelBinding.prototype.constructor = StageSplitPanelBinding;
StageSplitPanelBinding.superclass = SplitPanelBinding.prototype;

StageSplitPanelBinding.ACTION_LAYOUTUPDATE = "stagesplitpanel layout changed";

/**
 * @class
 */
function StageSplitPanelBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "StageSplitPanelBinding" );
	
	/**
	 * Flipped when the panel gets maximized. This acts as preparation 
	 * for the actual maximization, which is handled by the StageCrawler.
	 * @see {StageDeckBinding#handleControlBoxAction}
	 * @type {boolean}
	 */
	this.isMaximizePrepared = false;
	
	/**
	 * Flipped when the StageCrawler calls the handleMaximization method.
	 * @see {StageDeckBinding#handleControlBoxAction}
	 * @type {boolean}
	 */
	this.isMaximizedForReal = null;
	
	/**
	 * Flipped when minimized.
	 * @see {StageDeckBinding#handleControlBoxAction}
	 * @type {boolean}
	 */
	this.isMinimizedForReal = null;
	
	/**
	 * Indicates that style.visibility is set to hidden.
	 * @type {boolean}
	 */
	this._isInvisibilized = false;
	
	/** 
	 * Computing "ghosted" controls. Modified by DockBinding.
	 * @see {DockBinding#activate} 
	 * @see {ControlImageProfile}
	 * @type {boolean}
	 */
	this.isActive = true;
	 
	/**
	 * @type {boolean}
	 */
	this.isFixed = false;
}

/**
 * Identifies binding.
 */
StageSplitPanelBinding.prototype.toString = function () {

	return "[StageSplitPanelBinding]";
}

/**
 * @see {StageBoxAbstraction#onBindingRegister}
 */
StageSplitPanelBinding.prototype.onBindingRegister = function () {
	
	StageSplitPanelBinding.superclass.onBindingRegister.call ( this );
	StageBoxAbstraction.onBindingRegister.call ( this );
	
	this.addActionListener ( DockBinding.ACTION_OPENED, this );
	this.addActionListener ( DockBinding.ACTION_EMPTIED, this );
	this.addActionListener ( StageSplitBoxBinding.ACTION_HIDE, this );
	this.addActionListener ( StageSplitBoxBinding.ACTION_SHOW, this );
	this.addActionListener ( StageSplitPanelBinding.ACTION_LAYOUTUPDATE, this );
}

/**
 * @see {StageBoxAbstraction#handleAction}
 * @implements {IactionListener}
 * @overloads {SplitPanelBinding#handleEvent}
 * @param {Action} action
 */
StageSplitPanelBinding.prototype.handleAction = function ( action ) {
	
	StageSplitPanelBinding.superclass.handleAction.call ( this, action );
	StageBoxAbstraction.handleAction.call ( this, action );
 	
	// dont consume these actions, other bindings are listening!
	switch ( action.type ) {
		
		case DockBinding.ACTION_EMPTIED :
		case StageSplitBoxBinding.ACTION_HIDE :
		
			if ( this.isMaximized == true ) {
				this.normalize ();
			}
			var dock = this.getContainedDock ();
			if ( dock && dock.type == DockBinding.TYPE_EDITORS ) {
				this._invisibilize ( true );
				
				/*
				 * StageSplitBoxBinding listens for DockBinding.ACTION_EMPTIED, 
				 * but at one point we were consuming this as well! Hmmmm...... 
				 */
				if ( action.type == StageSplitBoxBinding.ACTION_HIDE ) {
					action.consume ();
				}
			} else {
				this.hide ();
				if ( this.isFixed == true ) {
					this.setFix ( false );
				}
			}
			if ( action.type == DockBinding.ACTION_EMPTIED ) {
				var self = this;
				setTimeout ( function () {
					self.dispatchAction ( StageSplitPanelBinding.ACTION_LAYOUTUPDATE );
				}, 0 );
			}
			break;
		
		case DockBinding.ACTION_OPENED :
		case StageSplitBoxBinding.ACTION_SHOW :
		
			var dock = this.getContainedDock ();
			if ( dock && dock.type == DockBinding.TYPE_EDITORS ) {
				this._invisibilize ( false );
				if ( action.type == StageSplitBoxBinding.ACTION_SHOW ) {
					action.consume (); // is this required?
				}
			} else {
				this.show ();
				if ( this.isFixed == true ) {
					this.setFix ( false );
				}
			}
			break;
			
		case StageSplitPanelBinding.ACTION_LAYOUTUPDATE :
			var binding = action.target;
			if ( binding != this && binding.getContainedDock ()) {
				if ( this._containingSplitBoxBinding.getOrient () == SplitBoxBinding.ORIENT_VERTICAL ) {
					var subBox = binding._containingSplitBoxBinding;
					if ( subBox.getOrient () == SplitBoxBinding.ORIENT_HORIZONTAL ) {
						var subPanels = subBox.getChildBindingsByLocalName ( "splitpanel" );
						var subPanel1 = subPanels.getFirst ();
						var subPanel2 = subPanels.getLast ();
						if ( this.isFixed == true ) {
							if ( !subPanel1.isFixed || !subPanel2.isFixed || ( !subBox.hasBothPanelsVisible () && binding.isMinimizedForReal ) ) {
								this.setFix ( false );
								action.consume ();
								this.dispatchAction ( StageSplitPanelBinding.ACTION_LAYOUTUPDATE );
							}
						} else {
							if ( subBox.hasBothPanelsFixed () || ( !subBox.hasBothPanelsVisible () && binding.isMinimizedForReal )) {
								this.setFix ( binding.getContainedDock ().getHeight ());
								action.consume ();
								this.dispatchAction ( StageSplitPanelBinding.ACTION_LAYOUTUPDATE );
							}
						}
					}
				} else {
					
				}
			}
			break;
		
	}
}

/**
 * Handle maximization. Depending on the status of property "isMaximizePrepared",
 * this will either maximize or hide the splitpanel.
 */
StageSplitPanelBinding.prototype.handleMaximization = function () {
	
	//this.isFlexible = false;
	StageBoxAbstraction.handleMaximization.call ( this );
	
	var dockBinding = this.getContainedDock ();
	if ( dockBinding ) {
		if ( this.isMaximizePrepared == true ) {
			// do nothing
		} else {
			dockBinding.interceptDisplayChange ( false );
		}
	}
}

/**
 * Handle unmaximization.
 */
StageSplitPanelBinding.prototype.handleUnMaximization = function () {
	
	StageBoxAbstraction.handleUnMaximization.call ( this );
	//this.isFlexible = true;

	var dockBinding = this.getContainedDock ();
	if ( dockBinding ) {
		if ( dockBinding.type == DockBinding.TYPE_EDITORS ) {
			if ( dockBinding.isEmpty ) {
				this._invisibilize ( true );
			}
		}
		if ( this.isMaximized == true ) {
			this.normalize ();
		} else {
			dockBinding.interceptDisplayChange ( true );
		}
	}
}

/**
 * Maximize.
 * @overloads {SplitPanelBinding#maximize}
 */
StageSplitPanelBinding.prototype.maximize = function () {
	
	if ( this.isMinimized == true ) {
		this.normalize ( true );
	}
	StageSplitPanelBinding.superclass.maximize.call ( this );
	this.dispatchAction ( StageSplitPanelBinding.ACTION_LAYOUTUPDATE );
	
	var dockBinding = this.getContainedDock ();
	if ( dockBinding ) {
		dockBinding.activate ();
		EventBroadcaster.broadcast ( BroadcastMessages.DOCK_MAXIMIZED, dockBinding );
	}
}

/**
 * Minimize.
 * @overloads {SplitPanelBinding#minimize}
 */
StageSplitPanelBinding.prototype.minimize = function () {
	
	var isHorizontalOrient = 
		this._containingSplitBoxBinding.getOrient () == 
		SplitBoxBinding.ORIENT_HORIZONTAL;
	
	var dockBinding = this.getContainedDock ();
	if ( dockBinding ) {
		dockBinding.collapse ( isHorizontalOrient );
		if ( !isHorizontalOrient ) {
			this.setFix ( dockBinding.getHeight ());
		} else {
			this.setFix ( dockBinding.getWidth ());
		}
	}
	if ( this.isMaximized == true ) {
		this.normalize ( true );
	}
	StageSplitPanelBinding.superclass.minimize.call ( this );
	this.dispatchAction ( StageSplitPanelBinding.ACTION_LAYOUTUPDATE );
	if ( dockBinding && dockBinding.isActive ) {
		dockBinding.deActivate ();
		EventBroadcaster.broadcast ( BroadcastMessages.DOCK_MINIMIZED, dockBinding );
	}
}

/**
 * Normalize.
 * @overloads {SplitPanelBinding#normalize}
 */
StageSplitPanelBinding.prototype.normalize = function ( isDispatchPrevented ) {

	var isHorizontalOrient = 
		this._containingSplitBoxBinding.getOrient () == 
		SplitBoxBinding.ORIENT_HORIZONTAL;

	var dockBinding = this.getContainedDock ();
	if ( dockBinding ) {
		if ( this.isMinimized == true ) {
			dockBinding.unCollapse ( isHorizontalOrient );
			this.setFix ( false );
		}
	}
	StageSplitPanelBinding.superclass.normalize.call ( this );
	if ( !isDispatchPrevented ) {
		this.dispatchAction ( StageSplitPanelBinding.ACTION_LAYOUTUPDATE );
		if ( dockBinding ) {
			dockBinding.activate ();
			EventBroadcaster.broadcast ( BroadcastMessages.DOCK_NORMALIZED, dockBinding );
		}
	}
}

/**
 * In case we end up movie docks between splitpanels, better get 
 * a fresh reading on the contained dock each time it is required.
 * @return {DockBinding}
 */
StageSplitPanelBinding.prototype.getContainedDock = function () {
	
	// TODO: DONT INCLUDE START DOCK IN THIS?
	// TODO: DID WE FÅK THIS UP WITH THE START DOCK?
	
	return this.getChildBindingByLocalName ( "dock" );
}

/**
 * Make splitpanel invisible. The visibility of the editors-dock 
 * is not affected by this method, it is handled internally. 
 * @param {boolean} isHide
 */
StageSplitPanelBinding.prototype.invisibilize = function ( isHide ) {

	var isContinue = true;
	var dock = this.getContainedDock ();
	if ( dock != null && dock.type == DockBinding.TYPE_EDITORS ) {
		if ( dock.isEmpty == true ) {
			isContinue = false;
		}
	}
	if ( isContinue == true ) {
		this._invisibilize ( isHide );
	}
	
}

/**
 * Make splitpanel invisible (private).
 * @param {boolean} isHide
 */
StageSplitPanelBinding.prototype._invisibilize = function ( isHide ) {
	
	if ( isHide != this._isInvisibilized ) {
		if ( isHide ) {
			this.bindingElement.style.visibility = "hidden";
		} else {
			this.bindingElement.style.visibility = "visible";
		}
		this._isInvisibilized = !this._isInvisibilized;
	}
}

StageSplitterBinding.prototype = new SplitterBinding;
StageSplitterBinding.prototype.constructor = StageSplitterBinding;
StageSplitterBinding.superclass = SplitterBinding.prototype;

/**
 * @class
 */
function StageSplitterBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "StageSplitterBinding" );
	
	/** 
	 * @type {boolean}
	 */
	this._wasHidden = null;
}

/**
 * Identifies binding.
 */
StageSplitterBinding.prototype.toString = function () {

	return "[StageSplitterBinding]";
}

/**
 * Invoked by the {@link StageDeckBinding} when maximizing occurs.
 * @see {StageDeckBinding#handleControlBoxAction}
 */
StageSplitterBinding.prototype.handleMaximization = function () {
	
	this._wasHidden = !this.isVisible;
	this.bindingElement.style.display = "none"; // why hide-show fail in mozilla?
}

/**
 * Invoked by the {@link StageDeckBinding} when unmaximizing occurs.
 * @see {StageDeckBinding#handleControlBoxAction}
 */
StageSplitterBinding.prototype.handleUnMaximization = function () {
	
	if ( !this._wasHidden ) {
		this.bindingElement.style.display = "block";
		this._wasHidden = null;
	}
}

/**
 * @overloads {SplitterBinding#onDragStart}
 * @param {Point} point
 */
StageSplitterBinding.prototype.onDragStart = function ( point ) {

	var cover = top.app.bindingMap.stagesplittercover;
	var orient = this._containingSplitBoxBinding.getOrient ();
	
	switch ( orient ) {
		case SplitBoxBinding.ORIENT_HORIZONTAL :
			cover.bindingElement.style.cursor = "e-resize";
			break;
		case SplitBoxBinding.ORIENT_VERTICAL :
			cover.bindingElement.style.cursor = "n-resize";
			break;
	}
	cover.show ();
	
	var body = top.app.bindingMap.stagesplitterbody;
	body.setPosition ( this.getPosition ());
	body.setDimension ( this.getDimension ());
	body.setOrient ( orient );
	body.show ();
	
	this.isDragging = true;
}

/**
 * @overloads {SplitterBinding#onDrag}
 * @param {Point} diff
 */
StageSplitterBinding.prototype.onDrag = function ( diff ) {

	this._updateSplitterBodyPosition (
		this.getEvaluatedDiff ( diff )
	);
}

/**
 * @overloads {SplitterBinding#onDragStop}
 * Dispatced action causes containing slitbox to redraw.
 * @see {SplitBoxBinding#handleAction}
 * @param {Point} diff
 */
StageSplitterBinding.prototype.onDragStop = function ( diff ) {

	this._updateSplitterBodyPosition (
		this.getEvaluatedDiff ( diff )
	);
	
	top.app.bindingMap.stagesplitterbody.hide ();
	top.app.bindingMap.stagesplittercover.hide ();
	
	this.isDragging = false;
	this.offset = this._containingSplitBoxBinding.isHorizontalOrient () ? diff.x : diff.y;
	this.dispatchAction ( SplitterBinding.ACTION_DRAGGED );
}

/**
 * @param {Point} diff
 */
StageSplitterBinding.prototype._updateSplitterBodyPosition = function ( diff ) {
	
	var pos = this.getPosition ();
	pos.x += diff.x;
	pos.y += diff.y;
	
	app.bindingMap.stagesplitterbody.setPosition ( pos );
}

/**
 * @return {Position}
 */
StageSplitterBinding.prototype.getPosition = function () {
	
	return DOMUtil.getUniversalPosition ( this.bindingElement );
}

/**
 * @return {Dimension}
 */
StageSplitterBinding.prototype.getDimension = function () {
	
	return new Dimension ( 
		this.bindingElement.offsetWidth, 
		this.bindingElement.offsetHeight 
	);
}

StageSplitterBodyBinding.prototype = new Binding;
StageSplitterBodyBinding.prototype.constructor = StageSplitterBodyBinding;
StageSplitterBodyBinding.superclass = Binding.prototype;

/**
 * When dragging stage splitters, this fellow needs to be rendered  
 * in a top level layer in order to appear above views.
 * @class
 */
function StageSplitterBodyBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "StageSplitterBodyBinding" );
	
	/**
	 * @type {string}
	 */
	this._orient = null;
}

/**
 * Identifies binding.
 */
StageSplitterBodyBinding.prototype.toString = function () {

	return "[StageSplitterBodyBinding]";
}

/**
 * Set orientation. This determines the draggable directions.
 */
StageSplitterBodyBinding.prototype.setOrient = function ( orient ) {
	
	this._orient = orient;
	this.attachClassName ( orient );
}

/**
 * Set position.
 * @param {Position} pos
 */
StageSplitterBodyBinding.prototype.setPosition = function ( pos ) {
	
	var isHorizontal = true;
	var isVertical = true;
	
	switch ( this._orient ) {
		case SplitBoxBinding.ORIENT_HORIZONTAL :
			isVertical = false;
			break;
 		case SplitBoxBinding.ORIENT_VERTICAL :
			isHorizontal = false;
			break;
	}
	if ( isHorizontal ) {
		this.bindingElement.style.left = pos.x + "px";
	}
	if ( isVertical ) {
		this.bindingElement.style.top = pos.y + "px";
	}
}

/**
 * Set dimension.
 * @param {Dimension} dim
 */
StageSplitterBodyBinding.prototype.setDimension = function ( dim ) {
	
	this.bindingElement.style.width = dim.w + "px";
	this.bindingElement.style.height = dim.h + "px";
}

/**
 * Show.
 */
StageSplitterBodyBinding.prototype.show = function () {
	
	this.bindingElement.style.display = "block";
}

/**
 * Hide. This will automatically reset drag session settings.
 * @overwrites {Binding#hide}
 */
StageSplitterBodyBinding.prototype.hide = function () {
	
	this.bindingElement.style.display = "none";
	this.detachClassName ( SplitBoxBinding.ORIENT_HORIZONTAL );
	this.detachClassName ( SplitBoxBinding.ORIENT_VERTICAL );
	this._orient = null;
}


StageBoxAbstraction.ACTION_HIDDENSTUFF_UPDATED = "hidden stagebox stuff updated";

/**
 * @class
 * This class is never instantiated, we just need to borrow it's methods for other 
 * classes. This hack is very javascriptish, but it helps us not to copypaste some code.
 * @see {StageSplitBoxBinding}
 * @see {StageSplitPanelBinding}
 */
function StageBoxAbstraction () {

 	/**
 	 * 
 	 * @type {boolean}
 	 */
	this.isMaximizePrepared = false;
	
	/**
 	 * @type {boolean}
 	 */
	this.isMaximizedForReal = null;
	
	/**
 	 * @type {boolean}
 	 */
	this.isMinimizedForReal = null;
	
	/**
 	 * @type {boolean}
 	 */
	this.isHiddenForReal = null;
}

/**
 * @see {StageSplitBoxBinding#onBindingRegister}
 * @see {StageSplitPanelBinding#onBindingRegister}
 */
StageBoxAbstraction.onBindingRegister = function () {

	this.addActionListener ( ControlBoxBinding.ACTION_MAXIMIZE );
	this.addActionListener ( ControlBoxBinding.ACTION_MINIMIZE );
	this.addActionListener ( ControlBoxBinding.ACTION_NORMALIZE );
	this.addActionListener ( TabBoxBinding.ACTION_UPDATED );
}

/**
 * @see {StageSplitBoxBinding#handleAction}
 * @see {StageSplitPanelBinding#handleAction}
 * @param {Action} action
 */
StageBoxAbstraction.handleAction = function ( action ) {
	
	switch ( action.type ) {
		case ControlBoxBinding.ACTION_MAXIMIZE :
		 	this.isMaximizePrepared = true;
			break;
		case ControlBoxBinding.ACTION_MINIMIZE :
		 	this.isMinimizedForReal = true;
		 	break;
		case ControlBoxBinding.ACTION_NORMALIZE :
		 	this.isMaximizePrepared = false;
		 	this.isMinimizedForReal = null;
		 	break;
		case TabBoxBinding.ACTION_UPDATED : // TODO: DockBinding.ACTION_ACTIVATED?
			if ( action.target instanceof DockBinding ) {
				if ( this.isHiddenForReal ) {
					this.dispatchAction ( 
						StageBoxAbstraction.ACTION_HIDDENSTUFF_UPDATED 
					);
				} else if ( this.isMinimizedForReal ) {
					this.normalize ();
				}
			}
			action.consume ();
			break;
	}
}

/**
 * Maximize. This method is called by the StageCrawler.
 */
StageBoxAbstraction.handleMaximization = function () {

	if ( this.isMaximizePrepared == true ) {
	 	this.isMaximizedForReal = true;
	 	this.isHiddenForReal = false;
	 	this.isFlexible = false;
	 	if ( Client.isMozilla == true ) {
	 		var style = this.bindingElement.style;
	 		style.position	= "absolute";
			style.width		= "100%";
			style.height	= "100%";
			style.top 		= "0";
			style.left 		= "0";
	 	} else {
		 	this.attachClassName ( "maximized" );
	 		if ( this instanceof StageSplitPanelBinding ) {
	 			StageBoxAbstraction._emulateBasicCSS ( this, true );
	 		}
	 	}
	} else {
		this.isMaximizedForReal = false;
		this.isHiddenForReal = true;
		if ( this instanceof StageSplitPanelBinding ) {
			this.invisibilize ( true );
		}
	}
}

/**
 * Unmaximize. This method is called by the StageCrawler.
 */
StageBoxAbstraction.handleUnMaximization = function () {
	
	if ( this.isMaximizedForReal == true ) {
		this.isFlexible = true;
		if ( Client.isMozilla == true ) {
			var style = this.bindingElement.style;
			style.position	= "relative";
			style.width		= "auto";
			style.height	= "auto";
			style.top 		= "auto";
			style.left 		= "auto";
		} else {
			this.detachClassName ( "maximized" );
			if ( this instanceof StageSplitPanelBinding ) {
				StageBoxAbstraction._emulateBasicCSS ( this, false );
			}
		}
	} else {
		if ( this instanceof StageSplitPanelBinding ) {
			this.invisibilize ( false );
		}
	}
	this.isMaximizePrepared = false
	this.isMaximizedForReal = null;
	this.isHiddenForReal = null;
}

/**
 * Explorer sucks. This explains why IE cannot reliably resolve the meaning of  
 * width and height set to 100%. We hack it with Javascript and forget about it.
 * @param {StageSplitPanelBinding} binding
 * @param {boolean} isMimic
 */
StageBoxAbstraction._emulateBasicCSS = function ( binding, isMimic ) {
	
	var style = binding.bindingElement.style;
	var parent = binding.bindingElement.parentNode;
	var box = binding._containingSplitBoxBinding;
	
	if ( Client.isExplorer == true ) {
		if ( isMimic ) {
			binding._unmodifiedFlexMethod = binding.flex;
			binding.flex = function () {
				style.width = parent.offsetWidth + "px";
				style.height = parent.offsetHeight + "px";
			}
		} else {
			style.width = "100%";
			style.height = "100%";
			if ( !box.isHorizontalOrient ()) { // now it gets really painful...
				setTimeout ( function () {
					style.width = "auto";
					style.height = "auto";
					box.reflex ( true );
				}, 0 );
			}
			binding.flex = binding._unmodifiedFlexMethod;
			binding._unmodifiedFlexMethod = null;
		}
	}
}

/*
var s = "StageBoxAbstraction\n\n"
s += "TODO: invisibilize main when unmaximize\n\n";
s += "TODO: Reflex stage on maximize (timeout? max low panels to see)\n\n";
s += "TODO: Reflex stage on unmaximize (maximize, resize, unmaximize to see)";
alert ( s );
*/

/**
 * This class is never instantiated, we just need to borrow it's methods for other 
 * classes (as if this class belonged in the inheritance chain of these classes).
 * This hack is very javascriptish, but it helps us not to copypaste some code.
 * @see {StageDeckBinding}
 * @see {StageBinding}
 */
function StageBoxHandlerAbstraction () {

	/**
	 * @type {boolean}
	 */
	this.isSubPanelMaximized = false;
}

/**
 * Registering listeners for maximization and unmaximization of panels.
 */
StageBoxHandlerAbstraction.onBindingRegister = function () {

	this.addActionListener ( ControlBoxBinding.ACTION_MAXIMIZE, this );
	this.addActionListener ( ControlBoxBinding.ACTION_NORMALIZE, this );
	this.addActionListener ( StageBoxAbstraction.ACTION_HIDDENSTUFF_UPDATED, this );
	this.addActionListener ( StageSplitPanelBinding.ACTION_LAYOUTUPDATE, this );
}

/**
 * @param {Action} action
 */
StageBoxHandlerAbstraction.handleAction = function ( action ) {
	
	var binding = action.target;
	
	switch ( action.type ) {
		case ControlBoxBinding.ACTION_MAXIMIZE :
		case ControlBoxBinding.ACTION_NORMALIZE :
			if ( binding instanceof StageSplitPanelBinding ) {
				StageBoxHandlerAbstraction.handleControlBoxAction.call ( this, action );
				action.consume ();
			}
			break;
		
		case StageBoxAbstraction.ACTION_HIDDENSTUFF_UPDATED :
			if ( this.isSubPanelMaximized ) {
				/*
				var filter = StageBoxHandlerAbstraction.unMaximizeFilter;
				*/
				this.iterateContainedStageBoxBindings ( StageCrawler.MODE_UNMAXIMIZE );
				this.isSubPanelMaximized = false;
			}
			action.consume ();
			break;
		
		/*
		 * see {StageBinding#handleAction}
		 */
		case StageSplitPanelBinding.ACTION_LAYOUTUPDATE :
		 	break;
	}
}

/**
 * Handle {@link ControlBoxBinding} actions.
 * @param {Action} action
 * @return {function}
 */
StageBoxHandlerAbstraction.handleControlBoxAction = function ( action ) {
	
	var mode = null;
	
	switch ( action.type ) {
		case ControlBoxBinding.ACTION_MAXIMIZE :
			if ( !this.isSubPanelMaximized ) {
				mode = StageCrawler.MODE_MAXIMIZE;
				this.isSubPanelMaximized = true;
			}
			break;
		case ControlBoxBinding.ACTION_NORMALIZE :
			if ( this.isSubPanelMaximized ) {
				mode = StageCrawler.MODE_UNMAXIMIZE;
				this.isSubPanelMaximized = false;
			}
			break;
	}
	if ( mode != null ) {
		this.iterateContainedStageBoxBindings ( mode );
	}
}

StageMenuBarBinding.prototype = new MenuBarBinding;
StageMenuBarBinding.prototype.constructor = StageMenuBarBinding;
StageMenuBarBinding.superclass = MenuBarBinding.prototype;

/**
 * @class
 */
function StageMenuBarBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "StageMenuBarBinding" );
	
	/**
	 * @type {SystemNode}
	 */
	this._rootNode = null;
}

/**
 * Identifies binding.
 */
StageMenuBarBinding.prototype.toString = function () {
	
	return "[StageMenuBarBinding]";
}

/**
 * Intercept for system-hooked menuitem commands.
 * @overloads {Binding#onBindingAttach}
 */
StageMenuBarBinding.prototype.onBindingAttach = function () {
	
	StageMenuBarBinding.superclass.onBindingAttach.call ( this );
	if ( System.hasActivePerspectives ) {
		this.addActionListener ( MenuItemBinding.ACTION_COMMAND );
	} else {
		Binding.prototype.hide.call ( this ); // this.hide () burned by MenuContainerBinding#hide
	}
}


/** 
 * Invoke system actions. These are hardwired to act on the root SystemNode.
 * @implements {IActionListener}
 * @overloads {MenuBarBinding#handleAction}
 * @param {Action} action
 */
StageMenuBarBinding.prototype.handleAction = function ( action ) {
	
	StageMenuBarBinding.superclass.handleAction.call ( this, action );
	
	switch ( action.type ) {
		case MenuItemBinding.ACTION_COMMAND :
			var systemAction = action.target.associatedSystemAction;
			if ( Application.isLoggedIn ) { // otherwise this will trigger when "Exit" is pressed.
				if ( !this._rootNode ) {
					this._rootNode = System.getRootNode ();
				}
				if ( systemAction ) {
					SystemAction.invoke ( systemAction, this._rootNode );
				}
			}
			action.consume ();
			break;
	}
}

StageViewMenuItemBinding.prototype = new MenuItemBinding;
StageViewMenuItemBinding.prototype.constructor = StageViewMenuItemBinding;
StageViewMenuItemBinding.superclass = MenuItemBinding.prototype;

/**
 * @class
 */
function StageViewMenuItemBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "StageViewMenuItemBinding" );
	
	/**
	 * @type {string}
	 */
	this._handle = null;
}

/**
 * Identifies binding.
 */
StageViewMenuItemBinding.prototype.toString = function () {

	return "[StageViewMenuItemBinding]";
}

/**
 * @overloads {MenuItemBinding.#onBindingAttach}
 */
StageViewMenuItemBinding.prototype.onBindingAttach = function () {

	StageViewMenuItemBinding.superclass.onBindingAttach.call ( this );
	
	if ( this.type == MenuItemBinding.TYPE_CHECKBOX ) {
		this.subscribe ( BroadcastMessages.VIEW_OPENED );
		this.subscribe ( BroadcastMessages.VIEW_CLOSED );
		this.subscribe ( BroadcastMessages.STAGE_INITIALIZED );
	}
}

/**
 * @overloads {MenuItemBinding#buildDOMContent}
 */
StageViewMenuItemBinding.prototype.buildDOMContent = function () {
 	
	StageViewMenuItemBinding.superclass.buildDOMContent.call ( this );
	
	var handle = this.getProperty ( "handle" );
	if ( handle ) {
		
		this._handle = handle;
		
		if ( StageBinding.isViewOpen ( handle )) {
			if ( this.type == MenuItemBinding.TYPE_CHECKBOX ) {
				this.check ( true );
			}
		}
		this.oncommand = function () {
			var self = this;
			Application.lock ( self );
			setTimeout ( function () {
				StageBinding.handleViewPresentation ( handle );
				Application.unlock ( self );
			}, Client.hasTransitions ? Animation.DEFAULT_TIME : 0 );
		}
		
	} else {
		throw new Error ( "StageViewMenuItemBinding: missing handle" );
	}
}

/**
 * Set handle.
 * @param {string} handle
 */
StageViewMenuItemBinding.prototype.setHandle = function ( handle ) {
	
	this.setProperty ( "handle", handle );
}

/*
 * @implements {IBroadcastListener}
 * @param {string} message
 * @param {object} arg
 */
StageViewMenuItemBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	StageViewMenuItemBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	if ( this.type == MenuItemBinding.TYPE_CHECKBOX ) {
		switch ( broadcast ) {
			case BroadcastMessages.STAGE_INITIALIZED :
				if ( this.isChecked ) {
					this.fireCommand ();
				}
				break;
			case BroadcastMessages.VIEW_OPENED :
				if ( arg == this._handle ){
					this.check ( true );
				}
				break;
			case BroadcastMessages.VIEW_CLOSED :
				if ( arg == this._handle ){
					this.uncheck ( true );
				}
				break;
		}
	}
}

/**
 * StageViewMenuItemBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {StageViewMenuItemBinding}
 */
StageViewMenuItemBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:menuitem", ownerDocument );
	UserInterface.registerBinding ( element, StageViewMenuItemBinding );
	return UserInterface.getBinding ( element );
}

StageStatusBarBinding.prototype = new ToolBarBinding;
StageStatusBarBinding.prototype.constructor = StageStatusBarBinding;
StageStatusBarBinding.superclass = ToolBarBinding.prototype;

/**
 * @class
 */
function StageStatusBarBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "StageStatusBarBinding" );
	
	/**
	 * @type {ToolBarLabelBinding}
	 */
	this._label = null;
}

/**
 * Identifies binding.
 */
StageStatusBarBinding.prototype.toString = function () {
	
	return "[StageStatusBarBinding]";
}

/**
 * Initialize top level StatusBar object when ready.
 * @overloads {Binding#onBindingInitialize} binding
 */
StageStatusBarBinding.prototype.onBindingInitialize = function () {
	
	this._label = this.bindingWindow.bindingMap.statusbarlabel;
	StatusBar.initialize ( this );
	StageStatusBarBinding.superclass.onBindingInitialize.call ( this );
}

/**
 * Set statusbar text.
 * @param {string} message
 */
StageStatusBarBinding.prototype.setLabel = function ( message ) {
	
	this._label.setLabel ( message );
}

/**
 * Set statusbar image.
 * @param {string} image
 */
StageStatusBarBinding.prototype.setImage = function ( image ) {
	
	this._label.setImage ( image );
}

/**
 * Clear statusbar.
 * @param {string} image
 */
StageStatusBarBinding.prototype.clear = function () {
	
	this._label.setLabel ( null );
	this._label.setImage ( false );
}

/**
 * Fade out after a given amount of time. 
 * TODO: IMPLEMENT THIS!
 * @param {int} timeout
 */
StageStatusBarBinding.prototype.startFadeOut = function ( timeout ) {
	
	this.logger.debug ( "START FADEOUT" );
}

ExplorerBinding.prototype = new FlexBoxBinding;
ExplorerBinding.prototype.constructor = ExplorerBinding;
ExplorerBinding.superclass = FlexBoxBinding.prototype;
ExplorerBinding.ACTION_INITIALIZED = "explorer initialized";
ExplorerBinding.ACTION_DECK_LOADED = "explorer deck loaded";

/*
 * Perspective tags.
 * TODO: These should be updated to something more ... particular!
 */
ExplorerBinding.PERSPECTIVE_CONTENT		= "Content";
ExplorerBinding.PERSPECTIVE_MEDIA 		= "Media";
ExplorerBinding.PERSPECTIVE_DATA 		= "Datas";
ExplorerBinding.PERSPECTIVE_DESIGN 		= "Design";
ExplorerBinding.PERSPECTIVE_FUNCTIONS 	= "Functions";
ExplorerBinding.PERSPECTIVE_USERS 		= "Users";
ExplorerBinding.PERSPECTIVE_SYSTEM 		= "System";

/**
 * Static reference to the ExplorerBinding instance. Assigned on startup.
 * @see {ExplorerBinding#onBindingInitialize}
 * @type {ExplorerBinding}
 */
ExplorerBinding.bindingInstance = null;

/**
 * Get focused treenodes.
 * @return {List}
 */
ExplorerBinding.getFocusedTreeNodeBindings = function () {
	
	var selectedDeck = ExplorerBinding.bindingInstance.getSelectedDeckBinding ();
	var selectedView = selectedDeck.getAssociatedView ();
	var selectedTree = selectedView.getContentWindow ().bindingMap.tree;
	return selectedTree.getFocusedTreeNodeBindings ();
}

/**
 * @class
 */
function ExplorerBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ExplorerBinding" );

	/**
	 * @type {ExplorerDecksBinding}
	 */
	this._decksBinding = null;
	
	/**
	 * @type {ExplorerMenuBinding}
	 */
	this._menuBinding = null;
	
	/**
	 * @type {ExplorerSplitterBinding}
	 */
	this._splitterBinding = null;
	
	/**
	 * @type {int}
	 */
	this._dragStart = 0;
	
	/**
	 * @type {int}
	 */
	this._dragSlot = 0;
	
	/**
	 * @type {int}
	 */	
	this._dragHeight = 0;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
ExplorerBinding.prototype.toString = function () {

	return "[ExplorerBinding]";
}

/**
 * @overloads {Binding#onBindingAttach}
 */
ExplorerBinding.prototype.onBindingAttach = function () {
	
	ExplorerBinding.superclass.onBindingAttach.call ( this );
	
	this.addActionListener ( ExplorerMenuBinding.ACTION_SELECTIONCHANGED );
	this.addActionListener ( ViewBinding.ACTION_LOADED );
	this.addActionListener ( Binding.ACTION_DRAG );

	this._decksBinding = this.addMember ( 
		this.getDescendantBindingByLocalName ( "explorerdecks" )
	);
	this._splitterBinding = this.addMember ( 
		this.getDescendantBindingByLocalName ( "explorersplitter" )
	);
	this._menuBinding = this.addMember ( 
		this.getDescendantBindingByLocalName ( "explorermenu" )
	);
}

/**
 * @overloads {Binding#onBindingInitialize}
 */
ExplorerBinding.prototype.onBindingInitialize = function () {
	
	ExplorerBinding.bindingInstance = this;
	ExplorerBinding.superclass.onBindingInitialize.call ( this );
	this.dispatchAction ( ExplorerBinding.ACTION_INITIALIZED );
}

/**
 * @implements {IActionListener}
 * @overloads {FlexBoxBinding#handleAction}
 * @param {Action} action
 */
ExplorerBinding.prototype.handleAction = function ( action ) {
	
	ExplorerBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	
	switch ( action.type ) {
	
		case ExplorerMenuBinding.ACTION_SELECTIONCHANGED :
			this._decksBinding.setSelectionByHandle ( 
				this._menuBinding.getSelectionHandle ()
			);
			var tag = this._menuBinding.getSelectionTag ();
			EventBroadcaster.broadcast ( BroadcastMessages.PERSPECTIVE_CHANGED, tag );
			break;
			
		case ViewBinding.ACTION_LOADED :
			this.dispatchAction ( ExplorerBinding.ACTION_DECK_LOADED );
			action.consume ();
			break;
			
		case Binding.ACTION_DRAG :
			if ( binding instanceof ExplorerSplitterBinding ) {
				binding.dragger.registerHandler ( this );
			}
			action.consume ();
	}
}

/**
 * Set selection by handle.
 * @param {string} handle
 */
ExplorerBinding.prototype.setSelectionByHandle = function ( handle ) {

	this._menuBinding.setSelectionByHandle ( handle );
}

/**
 * Selecting default (the first button).
 */
ExplorerBinding.prototype.setSelectionDefault = function () {
	
	this._menuBinding.setSelectionDefault ();
}

/**
 * Get selected deck.
 * @return {DeckBinding}
 */
ExplorerBinding.prototype.getSelectedDeckBinding = function () {
	
	return this._decksBinding.getSelectedDeckBinding ();
}

/**
 * Building explorer content on startup.
 * @param {SystemViewDefinition} definition
 */
ExplorerBinding.prototype.mountDefinition = function ( definition ) {
	
	if ( definition instanceof SystemViewDefinition ) {
		this._decksBinding.mountDefinition ( definition );
		this._menuBinding.mountDefinition ( definition );
	} else {
		throw new Error ( "ExplorerBinding: No such ViewDefinition supported" );
	}
}


/**
 * Start splitter drag.
 * @implements {IDragHandler}
 * @param {Point} point
 */
ExplorerBinding.prototype.onDragStart = function ( point ) {
	
	var buttons = this._menuBinding.getDescendantBindingsByLocalName ( "explorertoolbarbutton" );
	
	if ( buttons.hasEntries ()) {
		
		var button = buttons.getFirst ();
		this._dragStart = button.boxObject.getLocalPosition ().y;
		this._dragSlot = 0;
		
		if ( this._dragHeight == 0 ) {
			this._dragHeight = button.boxObject.getDimension ().h;
		}
		
		this.bindingWindow.bindingMap.explorercover.show ();
	}
}

/**
 * On splitter drag.
 * @implements {IDragHandler}
 * @param {Point} diff
 */
ExplorerBinding.prototype.onDrag = function ( diff ) {
	
	var y = this._dragStart + diff.y;
	
	/*
	 * Show less?
	 */
	if ( y > this._dragStart + this._dragSlot + this._dragHeight ) {
		if ( this._menuBinding.showLess ()) {
			this._decksBinding.expandBy ( this._dragHeight);
			this._dragSlot += this._dragHeight;
		}
	}
	
	/*
	 * Show more?
	 */
	if ( y < this._dragStart + this._dragSlot ) {
		if ( this._menuBinding.showMore ()) {
			this._decksBinding.expandBy ( - this._dragHeight);
			this._dragSlot -= this._dragHeight;
		}
	}
}

/**
 * Stop splitter drag.
 * @implements {IDragHandler}
 * @param {Point} diff
 */
ExplorerBinding.prototype.onDragStop = function ( diff ) {

	this.bindingWindow.bindingMap.explorercover.hide ();
}

ExplorerDecksBinding.prototype = new DecksBinding;
ExplorerDecksBinding.prototype.constructor = ExplorerDecksBinding;
ExplorerDecksBinding.superclass = DecksBinding.prototype;
ExplorerDecksBinding.NODENAME_DECK = "explorerdeck";

/**
 * @class
 */
function ExplorerDecksBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ExplorerDecksBinding" );
	
	/**
	 * Associating handles to decks.
	 * @type {HashMap<string><ExplorerDeckBinding>} 
	 */
	this._decks = {};
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * @overloads {DecksBinding#onBindingAttach}
 */
ExplorerDecksBinding.prototype.onBindingAttach = function () {
	
	ExplorerDecksBinding.superclass.onBindingAttach.call ( this );
	this.addActionListener ( PageBinding.ACTION_ATTACHED );
	// this.dispatchAction ( Binding.ACTION_ATTACHED );
}

/**
 * Identifies binding.
 */
ExplorerDecksBinding.prototype.toString = function () {

	return "[ExplorerDecksBinding]";
}

/**
 * Building decks on startup.
 * @param {SystemViewDefinition} definition
 */
ExplorerDecksBinding.prototype.mountDefinition = function ( definition ) {

	if ( definition instanceof SystemViewDefinition ) {
	
		// construct ViewBinding
		var viewBinding = ViewBinding.newInstance ( this.bindingDocument );
		viewBinding.setType ( ViewBinding.TYPE_EXPLORERVIEW );
		viewBinding.setDefinition ( definition );
		
		// construct DeckBinding
		var deckBinding = ExplorerDeckBinding.newInstance ( this.bindingDocument );
		deckBinding.setAssociatedView ( viewBinding );
		this._decks [ definition.handle ] = deckBinding;
		
		// append
		deckBinding.add ( viewBinding );
		this.add ( deckBinding );
		
		// attach
		deckBinding.attach ();
		viewBinding.attach ();
	}
}

/**
 * @param {string} handle
 */
ExplorerDecksBinding.prototype.setSelectionByHandle = function ( handle ) {
	
	var deckBinding = this._decks [ handle ];
	this.select ( deckBinding );
}

/**
 * Emulates recursive flex, but performs faster.
 * @param {int} pixels
 */
DecksBinding.prototype.expandBy = function ( pixels ) {
	
	var deck = this.getSelectedDeckBinding ();
	if ( deck ) {
		var height = this.bindingElement.offsetHeight + pixels;
		var view = deck.getAssociatedView ();
		this.bindingElement.style.height = height + "px";
		this.reflex ( true );
	}
}

/**
 * ExplorerDecksBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {ExplorerDecksBinding}
 */
ExplorerDecksBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:explorerdecks", ownerDocument );
	return UserInterface.registerBinding ( element, ExplorerDecksBinding );
}

ExplorerDeckBinding.prototype = new DeckBinding;
ExplorerDeckBinding.prototype.constructor = ExplorerDeckBinding;
ExplorerDeckBinding.superclass = DeckBinding.prototype;
ExplorerDeckBinding.NODENAME_DECKS = "explorerdecks";

/**
 * @class
 */
function ExplorerDeckBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ExplorerDeckBinding" );
	
	/**
	 * Entitytoken of the associated SystemNode.
	 */
	this._entityToken = null;
	
	/**
	 * If true, contained tree needs to be refreshed.
	 * @type {boolean}
	 */
	this._isRefreshRequired = false;
	
	/**
	 * @type {ViewBinding}
	 */
	this._viewBinding = null;
	
	/**
	 * Flipped when viewbinding is loaded.
	 * @type {boolean}
	 */
	this._isExplorerDeckBindingInitialized = false;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
ExplorerDeckBinding.prototype.toString = function () {

	return "[ExplorerDeckBinding]";
}

/**
 * @overloads {DeckBinding#onBindingRegister}
 */
ExplorerDeckBinding.prototype.onBindingRegister = function () {
	
	ExplorerDeckBinding.superclass.onBindingRegister.call ( this );
	this.subscribe ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHALL );
}

/**
 * Set associated ViewBinding.
 * @param {ViewBinding} viewBinding
 */
ExplorerDeckBinding.prototype.setAssociatedView = function ( viewBinding ) {
	
	this._viewBinding = viewBinding;
}

/**
 * Get associated ViewBinding.
 * @return {ViewBinding}
 */
ExplorerDeckBinding.prototype.getAssociatedView = function () {
	
	return this._viewBinding;
}

/**
 * @overloads {DeckBinding#select}
 */
ExplorerDeckBinding.prototype.select = function () {
	
	if ( !this._isExplorerDeckBindingInitialized ) {
	
		/*
		 * Lock app and update statusbar
		 */
		Application.lock ( this );
		var message = StringBundle.getString ( "ui", "Website.App.StatusBar.Loading" );
		var label = this._viewBinding.getDefinition ().label;
		StatusBar.busy ( message, [ label ]);
		
		/*
		 * Mount the show.
		 */
		this.bindingWindow.bindingMap.explorerdeckscover.show ();
		this.addActionListener ( PageBinding.ACTION_INITIALIZED );
		this._viewBinding.initialize ();
	}
	
	/*
	 * Refresh tree required? If yes, the deck will  
	 * be selected when the tree is done refreshing. 
	 */
	if ( this._isRefreshRequired == true ) {
		this._refreshTree ();
		this._isRefreshRequired = false;
	} else {
	
		/*
		 * This will force a change of label and image on related 
		 * containing DockTabBinding. See ILabel methods below.
		 */
		ExplorerDeckBinding.superclass.select.call ( this );
		this.dispatchAction ( DockTabBinding.ACTION_UPDATE_VISUAL );
	}
}

/**
 * @implements {IActionListener}
 * @overloads {DeckBinding#handleAction}
 * @param {Action} action
 */
ExplorerDeckBinding.prototype.handleAction = function ( action ) {
	
	ExplorerDeckBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	
	switch ( action.type ) {
		case PageBinding.ACTION_INITIALIZED :
			if ( binding instanceof SystemPageBinding ) {
				this._isExplorerDeckBindingInitialized = true;
				this._entityToken = binding.node.getEntityToken ();
				this.removeActionListener ( PageBinding.ACTION_INITIALIZED );
				this.bindingWindow.bindingMap.explorerdeckscover.hide ();
				this.dispatchAction ( DockTabBinding.ACTION_UPDATE_VISUAL );
				Application.unlock ( this );
				if ( StatusBar.state == StatusBar.BUSY ) {
					StatusBar.clear ();
				}
			}
			break;
	}
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
ExplorerDeckBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	ExplorerDeckBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		
		case BroadcastMessages.SYSTEMTREEBINDING_REFRESHALL :
			if ( this.isSelected == true ) {
				this._refreshTree ();
			} else if ( this._entityToken != null ) {
				this._isRefreshRequired = true;
			}
			break;
			
		case BroadcastMessages.SYSTEMTREEBINDING_REFRESHED :
			this.unsubscribe ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHED );
			this.select ();
			break;
	}
}

/**
 * Refresh the contained tree.
 */
ExplorerDeckBinding.prototype._refreshTree = function () {
	
	/*
	 * The broadcast will be intercepted by SystemPageBinding. 
	 */
	if ( this._entityToken != null ) {
		this.subscribe ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHED );
		EventBroadcaster.broadcast ( 
			BroadcastMessages.SYSTEMTREEBINDING_REFRESH, 
			this._entityToken 
		);
	}
}

/**
 * Collapse the contained tree.
 */
ExplorerDeckBinding.prototype._collapseTree = function () {
	
	alert ( "ExplorerDeckBinding: collapse tree!" );
}

/**
 * @implements {ILabel}
 * @return {string}
 */
ExplorerDeckBinding.prototype.getLabel = function () {
	
	var result = null;
	if ( this._isExplorerDeckBindingInitialized ) {
		result = this._viewBinding.getDefinition ().label;
	} else {
		result = DockTabBinding.LABEL_TABLOADING;
	}
	return result;
}

/** 
 * @implements {ILabel}
 * @return {string}
 */
ExplorerDeckBinding.prototype.getImage = function () {

	var result = null;
	if ( this._isExplorerDeckBindingInitialized ) {
		result = this._viewBinding.getDefinition ().image;
	} else {
		result = DockTabBinding.IMG_TABLOADING;
	}
	return result;
}

/**
 * @implements {ILabel}
 * @return {string}
 */
ExplorerDeckBinding.prototype.getToolTip = function () {

	var result = null;
	if ( this._isExplorerDeckBindingInitialized ) {
		result = this._viewBinding.getDefinition ().toolTip;
	}
	return result;
}

/**
 * ExplorerDeckBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {ExplorerDeckBinding}
 */
ExplorerDeckBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:explorerdeck", ownerDocument );
	return UserInterface.registerBinding ( element, ExplorerDeckBinding );
}

ExplorerSplitterBinding.prototype = new Binding;
ExplorerSplitterBinding.prototype.constructor = ExplorerSplitterBinding;
ExplorerSplitterBinding.superclass = Binding.prototype;

/**
 * @class
 */
function ExplorerSplitterBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ExplorerSplitterBinding" );
	
	/** 
	 * @overloads {Binding#isDraggable}
	 * @type {boolean}
	 */
	this.isDraggable = true;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
ExplorerSplitterBinding.prototype.toString = function () {

	return "[ExplorerSplitterBinding]";
}

/**
 * @overloads {Binding#onBindingAttach}
 *
ExplorerSplitterBinding.prototype.onBindingAttach = function () {
	
	ExplorerSplitterBinding.superclass.onBindingAttach.call ( this );
	this.dispatchAction ( Binding.ACTION_ATTACHED );
}
*/

ExplorerMenuBinding.prototype = new Binding;
ExplorerMenuBinding.prototype.constructor = ExplorerMenuBinding;
ExplorerMenuBinding.superclass = Binding.prototype;
ExplorerMenuBinding.ACTION_SELECTIONCHANGED = "explorermenu selectionchanged";

/**
 * @class
 */
function ExplorerMenuBinding () { 

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ExplorerMenuBinding" );
	
	/** 
	 * Associating buttons to handles.
	 * @type {Map<string><ExplorerToolBarButtonBinding>}
	 */
	this._maxButtons = new Map ();
	
	/**
	 * @type {List<ExplorerToolBarButtonBinding}
	 */
	this._maxList = new List ();
	
	/** 
	 * Associating buttons to handles.
	 * @type {Map<string><ToolBarButtonBinding>}
	 */
	this._minButtons = new Map ();
	
	/**
	 * @type {List<ToolBarButtonBinding}
	 */
	this._minList = new List ();
	
	/**
	 * @type {int}
	 */
	this._index = -1;
	
	/**
	 * The big toolbargroup
	 * @type {ToolBarGroupBinding}
	 */
	this._maxGroup= null;
	
	/**
	 * The small toolbargroup
	 * @type {ToolBarGroupBinding}
	 */
	this._minGroup = null;
	
	/**
	 * @type {string}
	 */
	this._selectedHandle = null;
	
	/**
	 * @type {string}
	 */
	this._selectedTag = null;
	
}

/**
 * Identifies binding.
 */
ExplorerMenuBinding.prototype.toString = function () {

	return "[ExplorerMenuBinding]";
}

/**
 * @overloads {Binding#onBindingRegister}
 */
ExplorerMenuBinding.prototype.onBindingRegister = function () {

	ExplorerMenuBinding.superclass.onBindingRegister.call ( this );
	this.addActionListener ( RadioGroupBinding.ACTION_SELECTIONCHANGED, this );
}

/**
 * @overloads {Binding#onBindingAttach}
 */
ExplorerMenuBinding.prototype.onBindingAttach = function () {

	ExplorerMenuBinding.superclass.onBindingAttach.call ( this );
	this.addMember ( this.getChildBindingByLocalName ( "explorertoolbar" ));
	this.addMember ( this.getChildBindingByLocalName ( "toolbar" ));
}

/**
 * @overloads {Binding#onMemberInitialize}
 * @param {Binding} binding
 */
ExplorerMenuBinding.prototype.onMemberInitialize = function ( binding ) {
	
	switch ( binding.constructor ) {
		case ExplorerToolBarBinding :
			this._maxGroup= binding.getToolBarGroupByIndex ( 0 );
			break;
		case ToolBarBinding :
			this._minGroup = binding.getToolBarGroupByIndex ( 0 );
			break;
	}
	ExplorerMenuBinding.superclass.onMemberInitialize.call ( this, binding );
}

/**
 * Mount viewDefinition, building menu items.
 * @param {SystemViewDefinition} definition
 */
ExplorerMenuBinding.prototype.mountDefinition = function ( definition ) {

	this._maxButtons.set ( definition.handle, this._mountMaxButton ( definition ));
	this._minButtons.set ( definition.handle, this._mountMinButton ( definition ));
	this._index ++;
}

/**
 * Building big menubutton.
 * @param {SystemViewDefinition} definition
 * @return {ExplorerToolBarButtonBinding}
 */
ExplorerMenuBinding.prototype._mountMaxButton = function ( definition ) {
	
	var button = ExplorerToolBarButtonBinding.newInstance ( 
		this.bindingDocument,
		ExplorerToolBarButtonBinding.TYPE_LARGE
	);
	button.setLabel ( definition.label );
	button.setToolTip ( definition.toolTip );
	button.handle = definition.handle;
	button.node = definition.node;
	this._maxGroup.add ( button );
	this._maxList.add ( button );
	button.attach ();
	return button;
}

/**
 * Building small menubutton.
 * @param {SystemViewDefinition} definition
 * @return {ExplorerToolBarButtonBinding}
 */
ExplorerMenuBinding.prototype._mountMinButton = function ( definition ) {

	var button = ExplorerToolBarButtonBinding.newInstance ( 
		this.bindingDocument,
		ExplorerToolBarButtonBinding.TYPE_NORMAL
	);
	button.setLabel ( definition.label );
	button.setToolTip ( definition.label ); // use label as tooltip
	button.handle = definition.handle;
	button.node = definition.node;
	this._minGroup.addFirst ( button );
	this._minList.add ( button );
	button.attach ();
	button.hide (); // note that we hide small buttons on startup!
	return button;
}

/**
 * Fires when selection changes in either one of the menus.
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
ExplorerMenuBinding.prototype.handleAction = function ( action ) {

	ExplorerMenuBinding.superclass.handleAction.call ( this, action );
	
	switch ( action.type ) {
		case RadioGroupBinding.ACTION_SELECTIONCHANGED :
		
			var radioGroupBinding = action.target;
			var buttonBinding = radioGroupBinding.getCheckedButtonBinding ();
			var handle = buttonBinding.handle;
	
			switch ( radioGroupBinding ) {
				case this._maxGroup:
					this._minGroup.setCheckedButtonBinding ( 
						this._minButtons.get ( handle ), true 
					);
					break;
				case this._minGroup :
					this._maxGroup.setCheckedButtonBinding ( 
						this._maxButtons.get ( handle ), true 
					);
					break;
			}
			
			this._selectedHandle = handle;
			this._selectedTag = buttonBinding.node.getTag ();
			this.dispatchAction ( ExplorerMenuBinding.ACTION_SELECTIONCHANGED );
			action.consume ();
			break;
	}
}

/**
 * Set selection by handle.
 * @param {string} handle
 */
ExplorerMenuBinding.prototype.setSelectionByHandle = function ( handle ) { 

	var buttonBinding = this._maxButtons.get ( handle );
	
	if ( buttonBinding ) {
		buttonBinding.check ();
	} else {
		this.setSelectionDefault ();
	}
}

/**
 * Get handle on selected viewDefinition.
 * @return {string}
 */
ExplorerMenuBinding.prototype.getSelectionHandle = function () { 

	return this._selectedHandle;
}

/**
 * Get tag on selected viewDefinition (or the SystemNode associated to it).
 * @return {string}
 */
ExplorerMenuBinding.prototype.getSelectionTag = function () {

	return this._selectedTag;
}

/**
 * Selecting first button by default.
 */
ExplorerMenuBinding.prototype.setSelectionDefault = function () {

	if ( this._maxList.hasEntries ()) {
		this._maxList.getFirst ().check ();
	}
}

/**
 * Show more.
 * @return {boolean} True if something changed.
 */
ExplorerMenuBinding.prototype.showMore = function () {
	
	var isUpdated = false;
	var max = this._maxList.getLength () - 1;
	
	if ( !this._maxList.get ( max ).isVisible ) {
		this._index ++;
		this._maxList.get ( this._index ).show ();
		this._minList.get ( this._index ).hide ();
		isUpdated = true;
	}
	return isUpdated;
}

/**
 * Show less.
 * @return {boolean} True if something changed.
 */
ExplorerMenuBinding.prototype.showLess = function () {
	
	var isUpdated = false;
	
	if ( this._maxList.get ( 0 ).isVisible ) {
		this._maxList.get ( this._index ).hide ();
		this._minList.get ( this._index ).show ();
		this._index --;
		isUpdated = true;
	}
	return isUpdated;
}

ExplorerToolBarBinding.prototype = new ToolBarBinding;
ExplorerToolBarBinding.prototype.constructor = ExplorerToolBarBinding;
ExplorerToolBarBinding.superclass = ToolBarBinding.prototype;

/**
 * @class
 */
function ExplorerToolBarBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ExplorerToolBarBinding" );
	
	/**
	 * No default content. Toolbar should be completely collapsible.
	 * @overwrites {ToolBarBinding#_hasDefaultContent}
	 * @type {boolean}
	 */
	this._hasDefaultContent = false;
}

/**
 * Identifies binding.
 */
ExplorerToolBarBinding.prototype.toString = function () {

	return "[ExplorerToolBarBinding]";
}

/**
 * Show large icons.
 */
ExplorerToolBarBinding.prototype.onBindingRegister = function () {
	
	ExplorerToolBarBinding.superclass.onBindingRegister.call ( this );
	this.setImageSize ( ToolBarBinding.IMAGESIZE_LARGE );
	
}

/**
 * ExplorerToolBarBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {ExplorerToolBarBinding}
 */
ExplorerToolBarBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:explorertoolbar", ownerDocument );
	return UserInterface.registerBinding ( element, ExplorerToolBarBinding );
}

ExplorerToolBarButtonBinding.prototype = new ToolBarButtonBinding;
ExplorerToolBarButtonBinding.prototype.constructor = ExplorerToolBarButtonBinding;
ExplorerToolBarButtonBinding.superclass = ToolBarButtonBinding.prototype;
ExplorerToolBarButtonBinding.TYPE_NORMAL = "normal";
ExplorerToolBarButtonBinding.TYPE_LARGE = "large";

/**
 * @class
 */
function ExplorerToolBarButtonBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ExplorerToolBarButtonBinding" );
	
	/** 
	 * @type {boolean}
	 */
	this.isRadioButton = true;
	
	/** 
	 * @type {string}
	 */
	this.explorerToolBarButtonType = null;
	
	/**
	 * This property is set by the {@link ExplorerMenuBinding}
	 * @type {SystemNode}
	 */
	this.node = null;
}

/**
 * Identifies binding.
 */
ExplorerToolBarButtonBinding.prototype.toString = function () {

	return "[ExplorerToolBarButtonBinding]";
}

/**
 * Compute button image.
 * @overloads {Binding#onBindingAttach}
 */
ExplorerToolBarButtonBinding.prototype.onBindingAttach = function () {
	
	var isLargeButton = this.explorerToolBarButtonType == ExplorerToolBarButtonBinding.TYPE_LARGE;
	var imageSizeParameter = isLargeButton ? ToolBarBinding.IMAGESIZE_LARGE : ToolBarBinding.IMAGESIZE_NORMAL;
	this.imageProfile = this.node.getImageProfile ( imageSizeParameter );
	ExplorerToolBarButtonBinding.superclass.onBindingAttach.call ( this );
}

/**
 * ExplorerToolBarButtonBinding factory.
 * @param {DOMDocument} ownerDocument
 * @param {string} explorerToolBarButtonType
 * @return {ExplorerToolBarButtonBinding}
 */
ExplorerToolBarButtonBinding.newInstance = function ( ownerDocument, explorerToolBarButtonType ) {

	var nodename = ( 
		explorerToolBarButtonType == ExplorerToolBarButtonBinding.TYPE_LARGE ? 
		 	"ui:explorertoolbarbutton" :
		 	"ui:toolbarbutton"
	);
	
	var element = DOMUtil.createElementNS ( Constants.NS_UI, nodename, ownerDocument );
	var binding = UserInterface.registerBinding ( element, ExplorerToolBarButtonBinding );
	binding.explorerToolBarButtonType = explorerToolBarButtonType;
	return binding;
}

EditorBinding.prototype = new WindowBinding;
EditorBinding.prototype.constructor = EditorBinding;
EditorBinding.superclass = WindowBinding.prototype;

/**
 * Subclasses should define these.
 */
EditorBinding.ACTION_ATTACHED = null;

/**
 * Clipboard security configuration dialog URL.
 */
EditorBinding.URL_DIALOG_MOZ_CONFIGURE = "${root}/content/dialogs/wysiwygeditor/mozsecuritynote/mozsecuritynote.aspx";

/**
 * The number of the beast.
 * @type {int}
 */
EditorBinding.ABSURD_NUMBER = -999999999;

/**
 * Used to preserve line-break entity &#xA; in source code. 
 * @type {String}
 */
EditorBinding.LINE_BREAK_ENTITY_HACK = "C1.LINE.BREAK.ENTITY.HACK";



// EDITITOR COMPONENT STUFF ..............................................

/**
 * Considered private to the EditorBinding.
 * @type {Map<string><List<IWysiwygEditorComponent>>}
 */
EditorBinding._components = new Map ();

/**
 * Considered private to the EditorBinding.
 * @type {Map<string><EditorBinding>}
 */
EditorBinding._editors = new Map ();

/**
 * Editor compontens can register themselves around here  
 * to be initialized when TinyMCE or CodePress is loaded.
 * @param {IWysiwygEditorComponent} binding
 * @param {WindowBinding} windowBinding
 */
EditorBinding.registerComponent = function ( binding, windowBinding ) {
	
	var components = EditorBinding._components;
	var editors = EditorBinding._editors;
	var key = windowBinding.key;
	
	/*
	 * This if-else is ugly - refactor!
	 */
	var isImplemented = Interfaces.isImplemented ( IWysiwygEditorComponent, binding );
	if ( !isImplemented ) {
		isImplemented = Interfaces.isImplemented ( ISourceEditorComponent, binding );
	}
	
	if ( isImplemented ) {
		if ( editors.has ( key )) { // already initialized
			editors.get ( key ).initializeEditorComponent ( binding );
		}  else { // not yet initialized
			if ( !components.has ( key )) {
				components.set ( key, new List ());
			}
			components.get ( key ).add ( binding );
		}
	} else {
		throw "Editor component interface not implemented: " + binding;
	}
}

/**
 * When an editor instance is initialized, it will 
 * fetch associated components and initialize them.
 * @param {EditorBinding} editor
 * @param {WindowBinding} windowBinding
 * @return {List<IWysiwygEditorComponent>}
 */
EditorBinding.claimComponents = function ( editor, windowBinding ) {
	
	var components = EditorBinding._components;
	var editors = EditorBinding._editors;
	var key = windowBinding.key;
	
	// Register editor as initialized.
	editors.set ( key, editor );
	
	// Fetch associated components
	var list = null;
	if ( components.has ( key )) {
		list = components.get ( key ).copy ();
		components.del ( key ); // deleting entries!
	}
	return list;
}


/**
 * @class
 * In order to function elegantly as a DataBinding, we should probably refactor 
 * the inheritance chain. For now, we simply implement the required interface.
 * @implements {@link IData}
 */
function EditorBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "EditorBinding" );
	
	/**
	 * Subclass must define.
	 * @type {string}
	 */
	this.action_initialized = null;
	
	/** 
	 * Subclass must define.
	 * @type {string}
	 */
	this.url_default = null;
	
	/** 
	 * @type {EditorPopupBinding}
	 */
	this._popupBinding = null;
	
	/**
	 * This is the string value of postbackable textarea.
	 * @type {string}
	 */
	this._startContent = null;
	
	/**
	 * An object with two properties, start and length. Used to cache   
	 * and restore the selection while document is out of focus.
	 * @type {object}
	 */
	this._explorerBookmark = null;
	
	/**
	 * Flipped when editor content changes first time.
	 * @type {boolean}
	 */
	this.isDirty = false;
	
	/**
	 * Flipped when editor launches and closed a dialog.
	 * @type {boolean}
	 */
	this.isDialogMode = false;
	
	/**
	 * @implements {IFocusable}
	 * @type {boolean}
	 */
	this.isFocusable = true;
	
	/**
	 * @implements {IFocusable}
	 * @type {boolean}
	 */
	this.isFocused = false;
	
	/**
	 * Flipped when editable document is handled.
	 * @type {boolean}
	 */
	this._isActivated = false;
	
	/**
	 * This will hide the "flash of white" in Explorer.
	 * @type {Binding}
	 */
	this._Binding = null;
	
	/**
	 * The URL to load. Defined during initialization 
	 * so that subclasses don't inherit the value.
	 */
	this._url = null;
	
	/**
	 * Dont relay events dispatched by any descendant binding.
	 * @overloads {Binding#isBlockingActions}
	 * @type {boolean}
	 */
	this.isBlockingActions = true;
	
	/**
	 * Flipped when the finalize method invokes.
	 * TODO: Investigate - do we still need this?
	 * @type {boolean}
	 */
	this._isFinalized = false;
	
	/**
	 * The bookmark thingy.
	 * @type {object}
	 */
	this._bookmark = null;
	
	/**
	 * Used to determine when a dirty flag should be raised.
	 * @type {string}
	 */
	this._checksum = null;
	
	/**
	 * Divert focus crawler.
	 * @type {Map<string><boolean>}
	 * @overwrites {Binding#crawlerFilters}
	 */
	this.crawlerFilters	= new List ([ FocusCrawler.ID, FitnessCrawler.ID ]);
}

/**
 * Identifies binding.
 */
EditorBinding.prototype.toString = function () {

	return "[EditorBinding]";
}

/**
 * @overloads {WindowBinding#onBindingRegister}
 */
EditorBinding.prototype.onBindingRegister = function () {
	
	EditorBinding.superclass.onBindingRegister.call ( this );
	
	/*
	 * Mount the URL.
	 */
	this._url = this.url_default;
	
	/*
	 * Hides the "flash of white" when loading in explorer.
	 */
	this._coverBinding = this.add (
		CoverBinding.newInstance ( this.bindingDocument )
	);
}

/**
 * @overloads {WindowBinding#onBindingAttach}
 */
EditorBinding.prototype.onBindingAttach = function () {
	
	Application.lock ( this ); // unlocked by method _initialize!
	
	// Hello.
	if ( this.hasCallBackID ()) {
		Binding.dotnetify ( this );
	}
	
	this._setup ();
	this.setURL ( this._url );

	/*
	 * Relay dirty events. Remember that this.isBlockingActions!
	 */
	this.addActionListener ( Binding.ACTION_DIRTY );
	EditorBinding.superclass.onBindingAttach.call ( this );
}

/**
 * Find start content and register as data binding.
 */
EditorBinding.prototype._setup = function () {

	/*
	 * Register as DataBinding so that we 
	 * may masquerade as a DataBinding.
	 */
	var name = this.getProperty ( "name" );
	if ( name == null || name == "" ) {
		name = "generated" + KeyMaster.getUniqueKey ();
	}
	this._registerWithDataManager ( name );
	
	/*
	 * Extract content from the textarea, unless 
	 * already specified programatically.
	 */
	var value = this.getProperty ( "value" );
	if ( value != null ) {
		value = decodeURIComponent ( value );
		value = value.replace ( /\&#xA;/g, EditorBinding.LINE_BREAK_ENTITY_HACK );
		this._startContent = value;
	}
}

/**
 * Unregister when disposed. 
 * TODO: UNREGISTER PAGE EDITOR!
 * @overloads {Binding#onBindingDispose}
 */
EditorBinding.prototype.onBindingDispose = function () {
	
	EditorBinding.superclass.onBindingDispose.call ( this );
	
	var name = this.getProperty ( "name" );
	if ( name != null ) {
		var dataManager = this.bindingWindow.DataManager;
		dataManager.unRegisterDataBinding ( name ); // TODO: PAGEEDITOR???
	}
}

/**
 * Initialize editor.
 */
EditorBinding.prototype._initialize = function () {
	
	this.subscribe ( BroadcastMessages.APPLICATION_BLURRED );
	this.subscribe ( BroadcastMessages.MOUSEEVENT_MOUSEUP );
	
	// if all else failed, at least we have a string
	if ( this._startContent == null ) {
		this._startContent = new String ( "" );
	}
	
	// setup internal events
	this.addEditorEvents ();
	
	// present startcontent - explorer needs a short break here
	var self = this;
	setTimeout ( function () {
		self._finalize ();
	}, 0 );
}

/**
 * Finalize initialization.
 */
EditorBinding.prototype._finalize = function () {
	
	this.resetUndoRedo ();
	this._popupBinding = this.getEditorPopupBinding ();
	Application.unlock ( this );
	this._isFinalized = true;
	this.dispatchAction ( this.action_initialized );
}

/*
 * Initialize components collected during startup.
 * @param {WindowBinding} windowBinding
 */
EditorBinding.prototype.initializeEditorComponents = function ( windowBinding ) {

	var components = EditorBinding.claimComponents ( this, windowBinding );
	if ( components != null ) {
		while ( components.hasNext ()) {
			this.initializeEditorComponent ( 
				components.getNext ()
			);
		}
	}
}


/**
 * We need this to masquerade the editor as a DataBinding!
 * @param {string} name
 */
EditorBinding.prototype._registerWithDataManager = function ( name ) {

	if ( name && name != "" ) {
		var dataManager = this.bindingWindow.DataManager;
		if ( dataManager.getDataBinding ( name )) {
			dataManager.unRegisterDataBinding ( name );
		}
		dataManager.registerDataBinding ( name, this );
	}
}

/*
 * Setup event handling inside the editable document.
 */
EditorBinding.prototype.addEditorEvents = function () {
	
	var editorDocument = this.getEditorDocument ();
	
	if ( editorDocument != null ) {
		Application.framework ( editorDocument );
		DOMEvents.addEventListener ( editorDocument, DOMEvents.CONTEXTMENU, this );
		DOMEvents.addEventListener ( editorDocument, DOMEvents.KEYPRESS, this );
		DOMEvents.addEventListener ( editorDocument, DOMEvents.MOUSEDOWN, this );
		DOMEvents.addEventListener ( editorDocument, DOMEvents.MOUSEMOVE, this );
	}
	
	/*
	 * Why this?
	 */
	DOMEvents.addEventListener ( this.bindingElement, DOMEvents.MOUSEDOWN, {
		handleEvent: function ( e ) {
			DOMEvents.stopPropagation ( e );
			DOMEvents.preventDefault ( e );
		}
	});
}

/**
 * Check for dirty. Note that VisualEditorPageBinding invokes this 
 * method on an interval (at least in Internet Explorer).
 * @param {boolean} isHiddenChange
 */
EditorBinding.prototype.checkForDirty = function ( isHiddenChange ) {
	
	if ( !this.isDirty ) {
		if ( isHiddenChange == true ) {
			this.dispatchAction ( Binding.ACTION_DIRTY );
			this.isDirty = true;
		} else {
			var self = this;
			setTimeout ( function () {
				self._checkForRealDirty ();
			}, 0 );
		}
	}
}

/**
 * The real dirty check.
 * @return
 */
EditorBinding.prototype._checkForRealDirty = function () {
	
	var checksum = this.getCheckSum ();
	if ( checksum != this._checksum ) {
		this.dispatchAction ( Binding.ACTION_DIRTY );
		this.isDirty = true;
		this._checksum = checksum;
	}
}

/**
 * Used to determine when a dirty flag should be raised.
 * @return {string}
 */
EditorBinding.prototype.getCheckSum = function () {
	
	var result = null;
	if ( Binding.exists ( this._pageBinding )) {
		result = this._pageBinding.getCheckSum ( this._checksum );
	}
	return result;
}

/**
 * @implements {IEventListener}
 * @overloads {Binding#handleEvent}
 * @param {eEvent} e
 */
EditorBinding.prototype.handleEvent = function ( e ) {
	
	EditorBinding.superclass.handleEvent.call ( this, e );
	
	var target = DOMEvents.getTarget ( e );
	
	switch ( e.type ) {
		
		/*
		 * Note that the contextmenu is build when first shown.
		 */
		case DOMEvents.CONTEXTMENU :
			DOMEvents.preventDefault ( e );
			this._popupBinding.editorBinding = this;
			this.handleContextMenu ( e );
			break;
		
		/*
		 * Check for dirty on all keystrokes.
		 */
		case DOMEvents.KEYPRESS :
			this.checkForDirty ();
			if ( !this._isActivated ) {
				this._activateEditor ( true );
			}
			break;
			
		/*
		 * Activate editor on editor mousedown.
		 */
		case DOMEvents.MOUSEDOWN :
			if ( target.ownerDocument == this.getEditorDocument ()) {
				if ( !this._isActivated ) {
					this._activateEditor ( true );
				}
			}
			break;
		
		/*
		 * A pityful and desperate attempt to fix the case where IE thinks 
		 * that no window has the current focus combined with IE's assumption 
		 * that mousedown on a contenteditable document should not invoke focus. 
		 */
		case DOMEvents.MOUSEMOVE :
			if ( Client.isExplorer ) {
				if ( Application.isBlurred ) {
					if ( !this._isActivated ) {
						this.getContentWindow ().focus ();
					}
				}
			}
			break;
	}
}

/**
 * Subclass can overload this to update contextmenu before displaying it.
 * @param {MouseEvent} e
 */
EditorBinding.prototype.handleContextMenu = function ( e ) {
	
	this.createBookmark ();
	this._popupBinding.snapToMouse ( e );
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
EditorBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	EditorBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	var target = null;
	
	switch ( broadcast ) {
		
		/*
		 * Global blur event should deactivate the editor.
		 */
		case BroadcastMessages.APPLICATION_BLURRED :
			
			if ( this._isActivated ) {
				this._activateEditor ( false );
			}
			break;
			
		/*
		 * When a mouseup was performed on something, we need to analyze 
		 * whether or not this something should deactivate the editor. 
		 */
		case BroadcastMessages.MOUSEEVENT_MOUSEUP :
			
			if ( !this.isDialogMode ) {
				try {
					var isDeactivate = true;
					if ( arg instanceof Binding ) {
						if ( Interfaces.isImplemented ( IEditorControlBinding, arg ) == true ) {
							if ( arg.isEditorControlBinding ) {
								isDeactivate = false; 
							}
						}
					} else {
						target = DOMEvents.getTarget ( arg );
						if ( target && target.ownerDocument == this.getEditorDocument ()) {
							isDeactivate = false;
						}
					}
					if ( isDeactivate ) {
						if ( this._isActivated ) {
							this._activateEditor ( false );
						}
					}
				} catch ( exception ) {
					this.unsubscribe ( BroadcastMessages.MOUSEEVENT_MOUSEUP );
					throw exception;
				}
			}
			break;
	}	
}

/**
 * Activate editor.
 * @param {boolean} isActivate 
 */
EditorBinding.prototype._activateEditor = function ( isActivate ) {
	
	if ( isActivate != this._isActivated ) {
	
		this._isActivated = isActivate;
		
		var handler = this.getEditorWindow ().standardEventHandler;
		var broadcaster = this.getContentWindow ().bindingMap.broadcasterIsActive;
		
		if ( broadcaster != null ) {
			if ( isActivate ) {
				 
				if ( this.hasBookmark ()) {
					this.deleteBookmark (); // no need to keep old bookmarks around
				}
				broadcaster.enable ();
				
				if ( Client.isExplorer ) { // fixes a glitch where Explorer needs multiple activations.
					this._sanitizeExplorer ();
				}
				
				this.focus ();
				handler.enableNativeKeys ( true );
				
			} else {
				
				broadcaster.disable ();
				handler.disableNativeKeys ();
				this.blur (); 
			}
		} else {
			throw "Required broadcaster not found";
		}
	}
}

/**
 * Invoke this whenever Explorer appears not to fully 
 * realize that we are in contentEditable mode.
 */
EditorBinding.prototype._sanitizeExplorer = function () {
	
	if ( Client.isExplorer ) {
		var range = this.getEditorDocument ().selection.createRange ();
		range.select ();
	}
}

/**
 * Invoke this whenever Mozilla appears not to fully 
 * realize that we are in contentEditable mode.
 * 
 * @see {https://bugzilla.mozilla.org/show_bug.cgi?id=520395}
 * @see {https://bugzilla.mozilla.org/show_bug.cgi?id=429308}
 * @see {https://bugzilla.mozilla.org/show_bug.cgi?id=454191}
 * @see {https://bugzilla.mozilla.org/show_bug.cgi?id=571694}
 * @see {https://bugzilla.mozilla.org/show_bug.cgi?id=439808}
 * @see {http://tinymce.moxiecode.com/punbb/viewtopic.php?pid=73988}
 * @see {http://tinymce.moxiecode.com/punbb/viewtopic.php?id=9153}
 * @see {http://tinymce.moxiecode.com/punbb/viewtopic.php?pid=2860}
 * @see {http://tinymce.moxiecode.com/punbb/viewtopic.php?pid=3278}
 * @see {http://tinymce.moxiecode.com/punbb/viewtopic.php?pid=604}
 * @see {http://tinymce.moxiecode.com/punbb/viewtopic.php?pid=3556}
 * @see {http://tinymce.moxiecode.com/punbb/viewtopic.php?pid=13366}
 */
EditorBinding.prototype._sanitizeMozilla = function () {
	
	/*
	 * This has now been hacked into TinyMCE source code by 
	 * adding a timeout to the place in "Editor.js" where it says:
	 * 
	 * // Design mode must be set here once again to fix a bug where
	 * // Ctrl+A/Delete/Backspace didn't work if the editor was added 
	 * // using mceAddControl then removed then added again
	 */
}

/**
 * Returns true if text is selected or in IE - strangely - if an 
 * image is selected (even simply right-clicked).
 * This method is not really handled elegantly.
 * @return {boolean}
 */
EditorBinding.prototype.hasSelection = function () {
	
	var result = false;
	if ( Client.isMozilla ) {
	 	var selection = this.getEditorWindow ().getSelection ();
		if ( selection != null ) {
			 result = selection.toString ().length > 0;
			 if ( !result ) {
				var range = selection.getRangeAt ( 0 );
				var frag = range.cloneContents ();
				var element = this.getEditorDocument ().createElement ( "element" );
				while ( frag.hasChildNodes ()) {
					element.appendChild ( frag.firstChild );
				}
				var img = element.getElementsByTagName ( "img" ).item ( 0 );
				if ( img != null ) {
					
					/*
					 * Major hack. Should not be performed here, but the  
					 * class check will at least prevent the Link button 
					 * from being enabled when a Function is selected.
					 */
					if ( !CSSUtil.hasClassName ( img, VisualEditorBinding.FUNCTION_CLASSNAME )) {
						result = true;
					} 
				}
			 }
		}
	} else {
		var range = this.getEditorDocument ().selection.createRange ();
		result = ( range && range.text ) && range.text.length > 0;
	}
	return result;
}

/**
 * @param {EditorBinding} editorBinding
 * @param {string} command
 * @return {boolean}
 */
EditorBinding.prototype.isCommandEnabled = function ( command ) {
	
	var result = true; // by default enabling all commands!
	
	switch ( command ) {
		case "Cut" :
		case "Copy" :
		case "Paste" :
			result = this.getEditorDocument ().queryCommandEnabled ( command );
			break;
	}	
	return result;
}

/**
 * Handle command. Subclass may overload this.
 * @param {string} cmd
 * @param {boolean} gui
 * @param {string} val
 */
EditorBinding.prototype.handleCommand = function ( cmd, gui, val ) {
	
	var isCommandHandled = false;
	
	// IE neeeds this!
	this.restoreBookmark ();
	
	switch ( cmd ) {
	
		case "Cut" :
		case "Copy" :
		case "Paste" :
			
			var value = null;
			if ( cmd == "Paste" ) {
				value = null;
			} else {
				value = this.hasSelection ();
			}
			
			try { // mozilla may throw a clipboard security exception here
				this.getEditorDocument ().execCommand ( cmd, gui, value );
			} catch ( mozillaSecurityException ) {
				if ( Client.isMozilla == true ) {
					Dialog.invokeModal ( EditorBinding.URL_DIALOG_MOZ_CONFIGURE );
				} else {
					throw "Clipboard operation malfunction. Contact your developer.";
				}
			} finally {
				isCommandHandled = true; 
			}
		break;
	}
	
	return isCommandHandled;		
}

/**
 * Get button for command. Probably the contextmenu want's to know, but TinyMCE plugins may also ask. 
 * @param {string} cmd
 * @return {EditorToolBarButtonBinding}
 */
EditorBinding.prototype.getButtonForCommand = function ( cmd ) {

	var toolbar = this.getContentWindow ().bindingMap.toolbar;
	var button = toolbar.getButtonForCommand ( cmd );
	if ( !button ) {
		throw "No button for command " + cmd;
	}
	return button;
}

/**
 * Get name.
 * @implements {IData}
 * @return {string}
 */
EditorBinding.prototype.getName = function () {
	
	return this.getProperty ( "name" );
}

/**
 * Set dirty flag.
 * @implements {IData}
 */
EditorBinding.prototype.dirty = DataBinding.prototype.dirty;

/**
 * Reset dirty flag.
 * @implements {IData}
 * @return {string}
 */
EditorBinding.prototype.clean = function () {
	
	this.isDirty = false;
	this._checksum = this.getCheckSum ();
}

/**
 * Enable dialog mode.
 */
EditorBinding.prototype.enableDialogMode = function () {
	
	if ( !this.isDialogMode ) {
		this.isDialogMode = true;
		if ( !this.hasBookmark ()) {
			this.createBookmark ();
		}
		
		/* 
		 * The activate-stuff seems required for Mozilla to keep track 
		 * on, whether or not backspace should be allowed. We bet it 
		 * could be fixed in a better way. Backspace is switched back on 
		 * when user focuses the editor window with the mouse...
		 */
		var self = this;
		setTimeout ( function () { // otherwise the insert selector may not disable...
			self._activateEditor ( false );
		}, 0 );
	}
}

/**
 * Disable dialog mode.
 */
EditorBinding.prototype.disableDialogMode = function () {
	
	if ( this.isDialogMode ) {
		if ( this.hasBookmark ()) {
			this.restoreBookmark ();
		}

		/*
		 * Allows for the popup to close before any 
		 * buttonclick disables editor toolbar.
		 * Maybe invoke this method AFTER dialog 
		 * is closed somehow?
		 */	
		var self = this;
		setTimeout ( function () {
			self.isDialogMode = false;
			self.blurEditor (); // force new activation to synch it all
		}, 100 );
	}
}

/**
 * Blur editor. Simply by transferring the focus 
 * to an inputfield, then hiding the inputfield.
 */
EditorBinding.prototype.blurEditor = function () {
	
	var input = this.getContentDocument ().getElementById ( "focusableinput" );
	
	if ( input != null ) {
		input.style.display = "block";
		FocusBinding.focusElement ( input );
		input.style.display = "none";
	} else {
		throw "Required element not found: focusableinput";
	}
}

/**
 * Hide cover when page initializes.
 * @implements {IActionListener}
 * @param {Action} action
 * @overloads {WindowBinding#handleAction}
 */
EditorBinding.prototype.handleAction = function ( action ) {
	
	EditorBinding.superclass.handleAction.call ( this, action );
	
	var binding = action.target;
	var self = this;
	var iframe = this.shadowTree.iframe;
	
	switch ( action.type ) {
		
		/*
		 * Dispatch dirty events. Remember that this.isBlockingActions!
		 */
		case Binding.ACTION_DIRTY :
			
			if ( action.target != this ) {
				this.checkForDirty ();
			}
			break;
	}
}

/**
 * Invoked when contained page initializes.
 * @overloads {WindowBinding#_onPageInitialze}
 * @param {PageBinding} binding
 */
EditorBinding.prototype._onPageInitialize = function ( binding ) {
	
	/* 
	 * Flex the content and hide the cover. Note that flex is repeated  
	 * on the finalize method in order to fix editors in lazy tabpanels. 
	 */
	if ( this._pageBinding == null ) {
		
		this.reflex ();
		if ( this._coverBinding != null && this._coverBinding.isVisible ) {
			this._coverBinding.hide ();
		}
	}
	
	EditorBinding.superclass._onPageInitialize.call ( this, binding );
}

/**
 * @implements {IUpdateHandler}
 * @overwrites {Binding#handleElement}
 * @param {Element} element
 */
EditorBinding.prototype.handleElement = function ( element ) {
	
	return true; // do handle element update
};

/**
 * @implements {IUpdateHandler}
 * @overwrites {Binding#updateElement}
 * @param {Element} element
 */
EditorBinding.prototype.updateElement = function ( element ) {
	
	return true; // stop crawling descendants
};


// IDATA .......................................................

/**
 * Focus.
 * @implements {IFocusable}
 */
EditorBinding.prototype.focus = DataBinding.prototype.focus;

/**
 * Blur.
 * @implements {IFocusable}
 */
EditorBinding.prototype.blur = DataBinding.prototype.blur;

/**
 * Manifest. This will write form elements into page DOM 
 * so that the server recieves something on form submit.
 * @implements {IData}
 */
EditorBinding.prototype.manifest = function () {
	
	this.shadowTree.dotnetinput.value = encodeURIComponent ( this.getValue ());
};


// ABSTRACT METHODS ......................................................

/**
 * Get the editable window.
 * @return {DOMDocumentView}
 */
EditorBinding.prototype.getEditorWindow = Binding.ABSTRACT_METHOD;

/**
 * Get the editable document.
 * @return {DOMDocument}
 */
EditorBinding.prototype.getEditorDocument = Binding.ABSTRACT_METHOD;

/**
 * Get the associated contextmenu.
 * @return {EditorPopupBinding}
 */
EditorBinding.prototype.getEditorPopupBinding = Binding.ABSTRACT_METHOD;

/**
 * Create selection bookmark, patching explorer focus dysfunction.
 */
EditorBinding.prototype.createBookmark = Binding.ABSTRACT_METHOD;

/**
 * Restore selection focus for explorer.
 */
EditorBinding.prototype.restoreBookmark = Binding.ABSTRACT_METHOD;

/**
 * Has bookmark
 * @return {boolean}
 */
EditorBinding.prototype.hasBookmark = Binding.ABSTRACT_METHOD;

/**
 * Delete bookmark.
 */
EditorBinding.prototype.deleteBookmark = Binding.ABSTRACT_METHOD;

/**
 * Reset undo-redo history.
 */
EditorBinding.prototype.resetUndoRedo = Binding.ABSTRACT_METHOD;


// ABSTRACT IDATA METHODS ............................................

/**
 * Validate.
 * @implements {IData}
 * @return {boolean}
 */
EditorBinding.prototype.validate = Binding.ABSTRACT_METHOD;

/**
 * Get value. This is intended for serversice processing.
 * @implements {IData}
 * @return {string}
 */
EditorBinding.prototype.getValue = Binding.ABSTRACT_METHOD;

/**
 * Get result. This is intended for clientside processing.
 * @implements {IData}
 * @return {object}
 */
EditorBinding.prototype.getResult = Binding.ABSTRACT_METHOD;

EditorPopupBinding.prototype = new PopupBinding;
EditorPopupBinding.prototype.constructor = EditorPopupBinding;
EditorPopupBinding.superclass = PopupBinding.prototype;

/*
 * Subclass defines this.
 */
EditorPopupBinding.CONTENT_TEMPLATE = null;

/**
 * @class
 */
function EditorPopupBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "EditorPopupBinding" );

	/**
	 * @type {boolean}
	 */
	this._isEditorPopupBindingInitialized = false;
	
	/** 
	 * This is set by the EditorBinding. Remember that   
	 * all editor instances use the same popup.
	 * @see {EditorBinding#handleEvent}
	 * @type {EditorBinding}
	 */
	this.editorBinding = null;
}

/**
 * Identifies binding.
 */
EditorPopupBinding.prototype.toString = function () {

	return "[EditorPopupBinding]";
}

/**
 * To reduce startup time, menu generation is delayed until first show.
 * @overloads {PopupBinding#show}
 */
EditorPopupBinding.prototype.show = function () {
	
	if ( !this._isEditorPopupBindingInitialized ) {
		var self = this;
		Application.lock ( this );
		setTimeout ( function () { // timeout allows mastercover to appear
			self._initialize ();
			Application.unlock ( self );
		}, 0 );
	} else {
		EditorPopupBinding.superclass.show.call ( this );
	}
}

/**
 * Initialize menu content.
 * {@see EditorBinding#handleEvent}
 */
EditorPopupBinding.prototype._initialize = function () {
	
	if ( !this._isEditorPopupBindingInitialized ) {
		this.subTreeFromString ( 
			Templates.getTemplateElementText ( 
				this.constructor.CONTENT_TEMPLATE 
			)
		);
		this._bodyBinding = this.getChildBindingByLocalName ( "menubody" );
		this.addActionListener ( MenuItemBinding.ACTION_COMMAND, this );
		this._indexMenuContent ();
		this._isEditorPopupBindingInitialized = true;
		this._onInitialize ();
	}
}

/**
 * Show popup when initialized. Move to separate method 
 * so that subclasses may overload at this point.
 */
EditorPopupBinding.prototype._onInitialize = function () {
	
	this._configure ();
	this.show ();
}

/**
 * Configure.
 */
EditorPopupBinding.prototype.configure = function () {
	
	if ( this._isEditorPopupBindingInitialized ) {
		this._configure ();
	}
}

/**
 * Subclass must overwrite this.
 */
EditorPopupBinding.prototype._configure = Binding.ABSTRACT_METHOD;

/**
 * Hide menugroups.
 * @param {string} rel
 */
EditorPopupBinding.prototype._showMenuGroups = function ( rel ) {
	
	this._menuGroups [ rel ].each ( function ( group ) {
		group.show ();
	});
}

/**
 * Show menugroups.
 * @param {string} rel
 */
EditorPopupBinding.prototype._hideMenuGroups = function ( rel ) {
	
	this._menuGroups [ rel ].each ( function ( group ) {
		group.hide ();
	});
}


/**
 * Subclass may overload this.
 * @overloads {PopupBinding#handleAction}
 * @param {Action} action
 * @return {boolean}
 */
EditorPopupBinding.prototype.handleAction = function ( action ) {

	EditorPopupBinding.superclass.handleAction.call ( this, action );

	var binding = action.target;

	if ( action.type == MenuItemBinding.ACTION_COMMAND ) {
		
		this.hide (); // this should happen automatically, but ie doesn't get it
		
		var cmd = binding.getProperty ( "cmd" );
		var gui = binding.getProperty ( "gui" );
		var val = binding.getProperty ( "val" );
		
		this.handleCommand ( cmd, gui, val );
	}
}

/**
 * Handle that command.
 * @param {string} cmd
 * @param [string} gui
 * @param {string} val
 */
EditorPopupBinding.prototype.handleCommand = Binding.ABSTRACT_METHOD;

EditorClickButtonBinding.prototype = new ClickButtonBinding;
EditorClickButtonBinding.prototype.constructor = EditorClickButtonBinding;
EditorClickButtonBinding.superclass = ClickButtonBinding.prototype;

/**
 * We need a special binding for buttons in the editor because IE will loose focus on  
 * the editor selection if any HTML element is clicked *except* form elements, IMG 
 * and A elements. We overload the method {@link ButtonBinding#buildDOMContent} 
 * to inject an IMG element absolutely positioned on top of the toolbarbutton subchildren.
 * @implements {IWysiwygEditorComponent}
 * @implements {IEditorControlBinding}
 * @class
 */
function EditorClickButtonBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "EditorClickButtonBinding" );
	
	/**
	 * The containing editor.
	 * @type {WysiwygEditorBinding}
	 */
	this._editorBinding = null;
	
	/**
	 * Indicates that editors should not blur 
	 * the toolbars when binding is handled.
	 * @implements {IEditorControlBinding}
	 * @type {boolean}
	 */
	this.isEditorControlBinding = true;
	
	/**
	 * Indicates that editor should refocus 
	 * on the mouseup event.
	 * @type {boolean}
	 */
	this.isEditorSimpleControl = true;
	
	/**
	 * Shorthand the "cmd" property.
	 * @type {string}
	 */
	this.cmd = null;
	
	/**
	 * Shorthand the "val" property (not always used).
	 * @type {string}
	 */
	this.val = null;
	
	/**
	 * Shorthand the "gui" property (not always used).
	 * @type {string}
	 */
	this.gui = null;
	
	
	// TINYMCE CONTROL .............................................
	
	/**
	 * The TinyMCE engine.
	 * @type {TinyMCE_Engine} 
	 */
	this._tinyEngine = null;
	
	/**
	 * The TinyMCE instance.
	 * @type {TinyMCE_Control}
	 */
	this._tinyInstance = null;
	
	/**
	 * The TinyMCE theme.
	 * @type {TinyMCE_CompositeTheme}
	 */
	this._tinyTheme = null;
	
	
	// CODEPRESS CONTROL .............................................
	
	/**
	 * This element has been spirited with some extendo  
	 * functions constituting the core CorePress ballyhoo.  
	 * @type {HTMLIframeElement}
	 */
	this._codePressFrame = null;
	
	/**
	 * Somehow there are two CodePress objects in this 
	 * version of CodePress. This is the "engine" version.
	 * @type {CodePress}
	 */
	this._codePressEngine = null;
}

/**
 * Identifies binding.
 */
EditorClickButtonBinding.prototype.toString = function () {

	return "[EditorClickButtonBinding]";
}

/**
 * Register as editor component.
 * @overloads {ClickButtonBinding#onBindingAttach}
 */
EditorClickButtonBinding.prototype.onBindingAttach = function () {
	
	EditorClickButtonBinding.superclass.onBindingAttach.call ( this );
	this._setupEditorButton ();
}

/**
 * Setup as editor button.
 */
EditorClickButtonBinding.prototype._setupEditorButton = function () {

	this.cmd = this.getProperty ( "cmd" );
	this.val = this.getProperty ( "val" );
	this.gui = this.getProperty ( "gui" );
	
	if ( this.getProperty ( "editorcontrol" ) == false ) {
		this.isEditorControlBinding = false;
	}
	
	/*
	 * THIS WILL FAIL IN SOURCECODEEDITOR!
	 */
	var tinywindow = this.bindingWindow.bindingMap.tinywindow;
	var codepresswin = this.bindingWindow.bindingMap.codepresswindow;
	
	if ( tinywindow ) {
		EditorBinding.registerComponent ( this, tinywindow );
	} else if ( codepresswin ) {
		EditorBinding.registerComponent ( this, codepresswin );
	}
}

/**
 * @overloads {ButtonBinding#buildDOMContent}
 */
EditorClickButtonBinding.prototype.buildDOMContent = function () {

	EditorClickButtonBinding.superclass.buildDOMContent.call ( this );
	this._buildDesignModeSanitizer ();
}

/**
 * Initialize as editor component.
 * @implements {IWysiwygEditorComponent}
 * @param {WysiwygEditorBinding} editor
 * @param {TinyMCE_Engine} engine
 * @param {TinyMCE_Control} instance
 * @param {TinyMCE_CompositeTheme} theme
 */
EditorClickButtonBinding.prototype.initializeComponent = function ( editor, engine, instance, theme ) {

	this._editorBinding = editor;
	this._tinyEngine	= engine;
	this._tinyInstance 	= instance;
	this._tinyTheme 	= theme;
	
	this._setupEditorBookmarking ();
}

/**
 * @implements {IWysiwygEditorComponent}
 * @param {SourceEditorBinding} editor
 * @param {HTMLIframeElement} frame
 * @param {CodePress} engine
 */
EditorClickButtonBinding.prototype.initializeSourceEditorComponent = function ( editor, frame, engine ) {
	
	this._editorBinding = editor;
	this._codePressFrame = frame;
	this._codePressEngine = engine;
}

/**
 * Places an IMG element on top of all other elements. This feature is 
 * disabled for Mozilla because it makes the button draggable; it's not 
 * needed in Mozilla anyway.
 */
EditorClickButtonBinding.prototype._buildDesignModeSanitizer = function () {

	if ( Client.isExplorer ) {
		var img = this.bindingDocument.createElement ( "img" );
		img.className = "designmodesanitizer";
		img.src = Resolver.resolve ( "${root}/images/blank.png" );
		this.shadowTree.designmodesanitizer = img;
		this.bindingElement.appendChild ( img );
	}
}

/**
 * Bookmark editor selection when the button is handled. 
 * @see {EditorClickButtonBinding#_setupEditorBookmarking}
 */
EditorClickButtonBinding.prototype._setupEditorBookmarking = function () {
	
	var editor = this._editorBinding;
	
	if ( editor != null ) {
		
		var self = this;
		var handler = { 
			handleEvent : function ( e ) {
				switch ( e.type ) {
					case DOMEvents.MOUSEDOWN :
						if ( !editor.hasBookmark ()) {
							editor.createBookmark ();
						}
						break;
					case DOMEvents.MOUSEUP :
						if ( self.isEditorSimpleControl ) {
							if ( self.popupBinding == null ) { // hacking a bit here...
								if ( editor.hasBookmark ()) {
									editor.restoreBookmark ();
								}
							}
						}
						break;
				}
			}
		};
		
		DOMEvents.addEventListener ( this.bindingElement, DOMEvents.MOUSEDOWN, handler );
		DOMEvents.addEventListener ( this.bindingElement, DOMEvents.MOUSEUP, handler );
	}
}

/**
 * EditorClickButtonBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {EditorClickButtonBinding}
 */
EditorClickButtonBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:clickbutton", ownerDocument );
	return UserInterface.registerBinding ( element, EditorClickButtonBinding );
}

EditorToolBarButtonBinding.prototype = new ToolBarButtonBinding;
EditorToolBarButtonBinding.prototype.constructor = EditorToolBarButtonBinding;
EditorToolBarButtonBinding.superclass = ToolBarButtonBinding.prototype;

/**
 * We need a special binding for buttons in the editor because IE will loose focus on  
 * the editor selection if any HTML element is clicked *except* form elements, IMG 
 * and A elements. We overload the method {@link ButtonBinding#buildDOMContent} 
 * to inject an IMG element absolutely positioned on top of the toolbarbutton subchildren.
 * @implements {IWysiwygEditorComponent}
 * @implements {IEditorControlBinding}
 * @class
 */
function EditorToolBarButtonBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "EditorToolBarButtonBinding" );
	
	/**
	 * The containing editor.
	 * @type {WysiwygEditorBinding}
	 */
	this._editorBinding = null;
	
	/**
	 * The TinyMCE engine.
	 * @type {TinyMCE_Engine} 
	 */
	this._tinyEngine = null;
	
	/**
	 * The TinyMCE instance.
	 * @type {TinyMCE_Control}
	 */
	this._tinyInstance = null;
	
	/**
	 * The TinyMCE theme.
	 * @type {TinyMCE_CompositeTheme}
	 */
	this._tinyTheme = null;
	
	/**
	 * Indicates that editor should refocus 
	 * on the mouseup event.
	 * @type {boolean}
	 */
	this.isEditorSimpleControl = true;
	
	/**
	 * Indicates that editors should not blur 
	 * the toolbars when binding is handled.
	 * @implements {IEditorControlBinding}
	 * @type {boolean}
	 */
	this.isEditorControlBinding = true;
	
	/**
	 * Shorthand the "cmd" property.
	 * @type {string}
	 */
	this.cmd = null;
	
	/**
	 * Shorthand the "val" property (not always used).
	 * @type {string}
	 */
	this.val = null;
	
	/**
	 * Shorthand the "gui" property (not always used).
	 * @type {string}
	 */
	this.gui = null;

}

/**
 * Identifies binding.
 */
EditorToolBarButtonBinding.prototype.toString = function () {

	return "[EditorToolBarButtonBinding]";
}

/**
 * Register as editor component.
 * @overloads {ToolBarButtonBinding#onBindingAttach}
 */
EditorToolBarButtonBinding.prototype.onBindingAttach = function () {
	
	EditorToolBarButtonBinding.superclass.onBindingAttach.call ( this );
	this._setupEditorButton ();
}

/**
 * Setup as editor button.
 */
EditorToolBarButtonBinding.prototype._setupEditorButton = EditorClickButtonBinding.prototype._setupEditorButton;

/**
 * @overloads {ButtonBinding#buildDOMContent}
 */
EditorToolBarButtonBinding.prototype.buildDOMContent = function () {

	EditorToolBarButtonBinding.superclass.buildDOMContent.call ( this );
	this._buildDesignModeSanitizer ();
}

/**
 * Initialize as editor component.
 * @implements {IWysiwygEditorComponent}
 * @param {WysiwygEditorBinding} editor
 * @param {TinyMCE_Engine} engine
 * @param {TinyMCE_Control} instance
 * @param {TinyMCE_CompositeTheme} theme
 */
EditorToolBarButtonBinding.prototype.initializeComponent = EditorClickButtonBinding.prototype.initializeComponent;

/**
 * @implements {IWysiwygEditorComponent}
 * @param {SourceEditorBinding} editor
 * @param {HTMLIframeElement} frame
 * @param {CodePress} engine
 */
EditorToolBarButtonBinding.prototype.initializeSourceEditorComponent = EditorClickButtonBinding.prototype.initializeSourceEditorComponent;

/**
 * Places an IMG element on top of all other elements. This feature is 
 * disabled for Mozilla because it makes the button draggable; it's not 
 * needed in Mozilla anyway.
 * @see {EditorClickButtonBinding#_buildDesignModeSanitizer}
 */
EditorToolBarButtonBinding.prototype._buildDesignModeSanitizer = EditorClickButtonBinding.prototype._buildDesignModeSanitizer;

/**
 * Bookmark editor selection when the button is handled.
 * @see {EditorClickButtonBinding#_setupEditorBookmarking}
 */
EditorToolBarButtonBinding.prototype._setupEditorBookmarking = EditorClickButtonBinding.prototype._setupEditorBookmarking;

/**
 * EditorToolBarButtonBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {EditorToolBarButtonBinding}
 */
EditorToolBarButtonBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:toolbarbutton", ownerDocument );
	return UserInterface.registerBinding ( element, EditorToolBarButtonBinding );
}

EditorSelectorBinding.prototype = new SelectorBinding;
EditorSelectorBinding.prototype.constructor = EditorSelectorBinding;
EditorSelectorBinding.superclass = SelectorBinding.prototype;

/**
 * @class
 * Bookmarking cursor position and selection status in 
 * the editor whenever the selector is handled. 
 * Restore selection when done.
 * @implements {IWysiwygEditorComponent}
 */
function EditorSelectorBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "EditorSelectorBinding" );
	
	/**
	 * The containing editor.
	 * @type {WysiwygEditorBinding}
	 */
	this._editorBinding = null;
	
	/**
	 * The TinyMCE engine.
	 * @type {TinyMCE_Engine} 
	 */
	this._tinyEngine = null;
	
	/**
	 * The TinyMCE instance.
	 * @type {TinyMCE_Control}
	 */
	this._tinyInstance = null;
	
	/**
	 * The TinyMCE theme.
	 * @type {TinyMCE_CompositeTheme}
	 */
	this._tinyTheme = null;
		
	/**
	 * TODO: since this property is obviously not constant, lowercase it!
	 * @overwrites {SelectorBinding#BUTTON_IMPLEMENTATION}
	 * @type {class}
	 */
	this.BUTTON_IMPLEMENTATION = EditorClickButtonBinding;
	
	/*
	 * @overwrites {SelectorBinding#MENUITEM_IMPLEMENTATION}
	 * @type {class}
	 */
	this.MENUITEM_IMPLEMENTATION = EditorMenuItemBinding;
	
	/* 
	 * Never recieve the focus!
	 * @overwrites {SelectorBinding#isFocusable}
	 */
	this.isFocusable = false;
	
	/**
	 * Indicates that editors should not blur 
	 * the toolbars when binding is handled.
	 * @implements {IEditorControlBinding}
	 * @type {boolean}
	 */
	this.isEditorControlBinding = true;
}

/**
 * Identifies binding.
 */
EditorSelectorBinding.prototype.toString = function () {

	return "[EditorSelectorBinding]";
}

/**
 * @overloads {SelectorBinding#onBindingAttach}
 */
EditorSelectorBinding.prototype.onBindingAttach = function () {

	/*
	 * Should editor activation be maintained while handling this selector? 
	 */
	if ( this.getProperty ( "editorcontrol" ) == false ) {
		this.isEditorControlBinding = false;
		this.BUTTON_IMPLEMENTATION = ClickButtonBinding;
		this.MENUITEM_IMPLEMENTATION = MenuItemBinding;
	}
	
	/*
	 * THIS WILL FAIL IN SOURCECODEEDITOR!
	 */
	var tinywindow = this.bindingWindow.bindingMap.tinywindow;
	EditorBinding.registerComponent ( this, tinywindow );
	
	
	/*
	 * Executed last so that isEditorControlBinding 
	 * is determined before we build the button.
	 */
	EditorSelectorBinding.superclass.onBindingAttach.call ( this );
}

/** 
 * Button must inherit IEditorControlBinding status.
 * @overloads {SelectorBinding#buildButton}
 */
EditorSelectorBinding.prototype.buildButton = function () {
	
	EditorSelectorBinding.superclass.buildButton.call ( this );
	this._buttonBinding.isEditorSimpleControl = false;
	if ( this.isEditorControlBinding == false ) {
		this._buttonBinding.isEditorControlBinding = false;
	}
}

/**
 * Register as node change handler when TinyMCE is initialized.
 * @implements {IWysiwygEditorComponent}
 * @param {WysiwygEditorBinding} editor
 * @param {TinyMCE_Engine} engine
 * @param {TinyMCE_Control} instance
 * @param {TinyMCE_CompositeTheme} theme
 */
EditorSelectorBinding.prototype.initializeComponent = function ( editor, engine, instance, theme ) {

	this._editorBinding = editor;
	this._tinyEngine	= engine;
	this._tinyInstance 	= instance;
	this._tinyTheme 	= theme;
}

/**
 * Restore selection just after action invoked - unless a dialog was opened...
 * @overloads {SelectorBinding#handleAction}
 * @param {Action} action
 */
EditorSelectorBinding.prototype.handleAction = function ( action ) {
	
	EditorSelectorBinding.superclass.handleAction.call ( this, action );
	
	switch ( action.type ) {
		case MenuItemBinding.ACTION_COMMAND :
			if ( this._editorBinding.hasBookmark ()) {
				var self = this;
				setTimeout ( function () {
					if ( !self._editorBinding.isDialogMode ) {
						self._editorBinding.restoreBookmark ();
					}
				}, 0 );
			}
			break;
	}
	
	EditorSelectorBinding.superclass.handleAction.call ( this, action );
}

/**
 * Never grab keyboard!
 * @overwrites {SelectorBinding#_grabKeyboard}
 */
EditorSelectorBinding.prototype._grabKeyboard = function () {}

/**
 * Never release keyboard!
 * @overwrites {SelectorBinding#_releaseKeyboard}
 */
EditorSelectorBinding.prototype._releaseKeyboard = function () {}

EditorMenuItemBinding.prototype = new MenuItemBinding;
EditorMenuItemBinding.prototype.constructor = EditorMenuItemBinding;
EditorMenuItemBinding.superclass = MenuItemBinding.prototype;

/**
 * @class
 * @deprecated
 * @implements {IEditorControlBinding}
 */
function EditorMenuItemBinding () {

	/** 
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "EditorMenuItemBinding" );
	
	/**
	 * Indicates that editors should not blur 
	 * the toolbars when binding is handled.
	 * @implements {IEditorControlBinding}
	 * @type {boolean}
	 */
	this.isEditorControlBinding = true;
}

/**
 * Identifies binding.
 */
EditorMenuItemBinding.prototype.toString = function () {
	
	return "[EditorMenuItemBinding]";
}

/**
 * @overloads {EditorMenuItemBinding#buildDOMContent}
 */
EditorMenuItemBinding.prototype.buildDOMContent = function () {
	
	EditorMenuItemBinding.superclass.buildDOMContent.call ( this );
	
	if ( Client.isExplorer ) {
		this._buildDesignModeSanitizer ();
	}
}

/**
 * Places an IMG element on top of all other elements. This feature is 
 * disabled for Mozilla because it makes the button draggable; it's not 
 * needed in Mozilla anyway.
 */
EditorMenuItemBinding.prototype._buildDesignModeSanitizer = function () {
	
	if ( Client.isExplorer ) {
		var img = this.bindingDocument.createElement ( "img" );
		img.className = "designmodesanitizer";
		img.src = Resolver.resolve ( "${root}/images/blank.png" );
		this.shadowTree.designmodesanitizer = img;
		this.bindingElement.appendChild ( img );
	}
}

/**
 * EditorMenuItemBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {EditorMenuItemBinding}
 */
EditorMenuItemBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:menuitem", ownerDocument );
	return UserInterface.registerBinding ( element, EditorMenuItemBinding );
}

VisualEditorBinding.prototype = new EditorBinding;
VisualEditorBinding.prototype.constructor = VisualEditorBinding;
VisualEditorBinding.superclass = EditorBinding.prototype;

VisualEditorBinding.FUNCTION_CLASSNAME = "compositeFunctionWysiwygRepresentation";
VisualEditorBinding.FIELD_CLASSNAME = "compositeFieldReferenceWysiwygRepresentation";
VisualEditorBinding.ACTION_INITIALIZED = "visualeditor initialized";
VisualEditorBinding.DEFAULT_CONTENT = "<p><br/></p>";
VisualEditorBinding.DEFAULT_STYLESHEET = Resolver.resolve ( "${root}/content/misc/editors/visualeditor/tinymce.css" );

VisualEditorBinding.URL_DIALOG_CONTENTERROR = "${root}/content/dialogs/wysiwygeditor/errors/contenterror.aspx";
VisualEditorBinding.XHTML = "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n\t<head>${head}</head>\n\t<body>\n${body}\n\t</body>\n</html>";

/**
 * It ain't pretty, but we had to put this somewhere.
 * @param {string} classname
 * @return {string}
 */
VisualEditorBinding.getTinyLessClassName = function ( classname ) {
	
	var i = 0, singlename, result = "", split = classname.split ( " " );
	while (( singlename = split [ i ]) != null ) {
		if ( singlename.length >= 3 && singlename.substring ( 0, 3 ) == "mce" ) {
			singlename = "";
		} else if ( singlename.length >= 14 && singlename.substring ( 0, 14 ) == "compositemedia" ) {
			singlename = "";
		}
		result += singlename;
		if ( split [ i + 1 ]) {
			result += " ";
		}
		i++;
	}
	return result;
}

/**
 * Convert tinymarkup to structured markup.
 * @param {string} content
 * @return {string}
 */
VisualEditorBinding.getStructuredContent = function ( content ) {
	
	var result = null;
	WebServiceProxy.isFaultHandler = false;
	var soap = XhtmlTransformationsService.TinyContentToStructuredContent ( content );
	if ( soap instanceof SOAPFault ) {
		// DO SOMETHING!?
	} else {
		result = soap.XhtmlFragment;
		if ( !result ) {
			result = "";
		}
	}
	WebServiceProxy.isFaultHandler = true;
	return result;
}

/**
 * Convert structured markup to tinymarkup.
 * @param {string} content Structured markup
 * @param {VisualEditorBinding} binding
 * @return {string}
 */
VisualEditorBinding.getTinyContent = function ( content, binding ) {
	
	var result = null;
	
	/*
	 * Some content seems to be needed for the webservice to return valid fragment.
	 */
	if ( content == null || content == "" ) {
		content = VisualEditorBinding.DEFAULT_CONTENT;
	}
	
	/*
	 * If webservice fails to convert structured markup,
	 * a dialog will be presented and null will be returned.
	 */
	WebServiceProxy.isFaultHandler = false;
	var soap = XhtmlTransformationsService.StructuredContentToTinyContent ( content );
	if ( soap instanceof SOAPFault ) {
		var dialogArgument = soap;
		var dialogHandler = {
			handleDialogResponse : function () {
				/*
				 * Otherwise the save button could be disabled 
				 * indefinitely during save scenario
				 */
				binding.dispatchAction ( Binding.ACTION_VALID );
			}
		};
		Dialog.invokeModal (
			VisualEditorBinding.URL_DIALOG_CONTENTERROR,
			dialogHandler, 
			dialogArgument 
		);
	} else {
		result = soap.XhtmlFragment;
		if ( result == null ) { // always return a string!
			result = new String ( "" );
		}
	}
	WebServiceProxy.isFaultHandler = true;
	return result;
};

/**
 * Extract stuff from HTML. This entire operation is carried out in elaborate DOM,  
 * not string parsing, in order to maintain proper namespaces on elements. Otherwise 
 * we would be in trouble eg. if user moved the Function namespace to other tags. 
 * @param {string} html
 * @param {int} index
 * @return {string}
 */
VisualEditorBinding.extractByIndex = function ( html, index ) {
	
	/*
	 * TODO: We crate two DOM documents, one for HEAD and BODY each, where 
	 * only one is needed. This is expensive and should be rationalized...
	 */
	var result = null;
	var doc = XMLParser.parse ( html );
	
	if ( doc != null ) {
		
		/* For some lame reason, IE cannot find elements in a DOM document based 
		 * on their node name. This must be something new and absurd. Instead, we 
		 * locate the element by ordinal index and forget about it. But this is 
		 * seriously twisted, so consider looking into it...
		 */
		var children = new List ( doc.documentElement.childNodes );
		var elements = new List ();
		children.each ( function ( child ) {
			if ( child.nodeType == Node.ELEMENT_NODE ) {
				elements.add ( child );
			}
		})
		
		var target = elements.get ( index );
		if ( target == null ) {
			if ( Application.isDeveloperMode ) {
				alert ( "VisualEditorBinding: Bad HTML!" + "\n\n" + html );
			}
		} else if ( target.hasChildNodes ()) {
			
			/*
			 * Move target nodes to temporary document fragment.
			 */
			var frag = doc.createDocumentFragment ();
			while ( target.hasChildNodes ()) {
				frag.appendChild ( target.firstChild );
			}
			
			/*
			 * Empty the document and move target nodes back. We now have the  
			 * target seaction elements isolated with proper namespaces declared.
			 */
			doc.removeChild ( doc.documentElement );
			doc.appendChild ( DOMUtil.createElementNS ( Constants.NS_XHTML, "ROOT", doc ));
			doc.documentElement.appendChild ( frag );
			
			/*
			 * Finally we serialize the result. It may contain ugly   
			 * whitespace, but this will be dealt with elsewhere.
			 */
			result = DOMSerializer.serialize ( doc.documentElement );
			result = result.substring ( result.indexOf ( ">" ) + 1, result.length );
			result = result.substring ( 0, result.lastIndexOf (  "<" ));
		}
	}
	
	/*
	 * We don't want to return a null pointer here.
	 */
	if ( result == null ) {
		result = new String( "" );
	}
	return result;
}


/**
 * @class
 */
function VisualEditorBinding () {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "VisualEditorBinding" );
	
	/**
	 * @type {string}
	 */
	this.action_initialized = VisualEditorBinding.ACTION_INITIALIZED;
	
	/**
	 * @type {string}
	 */
	this.url_default = "${root}/content/misc/editors/visualeditor/visualeditor.aspx";
	
	/**
	 * The TinyMCE engine.
	 * @type {TinyMCE_Engine} 
	 */
	this._tinyEngine = null;
	
	/**
	 * The TinyMCE instance.
	 * @type {tinymce.Editor}
	 */
	this._tinyInstance = null;
	
	/**
	 * The TinyMCE theme.
	 * @type {TinyMCE_CompositeTheme}
	 */
	this._tinyTheme = null;

	/**
	 * @type {VisualEditorFormattingConfiguration}
	 */
	this.formattingConfiguration = null;
	
	/**
	 * @type {VisualEditorElementClassConfiguration}
	 */
	this.elementClassConfiguration = null;
	
	/**
	 * @type {VisualEditorFieldGroupConfiguration}
	 */
	this.embedableFieldConfiguration = null;
	
	/**
	 * TinyMCE internal stylesheet. Externalized  
	 * so that an TinyMCE upgrade won't overwrite.
	 */
	this.defaultStylesheet = VisualEditorBinding.DEFAULT_STYLESHEET;
	
	/**
	 * Editor configuration stylesheet URL.
	 * @type {string}
	 */
	this.configurationStylesheet = null;
	
	/**
	 * Editor presentation stylesheet URL.
	 * @type {string}
	 */
	this.presentationStylesheet = null;
	
	/**
	 * Stores the HEAD section markup.
	 * @type {string}
	 */
	this._head = null;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * @overloads {EditorBinding#onBindingRegister}
 */
VisualEditorBinding.prototype.onBindingRegister = function () {
	
	/* 
	 * Force an early indexation of VisualEditorBinding strings  
	 * to supress occasional glitches in string fetching.
	 */
	VisualEditorBinding.superclass.onBindingRegister.call ( this );
	StringBundle.getString ( "Composite.Web.VisualEditor", "Preload.Key" );
}

/**
 * @overloads {WindowBinding#onBindingAttach}
 */
VisualEditorBinding.prototype.onBindingAttach = function () {
	
	VisualEditorBinding.superclass.onBindingAttach.call ( this );
	
	this.subscribe ( BroadcastMessages.TINYMCE_INITIALIZED );
	this.subscribe ( BroadcastMessages.VISUALEDITOR_HACKED );
	
	this._parseDOMProperties ();
};

/**
 * Identifies binding.
 */
VisualEditorBinding.prototype.toString = function () {

	return "[VisualEditorBinding]";
};

/**
 * Parse DOM properties.
 */
VisualEditorBinding.prototype._parseDOMProperties = function () {

	var presentation = this.getProperty ( "presentationstylesheet" );
	if ( presentation != null ) {
		this.presentationStylesheet = presentation;
	}
	
	var configuration = this.getProperty ( "configurationstylesheet" );
	if ( configuration != null ) {
		this.configurationStylesheet = configuration;
	}

	var formatconfig = this.getProperty ( "formattingconfiguration" );
	if ( formatconfig != null ) {
		this.formattingConfiguration = VisualEditorFormattingConfiguration.getConfiguration ( formatconfig );
	}
	
	var classconfig = this.getProperty ( "elementclassconfiguration" );
	if ( classconfig != null ) {
		this.elementClassConfiguration = VisualEditorElementClassConfiguration.getConfiguration ( classconfig );
	}

	var fieldsconfig = this.getProperty ( "embedablefieldstypenames" );
	if ( fieldsconfig != null ) {
		this.embedableFieldConfiguration = VisualEditorFieldGroupConfiguration.getConfiguration ( fieldsconfig );
	}
};

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
VisualEditorBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	VisualEditorBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	var windowBinding = this.getContentWindow ().bindingMap.tinywindow;
	var contentWindow = windowBinding.getContentWindow ();
	
	switch ( broadcast ) {
		
		/*
		 * This broadcast is transmitted from inline javascript in the TinyMCE window.
		 * Window contains a textarea that we need to update *before* TinyMCE is loaded.
		 */
		case BroadcastMessages.VISUALEDITOR_HACKED :
			
			if ( arg.broadcastWindow == contentWindow ) {
				
				/*
				 * Normalize start content and extract HEAD and BODY section before we 
				 * feed it to TinyMCE. Normalization is required while old solutions 
				 * are upgraded to the new setup (with HEAD and BODY sections). 
				 */
				this._startContent = this.normalizeToDocument ( this._startContent );
				this.extractHead ( this._startContent );
				this._startContent = this.extractBody ( this._startContent );
				
				/*
				 * Inject BODY markup into TinyMCE. From now on, injection  
				 * is handled by the VisualEditorPageBinding.
				 */
				arg.textareaElement.value = VisualEditorBinding.getTinyContent ( this._startContent );
				this.unsubscribe ( BroadcastMessages.VISUALEDITOR_HACKED );
			}
			break;
		
		/*
		 * TinyMCE initialized.
		 */
		case BroadcastMessages.TINYMCE_INITIALIZED :
			
			if ( arg.broadcastWindow == contentWindow ) {
				
				this._tinyEngine	= arg.tinyEngine;
				this._tinyInstance 	= arg.tinyInstance;
				this._tinyTheme 	= arg.tinyTheme;
				
				this._tinyTheme.initC1 (
					this,
					this._tinyEngine,
					this._tinyInstance
				);
				this.initializeEditorComponents ( windowBinding );
				this._initialize ();
				
				this.unsubscribe ( BroadcastMessages.TINYMCE_INITIALIZED );
			}
			break;
	}
};

/**
 * Initialize components collected during startup. After startup, 
 * this method is invoked directly when bindings register themselves 
 * through method EditorBinding.registerComponent.
 * @param {IEditorComponent} binding
 */
VisualEditorBinding.prototype.initializeEditorComponent = function ( binding ) {

	binding.initializeComponent (
		this,
		this._tinyEngine,
		this._tinyInstance,
		this._tinyTheme
	);
};

/**
 * @overloads {EditorBinding#finalize}
 */
VisualEditorBinding.prototype._finalize = function () {
	
	VisualEditorBinding.superclass._finalize.call ( this );
	this._maybeShowEditor ();
};

/**
 * Invoked when contained page initializes.
 * @overloads {EditorBinding#_onPageInitialze}
 * @param {PageBinding} binding
 */
VisualEditorBinding.prototype._onPageInitialize = function ( binding ) {
	
	VisualEditorBinding.superclass._onPageInitialize.call ( this, binding );
	this._maybeShowEditor ();
};

/**
 * Stuff is not always loaded in a tight sequence arund here, so  
 * we make sure not to show the editor until we are ready. 
 */
VisualEditorBinding.prototype._maybeShowEditor = function () {
	
	if ( this._isFinalized && this._pageBinding != null ) {
		this._checksum = this.getCheckSum ();
		this._pageBinding.showEditor ( true );
	}
};

/**
 * Backup HEAD section from HTML document markup. 
 * This must be done whenever TinyMCE gets served. 
 * @param {string} html
 */
VisualEditorBinding.prototype.extractHead = function ( html ) {
	
	this._head = VisualEditorBinding.extractByIndex ( html, 0 );
}

/**
 * Extract BODY section and return it. TinyMCE 
 * should alwasy be fed BODY content only.
 * @param {string} html
 * @return {string}
 */
VisualEditorBinding.prototype.extractBody = function ( html ) {
	
	return VisualEditorBinding.extractByIndex ( html, 1 );
}

/**
 * Restore HEAD section and convert HTML fragment to normalized HTML document.   
 * This must be done whenever content is extracted from TinyMCE.
 * @param {string} body
 * @return {string}
 */
VisualEditorBinding.prototype.normalizeToDocument = function ( markup ) {
	
	var result = markup;
	if ( !this._isNormalizedDocument ( markup )) {
		markup = "\t\t" + markup.replace ( /\n/g, "\n\t\t" );
		result = VisualEditorBinding.XHTML
			.replace ( "${head}", this._getHeadSection ())
			.replace ( "${body}", markup );
	}
	return result;
}

/**
 * Is markup a valid HTML document; or simply a fragment?
 * @param {string} markup
 * @return {boolean}
 */
VisualEditorBinding.prototype._isNormalizedDocument = function ( markup ) {
	
	var result = false;
	var doc = XMLParser.parse ( markup, true );
	if ( doc != null ) {
		if ( doc.documentElement.nodeName == "html" ) {
			result = true;
		}
	}
	return result;
}

/**
 * Get cached HEAD section. Method isolated so that subclasses may overwrite.
 * @return {string}
 */
VisualEditorBinding.prototype._getHeadSection = function () {
	
	return this._head != null ? this._head : new String ( "" );
}

/**
 * Handle command.
 * @overwrites {EditorBinding#handleCommand}
 * @param {string} cmd
 * @param {boolean} gui
 * @param {string} val
 * @return {boolean} ... This is always true; maybe refactor something?
 */
VisualEditorBinding.prototype.handleCommand = function ( cmd, gui, val ) {
	
	/*
	 * The superclass handles special commmands "copy" and "paste" 
	 * thay may invoke a warning dialog in unprivileged Mozillas.
	 */
	var isCommandHandled = VisualEditorBinding.superclass.handleCommand.call ( this, cmd, gui, val );
	
	/*
	 * Otherwise, the command gets realyed to the TinyMCE instance.
	 */
	if ( !isCommandHandled ) {
		try {
			this._tinyInstance.execCommand ( cmd, gui, val );
			this.checkForDirty ();
		} catch ( e ) {
			SystemDebug.stack ( arguments );
		}
		isCommandHandled = true;
	}
	
	return isCommandHandled;
};

/**
 * Configure contextmenu before showing it.
 * @overloads {EditorBinding#handleContextMenu}
 * @param {MouseEvent} e
 */
VisualEditorBinding.prototype.handleContextMenu = function ( e ) {

	var element = DOMEvents.getTarget ( e );
	this._popupBinding.configure ( this._tinyInstance, this._tinyEngine, element );
	VisualEditorBinding.superclass.handleContextMenu.call ( this, e );
}



// ABSTRACT METHODS IMPLEMENTED .............................................

/**
 * Get the editable window.
 * @return {DOMDocumentView}
 */
VisualEditorBinding.prototype.getEditorWindow = function () {
	
	return DOMUtil.getParentWindow ( this.getEditorDocument ());
};

/**
 * Get the editable document.
 * @return {DOMDocument}
 */
VisualEditorBinding.prototype.getEditorDocument = function () {
	
	return this._tinyInstance.getDoc ();
};

/**
 * Get the contextmenu associated.
 * @return {VisualEditorPopupBinding}
 */
VisualEditorBinding.prototype.getEditorPopupBinding = function () {
	
	return app.bindingMap.visualeditorpopup;
};

/**
 * Create selection bookmark.
 */
VisualEditorBinding.prototype.createBookmark = function () {
	
	this._bookmark = this._tinyInstance.selection.getBookmark ( true );
	//this.logger.debug ( "Bookmark created! " + Math.random ());
};

/**
 * Restore selection from bookmark. This will delete the bookmark!
 */
VisualEditorBinding.prototype.restoreBookmark = function () {
	
	if ( this._bookmark != null ) {
		this._tinyInstance.selection.moveToBookmark ( this._bookmark );
		//this.logger.debug ( "Bookmark restored! " + Math.random ());
		this.deleteBookmark ();
	}
};

/**
 * Has bookmark?
 * @return {boolean}
 */
VisualEditorBinding.prototype.hasBookmark = function () {
	
	return this._bookmark != null;
};

/**
 * Delete bookmark.
 */
VisualEditorBinding.prototype.deleteBookmark = function () {
	
	this._bookmark = null;
	//this.logger.debug ( "Bookmark deleted! " + Math.random ());
};

/**
 * Reset undo-redo history.
 */
VisualEditorBinding.prototype.resetUndoRedo = function () {
	
	this._tinyInstance.undoManager.clear ();
	if ( this._pageBinding != null ) {
		this._pageBinding.updateUndoBroadcasters ();
	}
};

/**
 * Used to determine when a dirty flag should be raised.
 * @return {string}
 *
VisualEditorBinding.prototype.getCheckSum = function () {
	
	var result = null;
	if ( Binding.exists ( this._pageBinding )) {
		result = this._pageBinding.getCheckSum ( this._checksum );
	}
	return result;
}
*/


// IMPLEMENT AS DATABINDING .............................................

/**
 * Validate.
 * @implements {IData}
 * @return {boolean}
 */
VisualEditorBinding.prototype.validate = function () {
	
	return this._pageBinding.validate ();
};

/**
 * Get value. This is intended for serversice processing.
 * @implements {IData}
 * @return {string}
 */
VisualEditorBinding.prototype.getValue = function () {
	
	/*
	 * The content is probably valid at this point because the validate 
	 * method has been invoked. We can save some time here by not duplicating 
	 * validation, although theoretically we should.
	 */
	return this._pageBinding.getContent ();
};

/**
 * Set value. This resets the undo stack.
 * @param {string} value
 */
VisualEditorBinding.prototype.setValue = function ( value ) {
	
	if ( this._isFinalized ) {
		if ( Binding.exists ( this._pageBinding )) {
			this._pageBinding.setContent ( value );
			// resetUndoRedo invoked by page!
			// _checksum reset by page! (how ugly!)
		}
	} else if ( this._startContent == null ){
		this._startContent = value;
	}
};

/**
 * Get result. This is intended for clientside processing.
 * @implements {IData}
 * @return {object}
 */
VisualEditorBinding.prototype.getResult = function () {};

/**
 * Clean must be realyed to sourcecodeeditor.
 * @overloads {EditorBinding#clean}
 */
VisualEditorBinding.prototype.clean = function () {
	
	VisualEditorBinding.superclass.clean.call ( this );
	
	if ( this._pageBinding != null ) {
		this._pageBinding.clean ();
	}
}

/**
 * Set result. This is intended for clientside processing.
 * @param {string} result
 */
VisualEditorBinding.prototype.setResult = function ( result ) {};

VisualEditorPopupBinding.prototype = new EditorPopupBinding;
VisualEditorPopupBinding.prototype.constructor = VisualEditorPopupBinding;
VisualEditorPopupBinding.superclass = EditorPopupBinding.prototype;

VisualEditorPopupBinding.CONTENT_TEMPLATE = "wysiwygeditor/popup.xml";

/**
 * @class
 */
function VisualEditorPopupBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "VisualEditorPopupBinding" );

	/**
	 * @type {HTMLElement} 
	 */
	this.tinyElement = null;

	/**
	 * The TinyMCE engine.
	 * @type {tinymce.EngineManager} 
	 */
	this.tinyEngine = null;
	
	/** 
	 * A TinyMCE instance.
	 * @type {tinymce.Engine}
	 */
	this.tinyInstance = null;

	/**
	 * Flags whether or not a selection was made in the editor.
	 * @type {boolean}
	 */
	this.hasSelection = false;
	
	/**
	 * @type {boolean}
	 */
	this._isRenderingSelected = false;
}

/**
 * Identifies binding.
 */
VisualEditorPopupBinding.prototype.toString = function () {

	return "[VisualEditorPopupBinding]";
}

/**
 * Configures the menu. See also method _configure.
 * @param {TinyMCE_Control} instance
 * @param {TinyMCE_Engine} engine 
 * @param {HTMLElement} element
 */
VisualEditorPopupBinding.prototype.configure = function ( instance, engine, element ) {
	
	var hasSelection = this.editorBinding.hasSelection ();
	
	this.tinyInstance	= instance;
	this.tinyEngine 	= engine;
	this.tinyElement	= element;
	this.hasSelection 	= hasSelection;
	
	VisualEditorPopupBinding.superclass.configure.call ( this );
}

/**
 * Handle that command.
 * @param {string} cmd
 * @param [string} gui
 * @param {string} val
 */
VisualEditorPopupBinding.prototype.handleCommand = function ( cmd, gui, val ) {
	
	this.editorBinding.blurEditor ();
	this.editorBinding.handleCommand ( cmd, gui ? gui : false, val );
}

/**
 * Configure in separate method so that we may 
 * delay invokation until menu is initialized. 
 * Purpose of delay is to show the busy cursor.
 */
VisualEditorPopupBinding.prototype._configure = function () {

	if ( this._isEditorPopupBindingInitialized ) {
		this._configureLinkGroup ();
		this._configureInsertGroup ();
		this._configureTableGroup ();
		this._configureRenderingGroup ();
		this._configureFieldGroup ();
		this._configureImageGroup ();
	}
}

/**
 * Configures and displays the linkgroup.
 */
VisualEditorPopupBinding.prototype._configureLinkGroup = function () {

	var isVisible = false;
	
	if ( this.hasSelection ) {
		isVisible = true;
	} else if ( this.tinyElement ) {
		if ( this.tinyElement.nodeName == "A" && !this.tinyElement.getAttribute ( "name" )) {
			isVisible = true;
		} else if ( this.tinyElement.nodeName == "IMG" ) {
			isVisible = true;
		}
	}
	
	if ( isVisible ) {
		this._showMenuGroups ( "link" );
		this._configureLinkGroupDetails ();
	} else {
		this._hideMenuGroups ( "link" );
	}
}

/**
 * Configure link group details.
 */
VisualEditorPopupBinding.prototype._configureLinkGroupDetails = function () {
	
	var linkitem = this.getMenuItemForCommand ( "compositeInsertLink" );
	var unlinkitem = this.getMenuItemForCommand ( "unlink" );
	var linkbutton = this.editorBinding.getButtonForCommand ( "compositeInsertLink" );
	var unlinkbutton = this.editorBinding.getButtonForCommand ( "unlink" );
	
	unlinkitem.setDisabled ( unlinkbutton.isDisabled );
		
	if ( unlinkitem.isDisabled ) {
		linkitem.setLabel ( "Link" );
	} else {
		linkitem.setLabel ( "Link properties" );
	}
}

/**
 * Configure insert group. This is mostly 
 * a question of handling the fields menu.
 * TODO: Don't rebuild this on each show!
 */
VisualEditorPopupBinding.prototype._configureInsertGroup = function () {
	
	var config = this.editorBinding.embedableFieldConfiguration;
	var item = this.getMenuItemForCommand ( "compositeInsertFieldParent" );
	var doc = this.bindingDocument;
	
	if ( item ) {
		item.dispose ();
	}
	
	item = MenuItemBinding.newInstance ( doc );
	item.setLabel ( "Field" );
	item.image = "${icon:fields}";
	item.imageDisabled = "${icon:fields-disabled}";
	item.setProperty ( "cmd", "compositeInsertFieldParent" );
	
	if ( config ) {
		var groupnames = config.getGroupNames ();
		if ( groupnames.hasEntries ()) {
		
			var popup 	= MenuPopupBinding.newInstance ( doc );
			var body 	= popup.add ( MenuBodyBinding.newInstance ( doc ));
			var group 	= body.add ( MenuGroupBinding.newInstance ( doc ));
			
			groupnames.each ( function ( groupname ) {
				var fields = config.getFieldNames ( groupname );
				fields.each ( function ( fieldname ) {
					var i = group.add ( MenuItemBinding.newInstance ( doc ));
					i.setLabel ( fieldname );
					i.setImage ( "${icon:field}" );
					i.setProperty ( "cmd", "compositeInsertField" );
					i.setProperty ( "val", groupname + ":" + fieldname );
					group.add ( i );
				});
			});
			item.add ( popup );
		}
	} else {
		item.disable ();
	}
	
	this._menuGroups [ "insertions" ].getFirst ().add ( item );
	item.attachRecursive ();
	this._menuItems [ "compositeInsertFieldParent" ] = item;
}

/**
 * Configures and displays the tablegroup.
 */
VisualEditorPopupBinding.prototype._configureTableGroup = function () {

	var element = this.tinyInstance.dom.getParent ( this.tinyElement, "table,td" );
	var colspan = null;
	var rowspan = null;
	
	if ( element ) {
		if ( element.nodeName == "TD" ) {
			colspan = element.getAttribute ( "colspan" );
			rowspan = element.getAttribute ( "rowspan" )
		}
		this._menuItems [ "mceTableSplitCells" ].setDisabled ( colspan == "1" && rowspan == "1" );
		this._menuItems [ "mceTablePasteRowBefore" ].setDisabled ( this.tinyInstance.tableRowClipboard == null );
		this._menuItems [ "mceTablePasteRowAfter" ].setDisabled ( this.tinyInstance.tableRowClipboard == null );
	}
	if ( element ) {
		this._showMenuGroups ( "table" );
	} else {
		this._hideMenuGroups ( "table" );
	}
}

/**
 * Configures and displays the rendering group.
 */
VisualEditorPopupBinding.prototype._configureRenderingGroup = function () {
	
 	var isRendering = this._isRendering ();
	if ( isRendering ) {
		this._showMenuGroups ( "rendering" );
	} else {
		this._hideMenuGroups ( "rendering" );
	}
	this._isRenderingSelected = isRendering;
}

/**
 * Configures and displays the field group.
 */
VisualEditorPopupBinding.prototype._configureFieldGroup = function () {

	var isField = this._isField ();
	if ( isField ) {
		this._showMenuGroups ( "field" );
	} else {
		this._hideMenuGroups ( "field" );
	}
	this._isFieldSelected = isField;
}

/**
 * Configures and displays the tablegroup. This should
 * be done *after* rendering configuration.
 */
VisualEditorPopupBinding.prototype._configureImageGroup = function () {

	if ( this._isImage () && 
		!this._isRenderingSelected && 
		!this._isFieldSelected ) {
		this._showMenuGroups ( "image" );
	} else {
		this._hideMenuGroups ( "image" );
	}
}

/**
 * Is image? Will return FALSE if editor has selection!
 * This will in turn affect _isRendering and _isField
 * @return {boolean}
 */
VisualEditorPopupBinding.prototype._isImage = function () {
	
	var result = false;
	if ( !this.hasSelection ) {
		result = this.tinyElement && this.tinyElement.nodeName == "IMG";
	}
	return result;
}

/**
 * Is rendering?
 * @return {boolean}
 */
VisualEditorPopupBinding.prototype._isRendering = function () {
	
	return this._isImage () && 
		CSSUtil.hasClassName ( 
			this.tinyElement, 
			VisualEditorBinding.FUNCTION_CLASSNAME 
		);
}

/**
 * Is field?
 * @return {boolean}
 */
VisualEditorPopupBinding.prototype._isField = function () {
	
	return this._isImage () && 
		CSSUtil.hasClassName ( 
			this.tinyElement, 
			VisualEditorBinding.FIELD_CLASSNAME 
		);
}

/**
 * Considered internal to this class.
 * @type {Map<string><VisualEditorElementClassConfiguration>}
 */
VisualEditorElementClassConfiguration._configurations = new Map ();

/**
 * Caching configurations to save a few server requests.
 * @param {string} classconfig
 * @return {VisualEditorElementClassConfiguration}
 */
VisualEditorElementClassConfiguration.getConfiguration = function ( classconfig ) {
	
	var configs = VisualEditorElementClassConfiguration._configurations;
	if ( !configs.has ( classconfig )) {
		configs.set ( classconfig, new VisualEditorElementClassConfiguration (
			EditorConfigurationService.GetElementClassConfiguration ( classconfig ) 
		));
	};
	return configs.get ( classconfig );
};

/**
 * @class
 * @param {DOMDocument} doc
 */
function VisualEditorElementClassConfiguration ( doc ) {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "VisualEditorElementClassConfiguration" );
	
	/**
	 * @type {HashMap<string><List>}
	 */
	this._elements = {};
	
	/*
	 * populate! 
	 */
	var resolver = new XPathResolver ();
	var elements = resolver.resolveAll ( "elements/element", doc );
	while ( elements.hasNext ()) {
		var element = elements.getNext ();
		var elementname = element.getAttribute ( "name" );
		this._elements [ elementname ] = new List ();
		var classnames = resolver.resolveAll ( "class", element );
		while ( classnames.hasNext ()) {
			var classname = classnames.getNext ().getAttribute ( "name" );
			this._elements [ elementname ].add ( classname );
		}
	}
};

/**
 * @param {string} name 
 * @return {List<string>}
 */
VisualEditorElementClassConfiguration.prototype.getClassNamesForElement = function ( name ) {
	
	var result = null;
	if ( this._elements [ name ]) {
		result = this._elements [ name ].copy ();
	} else {
		result = new List ();
	}
	return result;
};

/**
 * Considered internal to this class.
 * @type {Map<string><VisualEditorFormattingConfiguration>}
 */
VisualEditorFormattingConfiguration._configurations = new Map ();

/**
 * Populated when the editor is first loaded, see below.
 * @type {HashMap<string><string>}
 */
VisualEditorFormattingConfiguration._options = null;

/**
 * Caching configurations to save a few server requests.
 * @param {string} formatconfig
 * @return {VisualEditorFormattingConfiguration}
 */
VisualEditorFormattingConfiguration.getConfiguration = function ( formatconfig ) {
	
	var configs = VisualEditorFormattingConfiguration._configurations;
	if ( !configs.has ( formatconfig )) {
		configs.set ( formatconfig, new VisualEditorFormattingConfiguration ());
	};
	return configs.get ( formatconfig );
};

/**
 * Get all POSSIBLE formatting options.
 */
VisualEditorFormattingConfiguration._getOptions = function () {
	
	if ( VisualEditorFormattingConfiguration._options == null ) {
		
		var p = "Composite.Web.VisualEditor";	
		VisualEditorFormattingConfiguration._options = {
				"p" 			: StringBundle.getString ( p, "FormatSelector.LabelParagraph" ),
				"address" 		: StringBundle.getString ( p, "FormatSelector.LabelAddress" ),
				"blockquote" 	: StringBundle.getString ( p, "FormatSelector.LabelBlockQuote" ),
				"div"			: StringBundle.getString ( p, "FormatSelector.LabelDivision" ),
				"h1"			: StringBundle.getString ( p, "FormatSelector.LabelHeading1" ),
				"h2"			: StringBundle.getString ( p, "FormatSelector.LabelHeading2" ),
				"h3"			: StringBundle.getString ( p, "FormatSelector.LabelHeading3" ),
				"h4"			: StringBundle.getString ( p, "FormatSelector.LabelHeading4" ),
				"h5"			: StringBundle.getString ( p, "FormatSelector.LabelHeading5" ),
				"h6"			: StringBundle.getString ( p, "FormatSelector.LabelHeading6" )
		};
	}
	
	return VisualEditorFormattingConfiguration._options;
}

/**
 * @class
 * @param {string} config
 */
function VisualEditorFormattingConfiguration ( config ) {
	
	/**
	 * @type {HashMap<string><string>}
	 */
	this._options = VisualEditorFormattingConfiguration._getOptions ();
}

/**
 * Get formatting.
 */
VisualEditorFormattingConfiguration.prototype.getFormattingOptions = function () {
	
	return this._options;
}

/**
 * Considered internal to this class.
 * @type {Map<string><VisualEditorFieldGroupConfiguration>}
 */
VisualEditorFieldGroupConfiguration._configurations = new Map ();

/**
 * Caching configurations to 
 * save a few server requests.
 * @param {string} classconfig
 * @return {VisualEditorFieldGroupConfiguration}
 */
VisualEditorFieldGroupConfiguration.getConfiguration = function ( fieldsconfig ) {
	
	var result = null;
	var configs = VisualEditorFieldGroupConfiguration._configurations;
	if ( !configs.has ( fieldsconfig )) {
		configs.set ( fieldsconfig, new VisualEditorFieldGroupConfiguration (
			EditorConfigurationService.GetEmbedableFieldGroupConfigurations ( fieldsconfig )
		));
	};
	return configs.get ( fieldsconfig );
}


/**
 * VisualEditor field config.
 * @param {object} object Provided by SOAP
 */
function VisualEditorFieldGroupConfiguration ( object ) {
	
	var groups = new Map ();
	new List ( object ).each ( function ( group ) {
		var map = new Map ();
		new List ( group.Fields ).each ( function ( field ) {
			map.set ( field.Name, {
				xhtml : field.XhtmlRepresentation,
				xml	: field.XhtmlRepresentation
			});
		});
		groups.set ( group.GroupName, map );
	});
	
	/**
	 * @type {Map<string><Map<string><object>>}
	 */
	this._groups = groups;
}

/**
 * Get field names for a group.
 * @return {List<string>}
 */
VisualEditorFieldGroupConfiguration.prototype.getGroupNames = function () {
	
	return this._groups.toList ( true );
}

/**
 * Get field names for a group.
 * @param {string} groupname
 * @return {List<string>}
 */
VisualEditorFieldGroupConfiguration.prototype.getFieldNames = function ( groupname ) {
	
	return this._groups.get ( groupname ).toList ( true );
}

/**
 * Get the VisualEditor markup for a given field.
 * @param {string} groupname
 * @param {string} fieldname
 * @return {string}
 */
VisualEditorFieldGroupConfiguration.prototype.getTinyMarkup = function ( groupname, fieldname ) {
	
	return this._groups.get ( groupname ).get ( fieldname ).xhtml;
}

/**
 * Get the sourcodeeditor markup for a given field.
 * @param {string} groupname
 * @param {string} fieldname
 * @return {string}
 */
VisualEditorFieldGroupConfiguration.prototype.getStructuredMarkup = function ( name ) {

	return this._groups.get ( groupname ).get ( fieldname ).xml;
}

VisualMultiEditorBinding.prototype = new VisualEditorBinding;
VisualMultiEditorBinding.prototype.constructor = VisualMultiEditorBinding;
VisualMultiEditorBinding.superclass = VisualEditorBinding.prototype;

/**
 * The VisualMultiTemplateEditorBinding supports multiple content areas.
 * @class
 */
function VisualMultiEditorBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "VisualMultiEditorBinding" );
	
	/**
	 * Any placeholders in template? 
	 * @type {boolean}
	 */
	this._hasPlaceHolders = false;
	
	/**
	 * Currently selected template placeholder.
	 * @type {string}
	 */
	this._textareaname = null;
	
	/**
	 * Map content of current template placeholders.
	 * @type {Map<string><string>}
	 */
	this._textareas = null;
	
	/**
	 * Index HEAD section of multiple documents.
	 * @type {Map<string><string>}
	 */
	this._heads = null;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
VisualMultiEditorBinding.prototype.toString = function () {

	return "[VisualMultiEditorBinding]";
};

/**
 * Make sure that we have som placeholders to show.
 * @overloads {VisualEditorBining#_maybeShowEditor}
 */
VisualMultiEditorBinding.prototype._maybeShowEditor = function () {
	
	if ( this._hasPlaceHolders ) {
		VisualMultiEditorBinding.superclass._maybeShowEditor.call ( this );
	}
};

/**
 * @overwrites {VisualEditorBinding#_setup}
 */
VisualMultiEditorBinding.prototype._setup = function () {
	
	/*
	 * Prepare for multiple head sections.
	 */
	this._heads = new Map ();
	
	/*
	 * Extract start content and determine key for storing HEAD section.
	 */
	var textareas = this.getDescendantElementsByLocalName ( "textarea" );
	while ( textareas.hasNext ()) {
		var textarea = textareas.getNext ();
		if ( textarea.getAttribute ( "selected" ) == "true" ) {
			this._startContent = textarea.value;
			this._textareaname = textarea.getAttribute ( "placeholderid" );
		}
	}
	
	/*
	 * Fallback start content.
	 * TODO: Can this be fixed in super or even superduper class?
	 */
	if ( this._startContent == null ) {
		this._startContent = VisualEditorBinding.DEFAULT_CONTENT;
	}
}

/**
 * @overloads {VisualEditorBinding#_initialize}
 */
VisualMultiEditorBinding.prototype._initialize = function () {
	
	var self = this;
		
	/*
	 * Rregister formally as DataBinding with random key.
	 */
	this._registerWithDataManager ( "generated" + KeyMaster.getUniqueKey ());

	/*
	 * Rig up the templates tree to update editor 
	 * content when a new placeholder is selected.
	 */
	var templatetree = this.getContentWindow ().bindingMap.templatetree;
	templatetree.addActionListener ( TreeBinding.ACTION_SELECTIONCHANGED, {
		handleAction : function ( action ) {
			var treenode = templatetree.getSelectedTreeNodeBindings ().getFirst ();
			self._placeHolderSelected ( treenode.textareaname );
			action.consume ();
		}
	});
	
	templatetree.addActionListener ( Binding.ACTION_FOCUSED, {
		handleAction : function ( action ) {
			self._activateEditor ( false );
		}
	})
	
	/*
	 * Inject startup content. 
	 */
	this._updatePlaceHolders ();
	
	/*
	 * Show the tools panel.
	 * TODO: Maybe move this somewhere else so that uncollapse isn't noticable?
	 */
	var splitter = this.getContentWindow ().bindingMap.toolsplitter;
	splitter.unCollapse ();
	
	/*
	 * Finally invoke super method.
	 */
	VisualMultiEditorBinding.superclass._initialize.call ( this );
};

/**
 * Parse textareas into treenodes.
 */
VisualMultiEditorBinding.prototype._updatePlaceHolders = function () {
	
	templatetree = this.getContentWindow ().bindingMap.templatetree;
	var textareas = this.getDescendantElementsByLocalName ( "textarea" );
	
	templatetree.empty ();
	
	if ( textareas.hasEntries ()) {
		this._hasPlaceHolders = true;
		this._parsePlaceHolders ( textareas );
		if ( this._isFinalized ) {
			this._pageBinding.showEditor ( true );
		}
	} else {
		this._hasPlaceHolders = false;
		this._noPlaceHolders ();
		if ( this._isFinalized ) {
			this._pageBinding.showEditor ( false );
		}
	}
};

/**
 * Actually parse textareas into treenodes.
 * @param {List<DOMElement>}
 */
VisualMultiEditorBinding.prototype._parsePlaceHolders = function ( textareas ) {
	
	this._textareas = new Map ();
	
	/*
	 * Rig up textareas.
	 */
	while ( textareas.hasNext ()) {
		var textarea = textareas.getNext ();
		var placeholderid = textarea.getAttribute ( "placeholderid" );
		this._textareas.set ( placeholderid, 
			{
				placeholderid       : placeholderid,
				placeholdername 	: textarea.getAttribute ( "placeholdername" ),
				placeholdermarkup 	: textarea.value,
				textareaelement		: textarea,
				isSelected 			: textarea.getAttribute ( "selected" ) == "true"
			}
		);
	}
	
	/*
	 * Populate the tree and locate the selected treenode.
	 */
	var treenodes = new Map ();
	this._textareas.each ( function ( name, object ) {
		var treenode = templatetree.add ( 
			TreeNodeBinding.newInstance ( 
				templatetree.bindingDocument 
			)
		);
		treenode.setLabel ( object.placeholdername );
		treenode.setImage ( "${icon:placeholder}" );
		treenode.setProperty ( "placeholder", true );
		treenode.textareaname = name;
		treenodes.set ( object.placeholdername, treenode );
		if ( object.isSelected ) {
			selected = treenode;
		}
	});
	
	templatetree.attachRecursive ();
	
	/*
	 * Select treenode and mount editor content.
	 */
	if ( selected != null ) {
		var object = this._textareas.get ( selected.textareaname );
		this._textareaname = selected.textareaname;
		this._placeholdername = object.placeholdername;
		this._setContentFromPlaceHolder ( selected.textareaname );
		selected.focus ();
	}
};

/**
 * No placeholders in template: Display warning.
 */
VisualMultiEditorBinding.prototype._noPlaceHolders = function () {
	
	/*
	 * Build warning treenode.
	 */
	var templatetree = this.getContentWindow ().bindingMap.templatetree;
	var treenode = templatetree.add ( 
		TreeNodeBinding.newInstance ( 
			templatetree.bindingDocument 
		)
	);
	treenode.setLabel ( StringBundle.getString ( "Composite.Web.VisualEditor", "TemplateTree.NoTemplateWarning" ));
	treenode.setImage ( "${icon:warning}" );
	treenode.attach ();
	
	/*
	 * Neutralize statusbar
	 */
	var statusbar = this.getContentWindow ().bindingMap.statusbar;
	statusbar.setPlaceHolderName ( null );
};

/** 
 * Set editor content based on placeholder name. Currently, 
 * this will reset the undo history for all placeholders.
 * @param {string} name
 */
VisualMultiEditorBinding.prototype._setContentFromPlaceHolder = function ( name ) {
	
	/*
	 * While initializing, content is presented in TinyMCE independantly from 
	 * the current placeholder selction. Content is only updated when finalized.
	 */
	if ( this._isFinalized == true ) {
		var object = this._textareas.get ( name );
		var content = object.placeholdermarkup;
		this.setValue ( this.normalizeToDocument ( content ));
		this.resetUndoRedo ();
	}
};

/**
 * Do stuff when tree selection changes.
 * @param {string} textareaname
 */
VisualMultiEditorBinding.prototype._placeHolderSelected = function ( textareaname ) {
	
	/*
	 * Unless we are initializing, backup current placeholdermarkup.
	 */
	if ( this._isFinalized == true ) {
		if ( this._textareaname && this._textareas.has ( this._textareaname )) {
			this._textareas.get ( this._textareaname ).placeholdermarkup = this.getValue ();
		}
	}
	
	/*
	 * Register new placeholdernames 
	 * and update the statusbar.
	 */
	this._textareaname = textareaname;
	this._placeholdername = this._textareas.get ( this._textareaname ).placeholdername;
	var statusbar = this.getContentWindow ().bindingMap.statusbar;
	statusbar.setPlaceHolderName ( this._placeholdername );
	
	/*
	 * Unless we are initializing, 
	 * update TinyMCE contentarea.
	 */
	if ( this._isFinalized == true ) {
		var self = this;
		Application.lock ( self );
		setTimeout ( function () {
			self._setContentFromPlaceHolder ( textareaname );
			Application.unlock ( self );
		}, 0 );
	}
}

/**
 * Cache HEAD section.
 * @overloads {VisualEditorBinding#extractHead}
 * @param {string} html
 */
VisualMultiEditorBinding.prototype.extractHead = function ( html ) {
	
	VisualMultiEditorBinding.superclass.extractHead.call ( this, html );
	this._heads.set ( this._textareaname, this._head );
}

/**
 * Get cached HEAD section.
 * @overwrites {VisualEditorBinding#_getHeadSection}
 * @return {string}
 */
VisualMultiEditorBinding.prototype._getHeadSection = function () {
	
	var result = "";
	if ( this._heads.has ( this._textareaname )) {
		result = this._heads.get ( this._textareaname );
		if ( result == null ) {
			result = new String ( "" );
		}
	}
	return result;
}

/**
 * Manifest. This will write form elements into page DOM 
 * so that the server recieves something on form submit.
 * @overwrites {VisualEditorBinding#manifest}
 * @implements {IData}
 */
VisualMultiEditorBinding.prototype.manifest = function () {

	if ( this._textareas != null && this._textareas.hasEntries ()) {
		this._textareas.get ( this._textareaname ).placeholdermarkup = this.getValue ();
		this._textareas.each ( function ( name, object ) {
			object.textareaelement.value = object.placeholdermarkup;
		});
	}
};

/**
 * TODO: Fix this horrendous uglyfication.
 * @implements {IUpdateHandler}
 * @overwrites {EditorBinding#updateElement}
 * @param {Element} newelement
 * @param {Element} oldelement
 * @return {boolean}
 */
VisualMultiEditorBinding.prototype.updateElement = function ( newelement, oldelement ) {
	
	var newdiv = newelement.getElementsByTagName ( "div" ).item ( 0 );
	var olddiv = oldelement.getElementsByTagName ( "div" ).item ( 0 );
	var newareas = new List ( newdiv.getElementsByTagName ( "textarea" ));
	var oldareas = new List ( olddiv.getElementsByTagName ( "textarea" ));
	
	var hasChanges = false;
	if ( newareas.getLength () != oldareas.getLength ()) {
		hasChanges = true;
	} else {
		var index = 0;
		newareas.each ( function ( newarea, index ) {
			var oldarea = oldareas.get ( index );
			var newid = newarea.getAttribute ( "placeholderid" );
			var oldid = oldarea.getAttribute ( "placeholderid" );
			var newname = newarea.getAttribute ( "placeholdername" );
			var oldname = oldarea.getAttribute ( "placeholdername" );
			if ( newid != oldid || newname != oldname ) {
				hasChanges = true;
			}
			return !hasChanges;
		})
	}
	
	if ( hasChanges ) {
		
		var html = null;
		if ( newdiv.innerHTML != null ) {
			html = newdiv.innerHTML;
		} else {
			html = DOMSerializer.serialize ( newdiv );
			html = html.substring ( html.indexOf ( ">" ) + 1, html.length );
			html = html.substring ( 0, html.lastIndexOf ( "<" ));
		}
		
		var div = this.bindingElement.getElementsByTagName ( "div" ).item ( 0 );
		if ( div != null ) {
			div.innerHTML = html;
		}
		
		this._updatePlaceHolders ();
	}
	
	return true;
}

VisualMultiTemplateEditorBinding.prototype = new VisualMultiEditorBinding;
VisualMultiTemplateEditorBinding.prototype.constructor = VisualMultiTemplateEditorBinding;
VisualMultiTemplateEditorBinding.superclass = VisualMultiEditorBinding.prototype;

/** 
 * The VisualMultiTemplateEditorBinding supports multiple GROUPED content areas.
 * @class
 */
function VisualMultiTemplateEditorBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "VisualMultiTemplateEditorBinding" );
	
	/**
	 * Cache content of deselected template placeholders, restore on reselection.
	 * @type {Map<string><string>}
	 */
	this._oldtextareas = null;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
VisualMultiTemplateEditorBinding.prototype.toString = function () {

	return "[VisualMultiTemplateEditorBinding]";
};

/**
 * @overloads {VisualEditorBinding#onBindingAttach}
 * @return
 */
VisualMultiTemplateEditorBinding.prototype.onBindingAttach = function () {
	
	VisualMultiTemplateEditorBinding.superclass.onBindingAttach.call ( this );
	this._oldtextareas = new Map ();
}


/**
 * @overloads {VisualMultiEditorBinding#_initialize}
 */
VisualMultiTemplateEditorBinding.prototype._initialize = function () {
	
	var self = this;
	
	/*
	 * Rig up selector.
	 */
	var selector = this.getDescendantBindingByLocalName ( "selector" );
	selector.attach ();
	this._populateTemplateSelector ();
	
	/*
	 * Contained page selector is wired to control main page selector.
	 * When selection changes, main page performs a postback.
	 */
	var templateselector = this.getContentWindow ().bindingMap.templateselector;
	templateselector.addActionListener ( SelectorBinding.ACTION_SELECTIONCHANGED, {
		handleAction : function () {
			setTimeout ( function () {
				self._onTemplateSelectionChanged ();
			}, 0 );
		}
	});
	
	/*
	 * Show the template toolbar.
	 */
	this.getContentWindow ().bindingMap.templatetoolbar.show ();
	
	/*
	 * Invoke super method.
	 */
	VisualMultiTemplateEditorBinding.superclass._initialize.call ( this );
};

/**
 * Populate template selector from hidden selector selections.
 */
VisualMultiTemplateEditorBinding.prototype._populateTemplateSelector = function () {
	
	var hiddenselector = this.getDescendantBindingByLocalName ( "selector" );
	var templateselector = this.getContentWindow ().bindingMap.templateselector;
	hiddenselector.selections.each ( function ( selection ) {
		selection.imageProfile = new ImageProfile ({
			image : "${icon:page-template-template}"
		});
	});
	templateselector.populateFromList ( hiddenselector.selections );
}

/**
 * Template selection changed. This event must be channelized to the hidden selector.
 */
VisualMultiTemplateEditorBinding.prototype._onTemplateSelectionChanged = function () {
	
	var hiddenselector = this.getDescendantBindingByLocalName ( "selector" );
	var templateselector = this.getContentWindow ().bindingMap.templateselector;
	hiddenselector.selectByValue ( templateselector.getValue ());
	hiddenselector.dispatchAction ( PageBinding.ACTION_DOPOSTBACK );
	this.checkForDirty ( true );
}

/**
 * Actually parse textareas into treenodes.
 * @param {List<DOMElement>}
 */
VisualMultiTemplateEditorBinding.prototype._parsePlaceHolders = function ( textareas ) {
	
	/*
	 * Reset textareas Map but keep a copy of the old 
	 * map content in order to persist content changes. 
	 * Similarly named placeholder will inherit cache.
	 */
	var nev = this._textareas;
	var old = this._oldtextareas;
	
	if ( nev != null ) {	
		nev.each ( function ( key, value ) {
			old.set ( key, value );
		});
	}
	
	this._textareas = new Map ();
	
	/*
	 * Nifty function to persist changes. 
	 * @param {string} placeholderid
	 * @param {string} placeholdermarkup
	 * @return {string}
	 */
	function compute ( placeholderid, placeholdermarkup ) {
		var result = placeholdermarkup;
		if ( old.has ( placeholderid )) {
			result = old.get ( placeholderid ).placeholdermarkup;
		}
		return result;
	}
	
	/*
	 * Rig up textareas.
	 */
	while ( textareas.hasNext ()) {
		var textarea = textareas.getNext ();
		var placeholderid = textarea.getAttribute ( "placeholderid" );
		this._textareas.set ( placeholderid, 
			{
				placeholderid       : placeholderid,
				placeholdername 	: textarea.getAttribute ( "placeholdername" ),
				placeholdermarkup 	: compute ( placeholderid, textarea.value ),
				textareaelement		: textarea,
				isSelected 			: textarea.getAttribute ( "selected" ) == "true"
			}
		);
	}
	
	/*
	 * Populate the tree and locate the selected treenode.
	 * TODO: Don't copy paste this step from super class!
	 */
	var selected = null;
	var templatetree = this.getContentWindow ().bindingMap.templatetree;
	
	var treenodes = new Map ();
	this._textareas.each ( function ( name, object ) {
		var treenode = templatetree.add ( 
			TreeNodeBinding.newInstance ( 
				templatetree.bindingDocument 
			)
		);
		treenode.setLabel ( object.placeholdername );
		treenode.setImage ( "${icon:placeholder}" );
		treenode.setProperty ( "placeholder", true );
		treenode.textareaname = name;
		treenodes.set ( object.placeholdername, treenode );
		if ( object.isSelected ) {
			selected = treenode;
		}
	});
	
	templatetree.attachRecursive ();
	
	/*
	 * This convoluted setup ensures that a placeholder  
	 * will be selected that matches the last selected    
	 * placeholder (before template was changed).
	 */
	if ( selected != null ) {
	
		var isDefaultBehavior = true;
		
		if ( this._oldtextareas.hasEntries ()) {
			
			isDefaultBehavior = false;
			var map = new Map ();
			this._textareas.each ( function ( id, object ) {
				map.set ( object.placeholdername, true );
			});
			if ( !map.has ( this._placeholdername )) {
				isDefaultBehavior = true;
			}
		}
		
		if ( isDefaultBehavior ) {
			var object = this._textareas.get ( selected.textareaname );
			this._textareaname = selected.textareaname;
			this._placeholdername = object.placeholdername;
			this._setContentFromPlaceHolder ( selected.textareaname );
			selected.focus ();
		} else {
			var treenode = treenodes.get ( this._placeholdername );
			this._textareaname = treenode.textareaname;
			treenode.focus ();
		}
	}
};

/**
 * Some pretty hacked stuff going on here. Stuff like this should not be communicated 
 * through the page DOM, but via a dedicated service offering structured data. Oh well...
 * @implements {IUpdateHandler}
 * @overloads {VisualMultiEditorBinding#updateElement}
 * @param {Element} newelement
 * @param {Element} oldelement
 * @return {boolean}
 */
VisualMultiTemplateEditorBinding.prototype.updateElement = function ( newelement, oldelement ) {
	
	var newselector = newelement.getElementsByTagName ( "ui:selector" ).item ( 0 );
	var oldselector = oldelement.getElementsByTagName ( "ui:selector" ).item ( 0 );
	
	var hasChanges = false;
	
	if ( newselector != null && oldselector != null ) {
		var newselections = new List ( newselector.getElementsByTagName ( "ui:selection" )); 
		var oldselections = new List ( oldselector.getElementsByTagName ( "ui:selection" ));
		if ( newselections.getLength () != oldselections.getLength ()) {
			hasChanges = true;
		} else {
			newselections.each ( function ( element, index ) {
				var newvalue = element.getAttribute ( "value" );
				var oldvalue = oldselections.get ( index ).getAttribute ( "value" );
				if ( newvalue != oldvalue ) {
					hasChanges = true;
				}
				return !hasChanges;
			});
		}
	}
	
	if ( hasChanges ) {
		var div = this.bindingElement.getElementsByTagName ( "div" ).item ( 1 );
		this.bindingWindow.DocumentManager.detachBindings ( div, true );
		div.innerHTML = DOMSerializer.serialize ( newselector );
		this.bindingWindow.DocumentManager.attachBindings ( div );
		this._populateTemplateSelector ();
	}
	
	return VisualMultiTemplateEditorBinding.superclass.updateElement.call ( this, newelement, oldelement );
}

SourceEditorBinding.prototype = new EditorBinding;
SourceEditorBinding.prototype.constructor = SourceEditorBinding;
SourceEditorBinding.superclass = EditorBinding.prototype;

SourceEditorBinding.ACTION_INITIALIZED = "sourceeditor initialized";

/**
 * Supported syntax list (although not checked for).
 * type {object}
 */
SourceEditorBinding.syntax = {
	
	XML			: "xml",
	ASP 		: "asp",
	CSHARP 		: "csharp",
	CSS 		: "css",
	HTML 		: "html",
	JAVA 		: "java",
	JAVASCRIPT 	: "javascript",
	PERL 		: "perl",
	PHP 		: "php",
	RUBY 		: "ruby",
	SQL 		: "sql",
	TEXT 		: "text",
	VBSCRIPT 	: "vbscript",
	XSL 		: "xsl"
}

/**
 * @class
 */
function SourceEditorBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SourceEditorBinding" );
	
	/**
	 * @type {string}
	 */
	this.action_initialized = SourceEditorBinding.ACTION_INITIALIZED;

	/**
	 * Hosted document.
	 * @type {string}
	 */
	this.url_default = "${root}/content/misc/editors/sourceeditor/sourceeditor.aspx?language=${syntax}";
	
	/**
	 * @type {DocumentView}
	 */
	this._editorWindowBinding = null; 
	
	/**
	 * This element has been spirited with some extendo  
	 * functions constituting the core CorePress ballyhoo.  
	 * @type {HTMLIframeElement}
	 */
	this._codePressFrame = null;
	
	/**
	 * Somehow there are two CodePress objects in this 
	 * version of CodePress. This is the "engine" version.
	 * @type {CodePress}
	 */
	this._codePressEngine = null;
	
	/**
	 * Syntax defaults to plain text.
	 * @type {string}
	 */
	this.syntax = new String ( SourceEditorBinding.syntax.TEXT );
	
	/**
	 * @type {boolean}
	 */
	this._isPlainEditMode = false;
	
	/**
	 * @implements {IData}
	 * @type {boolean}
	 */
	this.isFocusable = true;
	
	/**
	 * True when embedded inside the visual editor. 
	 * TODO: Convert to public property - remove the underscore!
	 * @type {boolean}
	 */
	this._isEmbedded = false;
	
	/**
	 * Flip this by the "validate" property. When true, content 
	 * will be validated according to a stricter ruleset. For now, 
	 * this is only enabled for HTML syntax files.
	 */
	this._hasStrictValidation = false;
	
	/**
	 * This new thingy will rule all validation.
	 * TODO: Deprecate _hasStrictValidation eventually...
	 * @type {String}
	 */
	this._validator = null;
	
	/**
	 * Firefox 4 beta seems to have a problem with completely empty 
	 * documents (the root PRE tag is missing) so we will fallback 
	 * to this zero-width-space. Removed again on save.
	 * @see {SourceEditorBinding#getContent}
	 * @overwrites {EditorBinding#_startContent}
	 */
	this._startContent = "\u200B";
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
SourceEditorBinding.prototype.toString = function () {

	return "[SourceEditorBinding]";
}

/**
 * @overloads {EditorBinding#onBindingRegister}
 */
SourceEditorBinding.prototype.onBindingRegister = function () {
	
	/* 
	 * Force an early indexation of SourceEditorBinding strings  
	 * to supress occasional glitches in string fetching.
	 */
	SourceEditorBinding.superclass.onBindingRegister.call ( this );
	StringBundle.getString ( "Composite.Web.SourceEditor", "Preload.Key" );
}

/**
 * @overloads {Binding#onBindingAttach}
 */
SourceEditorBinding.prototype.onBindingAttach = function () {
	
	/*
	 * Only Mozilla loads CodePress.
	 */
	if ( Client.isMozilla == true ) {
		this.subscribe ( BroadcastMessages.CODEPRESS_INITIALIZED );
	}
	
	/*
	 * This has something to do with the editor 
	 * being embedded inside the visual editor.
	 * TODO: Refactor out this weird hardcode.
	 */
	if ( this.getProperty ( "embedded" ) == true ) {
		this._isEmbedded = true;
	}
	
	/*
	 * Enable strict validation?
	 */
	var validate = this.getProperty ( "validate" );
	if ( validate == true ) {
		this._hasStrictValidation = true;
	}
	
	/*
	 * Assign a validator?
	 */
	var validator = this.getProperty ( "validator" );
	if ( validator != null ) {
		this._validator = validator;
	}
	
	/*
	 * Modify URL to reflect syntax.
	 */
	this.syntax = this.getProperty ( "syntax" );
	this._url = this._url.replace ( "${syntax}", this.syntax );
	
	/*
	 * While developing, mount test file based on current syntax
	 */ 
	if ( this.getProperty ( "debug" )) {
		this._startContent = Templates.getPlainText ( 
			"sourcecodeeditor/" + this.syntax + ".txt" 
		);
	}
	
	// finally call super method.
	SourceEditorBinding.superclass.onBindingAttach.call ( this );
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
SourceEditorBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	SourceEditorBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
	
		case BroadcastMessages.CODEPRESS_INITIALIZED :
			
			var windowBinding = this.getContentWindow ().bindingMap.codepresswindow;
			
			if ( windowBinding ) {
				
				var contentWindow = windowBinding.getContentWindow ();
			
				if ( arg.broadcastWindow == contentWindow ) {
					
					this._editorWindowBinding = windowBinding;
					this._codePressFrame = arg.codePressFrame;
					this._codePressEngine = arg.codePressFrame.editor;
					
					this.initializeEditorComponents ( windowBinding );
					
					/*
					 * We have the editor but do we have the page? 
					 * if yes, initialize, otherwise wait for page.
					 * @see {SourceEditorBinding#_onPageInitialize}
					 */
					if ( this._pageBinding != null ) {
						this._initialize ();
					}
					
					/*
					 * When embedded, this is handled by the containing page.
					 * Becuase in that case, the editor is covered by a cover.
					 * @see {WysigwygEditorPageBinding#handleAction}
					 */	
					if ( !this._isEmbedded ) {
						this.blurEditor ();
					}
					
					this.unsubscribe ( BroadcastMessages.CODEPRESS_INITIALIZED );
				}
			}
			break;
	}
}

/**
 * Invoked when contained page initializes.
 * @overloads {EditorBinding#_onPageInitialze}
 * @param {PageBinding} binding
 */
SourceEditorBinding.prototype._onPageInitialize = function ( binding ) {
	
	SourceEditorBinding.superclass._onPageInitialize.call ( this, binding );
	
	/*
	 * Mozilla depends on CodePress for initialize. Explorer may go ahead.
	 */
	if ( Client.isExplorer || this._codePressEngine != null ) {
		this._initialize ();
	}
}

/**
 * Debug editor HTML content.
 * TODO: Move to super?
 */
SourceEditorBinding.prototype.debug = function () {
	
	var html = this.getEditorDocument ().body.innerHTML;
	if ( Client.isMozilla ) {
		html = html.replace(/<br>/g,"<br/>");
		html = html.replace(/\t/g,"....");
		var dom = XMLParser.parse ( html );
		if ( dom ) {
			html = DOMSerializer.serialize ( dom, true );
		}
	} else {
		html = "Debug not supported in IE.";
	}
	this.logger.debug ( html );
}

/**
 * @param {string} cmd
 * @param {boolean} gui
 * @param {string} val
 */
SourceEditorBinding.prototype.handleCommand = function ( cmd, gui, val ) {
	
	var isCommandHandled = SourceEditorBinding.superclass.handleCommand.call ( this, cmd, val );
	/*
	 * THIS IS NOT YET SUPPORTED BY GUI!
	 */
	switch ( cmd ) {
		case "Paste" :
			this._codePressFrame.syntaxHighlight ( "generic" );
			break;
	}
	return isCommandHandled;
}

/**
 * Finalize initialization.
 * @overloads {EditorBinding._finalize}
 */
SourceEditorBinding.prototype._finalize = function () {
	
	this.setContent ( this._startContent );
	SourceEditorBinding.superclass._finalize.call ( this );
}

/**
 * Initialize component. After startup, this method is invoked 
 * directly by method EditorBinding.registerComponent.
 * @param {IEditorComponent} binding
 */
SourceEditorBinding.prototype.initializeEditorComponent = function ( binding ) {

	binding.initializeSourceEditorComponent ( 
		this, 
		this._codePressFrame,
		this._codePressEngine
	);
}

/**
 * On clean, also clean the plaintext editor.
 * @overloads {EditorBinding#clean}
 */
SourceEditorBinding.prototype.clean = function () {
	
	SourceEditorBinding.superclass.clean.call ( this );
	this.getContentWindow ().bindingMap.editorpage.clean ();
}

/**
 * @param {MouseEvent} e
 */
SourceEditorBinding.prototype.handleContextMenu = function ( e ) {
	
	this._popupBinding.configure ( this, this._codePressFrame, this._codePressEngine );
	SourceEditorBinding.superclass.handleContextMenu.call ( this, e );
}

/**
 * @return {SourceCodeEditorPopupBinding}
 */
SourceEditorBinding.prototype.getEditorPopupBinding = function () {
	
	return top.app.bindingMap.sourcecodeeditorpopup;
}

/**
 * Get editor window.
 * @return {DOMDocumentView}
 */
SourceEditorBinding.prototype.getEditorWindow = function () {
	
	return this._codePressFrame.contentWindow;
}

/**
 * Get editor document.
 * @return {DOMDocument}
 */
SourceEditorBinding.prototype.getEditorDocument = function () {
	
	var result = null;
	if ( this._codePressFrame != null ) {
		result = this._codePressFrame.contentWindow.document;
	}
	return result;
}

/**
 * Set content.
 * @param {string} string
 * @return {boolean} True if content can be mounted. HARDCODED for now.
 */
SourceEditorBinding.prototype.setContent = function ( string ) {
	
	if ( !this._isFinalized ) {
		if ( string != this._startContent ) {
			this._startContent = string;
		}
	}
	
	if ( this.isInitialized && this.getContentWindow ().bindingMap != null ) {
	
		/* 
		 * In structured content, newlines are indicated by &#xA; 
		 * We replace this now, but it should be done elsewhere...
		 */  
		string = string.replace ( /&#xA;/g, "\n" );
		this.getContentWindow ().bindingMap.editorpage.setContent ( string );
		this.resetUndoRedo ();
		
		/*
		 * Reset checksum system.
		 */
		this._checksum = this.getCheckSum ();
	
	}
		
	/*
	 * HARDCODED!
	 * TODO: Validate stuff here?
	 */
	return true; // 
}

/**
 * Get content.
 * @return {string}
 */
SourceEditorBinding.prototype.getContent = function () {
	
	var result = this.getContentWindow ().bindingMap.editorpage.getContent ();
	if ( result != null ) {
		result = result.replace ( /\u200B/g, "" ); // Firefox 4 beta bug hack.
	}
	return result ? result : "";
}

/**
 * Reset undo-redo history.
 */
SourceEditorBinding.prototype.resetUndoRedo = function () {
	
	this.logger.warn ( "SourceEditorBinding.prototype.resetUndoRedo!!!" );
	
	/**
	 * TODO: Migrate to custom undomanager!
	 * UPDATE: Don't we have one of those now?
	 */
	if ( this._codePressEngine ) {
		this._codePressEngine.actions.pos = -1;
	}
}

/**
 * Cover the editor (toolbars not covered). Used when the editor  
 * is embedded inside VisualEditorBinding; and other places.
 * @see {VisualEditorPageBinding#showEditor}
 * @param {boolean} isCover
 */
SourceEditorBinding.prototype.cover = function ( isCover ) {
	
	if ( this._pageBinding != null ) {
		this._pageBinding.cover ( isCover );
	}
}

/**
 * TODO: MOVE TO SUPER! And implement for VisualEditor as well...
 * @implements {IUpdateHandler}
 * @overwrites {EditorBinding#updateElement}
 * @param {Element} element
 */
SourceEditorBinding.prototype.updateElement = function ( element ) {
	
	if ( element != null && this.shadowTree.dotnetinput != null ) {
		var value = element.getAttribute ( "value" );
		if ( value != null && value != this.shadowTree.dotnetinput.value ) {
			this.setValue ( decodeURIComponent ( value ));
		}
	}
	
	return true; // stop crawling
};

// ABSTRACT METHODS ..........................................................

/**
 * Focus.
 * @implements {IFocusable}
 *
SourceEditorBinding.prototype.focus = function () {
	
	this.dispatchAction ( Binding.ACTION_FOCUSED );
};

/**
 * Blur.
 * @implements {IFocusable}
 *
SourceEditorBinding.prototype.blur = function () {};
*/

/**
 * Validate. This is currently only done for  
 * XML dialect syntax. Otherwise hardcoded "true".
 * @implements {IData}
 * @return {boolean}
 */
SourceEditorBinding.prototype.validate = function () {
	
	var result = true;
	var source = this.getContent ();
	
	if ( this._validator != null ) { // server side validation?
		
		result = Validator.validateInformed ( source, this._validator );
	
	} else {
		
		switch ( this.syntax ) {
			
			/*
			 * Validate markup languages.
			 */
			case SourceEditorBinding.syntax.XML :
			case SourceEditorBinding.syntax.XSL :
			case SourceEditorBinding.syntax.HTML :
				
				
				result = XMLParser.isWellFormedDocument ( source, true );
				
				/*
				 * Strict validation?
				 */
				if ( result == true && this._hasStrictValidation ) {
					switch ( this.syntax ) {
						case SourceEditorBinding.syntax.HTML :
							result = this._isValidHTML ( source );
							break;
					}
				}
				break;
		}
	}
	return result;
};

/**
 * Basic XHTML checker.
 * TODO: Schema-validate this stuff on the server!
 * @return {boolean}
 */
SourceEditorBinding.prototype._isValidHTML = function ( xml ) {
	
	var result = true;
	var doc = XMLParser.parse ( xml );
	var errors = new List ();
	
	/*
	 * Collect errors.
	 */
	if ( doc != null ) {
		
		var root = doc.documentElement;
		if ( root.nodeName != "html" ) {
			errors.add ( "MissingHtml" );
		}
		if ( root.namespaceURI != Constants.NS_XHTML ) {
			errors.add ( "NamespaceURI" );
		}
		var head = null, body = null;
		var children = new List ( root.childNodes );
		while ( children.hasNext ()) {
			var child = children.getNext ();
			if ( child.nodeType == Node.ELEMENT_NODE ) {
				switch ( child.nodeName ) {
					case "head" :
						if ( head != null ) {
							errors.add ( "MultipleHead" );
						}
						if ( body != null ) {
							errors.add ( "HeadBodyIndex" );
						}
						head = child;
						break;
					case "body" :
						if ( body != null ) {
							errors.add ( "MultipleBody" );
						}
						body = child;
						break;
				}
			}
		}
		if ( head == null ) {
			errors.add ( "MissingHead" );
		}
		if ( body == null ) {
			errors.add ( "MissingBody" );
		}
	}
	
	/*
	 * Show dialog if errors.
	 */
	if ( errors.hasEntries ()) {
		result = false;
		Dialog.error ( 
			StringBundle.getString ( "Composite.Web.SourceEditor", "Invalid.HTML.DialogTitle" ),
			StringBundle.getString ( "Composite.Web.SourceEditor", "Invalid.HTML." + errors.getFirst ())
		);
	}
	
	return result;
}

/**
 * Basic XSL checker. Result is HARDCODED for now.
 * @return {boolean}
 */
SourceEditorBinding.prototype._isValidXSL = function () {
	
	return true;
}

/**
 * Get value. This is intended for serverside processing.
 * @implements {IData}
 * @return {string}
 */
SourceEditorBinding.prototype.getValue = SourceEditorBinding.prototype.getContent;

/**
 * Set value.
 * @implements {IData}
 * @param {string} value
 */
SourceEditorBinding.prototype.setValue = SourceEditorBinding.prototype.setContent;

/**
 * Get result. This is intended for clientside processing.
 * @implements {IData}
 * @return {object}
 */
SourceEditorBinding.prototype.getResult = SourceEditorBinding.prototype.getContent;

/**
 * Set result.
 * @implements {IData}
 * @param {object} result
 */
SourceEditorBinding.prototype.setResult = SourceEditorBinding.prototype.setContent;


/**
 * TODO!
 * Create selection bookmark, patching explorer focus dysfunction.
 */
SourceEditorBinding.prototype.createBookmark = function () {};

/** 
 * TODO!
 * Restore selection focus for explorer.
 */
SourceEditorBinding.prototype.restoreBookmark = function () {};

/**
 * TODO!
 * Has bookmark?
 * @return {boolean}
 */
SourceEditorBinding.prototype.hasBookmark = function () {};

/**
 * TODO!
 * Delete bookmark.
 */
SourceEditorBinding.prototype.deleteBookmark = function () {};

/**
 * Used to determine when a dirty flag should be raised.
 * @return {string}
 *
SourceEditorBinding.prototype.getCheckSum = function () {
	
	var result = null;
	var page = this._pageBinding;
	
	if ( page != null ) {
		result = page.getCheckSum ();
	}
	
	return result;
}
*/

SourceEditorPopupBinding.prototype = new EditorPopupBinding;
SourceEditorPopupBinding.prototype.constructor = SourceEditorPopupBinding;
SourceEditorPopupBinding.superclass = EditorPopupBinding.prototype;

SourceEditorPopupBinding.CONTENT_TEMPLATE = "sourceeditor/popup.xml";

/**
 * @class
 */
function SourceEditorPopupBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SourceEditorPopupBinding" );
	
	/**
	 * The containing editor.
	 * @type {SourceEditorBinding}
	 */
	this._editorBinding = null;
	
	/**
	 * This element has been spirited with some extendo  
	 * functions constituting the core CorePress ballyhoo.  
	 * @type {HTMLIframeElement}
	 */
	this._codePressFrame = null;
	
	/**
	 * Somehow there are two CodePress objects in this 
	 * version of CodePress. This is the "engine" version.
	 * @type {CodePress}
	 */
	this._codePressEngine = null;
}

/**
 * Identifies binding.
 */
SourceEditorPopupBinding.prototype.toString = function () {

	return "[SourceEditorPopupBinding]";
}

/**
 * Configure contextmenu for the current source code editor.
 * @implements {IWysiwygEditorComponent}
 * @param {SourceEditorBinding} editor
 * @param {HTMLIframeElement} frame
 * @param {CodePress} engine
 */
SourceEditorPopupBinding.prototype.configure = function ( editor, frame, engine ) {

	this._editorBinding = editor;
	this._codePressFrame = frame;
	this._codePressEngine = engine;
	
	WysiwygEditorPopupBinding.superclass.configure.call ( this );
}

/**
 * Configure stuff.
 */
SourceEditorPopupBinding.prototype._configure = function () {
	
	/*
	 * Show XML tools?
	 */
	switch ( this._editorBinding.syntax ) {
		case SourceEditorBinding.syntax.XML :
		case SourceEditorBinding.syntax.XSL :
		case SourceEditorBinding.syntax.HTML :
			this._showMenuGroups ( "xml" );
			break;
		default :
			this._hideMenuGroups ( "xml" );
			break;
	}
}

/**
 * Handle that command.
 * @param {string} cmd
 * @param [string} gui
 * @param {string} val
 */
SourceEditorPopupBinding.prototype.handleCommand = function ( cmd, gui, val ) {
	
	var win = this._editorBinding.getContentWindow ();
	var but = null;
	
	switch ( cmd ) {
		
		case "compositeInsert" :	
			but = win.bindingMap.insertbutton;
			break;
			
		case "compositeFormat" :
			but = win.bindingMap.formatbutton;
			break;
	}
	
	if ( but != null ) {
		but.handleCommand ( cmd, gui, val );
	}
}

AudioWindowBinding.prototype= new WindowBinding;
AudioWindowBinding.prototype.constructor = AudioWindowBinding;
AudioWindowBinding.superclass = WindowBinding.prototype;

AudioWindowBinding.URL = "${root}/content/misc/audioloader/audio.aspx";

/**
 * @class
 */
function AudioWindowBinding () {
	
	/**
	 * @overloads {FlexBoxBinding#isFlexible}
	 * @type {boolean}
	 */
	this.isFlexible = false;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 * @return {string}
 */
AudioWindowBinding.prototype.toString = function () {
	
	return "[AudioWindowBinding]";
}

/**
 * Load the audio gear only if client has the correct Flash version installed.
 * @overloads {WindowBinding#onBindingRegister}
 */
AudioWindowBinding.prototype.onBindingRegister = function () {
	
	AudioWindowBinding.superclass.onBindingRegister.call ( this );
	
	if ( Client.hasFlash == true ) {
		// document.location = Resolver.resolve ( AudioWindowBinding.URL );
		this.setURL ( AudioWindowBinding.URL );
	}
}

ThrobberBinding.prototype = new Binding;
ThrobberBinding.prototype.constructor = ThrobberBinding;
ThrobberBinding.superclass = Binding.prototype;

ThrobberBinding.URL_DEFAULT = Resolver.resolve ( "${skin}/throbber/throbber.gif" );
ThrobberBinding.URL_ACTIVATE = Resolver.resolve ( "${skin}/throbber/throbber_activate.gif" );
ThrobberBinding.URL_DEACTIVATE = Resolver.resolve ( "${skin}/throbber/throbber_deactivate.gif" );

/**
 * Throbber!
 * @class
 */
function ThrobberBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ThrobberBinding" );
	
	/**
	 * @type {boolean}
	 */
	this._isPlaying = false;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
ThrobberBinding.prototype.toString = function () {
	
	return "[ThrobberBinding]";
}

/**
 * @overloads {Binding#onBindingRegister}
 */
ThrobberBinding.prototype.onBindingRegister = function () {
	
	ThrobberBinding.superclass.onBindingRegister.call ( this );
	
	this._setImage ( ThrobberBinding.URL_DEFAULT );
	
	if ( Application.hasStartPage && Application.hasExternalConnection ) {
	
		this.subscribe ( BroadcastMessages.COMPOSITE_START );
		this.subscribe ( BroadcastMessages.COMPOSITE_STOP );
		this.subscribe ( BroadcastMessages.START_COMPOSITE );
		
		this.bindingElement.title = " Composite Start ";
		this.attachClassName ( "active" );
		this.addEventListener ( DOMEvents.CLICK, {
			handleEvent : function () {
				EventBroadcaster.broadcast ( BroadcastMessages.START_COMPOSITE );
			}
		});
	}
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
ThrobberBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	ThrobberBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		case BroadcastMessages.COMPOSITE_START :
		case BroadcastMessages.START_COMPOSITE :
			this.hide ();
		 	break;
		case BroadcastMessages.COMPOSITE_STOP :
			this.show ();
			break;
	}
}

/**
 * Play.
 */
ThrobberBinding.prototype.play = function () {
	
	if ( !this._isPlaying ) {
		this._setImage ( ThrobberBinding.URL_ACTIVATE );
		this._isPlaying = true;
	}
}

/**
 * Stop.
 */
ThrobberBinding.prototype.stop = function () {

	if ( this._isPlaying == true ) {
		this._setImage ( ThrobberBinding.URL_DEACTIVATE ? ThrobberBinding.URL_DEACTIVATE : ThrobberBinding.URL_DEFAULT );
		this._isPlaying = false;
	}
}

/**
 * Hide.
 * @overwrites {Binding#hide}
 */
ThrobberBinding.prototype.hide = function () {

	if ( this.isVisible == true ) {
		this.bindingElement.style.visibility = "hidden";
		this.isVisible = false;
	}
}

/**
 * Show.
 * @overwrites {Binding#show}
 */
ThrobberBinding.prototype.show = function () {
	
	if ( !this.isVisible ) {
		this.bindingElement.style.visibility = "visible";
		this.isVisible = true;
	}
}

/**
 * Set image.
 * @param {string} url
 */
ThrobberBinding.prototype._setImage = function ( url ) {
	
	this.bindingElement.style.backgroundImage = 'url("' + url + '")';
}

ProgressBarBinding.prototype = new Binding;
ProgressBarBinding.prototype.constructor = ProgressBarBinding;
ProgressBarBinding.superclass = Binding.prototype;

ProgressBarBinding.WIDTH = 190;
ProgressBarBinding.NOTCH = 9;

/**
 * Considered private.
 * @type {ProgressBarBinding}
 */
ProgressBarBinding._bindingInstance = null;

/**
 * Notch progress.
 * @param {int} notches
 */
ProgressBarBinding.notch = function ( notches ) {
	
	var bar = ProgressBarBinding._bindingInstance;
	if ( bar != null ) {
		bar.notch ( notches );
	}
}

/**
 * @class
 * This is actually quite a fake progressbar, used only on app initialization.
 */
function ProgressBarBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ProgressBarBinding" );
	
	/**
	 * @type {CoverBinding}
	 */
	this._cover = null;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
ProgressBarBinding.prototype.toString = function () {
	
	return "[ProgressBarBinding]";
}

/**
 * @overloads {Binding#onBindingAttach}
 */
ProgressBarBinding.prototype.onBindingAttach = function () {
	
	ProgressBarBinding.superclass.onBindingAttach.call ( this );
	
	ProgressBarBinding._bindingInstance = this;
	
	this._cover = this.add ( CoverBinding.newInstance ( this.bindingDocument ));
	this._cover.setBusy ( false );
	this._cover.setWidth ( ProgressBarBinding.WIDTH );
	this.shadowTree.cover = this._cover;
}

/**
 * Notch progress. Defaults to a single notch if no argument is supplied.
 * @param {int} notches
 */
ProgressBarBinding.prototype.notch = function ( notches ) {
	
	notches = notches ? notches : 1;
	var width = this._cover.getWidth () - ( ProgressBarBinding.NOTCH * notches );
	this._cover.setWidth ( width >= 0 ? width : 0 );
}

StartMenuItemBinding.prototype = new MenuItemBinding;
StartMenuItemBinding.prototype.constructor = StartMenuItemBinding;
StartMenuItemBinding.superclass = MenuItemBinding.prototype;

/**
 * @class
 */
function StartMenuItemBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "StartMenuItemBinding" );
	
	/**
	 * @overwrites {MenuItemBinding#type}
	 * @type {string}
	 */
	this.type = MenuItemBinding.TYPE_CHECKBOX;
}

/**
 * Identifies binding.
 */
StartMenuItemBinding.prototype.toString = function () {
	
	return "[StartMenuItemBinding]";
}

/**
 * @overloads {MenuItemBinding#onBindingRegister}
 */
StartMenuItemBinding.prototype.onBindingRegister = function () {
	
	StartMenuItemBinding.superclass.onBindingRegister.call ( this );
	this.subscribe ( BroadcastMessages.COMPOSITE_START );
	this.subscribe ( BroadcastMessages.COMPOSITE_STOP );
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
StartMenuItemBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	StartMenuItemBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		case BroadcastMessages.COMPOSITE_START :
			if ( !this.isChecked ) {
				this.check ( true );
			}
		 	break;
		case BroadcastMessages.COMPOSITE_STOP :
			if ( this.isChecked ) {
				this.uncheck ( true );
			}
			break;
	}
}

/**
 * @overloads {MenuItemBinding#setChecked}
 * @param {boolean} isChecked
 * @param {boolean} isPreventCommand
 */
StartMenuItemBinding.prototype.setChecked = function ( isChecked, isPreventCommand ) {
	
	StartMenuItemBinding.superclass.setChecked.call ( 
		this, 
		isChecked, 
		isPreventCommand 
	);
	
	if ( !isPreventCommand ) {
		if ( this.isChecked ) {
			EventBroadcaster.broadcast ( BroadcastMessages.START_COMPOSITE );
		} else {
			EventBroadcaster.broadcast ( BroadcastMessages.STOP_COMPOSITE );
		}
	}
}

KeySetBinding.prototype = new Binding;
KeySetBinding.prototype.constructor = KeySetBinding;
KeySetBinding.superclass = Binding.prototype;

/**
 * MODIFIERS IMPLEMENTED
 * shift: 	The Shift key.
 * control:	The Control key.
 *
 * MODIFIERS NOT IMPLEMENTED
 * alt: 	The Alt key. On the Macintosh, this is the Option key.
 * meta: 	The Meta key. On the Macintosh, this is the Command key.
 * accel: 	The key used for keyboard shortcuts on the user's platform. Usually, this would be the value you would use.
 * access: 	The access key for activating menus and other elements. On Windows, this is the Alt key, used in conjuction with an element's accesskey.
 */


/**
 * @ type {HashMap<DOMDocument><HashMap<int><HashMap<string><IKeyEventHandler>>>}
 */
KeySetBinding.keyEventHandlers = {};
	
/**
 * Register keyevent handler.
 * @param {DOMDocument} doc
 * @param {string} key
 * @param {string} modifiers
 * @param {IKeyEventHandler} handler
 */
KeySetBinding.registerKeyEventHandler = function ( doc, key, modifiers, handler ) {
	
	var handlers = KeySetBinding.keyEventHandlers;
	
	if ( Interfaces.isImplemented ( IKeyEventHandler, handler, true ) == true ) {
		
		if ( modifiers != "*" ) {
			modifiers = KeySetBinding._sanitizeKeyModifiers ( modifiers );
		}
		var code = window.KeyEventCodes [ key ];
		if ( !code ) {
			code = key.charCodeAt ( 0 );
		}
		if ( !handlers [ doc ]) {
			handlers [ doc ] = {};
		}
		if ( !handlers [ doc ][ code ]) {
			handlers [ doc ][ code ] = {};
		}
		handlers [ doc ][ code ][ modifiers ] = handler;
	}
}

/**
 * Handle key.
 * @see {StandardEventHandler#_handleKeyDown}
 * @param {DOMDocument} doc
 * @param {KeyEvent} e
 * @return {boolean}
 */
KeySetBinding.handleKey = function ( doc, e ) {
	
	var isHandled = false;
	var code = e.keyCode;
	var handlers = KeySetBinding.keyEventHandlers;
	
	if ( handlers [ doc ] && handlers [ doc ][ code ]) {
	
		var modifiers = "[default]";	
		modifiers += code != KeyEventCodes.VK_SHIFT ? e.shiftKey ? " shift" : "" : "";
		modifiers += code != KeyEventCodes.VK_CONTROL ? e.ctrlKey ? " control" : "" : "";
		
		var handler = handlers [ doc ][ code ][ modifiers ];
		if ( handler == null ) {
			handler = handlers [ doc ][ code ][ "*" ];
		}
		
		if ( handler != null ) {
			
			/*
			 * The handler also handles any "preventDefault" 
			 * that my be relevant. "stopPropagation" is always invoked. 
			 */
			handler.handleKeyEvent ( e );
			isHandled = true;
		}
	}
	return isHandled;
}

/**
 * We need to index keyhandlers by modifiers in a clearly defined sequence.
 * @return {string}
 */
KeySetBinding._sanitizeKeyModifiers = function ( modifiers ) {
	 
	 var result = "[default]";
	 var mods = {};
	 
	 if ( modifiers ) {
		 new List ( modifiers.split ( " " )).each ( 
		 	function ( modifier ) {
		 		mods [ modifier ] = true;
		 	}	
		 );
		 function check ( modifier ) {
		 	if ( mods [ modifier ]) {
		 		result += " " + modifier;
		 	} 
		 }
		 check ( "shift" );
		 check ( "control" );
	}
	return result;
}

function KeySetBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "KeySetBinding" );
	
	/**
	 * Block common crawlers.
	 * @type {Map<string><boolean>}
	 * @overwrites {Binding#crawlerFilters}
	 */
	this.crawlerFilters	= new List ([ DocumentCrawler.ID, FlexBoxCrawler.ID, FocusCrawler.ID ]);
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
KeySetBinding.prototype.toString = function () {
	
	return "[KeySetBinding]";
}

/**
 * Identifies binding.
 */
KeySetBinding.prototype.onBindingAttach = function () {
	
	KeySetBinding.superclass.onBindingAttach.call ( this );
	
	var self = this;
	var keys = new List ( 
		DOMUtil.getElementsByTagName ( this.bindingElement, "key" )
	);
	
	keys.each ( function ( key ) {
		
		var oncommand = key.getAttribute ( "oncommand" );
		var isPreventDefault = key.getAttribute ( "preventdefault" ) == "true";
		
		/*
		 * Register handler.
		 */
		KeySetBinding.registerKeyEventHandler (
				
			self.bindingDocument,
			key.getAttribute ( "key" ),
			key.getAttribute ( "modifiers" ), {
				
				/*
				 * This executes the action. 
				 * @param {KeyEvent} e
				 */
				handleKeyEvent : function ( e ) {
					DOMEvents.stopPropagation ( e );
					if ( isPreventDefault ) {
						DOMEvents.preventDefault ( e );
					}
					/*
					 * The timeout is needed for events 
					 * to properly cancel in Mozilla.
					 */
					var manager = self.bindingWindow.WindowManager;
					top.setTimeout ( function () {
						Binding.evaluate ( oncommand, self );
					}, 0 );
				}
			}
		);
	});
}

CursorBinding.prototype = new Binding;
CursorBinding.prototype.constructor = CursorBinding;
CursorBinding.superclass = Binding.prototype;

/**
 * Fade in cursor.
 * @param {CursorBinding} cursor
 */
CursorBinding.fadeIn = function ( cursor ) {
	
	if ( cursor instanceof CursorBinding ) {
		cursor.setOpacity ( 0 );
		cursor.show ();
		new Animation (
			{
				modifier : Client.isExplorer ? 18 : 9,
				onstep : function ( iterator ) {
					cursor.setOpacity ( 
						Math.sin ( iterator * Math.PI / 180 )
					);
				},
				onstop : function () {
					cursor.setOpacity ( 1 );
				}
			}
		).play ();
	}
}

/**
 * Fade out cursor.
 * @param {CursorBinding} cursor
 */
CursorBinding.fadeOut = function ( cursor ) {
	
	if ( cursor instanceof CursorBinding ) {
		new Animation ({
			modifier : Client.isExplorer ? 18 : 9,
			onstep : function ( iterator ) {
				cursor.setOpacity ( 
					Math.cos ( 
						iterator * Math.PI / 180
					)
				);
			},
			onstop : function () {
				cursor.hide ();
			}
		}).play ();
	}
}

/**
 * Move cursor from one point to another whilst fading it out.
 * @param {CursorBinding} cursor
 */
CursorBinding.moveOut = function ( cursor, startpoint, endpoint ) {
	
	if ( cursor instanceof CursorBinding ) {
		
		// compensate for cursor icons visual displacement
		endpoint.x -= 16;
		endpoint.y -= 16;
	
		new Animation ({
			modifier : 3,
			onstep : function ( iterator ) {
				var tal = Math.sin ( iterator * Math.PI / 180 );
				cursor.setPosition ( new Point (
					(( 1 - tal ) * startpoint.x ) + (( 0 + tal ) * endpoint.x ),
					(( 1 - tal ) * startpoint.y ) + (( 0 + tal ) * endpoint.y )
				));
			},
			onstop : function () {
				CursorBinding.fadeOut ( cursor )
			}
		}).play ();
	}
}

/**
 * @class
 */
function CursorBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "CursorBinding" );
	
	/**
	 * @type {LabelBinding}
	 */
	this._labelBinding = null;
	
	/**
	 * @type {number}
	 */
	this._opacity = 1;
	
	/**
	 * @type {boolean}
	 */
	this.isAccepting = true;
	
	/*
	 * @returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
CursorBinding.prototype.toString = function () {
	
	return "[CursorBinding]";
}

/**
 * @overloads {Binding#onBindingAttach}
 */
CursorBinding.prototype.onBindingAttach = function () {
	
	CursorBinding.superclass.onBindingAttach.call ( this );
	
	this._labelBinding = this.add (
		LabelBinding.newInstance ( 
			this.bindingDocument 
		)
	);
	
	var image = this.getProperty ( "image" );
	if ( image != null ) {
		this.setImage ( image );
	}
	
	this._stopIndicatorBinding = this.add (
		LabelBinding.newInstance ( 
			this.bindingDocument 
		)
	);
	
	this._stopIndicatorBinding.attachClassName ( "indicator" );
	this._stopIndicatorBinding.setImage ( 
		"${icon:cancel}" 
	);
	
	this.hide ();
	this._stopIndicatorBinding.hide ();
}

/**
 * @param {string} url
 */
CursorBinding.prototype.setImage = function ( url ) {
	
	this._labelBinding.setImage ( url );
}

/**
 * Show acceptance.
 */
CursorBinding.prototype.showAcceptance = function () {
	
	this.isAccepting = true;
	
	if ( Client.isMozilla ) {
		this._stopIndicatorBinding.hide ();
	} else {
		var self = this;
		setTimeout ( function () {
			if ( self.isAccepting ) {
				self._stopIndicatorBinding.hide ();
			}
		}, 0 );
	}
}

/**
 * Hide acceptance.
 */
CursorBinding.prototype.hideAcceptance = function () {

	this.isAccepting = false;
	
	if ( Client.isMozilla ) {
		this._stopIndicatorBinding.show ();
	} else {
		var self = this;
		setTimeout ( function () {
			if ( !self.isAccepting ) {
				self._stopIndicatorBinding.show ();
			}
		}, 0 );
	}
}

/**
 * @overloads {Binding#show}
 */
CursorBinding.prototype.show = function () {

	CursorBinding.superclass.show.call ( this );
	
	/*
	this._stopIndicatorBinding.show ()
	this._isAccepting = false;
	*/
}

/**
 * @param {number} opacity From zero to one!
 */
CursorBinding.prototype.setOpacity = function ( opacity ) {
	
	if ( Client.isMozilla ) {
		this.bindingElement.style.MozOpacity = new String ( opacity );
	} else {
		this.bindingElement.style.filter = "progid:DXImageTransform.Microsoft.Alpha(opacity=" + new String ( opacity * 100 ) + ")";
	}
	this._opacity = opacity;
}

/**
 * @return {number}
 */
CursorBinding.prototype.getOpacity = function () {
	
	return this._opacity;
}

/**
 * @param {Position} pos
 */
CursorBinding.prototype.setPosition = function ( pos ) {
	
	this.bindingElement.style.left = pos.x + "px";
	this.bindingElement.style.top = pos.y + "px";
}

/**
 * @return {Position}
 */
CursorBinding.prototype.getPosition = function () {
	
	return new Point (
		this.bindingElement.offsetLeft,
		this.bindingElement.offsetTop
	);
}

/**
 * Fade in.
 */
CursorBinding.prototype.fadeIn = function () {
	
	CursorBinding.fadeIn ( this ); 
}

/**
 * Fade out.
 */
CursorBinding.prototype.fadeOut = function () {
	
	CursorBinding.fadeOut ( this ); 
}

CoverBinding.prototype = new Binding;
CoverBinding.prototype.constructor = CoverBinding;
CoverBinding.superclass = Binding.prototype;

CoverBinding.CLASSNAME_TRANSPARENT = "transparent";

/**
 * Fade out cover.
 * TODO: move to higher order utility - an universal fade system?
 * TODO: Replace cover DIV with CSS transforms, canvas tag and/or IE transitions.
 * @param {CoverBinding} cover
 */
CoverBinding.fadeOut = function ( cover ) {
	
	function setOpacity ( opacity ) {
		if ( Client.isMozilla ) {
			cover.bindingElement.style.opacity = new String ( opacity );
		} else {
			cover.bindingElement.style.filter = "progid:DXImageTransform.Microsoft.Alpha(opacity=" + new String ( opacity * 100 ) + ")";
		}
	}
	
	if ( cover instanceof CoverBinding ) {
		new Animation ({
			modifier : Client.isExplorer ? 30 : 18,
			onstep : function ( iterator ) {
				if ( Binding.exists ( cover )) {
					setOpacity ( 
						Math.cos ( 
							iterator * Math.PI / 180
						)
					);
				}
			},
			onstop : function () {
				if ( Binding.exists ( cover )) {
					cover.hide ();
				}
			}
		}).play ();
	}
}

/**
 * Fade in cover
 * TODO: move to higher order utility.
 * @param {CoverBinding} cover
 */
CoverBinding.fadeIn = function ( cover ) {
	
	function setOpacity ( opacity ) {
		if ( Client.isMozilla ) {
			cover.bindingElement.style.MozOpacity = new String ( opacity );
		} else {
			cover.bindingElement.style.filter = "progid:DXImageTransform.Microsoft.Alpha(opacity=" + new String ( opacity * 100 ) + ")";
		}
	}
	
	if ( cover instanceof CoverBinding ) {
		new Animation ({
			modifier : Client.isExplorer ? 30 : 18,
			onstart : function () {
				if ( Binding.exists ( cover )) {
					setOpacity ( 0 );
					cover.show ();
				}
			},
			onstep : function ( iterator ) {
				if ( Binding.exists ( cover )) {
					setOpacity ( 
						Math.sin ( 
							iterator * Math.PI / 180
						)
					);
				}
			},
			onstop : function () {
				setOpacity ( 1 );
			}
		}).play ();
	}
};

/**
 * @class
 */
function CoverBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "CoverBinding" );
	
	/**
	 * Indicates that the cover should display a "wait" cursor when visible.
	 * @type {boolean}
	 */
	this._isBusy = true;
	
	/**
	 * @type {boolean}
	 */
	this._isTransparent = false;
	
	/**
	 * Stores the mouse position in a panicked attempt 
	 * to gain control of the rendered cursor.
	 * @type {Position}
	 */
	this._position = null;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
CoverBinding.prototype.toString = function () {
	
	return "[CoverBinding]";
}

/**
 * @overloads {Binding#onBindingRegister}
 */
CoverBinding.prototype.onBindingRegister = function () {
	
	CoverBinding.superclass.onBindingRegister.call ( this );
	
	/*
	 * Remember that this will interfere with the StandardEventHandler. 
	 * Event blocking should probably only be used on the mastercover.
	 */
	if ( this.getProperty ( "blockevents" )) {
		this.addEventListener ( DOMEvents.MOUSEDOWN );
		this.addEventListener ( DOMEvents.MOUSEUP );
		this.addEventListener ( DOMEvents.MOUSEMOVE );
		this.addEventListener ( DOMEvents.CLICK );
		this.addEventListener ( DOMEvents.DOUBLECLICK );
	}
	
	if ( this.getProperty ( "transparent" ) == true ) {
		this.setTransparent ( true );
	}
	
	if ( this.getProperty ( "busy" ) == false ) {
		this._isBusy = false;
	}
	
	if ( this._isBusy ) {
		this.bindingElement.style.cursor = "wait";
	}
}

/**
 * @overloads {Binding#show}
 */
CoverBinding.prototype.show = function () {
	
	CoverBinding.superclass.show.call ( this );
	if ( this._isBusy && this.isVisible ) {
		this.addEventListener ( DOMEvents.MOUSEMOVE );
	}
}

/**
 * Busy cover will summon the UncoverBinding.
 * @overloads {Binding#hide}
 */
CoverBinding.prototype.hide = function () {
	
	CoverBinding.superclass.hide.call ( this );
	if ( this._isBusy && !this.isVisible && this._position ) {
		UncoverBinding.uncover ( this._position );
		this.removeEventListener ( DOMEvents.MOUSEMOVE );
	}
}

/**
 * Tracking mouse position so that we know where to position the UncoverBinding.
 * @implements {IEventListener}
 * @overloads {Binding#handleEvent}
 * @param {MouseEvent} e
 */
CoverBinding.prototype.handleEvent = function ( e ) {
	
	CoverBinding.superclass.handleEvent.call ( this, e );
	
	DOMEvents.stopPropagation ( e );
	
	switch ( e.type ) {
		case DOMEvents.MOUSEMOVE :
			this._position = DOMUtil.getUniversalMousePosition ( e );
			break;
	}
}

/**
 * Control busy cursor.
 * @param {boolean} isBusy
 */
CoverBinding.prototype.setBusy = function ( isBusy ) {
	
	if ( isBusy != this._isBusy ) {
		if ( isBusy ) {
			this.bindingElement.style.cursor = "wait";
		} else {
			this.bindingElement.style.cursor = "default";
		}
		this._isBusy = isBusy;
	}
}

/**
 * Set transparency (it either is or it isn't).
 * @param {boolean} isTransparent
 */
CoverBinding.prototype.setTransparent = function ( isTransparent ) {
	
	if ( isTransparent != this._isTransparent ) {
		if ( isTransparent ) {
			this.attachClassName ( CoverBinding.CLASSNAME_TRANSPARENT );
		} else {
			this.detachClassName ( CoverBinding.CLASSNAME_TRANSPARENT );
		}
		this._isTransparent = isTransparent;
	}
}

/**
 * Set width. Progressbar uses this...
 * @see {ProgressBarBinding}
 * @param {int} width
 */
CoverBinding.prototype.setWidth = function ( width ) {
	
	if ( width >= 0 ) {
		this.bindingElement.style.width = new String ( width + "px" );
	}
}

/**
 * Get width.
 * @return {int}
 */
CoverBinding.prototype.getWidth = function () {
	
	return this.bindingElement.offsetWidth;
}

/**
 * Set height.
 * @param {int} width
 */
CoverBinding.prototype.setHeight = function ( height ) {
	
	if ( height >= 0 ) {
		this.bindingElement.style.height = new String ( height + "px" );
	}
}

/**
 * Get height.
 * @return {int}
 */
CoverBinding.prototype.getHeight = function () {
	
	return this.bindingElement.offsetHeight;
}

/**
 * CoverBinding factory.
 * @param {DOMDocument} ownerDocument
 * @return {CoverBinding}
 */
CoverBinding.newInstance = function ( ownerDocument ) {

	var element = DOMUtil.createElementNS ( Constants.NS_UI, "ui:cover", ownerDocument );
	return UserInterface.registerBinding ( element, CoverBinding );
}

UncoverBinding.prototype = new Binding;
UncoverBinding.prototype.constructor = UncoverBinding;
UncoverBinding.superclass = Binding.prototype;

/**
 * Considered private.
 * @type {UncoverBinding}
 */
UncoverBinding._bindingInstance = null;

/**
 * Invoke to normalize cursor.
 * @param {Position} pos
 */
UncoverBinding.uncover = function ( pos ) {
	
	var binding = UncoverBinding._bindingInstance;
	if ( Binding.exists ( binding )) {
		binding.setPosition ( pos );
	}
}

/**
 * @class
 * When a "busy" cover gets hidden, the wait cursor may 
 * hang on, indicating activity until the mouse is moved. 
 * We force a cursor update by positioning the uncover 
 * at exact mouse position.
 */
function UncoverBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "UncoverBinding" );
	
	/*
	 * Register globally.
	 */
	UncoverBinding._bindingInstance = this;
}

/**
 * Identifies binding.
 */
UncoverBinding.prototype.toString = function () {
	
	return "[UncoverBinding]";
}

/**
 * This will place the bindings CENTER at the specified position.
 * @param {Position} pos
 */
UncoverBinding.prototype.setPosition = function ( pos ) {
	
	this.bindingElement.style.display = "block";
	var dim = this.boxObject.getDimension ();
	
	pos.x -= 0.5 * dim.w;
	pos.y -= 0.5 * dim.h;
	
	pos.x = pos.x < 0 ? 0 : pos.x;
	pos.y = pos.y < 0 ? 0 : pos.y;
	
	this.bindingElement.style.left = String ( pos.x ) + "px";
	this.bindingElement.style.top = String ( pos.y ) + "px";
	this.bindingElement.style.cursor = "wait";
	
	/*
	 * Flashing the cursor property, 
	 * forcing IE to update rendering.
	 */
	var self = this;
	setTimeout ( function () {
		self.bindingElement.style.cursor = "default";
		self.bindingElement.style.display = "none";
	}, 0 );
}

TheatreBinding.prototype = new Binding;
TheatreBinding.prototype.constructor = TheatreBinding;
TheatreBinding.superclass = Binding.prototype;

TheatreBinding.CLASSNAME_INITIALIZED = "initialized";

/**
 * @class
 * The TheatreBinding currently handles only one scenario: The server offline show.
 */
function TheatreBinding () {
	
	/**
	 * @type {boolean}
	 */
	this._isPlaying = false;
	
	/**
	 * Don't use fade while the browser is negoatiating a HTTP connection.
	 * @type {boolean}
	 */
	this._isFading = false;
	
	/**
	 * @type {HTMLCanvasElement}
	 */
	this._canvas = null;
	
	/*
	 * Returnable 
	 */
	return this;
}

/**
 * Identifies binding
 * @return {string}
 */
TheatreBinding.prototype.toString = function () {
	
	return "[TheatreBinding]";
}

/**
 * @overloads {Binding#onBindingAttach}
 */
TheatreBinding.prototype.onBindingAttach = function () {
	
	TheatreBinding.superclass.onBindingAttach.call ( this );
	
	this._canvas = document.createElement ( "canvas" );
	if ( Client.isExplorer ) {
		this._canvas.style.filter = "progid:DXImageTransform.Microsoft.Fade(duration=30) progid:DXImageTransform.Microsoft.Alpha(opacity=50)";
	}
	this.bindingElement.appendChild ( this._canvas );
}

/**
 * Play.
 */
TheatreBinding.prototype.play = function ( isFading ) {
	
	this._isFading = isFading == true;
	
	if ( !this._isPlaying ) {
		Application.lock ( this );
		this.show ();
		this._isPlaying = true;
		if ( this._isFading ) {
			this._fade ();
		}
	}
}

TheatreBinding.prototype._fade = function () {
	
	if ( Client.isMozilla ) {
		
		var context = this._canvas.getContext ( "2d" );
		var alpha = parseInt ( 0 );

		TheatreBinding._interval = top.setInterval ( function () {
			if ( alpha < 0.5 ) {
				context.fillStyle = "rgba(0,0,0," + new String ( alpha ) + ")";
				context.clearRect ( 0, 0, 300, 150 );
				context.fillRect ( 0, 0, 300, 150 );
				alpha += 0.002;
			} else {
				top.clearInterval ( TheatreBinding._interval );
				TheatreBinding._interval = null;
			}
		}, 50 );
	} else {
		this._canvas.filters [ 0 ].Apply ();
		this._canvas.style.backgroundColor = "black";
		this._canvas.filters [ 0 ].Play ();
	}
}

/**
 * Stop.
 */
TheatreBinding.prototype.stop = function () {
	
	if ( this._isPlaying ) {
		
		if ( this._isFading ) {
			if ( TheatreBinding._interval != null ) {
				top.clearInterval ( TheatreBinding._interval );
			}
			if ( Client.isExplorer ) {
				this._canvas.style.backgroundColor = "transparent";
			} else {
				var context = this._canvas.getContext ( "2d" );
				context.clearRect ( 0, 0, 300, 150 );
			}
		}
		
		Application.unlock ( this, true ); // boolean arg because Explorer may stay locked...
		this.hide ();
		this._isPlaying = false;
	}
}

SourceCodeViewerBinding.prototype = new WindowBinding;
SourceCodeViewerBinding.prototype.constructor = SourceCodeViewerBinding;
SourceCodeViewerBinding.superclass = WindowBinding.prototype;

SourceCodeViewerBinding.ACTION_INITIALIZED = "sourcecodeviewer initialized";

/**
 * @type {string}
 */
SourceCodeViewerBinding.URL_DEFAULT = "${root}/content/misc/viewers/sourcecodeviewer/viewsourcecontent.aspx";

/*
 * Supported syntax list. Currently only XML supported!
 * type {object}
 */
SourceCodeViewerBinding.syntax = {

	XML : "xml"
}

/*
 * Transformatrix stylesheets.
 * type {HashMap<string><string>}
 */
SourceCodeViewerBinding.stylesheets = {

	"xml" : Resolver.resolve ( "${root}/transformations/viewsource-xml.xsl" )
}

/**
 * @class
 */
function SourceCodeViewerBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SourceCodeViewerBinding" );
	
	/**
	 * @type {string}
	 */
	this._syntax = null;
	
	/**
	 * @type {XSLTransformer}
	 */
	this._transformer = null;
}

/**
 * Identifies binding.
 */
SourceCodeViewerBinding.prototype.toString = function () {
	
	return "[SourceCodeViewerBinding]";
}

/**
 * @overloads {WindowBinding#onBindingAttach}.
 */
SourceCodeViewerBinding.prototype.onBindingAttach = function () {
	
	this._syntax = this.getProperty ( "syntax" );
	
	/*
	 * Verify syntax.
	 */
	switch ( this._syntax ) {
		case SourceCodeViewerBinding.syntax.XML :
			var stylesheet = SourceCodeViewerBinding.stylesheets [ this._syntax ];
			this._transformer = new XSLTransformer ();
			this._transformer.importStylesheet ( stylesheet );
			break;
		default :
			throw "SourceCodeViewer: Syntax error!";
			this._syntax = null;
			break;
	}
	
	/*
	 * Fetch the start content (serverside control scenario).
	 */
	var textarea = DOMUtil.getElementsByTagName ( this.bindingElement, "textarea" ).item ( 0 );
	if ( textarea ) {
		this._startcontent = textarea.value;
	}
	
	this.setURL ( SourceCodeViewerBinding.URL_DEFAULT );
	this.addActionListener ( WindowBinding.ACTION_ONLOAD );
	SourceCodeViewerBinding.superclass.onBindingAttach.call ( this );
}

/** 
 * @implements {IActionListener}
 * @overloads {Binding#handleAction}
 * @param {Action} action
 */
SourceCodeViewerBinding.prototype.handleAction = function ( action ) {

	SourceCodeViewerBinding.superclass.handleAction.call ( this, action );
	
	/*
	 * Show start content when iframe is loaded. Don't expose 
	 * the iframe, dispatching special action instead.
	 */
	switch ( action.type ) {
		case WindowBinding.ACTION_ONLOAD :
			if ( action.target == this ) {
				if ( this._startcontent ) {
					this.view ( this._startcontent );
				}
				this.dispatchAction ( SourceCodeViewerBinding.ACTION_INITIALIZED );
				action.consume ();
			}
			break;
	}
	
	SourceCodeViewerBinding.superclass.handleAction.call ( this, action );
}

/** 
 * View source. 
 * @param {object} arg Argument is loosely dependant on viewer syntax.
 */
SourceCodeViewerBinding.prototype.view = function ( arg ) {
	
	switch ( this._syntax ) {
		case SourceCodeViewerBinding.syntax.XML :
			this._viewXML ( arg );
			break;
	}
}

/** 
 * View XML source.
 * @param {object} arg This should be either a parsable string or an XMLDocument.
 */
SourceCodeViewerBinding.prototype._viewXML = function ( arg ) {
	
	var doc = null;
	
	if ( arg ) {
		if ( typeof arg == Types.STRING ) {
			doc = XMLParser.parse ( arg );
		} else if ( arg.nodeType && arg.nodeType == Node.DOCUMENT_NODE ) {
			doc = object;
		}
	}
	
	if ( doc ) {
		var result = this._transformer.transformToString ( doc );
		this._inject ( result );
	}
}

/** 
 * View HTML source.
 * @param {object} arg This should be either a parsable string or an HTMLDocument.
 */
SourceCodeViewerBinding.prototype._viewHTML = function ( arg ) {
	
	// Note to self: This will require a call to HTMLTidy in Explorer.
}

/** 
 * View HTML source.
 * @param {string} arg This should be a wellformed javascript.
 */
SourceCodeViewerBinding.prototype._viewJavascript = function ( arg ) {
	
	// Note to self: This should probably NOT be done using XSLT.
}

/**
 * Injecting transformation result into iframe document.
 * @param {string} markup
 */
SourceCodeViewerBinding.prototype._inject = function ( markup ) {
	
	this.getContentDocument ().body.innerHTML = markup;
}

PersistanceBinding.prototype = new Binding;
PersistanceBinding.prototype.constructor = PersistanceBinding;
PersistanceBinding.superclass = Binding.prototype;

/**
 * Access ID for IEs 
 * userdata behavior.
 */
PersistanceBinding.USERDATAKEY = "persistance";

/**
 * Access ID for Firefox
 * globalStorage object.
 */
PersistanceBinding.GLOBALSTOREKEY = document.location.host;

/**
 * Default persistance XML document.
 * Loaded for first time user.
 */
PersistanceBinding.TEMPLATE = "storagetemplates/persistance.xml";

/**
 * @class
 * Persistance comes bundled with an element and a binding because    
 * IE handles this stuff via the "userdata behavior". Anyway,  
 * it's good to externalize this code from {@link Persistance}.
 */
function PersistanceBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "PersistanceBinding" );
	
	/**
	 * @type {XPathResolver}
	 */
	this._resolver = null; 
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
PersistanceBinding.prototype.toString = function () {

	return "[PersistanceBinding]";
}

/**
 * Get persistance.
 * @return {HashMap<string><HashMap<string><string>>} 
 */
PersistanceBinding.prototype.getPersistanceMap = function () {
	
	var doc = null;
	var map = null;
	
	/*
	 * First we retrieve XML  
	 * from user filesystem.
	 */
	if ( Client.isExplorer == true ) {
		doc = this._getDocExplorer ();
	} else {
		doc = this._getDocMozilla ();
	}
	
	/*
	 * Next we parse XML into a 
	 * hashmap like structure.
	 */
	if ( doc != null ) {
		
		/*
		 * We store the doc on a variable 
		 * so that we can back it up later.
		 */
		this._document = doc;
		this.logger.fine ( DOMSerializer.serialize ( doc, true ));
		map = this._getPersistanceMap ( this._document );
	}
	
	return map;
}

/**
 * Persist.
 * @param {HashMap<string><HashMap<string><string>>} map
 */
PersistanceBinding.prototype.persist = function ( map ) {
	
	var doc = this._getPersistanceDoc ( map );
	alert ( DOMSerializer.serialize ( doc, true ));
	if ( Client.isExplorer == true ) {
		this._persistDocExplorer ( doc );
	} else {
		this._persistDocMozilla ( doc );
	}
}

/**
 * Parse XML document into a hashmap.
 * @param {DOMDocument} doc
 * @return {HashMap<string><HashMap<string><string>>}
 */
PersistanceBinding.prototype._getPersistanceMap = function ( doc ) {
	
	var map = {};
	
	if ( this._resolver == null ) {
		this._resolver = new XPathResolver ();
		this._resolver.setNamespacePrefixResolver ({
			"p" : Constants.NS_PERSISTANCE
		});
	}
	
	var list = this._resolver.resolveAll ( "p:persist", doc.documentElement );
	while ( list.hasNext ()) {
		
		var persist = list.getNext ();
		var id = persist.getAttribute ( "id" )
		map [ id ] = {};
		
		var atts = this._resolver.resolveAll ( "p:att", persist );
		while ( atts.hasNext ()) {
			
			var att = atts.getNext ();
			var name = att.getAttribute ( "name" );
			var value = att.getAttribute ( "value" );
			
			map [ id ][ name ] = value;
		}
	}
	
	return map;
}

/**
 * Parse hashmap into a XML document.
 * @param {HashMap<string><HashMap<string><string>>} map
 * @return {DOMDocument} doc
 */
PersistanceBinding.prototype._getPersistanceDoc = function ( map ) {
	
	var doc = this._document;
	var elm = doc.documentElement;
	
	/*
	 * Stamp the document with current build number. 
	 * Later builds may choose to delete persisted props.
	 */
	elm.setAttribute ( "version", Installation.versionString );
	
	/*
	 * Empty document (loaded on startup).
	 */
	while ( elm.hasChildNodes ()) {
		elm.removeChild ( elm.lastChild );
	}
	
	/*
	 * Build document from map.
	 */
	for ( var id in map ) {
		var persist = DOMUtil.createElementNS ( Constants.NS_PERSISTANCE, "persist", doc );
		persist.setAttribute ( "id", id );
		for ( var name in map [ id ]) {
			var att = DOMUtil.createElementNS ( Constants.NS_PERSISTANCE, "att", doc );
			att.setAttribute ( "name", name );
			att.setAttribute ( "value", map [ id ][ name ]);
			persist.appendChild ( att );
		}
		elm.appendChild ( persist );
	}
	
	return doc;
}

/**
 * Fetch the XML document in Explorer.
 * @return {DOMDocument}
 */
PersistanceBinding.prototype._getDocExplorer = function () {

	this.bindingElement.load ( PersistanceBinding.USERDATAKEY );
	var doc = this.bindingElement.XMLDocument;

	/*
	 * First time startup? Load clean 
	 * persistance template from filesystem.
	 */
	if ( doc.documentElement.namespaceURI == "" ) {
	
		var file = PersistanceBinding.TEMPLATE;
		var text = Templates.getTemplateElementText ( file );
		doc.loadXML ( text );
		
		/*
		 * Delete the xml comment!
		 */
		var elm = doc.documentElement;
		while ( elm.hasChildNodes ()) {
			elm.removeChild ( elm.firstChild );
		}
	}
	
	return doc;
}

/**
 * Backup the XML document in Explorer.
 * @return {DOMDocument}
 */
PersistanceBinding.prototype._persistDocExplorer = function ( doc ) {
	
	var text = DOMSerializer.serialize ( doc, true );
	this.bindingElement.XMLDocument.loadXML ( text );
	this.bindingElement.save ( PersistanceBinding.USERDATAKEY );
}

/**
 * Fetch the XML document in Mozilla.
 * @return {DOMDocument}
 */
PersistanceBinding.prototype._getDocMozilla = function () {
	
	delete window.globalStorage [ PersistanceBinding.GLOBALSTOREKEY ].persistance; /* !!!!!!!!!!! */
	
	var doc = null;
	var serialized = window.globalStorage [ PersistanceBinding.GLOBALSTOREKEY ].persistance;
	
	/*
	 * Parse the serialized storage 
	 * entry into a DOMDocument.
	 */
	if ( serialized ) {
		doc = XMLParser.parse ( serialized );
		
	/*
	 * Fetch doc from templates,
	 * removing the XML comment.
	 */
	} else {
		var file = PersistanceBinding.TEMPLATE;
		doc = Templates.getTemplateDocument ( file );
		var elm = doc.documentElement;
		while ( elm.hasChildNodes ()) {
			elm.removeChild ( elm.lastChild );
		}
	}
	
	return doc;
}

/**
 * Backup the XML document in Mozilla.
 */
PersistanceBinding.prototype._persistDocMozilla = function ( doc ) {
	
	/*
	 * We could - in theory - simply backup the hashmap structure. 
	 * But let's stick to the same setup as Internet Explorer, 
	 * the XML document is easier to debug and print out anyway. 
	 * We have to store it in serialized form...
	 */
	var serialized = DOMSerializer.serialize ( doc, true );
	window.globalStorage [ PersistanceBinding.GLOBALSTOREKEY ].persistance = serialized;
}

LocalizationSelectorBinding.prototype = new SelectorBinding;
LocalizationSelectorBinding.prototype.constructor = LocalizationSelectorBinding;
LocalizationSelectorBinding.superclass = SelectorBinding.prototype;

/**
 * @class
 */
function LocalizationSelectorBinding () {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "LocalizationSelectorBinding" );
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
LocalizationSelectorBinding.prototype.toString = function () {

	return "[LocalizationSelectorBinding]";
}

/**
 * @overloads {SelectorBinding#onBindingAttach}
 */
LocalizationSelectorBinding.prototype.onBindingAttach = function () {
	
	LocalizationSelectorBinding.superclass.onBindingAttach.call ( this );
	this.subscribe ( BroadcastMessages.UPDATE_LANGUAGES );
	this._populateFromLanguages ( Localization.languages );
}

/**
 * @implements {IBroadcastListener}
 * @param {string} broadcast
 * @param {object} arg
 */
LocalizationSelectorBinding.prototype.handleBroadcast = function ( broadcast, arg ) {
	
	LocalizationSelectorBinding.superclass.handleBroadcast.call ( this, broadcast, arg );
	
	switch ( broadcast ) {
		
		case BroadcastMessages.UPDATE_LANGUAGES :
			this._populateFromLanguages ( arg );
			break;
			
		case BroadcastMessages.SAVE_ALL_DONE :
			this.unsubscribe ( BroadcastMessages.SAVE_ALL_DONE );
			EventBroadcaster.broadcast ( BroadcastMessages.CLOSE_VIEWS );
			this._invokeAction ();
			break;
	}
}

/**
 * Populate selector. If no argument, then hide the selector.
 * @param {List<object>} list A list of objects with the following properties: 
 * Name
 * IsoName
 * UrlMappingName
 * IsCurrent
 * SerializedActionToken         
*/
LocalizationSelectorBinding.prototype._populateFromLanguages = function ( list ) {
	
	if ( list != null && list.hasEntries () && list.getLength () > 1 ) {
		var selections = new List ();
		list.each ( function ( lang ) {
			selections.add ( 
				new SelectorBindingSelection (
					lang.Name,
					lang.SerializedActionToken,
					lang.IsCurrent,
					null
				)
			);
		});
		this.populateFromList ( selections );
		this.show ();
	} else {
		this.hide ();
	}
}

/**
 * Backup old value so that we may cancel selector change.
 * @overwrites {SelectorBinding#populateFromList}
 * @param {List<SelectorBindingSelection>} list
 */
LocalizationSelectorBinding.prototype.populateFromList = function ( list ) {
	
	LocalizationSelectorBinding.superclass.populateFromList.call ( this, list );
	this._backupSelectionValue = this._selectionValue;
}

/**
 * @overwrites {SelectorBinding#onValueChange}
 */
LocalizationSelectorBinding.prototype.onValueChange = function () {
	
	var self = this;
	Dialog.warning ( 
		StringBundle.getString ( StringBundle.UI, "UserElementProvider.ChangeOtherActiveLocaleDialogTitle" ), 
		StringBundle.getString ( StringBundle.UI, "UserElementProvider.ChangeOtherActiveLocaleDialogText" ),
		Dialog.BUTTONS_ACCEPT_CANCEL, {
		handleDialogResponse : function ( response ) {
			switch ( response ) {
				case Dialog.RESPONSE_ACCEPT :
					if ( Application.hasDirtyDockTabs ()) {
						self.subscribe ( BroadcastMessages.SAVE_ALL_DONE );
						EventBroadcaster.broadcast ( BroadcastMessages.SAVE_ALL );
					} else {
						EventBroadcaster.broadcast ( BroadcastMessages.CLOSE_VIEWS );
						self._invokeAction ();
					}
					self._backupSelectionValue = self.getValue ();
					break;
				case Dialog.RESPONSE_CANCEL :
					self.selectByValue ( self._backupSelectionValue );
					break;
			}
		}
	})
}

/**
 * Invoke that action!
 */
LocalizationSelectorBinding.prototype._invokeAction = function () {
	
	var token = this.getValue ();
	var root = SystemNode.taggedNodes.get ( "Root" );
	var action = new SystemAction ({
		Label : "Generated Action: Change Locale",
		ActionToken : token
	});
	SystemAction.invoke ( action, root );
}

ResponseBinding.prototype = new Binding;
ResponseBinding.prototype.constructor = ResponseBinding;
ResponseBinding.superclass = Binding.prototype;

ResponseBinding.ACTION_SUCCESS = "response success";
ResponseBinding.ACTION_OOOOKAY = "response ooookay";
ResponseBinding.ACTION_FAILURE = "response failure";

/**
 * @class
 */
function ResponseBinding () {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "ResponseBinding" );
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Identifies binding.
 */
ResponseBinding.prototype.toString = function () {

	return "[ResponseBinding]";
}

/**
 * Note that we evaluate status as soon as binding attaches.
 * @overloads {Binding#onBindingAttach}
 */
ResponseBinding.prototype.onBindingAttach = function () {

	ResponseBinding.superclass.onBindingAttach.call ( this );
	this.propertyMethodMap [ "checksum" ] = this._update;
	this._update ();
}

/**
 * Update stuff!
 */
ResponseBinding.prototype._update = function () {
	
	/*
	 * Any status updates? These ations get intercepted somewhere in PageBinding.
	 * @see {PageBinding#_setupDotNet}
	 */
	var status = this.getProperty ( "status" );
	if ( status != null ) {
		switch ( status ) {
			case "success" :
				this.dispatchAction ( ResponseBinding.ACTION_SUCCESS );
				break;
			case "failure" :
				this.dispatchAction ( ResponseBinding.ACTION_FAILURE );
				break;
			case "ooookay" :
				this.dispatchAction ( ResponseBinding.ACTION_OOOOKAY );
				break;
		}
	}
	
	/*
	 * Any messages?
	 */
	var index = this.getProperty ( "messagequeueindex" );
	if ( index != null ) {
		/*
		this.logger.debug ( 
			"Client MessageQueue index: " + MessageQueue.index + "\n" + 
			"Server MessageQueue index: " + index 
		);
		*/
		if ( index > MessageQueue.index ) {
			MessageQueue.update ();
		}
	}
}

/**
 * @class
 * @param {HashMap<string><BindingImplementation>} map
 */
function UserInterfaceMapping ( map ) {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "UserInterfaceMapping" );
	
	/**
	 * @type {HashMap<string><BindingImplementation>}
	 */
	this.map = map;
}

/**
 * Merge with another mapping.
 * @param {UserInterfaceMapping} mapping
 */
UserInterfaceMapping.prototype.merge = function ( mapping ) {
	
	for ( var nodename in mapping.map ) {
		this.map [ nodename ] = mapping.getBindingImplementation ( nodename );
	}
}

/**
 * Get binding implementation for a given element.
 * @param {DOMElement} element
 * @return {BindingImplementation}
 */
UserInterfaceMapping.prototype.getBindingImplementation = function ( element ) {
	
	var result = null;
	var name = element.nodeName;
	
	if ( Client.isExplorer ) {
		var small = name.toLowerCase ();
		if ( name == small ) {
			name = "ui:" + name;
		} else {
			name = small;
		}
	}
	
	if ( this.map [ name ]) {
		result = this.map [ name ];
	}
	return result;
}

/**
 * @class
 * UserInterface.
 */
var UserInterface = new function () {
	
	/*
	 * This binding implementation is browser specific!
	 */
	var editortextboximpl = ( Client.isMozilla ? MozEditorTextBoxBinding : IEEditorTextBoxBinding );
	
	/*
	 * Application scope binding mappings. 
	 * These may be overruled locally.
	 */
	var mapping = new UserInterfaceMapping ({
	
		"body"							: RootBinding,
		"ui:binding"					: Binding,
		"ui:box"						: Binding,
		"ui:dialog"						: DialogBinding,
		"ui:dialoghead"					: DialogHeadBinding,
		"ui:dialogbody"					: DialogBodyBinding,
		"ui:dialogmatrix"				: DialogMatrixBinding,
		"ui:dialogset"					: DialogSetBinding,
		"ui:dialogborder"				: DialogBorderBinding,
		"ui:dialogcover"				: DialogCoverBinding,
		"ui:titlebar"					: DialogTitleBarBinding,
		"ui:titlebarbody"				: DialogTitleBarBodyBinding,
		"ui:window"						: WindowBinding,
		"ui:controlgroup"				: ControlGroupBinding,
		"ui:control"					: ControlBinding,
		"ui:menubar" 					: MenuBarBinding,
		"ui:menu" 						: MenuBinding,
		"ui:menubody" 					: MenuBodyBinding,
		"ui:menugroup" 					: MenuGroupBinding,
		"ui:menuitem" 					: MenuItemBinding,
		"ui:menupopup" 					: MenuPopupBinding,
		"ui:tabbox" 					: TabBoxBinding,
		"ui:tabs" 						: TabsBinding,
		"ui:tab" 						: TabBinding,
		"ui:tabpanels" 					: TabPanelsBinding,
		"ui:tabpanel" 					: TabPanelBinding,
		"ui:splitbox" 					: SplitBoxBinding,
		"ui:splitpanel" 				: SplitPanelBinding,
		"ui:splitter" 					: SplitterBinding,
		"ui:decks" 						: DecksBinding,
		"ui:deck" 						: DeckBinding,
		"ui:toolbar" 					: ToolBarBinding,
		"ui:toolbargroup"				: ToolBarGroupBinding,
		"ui:toolbarbody"				: ToolBarBodyBinding,
		"ui:toolbarbutton" 				: ToolBarButtonBinding,
		"ui:toolbarlabel" 				: ToolBarLabelBinding,
		"ui:labelbox" 					: LabelBinding,
		"ui:text" 						: TextBinding,
		"ui:clickbutton" 				: ClickButtonBinding,
		"ui:tree" 						: TreeBinding,
		"ui:treebody" 					: TreeBodyBinding,
		"ui:treenode" 					: TreeNodeBinding,
		"ui:flexbox" 					: FlexBoxBinding,
		"ui:scrollbox" 					: ScrollBoxBinding,
		"ui:popupset" 					: PopupSetBinding,
		"ui:popup" 						: PopupBinding,
		"ui:shadow" 					: ShadowBinding,
		"ui:matrix" 					: MatrixBinding,
		"ui:sourceeditor"				: SourceEditorBinding,
		"ui:visualeditor" 				: VisualEditorBinding,
		"ui:visualmultieditor" 			: VisualMultiEditorBinding,
		"ui:visualmultitemplateeditor" 	: VisualMultiTemplateEditorBinding,
		"ui:wysiwygeditortoolbarbutton" : EditorToolBarButtonBinding, // needed?
		"ui:dock" 						: DockBinding,
		"ui:docktabs" 					: DockTabsBinding,
		"ui:docktab" 					: DockTabBinding,
		"ui:dockpanels" 				: DockPanelsBinding,
		"ui:dockpanel"					: DockPanelBinding,
		"ui:page"						: PageBinding,
		"ui:editorpage"					: EditorPageBinding,
		"ui:dialogpage"					: DialogPageBinding,
		"ui:pagebody"					: DialogPageBodyBinding,
		"ui:wizardpage"					: WizardPageBinding,
		"ui:explorer" 					: ExplorerBinding,
		"ui:explorerdecks" 				: ExplorerDecksBinding,
		"ui:explorerdeck" 				: ExplorerDeckBinding,
		"ui:explorersplitter" 			: ExplorerSplitterBinding,
		"ui:explorermenu" 				: ExplorerMenuBinding,
		"ui:explorertoolbar" 			: ExplorerToolBarBinding,
		"ui:explorertoolbarbutton"		: ExplorerToolBarButtonBinding,
		"ui:stagecontainer"				: StageContainerBinding,
		"ui:stage"						: StageBinding,
		"ui:stagedecks"					: StageDecksBinding,
		"ui:stagedeck"					: StageDeckBinding,
		"ui:viewset"					: ViewSetBinding,
		"ui:view"						: ViewBinding,
		"ui:broadcasterset"				: BroadcasterSetBinding,
		"ui:broadcaster"				: BroadcasterBinding,
		"ui:fields"						: FieldsBinding,
		"ui:fieldgroup"					: FieldGroupBinding,
		"ui:field"						: FieldBinding,
		"ui:fielddesc"					: FieldDescBinding,
		"ui:fielddata"					: FieldDataBinding,
		"ui:fieldhelp"					: FieldHelpBinding,
		"ui:datainput"					: DataInputBinding,
		"ui:selector"					: SelectorBinding,
		"ui:simpleselector"				: SimpleSelectorBinding,
		"ui:multiselector"				: MultiSelectorBinding,
		"ui:datainputselector"			: DataInputSelectorBinding,
		"ui:datainputdialog"			: DataInputDialogBinding,
		"ui:textbox"					: TextBoxBinding,
		"ui:editortextbox"				: editortextboximpl,
		"ui:radiodatagroup"				: RadioDataGroupBinding,
		"ui:radio"						: RadioDataBinding,
		"ui:checkbutton"				: CheckButtonBinding,
		"ui:checkbox"					: CheckBoxBinding,
		"ui:checkboxgroup"				: CheckBoxGroupBinding,
		"ui:datadialog"					: DataDialogBinding,
		"ui:postbackdialog"				: PostBackDataDialogBinding,
		"ui:nullpostbackdialog"			: NullPostBackDataDialogBinding,
		"ui:htmldatadialog"				: HTMLDataDialogBinding,
		"ui:functioneditor"				: FunctionEditorDataBinding,
		"ui:parametereditor"			: ParameterEditorDataBinding,
		"ui:keyset"						: KeySetBinding,
		"ui:cover"						: CoverBinding,
		"ui:uncover"					: UncoverBinding,
		"ui:cursor"						: CursorBinding,
		"ui:dialogtoolbar"				: DialogToolBarBinding,
		"ui:focus"						: FocusBinding,
		"ui:balloonset"					: BalloonSetBinding,
		"ui:balloon"					: BalloonBinding,
		"ui:error"						: ErrorBinding,
		"ui:throbber"					: ThrobberBinding,
		"ui:progressbar"				: ProgressBarBinding,
		"ui:lazybinding"				: LazyBindingBinding,
		"ui:sourcecodeviewer"			: SourceCodeViewerBinding,
		"ui:theatre"					: TheatreBinding,
		"ui:persistance"				: PersistanceBinding,
		"ui:filepicker"					: FilePickerBinding,
		"ui:request"					: RequestBinding,
		"ui:response"					: ResponseBinding
	});
	
	/*
	 * @type {SystemLogger}
	 */
	var logger = SystemLogger.getLogger ( "UserInterface" );
	
	/*
	 * Indexing an object with two properties, "element" and "binding".
	 * @type {HashMap<string><object>}
	 */
	var keys = {};
	
	/**
	 * Regsiter element with binding implementation. If you omit the binding 
	 * implementation, we will search the element environment for the most 
	 * likely binding to register with.
	 * @param {DOMElement} element
	 * @param {Binding} impl Optional
	 * @return {Binding} Returns null if no suitable Binding was found.
	 */
	this.registerBinding = function ( element, impl ) {
		
		var binding = null;
		
		if ( !this.hasBinding ( element )) {
		
			var parentWindow = DOMUtil.getParentWindow ( element );
			
			if ( DOMUtil.getLocalName ( element ) != "bindingmapping" ) {
				
				// setup the quick and dirty way of assigning a custom binding
				if ( !impl && element.getAttribute ( "binding" ) != null ) {
					var bindingstring = element.getAttribute ( "binding" );
					impl = parentWindow [ bindingstring ];
					if ( impl == null ) {
						throw "No such binding in scope: " + bindingstring;
					}
				}
				
				// check for local scope binding mapping
				if ( !impl ) {
					var manager = parentWindow.DocumentManager;
					if ( manager ) {
						var custom = manager.customUserInterfaceMapping;
						if ( custom ) {
							impl = custom.getBindingImplementation ( element );
						}
					}
				}
				
				// check for global scope binding mapping
				if ( !impl ) {
					impl = mapping.getBindingImplementation ( element );
				}
				
				// instantiate new binding
				if ( impl != null && !Application.isMalFunctional ) {
					try {
						binding = new impl ();
					} catch ( exception ) {
						Application.isMalFunctional = true;
						alert ( "No such binding!\n" + exception.message + ( exception.stack ? "\n" + exception.stack : "" ));
						throw ( exception );
					}
				}
				
				// register element and binding, invoking the bindings onBindingRegister method. 
				if ( binding ) {
				
					var key = KeyMaster.getUniqueKey ();
					element.setAttribute ( "key", key );
					binding.key = key;
					if ( !element.id ) {
						element.id = key;
					}
					keys [ key ] = {
						element : element,
						binding : binding
					}
					binding.onBindingRegister ();
				}
			}
		}
		
		/*
		 * Finally return the binding.
		 */
		return binding;
	}
	
	/**
	 * Unregister binding. This will destroy the binding.
	 * @param {Binding} binding
	 */
	this.unRegisterBinding = function ( binding ) {
		
		terminate ( binding );
	}
	
	/**
	 * Terminate Binding.
	 */
	function terminate ( binding ) {
		
		if ( Binding.exists ( binding ) == true ) {
			var key = binding.key; 
			Binding.destroy ( binding );
			if ( key ) {
				if ( keys [ key ]) {
					keys [ key ].binding = null;
					keys [ key ].element = null;
					delete keys [ key ];
					binding = null;
				} else {
					logger.error ( "URGH: " + key );
				}
			}
		}
	}
	
	/**
	 * @param {Binding} binding
	 * @return {DOMElement}
	 * @deprecated
	 */
	this.getElement = function ( binding ) {
	
		var result = null;
		if ( keys [ binding.key ]) {
			result = keys [ binding.key ].element;
		}
		return result;
	}
	
	/**
	 * Get binding by bound element.
	 * @param {DOMElement} element
	 * @return {Binding}
	 */
	this.getBinding = function ( element ) {
	
		var result = null;
		if ( element && element.nodeType == Node.ELEMENT_NODE ) {
			try {
				var key = element.getAttribute ( "key" );
				if ( key && keys [ key ]) {
					result = keys [ key ].binding;
				}
			} catch ( exception ) { // if this happens, you can usually solve with a timeout
				alert ( "getBinding exception occured on element:\n\n\t\t" + element );
				if ( exception.stack ) {
					alert ( exception.stack );
				}
			}
		}
		return result;
	}
	
	/**
	 * Get binding by key.
	 * @param {string} key
	 * @return {Binding}
	 */
	this.getBindingByKey = function ( key ) {
		
		var result = null;
		if ( keys [ key ]) {
			result = keys [ key ].binding;
		}
		return result;
	}
	
	/**
	 * @param {DOMElement} element
	 * @return {boolean}
	 */
	this.hasBinding = function ( element ) {
	
		return this.getBinding ( element ) != null;
	}
	
	/**
	 * TODO: explain this!
	 */
	this.isBindingVisible = function ( binding ) {
		
		/*
		 * Note that we return false while startup up 
		 * for reasons of very small performance gain.
		 */
		var result = Application.isOperational;
		
		if ( result == true ) {
			
			/*
			 * TODO: construct this crawler only once!
			 */
			var crawler = new Crawler ();
			crawler.type = NodeCrawler.TYPE_ASCENDING;
			crawler.id = "visibilitycrawler";
			crawler.addFilter ( function ( element ) {
				var b = UserInterface.getBinding ( element );
				var res = 0;
				if ( !b.isVisible ) {
					result = false;
					res = NodeCrawler.STOP_CRAWLING;
				}
				return res;
			});
			crawler.crawl ( binding.bindingElement );
			crawler.dispose ();
		}
		return result;
	}
	
	// DEBUG STUFF ................................................................
	
	var debugKeys = null;
	
	/**
	 * Counting active Binding instances.
	 * @return {int}
	 */
	this.getBindingCount = function () {
	
		var count = 0;
		for ( var key in keys ) {
			count ++;
		}
		return count;
	}
	
	/*
	 * Copy all keys to a reference hashmap.
	 */
	this.setPoint = function () {
	
		debugKeys = {};
		for ( var key in keys ) {
			debugKeys [ key ] = true;
		}
	}
	
	/*
	 * Return list of NEW keys since point was set (see setPoint). 
	 * This can be used to pinpoint bindings not properly disposed.
	 * @return {List<string>}
	 */
	this.getPoint = function () {
		
		var result = null;
		if ( debugKeys ) {
			result = new List ();
			for ( var key in keys ) {
				if ( !debugKeys [ key ]) {
					result.add ( key );
				}
			}
		}
		return result;
	}
	
	/*
	 * Enough point.
	 */
	this.clearPoint = function () {
		
		debugKeys = null;
	}
	
	/**
	 * Tracking undisposed bindings.
	 */
	this.trackUndisposedBindings = function () {
		
		var report = null;
		
		for ( var key in keys ) {
			var entry = keys [ key ];
			if ( !entry.binding || !entry.element || !Binding.exists ( entry.binding )) {
				if ( !report ) {
					report = "Bindings illdisposed: ";
				}
				report += entry.binding + " ";
			}
		}
		if ( report != null ) {
			logger.error ( report );
		}
	}
	
	/**
	 * Autotrack.
	 * @param {boolean} isTrack
	 */
	this.autoTrackDisposedBindings = function ( isTrack ) {
		
		if ( isTrack ) {
			if ( !window.disposedbindingtrackinterval ) {
				window.disposedbindingtrackinterval = window.setInterval ( 
					UserInterface.trackUndisposedBindings, 10000 
				);
				this.trackUndisposedBindings ();
			}
		} else if ( window.disposedbindingtrackinterval ) {
			window.clearInterval ( window.disposedbindingtrackinterval );
			window.disposedbindingtrackinterval = null;
		}
	}
}

/**
 * @class
 */
function SOAPMessage () {}

SOAPMessage.prototype = {
	
	/** @type {DOMDocument} */
	document : null,
		
	/** @type {DOMElement} */
	envelope : null,
		
	/** @type {DOMElement} */
	header : null,
		
	/** @type {DOMElement} */
	body : null,
		
	/** @type {DOMElement} */
	fault : null
} 
	

SOAPRequest.prototype = new SOAPMessage;
SOAPRequest.prototype.constructor = SOAPRequest;
SOAPRequest.superclass = SOAPMessage.prototype;

/**
 * @type {XPathResolver}
 */
SOAPRequest.resolver = new XPathResolver ();
SOAPRequest.resolver.setNamespacePrefixResolver ({
	"soap" : Constants.NS_ENVELOPE,
	"xhtml" : Constants.NS_XHTML
});

/**
 * SOAPRequest factory method. Making sure that 
 * we instantiate only a single XPathResolver.
 * @param {string} namespace
 * @param {string} operation
 * @return {SOAPRequest}
 */
SOAPRequest.newInstance = function ( namespace, operation ) {
	
	var action			= namespace + "/" + operation;
	var request			= new SOAPRequest ( action );
	var resolver		= SOAPRequest.resolver;
	
	request.document	= Templates.getTemplateDocument ( "soapenvelope.xml" );
	request.envelope	= resolver.resolve ( "soap:Envelope", request.document );
	request.header		= resolver.resolve ( "soap:Header", request.envelope );
	request.body		= resolver.resolve ( "soap:Body", request.envelope );
	
	return request;
}

/**
 * Parse response.
 * @param {XMLHttpRequest} request
 * @return
 */
SOAPRequest._parseResponse = function ( request ) {
	
	var result = null;
	var isOffLine = false;
	var doc = request.responseXML;
	
	/*
	 * XML was returned.
	 */
	if ( doc != null && doc.documentElement != null ) {
		switch ( doc.documentElement.namespaceURI ) {
		
			/*
			 * Case SOAP - request success!
			 */
			case Constants.NS_ENVELOPE :
				result = SOAPRequestResponse.newInstance ( 
					request.responseXML 
				);
				if ( Application.isOffLine ) {
					EventBroadcaster.broadcast ( BroadcastMessages.SERVER_ONLINE );
				}
				break;
			
			/*
			 * Case XHTML. Probably the server went offline.
			 * Only Mozilla will intercept this; Explorer 
			 * sees only text garbage in this case, see below.
			 */
			case Constants.NS_XHTML :
				if ( !Application.isOffLine ) {
					var body = SOAPRequest.resolver.resolve ( 
						"xhtml:html/xhtml:body", 
						request.responseXML 
					);
					if ( body && body.getAttribute ( "id" ) == "offline" ) {
						isOffLine = true;
					}
				}
				break;
				
			case Constants.NS_DOMPARSEERROR :
				var cry = DOMSerializer.serialize ( doc );
				SystemLogger.getLogger ( "SOAPRequest._parseResponse (static)" ).error ( cry );
				if ( Application.isDeveloperMode ) {
					alert ( "SOAPRequest parseerror! \n\n" + cry );
				}
				break;
				
			default :
				if ( Application.isDeveloperMode ) {
					alert ( "SOAPRequest: " + doc.documentElement.namespaceURI )
				}
				break;
		}
		
	/*
	 * Garbage was returned.
	 */
	} else {
		
		/*
		 * Analyze garbage - is it the offline page?
		 */
		if ( !Application.isOffLine && !Application.isLoggedOut ) {
			var text = request.responseText;
			if ( text.indexOf ( "id=\"offline\"" ) >-1 ) {
				isOffLine = true;
			} else {
				var cry = "Invalid SOAP response: \n\n" + request.responseText;
				SystemLogger.getLogger ( "SOAPRequest._parseResponse (static)" ).error ( cry );
				if ( Application.isDeveloperMode ) {
					alert ( "Invalid SOAP response" );
					window.open ( "about:blank" ).document.write ( request.responseText );
				}
			}
		}
	}
	
	/*
	 * Broadcast intercepted by MessageQueue and Application.
	 */
	if ( isOffLine == true ) {
		EventBroadcaster.broadcast ( BroadcastMessages.SERVER_OFFLINE );
	}
	
	return result;
}


/**
 * @class
 * @param {string} action
 * Please use factory method!
 */
function SOAPRequest ( action ) {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SOAPRequest" );
	
	/** 
	 * @type {String} 
	 */
	this.action = action;
	
	/*
	 * Returnable.
	 */
	return this;
}

/**
 * Invoke request.
 * @param {string} url
 * @return {SOAPRequestResponse}
 */
SOAPRequest.prototype.invoke = function ( url ) {
	
	var request = DOMUtil.getXMLHTTPRequest ();
	var response = null;
	
	request.open ( "post", url,  false );
	request.setRequestHeader ( "Content-Type", "text/xml; charset=UTF-8" );
	request.setRequestHeader ( "SOAPAction", this.action );
	
	try {
		request.send ( this.document );
		response = SOAPRequest._parseResponse ( request );
	} catch ( exception ) {
		var error = "Dysfuntion in SOAP invoke: " + url;
		if ( this.document != null ) {
			error += "\n" + DOMSerializer.serialize ( this.document, true );
		}
		this.logger.error ( error );
		throw exception;
	}
	
	request = null;
	return response;
}

/**
 * Each request wraps a full DOM document. 
 * No time to wait for the garbage collector.
 */
SOAPRequest.prototype.dispose = function () {
	
	for ( var property in this ) {
		this [ property ] = null;
	}
}

SOAPRequestResponse.prototype = new SOAPMessage;
SOAPRequestResponse.prototype.constructor = SOAPRequestResponse;
SOAPRequestResponse.superclass = SOAPMessage.prototype;

/**
 * @class
 * Please use static factory method, see below. The word "SOAPResponse" is reserved 
 * for a Mozilla native javascript object, unfortunately we cannot use it.
 * TODO: Soap has been discontinued in Firefox 3.0, so maybe we can use it soon...
 */
function SOAPRequestResponse () {}

/**
 * @type {SystemLogger}
 */
SOAPRequestResponse.logger = SystemLogger.getLogger ( "SOAPRequestResponse" );

/**
 * @type {XPathResolver}
 */
SOAPRequestResponse.resolver = new XPathResolver ();
SOAPRequestResponse.resolver.setNamespacePrefixResolver ({
	"soap" : Constants.NS_ENVELOPE
});

/**
 * @param {DOMDocument} doc
 */
SOAPRequestResponse.newInstance = function ( doc ) {
	
	var response = null;
	
	if ( doc && doc.documentElement ) {
	
		response = new SOAPRequestResponse ();
		var resolver = SOAPRequestResponse.resolver;
		
		response.document	= doc;
		response.envelope	= resolver.resolve ( "soap:Envelope", response.document );
		response.header		= resolver.resolve ( "soap:Header", response.envelope );
		response.body		= resolver.resolve ( "soap:Body", response.envelope );
		
		var fault = resolver.resolve ( "soap:Fault", response.body );
		if ( fault ) {
			SOAPRequestResponse.logger.fatal ( 
				DOMSerializer.serialize ( fault, true )
			);
			response.fault = {
				element 			: fault,
				faultNamespaceURI	: fault.namespaceURI,
				faultCode		 	: DOMUtil.getTextContent ( resolver.resolve ( "faultcode", fault )),
				faultString		 	: DOMUtil.getTextContent ( resolver.resolve ( "faultstring", fault )),
				detail				: fault.getElementsByTagName ( "detail" ).item ( 0 )
			}
		}
	}
	return response;
}

/**
 * @class
 * Please use factory method below.
 * @param {string} operationName
 * @param {string} operationAddress
 * @param {string} faultString
 */
function SOAPFault ( operationName, operationAddress, faultString ) {
	
	this._operationName = operationName;
	this._operationAddress = operationAddress;
	this._faultString = faultString;
}

/**
 * Get operation name.
 * @return {string}
 */
SOAPFault.prototype.getOperationName = function () {
	
	return this._operationName;
}

/**
 * Get operation address.
 * @return {string}
 */
SOAPFault.prototype.getOperationAddress = function () {
	
	return this._operationAddress;
}

/**
 * Get fault string.
 * @return {string}
 */
SOAPFault.prototype.getFaultString = function () {

	return this._faultString;
}

/**
 * SOAPFault factory.
 * @param {WebServiceOperation} operation
 * @param {object} fault
 */
SOAPFault.newInstance = function ( operation, fault ) {
	
	return new SOAPFault ( 
		operation.name, 
		operation.address, 
		fault.faultString 
	);
}

/**
 * @class
 * @param {WSDLParser} wsdl
 * @param {string} operationName
 */

function SOAPEncoder ( wsdl, operation ) {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SOAPEncoder" );
	
	/** 
	 * @type {WSDLParser} 
	 * @private
	 */
	this._wsdl = wsdl;
	
	/** 
	 * @type {string} 
	 * @private
	 */
	this._operation = operation;
	
	/** 
	 * @type {string} 
	 * @private
	 */
	this._namespace = wsdl.getTargetNamespace ();
}

/**
 * @param {List} args
 * @return {SOAPMessage}
 */
SOAPEncoder.prototype.encode = function ( args ) {
	
	var message		= SOAPRequest.newInstance ( this._namespace, this._operation );
	var root 		= this._appendElement ( message.body, this._operation );
	var schema 		= this._wsdl.getSchema ();
	var schemaType 	= schema.lookup ( this._operation );
	var definitions	= schemaType.getListedDefinitions ();
	
	while ( definitions.hasNext ()) {
		var def = definitions.getNext ();
		var elm = this._appendElement ( root, def.name );
		var val = args.getNext ();
		this._resolve ( elm, def, val );
	}
	return message;
}

/**
 * @param {DOMElement} element
 * @param {SchemaDefinition} definition
 * @param {object} value
 */
SOAPEncoder.prototype._resolve = function ( element, definition, value ) {

	var schema = this._wsdl.getSchema ();
	
	if ( definition.isSimpleValue ) {
		this._appendText ( element, value, definition.type == "string" );
	} else {
	
		var schemaType 	= schema.lookup ( definition.type );
		if ( schemaType instanceof SchemaSimpleType ) {
			alert ( "SOAPEncoder: SchemaSimpleType support not implemented!" );
		} else {
			var defs = schemaType.getListedDefinitions ();
			if ( schemaType.isArray ) {
				var entries = new List ( value );
				var def = defs.getNext ();
				while ( entries.hasNext ()) {
					var elm = this._appendElement ( element, def.name );
					var val = entries.getNext ();
					this._resolve ( elm, def, val );
				}
			} else {
				while ( defs.hasNext ()) {
					try {
						var def = defs.getNext ();
						var elm = this._appendElement ( element, def.name );
						var val = value [ def.name ];						
						this._resolve ( elm, def, val );
					} catch ( exception ) {
						
						// This can happen when opening dataitems in particular.
						// Apparently, we recieve no OpenIcon but attempt to send it back...
						this.logger.error ( "Mysterius malfunction in " + this._operation + ":\n\n" + def.name + ": " + value )
					}
				}
			}
		}
	}
}

/**
 * @param {DOMNode} node
 * @return {DOMElement}
 */
SOAPEncoder.prototype._appendElement = function ( node, name ) {
	
	var child = DOMUtil.createElementNS ( 
		this._namespace, name, node.ownerDocument 
	);
	node.appendChild ( child );
	return child;
}

/**
 * Text stripped according to http://www.w3.org/TR/REC-xml/#charsets because 
 * delicious Office applications may throw in all sorts of illegal characters. 
 * @param {DOMElement} element
 * @param {object} value
 * @param {boolean} isString - not really used...
 */
SOAPEncoder.prototype._appendText = function ( element, value, isString ) {
	
	if ( value != null ) {
		
		value = new String ( value );
		var safe = new String ( "" );
		var chars = value.split ( "" );
		var wasDeleted = false;
		var i = 0, c;
		
		while ( c = chars [ i++ ]) {
			
			var isAbort = true;
			var code = c.charCodeAt ( 0 );
			
			// case 0x10 :
			// case 0x13 :
			
			switch ( code ) {
				case 0x9 :
				case 0xA :
				case 0xD :
					isAbort = false;
					break;
				default :
					if (
						( code >= 0x20 && code <= 0xD7FF ) ||
						( code >= 0xE000 && code  <= 0xFFFD ) || 
						( code >= 0x10000 && code <= 0x10FFFF )
					) {
						isAbort = false;
					}
					break;
			}
			if ( !isAbort ) {
				safe += c;
			} else {
				wasDeleted = true;
			}			
		}
		
		if ( wasDeleted ) {
			this.logger.debug ( "Illegal XML character(s) was deleted from the string: " + value )
		}
		
		element.appendChild ( element.ownerDocument.createTextNode ( safe ));
	}
}

/**
 * @class
 * @param {WSDLParser} wsdl
 * @param {string} operationName
 */

function SOAPDecoder ( wsdl, operation ) {
	
	/** 
	 * @type {WSDLParser} 
	 * @private
	 */
	this._wsdl = wsdl;
	
	/** 
	 * @type {string} 
	 * @private
	 */
	this._operation = operation;
	
	/** 
	 * @type {XpathResolver} 
	 * @private
	 */
	this._resolver = new XPathResolver ();
	this._resolver.setNamespacePrefixResolver ({
		"result" : wsdl.getTargetNamespace ()
	});
}

/**
 * @param {string} xpath
 * @param {DOMNode} node
 * @return {DOMElement)
 */
SOAPDecoder.prototype.resolve = function ( xpath, node ) {
	return this._resolver.resolve ( "result:" + xpath, node );
}

/**
 * @param {string} xpath
 * @param {DOMNode} node
 * @return {List)
 */
SOAPDecoder.prototype.resolveAll = function ( xpath, node ) {
	return this._resolver.resolveAll ( "result:" + xpath, node );
}

/**
 * We assume the webservice to follow this convention: If a request element is 
 * called "GetSomething", the result element will be wrapped in two elements 
 * called "GetSomethingResponse" and "GetSomethingResult". This is always the 
 * case for NET services, but it is possible to  extract this information from 
 * the WSDL.
 * @param {SOAPRequestResponse} soapResponse
 * @return {object}
 */
SOAPDecoder.prototype.decode = function ( soapResponse ) {

	var result	= null;
	var schema	= this._wsdl.getSchema ();
	
	// find the "response" element
	var id = this._operation + "Response";
	var responseElm = this.resolve ( id, soapResponse.body ); 
	
	// lookup the matching schema entity
	var schemaType = schema.lookup ( id );
	var definitions = schemaType.getListedDefinitions ();
	
	while ( !result && definitions.hasNext ()) {
	
		// find the "result" element and lookup the matching definition
		var def = definitions.getNext ();
		var elm = this.resolve ( def.name, responseElm )
		
		if ( def.type == SchemaDefinition.TYPE_XML_DOCUMENT ) {
			result = DOMUtil.getDOMDocument ();
			var e = elm.getElementsByTagName ( "*" ).item ( 0 );
			if ( typeof result.importNode != Types.UNDEFINED ) { // case for Moz and IE7
				result.appendChild ( 
					result.importNode ( e, true )
				);
			} else { // case for IE6
				result.loadXML ( 
					DOMSerializer.serialize ( e )
				);
			}
		} else { // start recursive process, following same pattern
			result = this._compute ( elm, def );
		}
	}
	return result;
}

/**
 * @param {DOMElement} element
 * @param {SchemaDefinition} definition
 */
SOAPDecoder.prototype._compute = function ( element, definition ) {

	var result = null;
	var schema = this._wsdl.getSchema ();

	if ( definition.isSimpleValue ) {
		result = this._getSimpleValue ( element, definition.type );
	} else {
		var schemaType = schema.lookup ( definition.type );
		if ( schemaType instanceof SchemaSimpleType ) {
			result = this._getSimpleValue ( element, schemaType.restrictionType );
		} else {
			var defs = schemaType.getListedDefinitions ();
			if ( schemaType.isArray ) {
				result = [];
				var def = defs.getNext ();
				var elms = this.resolveAll ( def.type, element );
				while ( elms.hasNext ()) {
					var elm = elms.getNext ();
					result.push (
						 this._compute ( elm, def )
					);
				}
			} else {
				result = {};
				defs.reset ();
				while ( defs.hasNext ()) {
					var def = defs.getNext ();
					var elm = this.resolve ( def.name, element );
					if ( elm ) {
						result [ def.name ] = this._compute ( elm, def );
					} else if ( def.isRequired ) {
						throw new Error ( "SOAPDecoder: invalid SOAP response." );
					}
				}
			}
		}
	}
	return result;
}

/**
 * @param {DOMElement} element
 * @param {string} type
 * @return {object}
 */
SOAPDecoder.prototype._getSimpleValue = function ( element, type ) {

	var result = null;
	
	if ( element.firstChild && element.firstChild.nodeType == Node.TEXT_NODE ) {
		
		/*
		 * Mozilla will split a 4K+ texnode into multiple smaller 
		 * textnodes. This will reassemble them into a single node.
		 */
		if ( Client.isMozilla && element.childNodes.length > 1 ) {
			element.normalize ();
		}
		
		result = element.firstChild.data;
		
		switch ( type ) {
			case Schema.types.STRING :
				result = result;
				break;
			case Schema.types.INT :
			case Schema.types.FLOAT :
			case Schema.types.DOUBLE :
				result = Number ( result );
				break;
			case Schema.types.BOOLEAN :
				result = result == "true";
				break;
			default :
				throw ( "SOAPDecoder: schema type \"" + type + "\" not handled." );
				break;
		}
	}
	
	return result;
}

Schema.prototype = new XPathResolver;
Schema.prototype.constructor = Schema;
Schema.superclass = XPathResolver.prototype;

/**
 * @type {HashMap<string><string>}
 */
Schema.types = {
	STRING	: "string",
	INT		: "int",
	FLOAT	: "float",
	DOUBLE	: "double",
	BOOLEAN	: "boolean"
}

/**
 * @type {Error}
 */
Schema.notSupportedException = new Error ( 
	"Schema: Schema structure not supported!"
);

/**
 * @class
 * @param {DOMElement} element
 */
function Schema ( element ) {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "Schema" );
	
	/**
	 * @type {HashMap<string><object>)
	 */
	this._map = this._parseSchema ( element );
}

/**
 * @param {DOMElement} element
 * @return {HashMmap<string><object>}
 */
Schema.prototype._parseSchema = function ( element ) {
	
	this.setNamespacePrefixResolver ({
		"wsdl"	: Constants.NS_WSDL,
		"soap"	: Constants.NS_SOAP,
		"s" 	: Constants.NS_SCHEMA
	});
	
	var result = {};
	var entry = null;
	var rules = this.resolveAll ( "s:*[@name]", element );
	
	while ( rules.hasNext ()) {	
		var rule = rules.getNext ();
		switch ( DOMUtil.getLocalName ( rule )) {
			case "element" :
				entry = new SchemaElementType ( this, rule );
				break;
			case "complexType" :
				entry = new SchemaComplexType ( this, rule );
				break;
			case "simpleType" :
				entry = new SchemaSimpleType ( this, rule );
				break;
		}
		result [ rule.getAttribute ( "name" )] = entry;
	};
	
	return result;
}

/**
 * @param {string} name
 * @return {SchemaType}
 */
Schema.prototype.lookup = function ( name ) {
	
	return this._map [ name ];
}


/**
 * TODO: place this around here?
 */
SchemaDefinition.TYPE_XML_DOCUMENT = "xmldocument";


/**
 * @class
 * @param {DOMElement} element
 */
function SchemaDefinition ( element ) {

	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SchemaDefinition" );

	/** 
	 * @type {boolean} 
	 */
	this.isRequired	= null;
	
	/** 
	 * @type {string} 
	 */
	this.type = null;
	
	/*
	 * Populate me! 
	 */
	this._parse ( element );
}

/**
 * @param {DOMElement} element
 * @private
 */
SchemaDefinition.prototype._parse = function ( element ) {
	
	var min 	= element.getAttribute ( "minOccurs" );
	var max 	= element.getAttribute ( "maxOccurs" );
	var type	= element.getAttribute ( "type" );
	
	this.name = element.getAttribute ( "name" );
	this.isRequired	= min != "0";
	
	if ( type ) {
	
		var split	= type.split ( ":" );
		var sort	= split [ 0 ];
		var typedef	= split [ 1 ];
		
		this.isSimpleValue  = sort != "tns";
		this.type 			= typedef;	
	
		//alert ( "OK\n" + DOMSerializer.serialize ( element, true ));
	
	} else {
		
		/* 
		 * TODO: rewrite to xpath, fetch a resolver somehow...
		 */
		var elm = element.getElementsByTagName ( "*" ).item ( 0 );
		if ( elm && DOMUtil.getLocalName ( elm ) == "complexType" && elm.getAttribute ( "mixed" ) == "true" ) {
			elm = elm.getElementsByTagName ( "*" ).item ( 0 );
			if ( elm && DOMUtil.getLocalName ( elm ) == "sequence" ) {
				elm = elm.getElementsByTagName ( "*" ).item ( 0 );
				if ( DOMUtil.getLocalName ( elm ) == "any" ) {
					this.type = SchemaDefinition.TYPE_XML_DOCUMENT;
				}
			}
		}
	}
}

/**
 * @class
 */
function SchemaType () {}
SchemaType.prototype = {};

SchemaElementType.prototype = new SchemaType;
SchemaElementType.prototype.constructor = SchemaElementType;
SchemaElementType.superclass = SchemaType.prototype;

/**
 * @param {Schema} schema
 * @param {DOMElement} element
 */
function SchemaElementType ( schema, element ) {
	
	/**
	 * @type {SystemLogger}
	 */
	this.logger = SystemLogger.getLogger ( "SchemaElementType" );
	
	/** 
	 * @type {List} 
	 * @private
	 */
	this._definitions = new List ();
	this._parseListedDefinitions ( schema, element );
}

/**
 * @param {Schema} schema
 * @param {DOMElement} element
 * @throws Schema.notSupportedException 
 * @private
 */
SchemaElementType.prototype._parseListedDefinitions = function ( schema, element ) {

	var els = schema.resolveAll ( "s:complexType/s:sequence/s:element", element );
	
	if ( els.hasEntries ()) {
		while ( els.hasNext ()) {
			this._definitions.add ( 
				new SchemaDefinition ( els.getNext ())
			);
		}
	} else {
		this.logger.warn ( "SchemaElementType: Unparsed SchemaDefinition encountered." );
		throw Schema.notSupportedException;
	}
}

/** 
 * @return {List} 
 */
SchemaElementType.prototype.getListedDefinitions = function () {

	return this._definitions.copy ();
}

SchemaComplexType.prototype = new SchemaType;
SchemaComplexType.prototype.constructor = SchemaComplexType;
SchemaComplexType.superclass = SchemaType.prototype;

/**
 * @param {Schema} schema
 * @param {DOMElement} element
 */
function SchemaComplexType ( schema, element ) {
	
	/** 
	 * @type {List} 
	 * @private
	 */
	this._definitions = new List ();
	this._parseListedDefinitions ( schema, element );
	
	/**
	 * TODO: Use schema structure instead of name? This could be very MS specific...
	 * @type {boolean}
	 */
	this.isArray = element.getAttribute ( "name" ).indexOf ( "ArrayOf" ) >-1;
}

/**
 * @param {Schema} schema
 * @param {DOMElement} element
 * @throws Schema.notSupportedException 
 * @private
 */
SchemaComplexType.prototype._parseListedDefinitions = function ( schema, element ) {

	var els = schema.resolveAll ( "s:sequence/s:element", element );
	
	if ( els.hasEntries ()) {
		while ( els.hasNext ()) {
			var el = els.getNext ();
			this._definitions.add ( 
				new SchemaDefinition ( el )
			);
			
			/*
			var name = el.getAttribute ( "name" );
			this [ name ] = new SchemaDefinition ( el );
			alert ( el.nodeName + ": " + name );
			*/
		}
	} else throw Schema.notSupportedException;	
}

/** 
 * @return {List} 
 */
SchemaComplexType.prototype.getListedDefinitions = function () {

	return this._definitions.copy ();
}

SchemaSimpleType.prototype = new SchemaType;
SchemaSimpleType.prototype.constructor = SchemaSimpleType;
SchemaSimpleType.superclass = SchemaType.prototype;

/**
 * @class
 * @param {Schema} schema
 * @param {DOMElement} element
 * @throws Schema.notSupportedException 
 */
function SchemaSimpleType ( schema, element ) {
	
	/**
	 * @type {string}
	 */
	this.restrictionType = null;
	
	this._parse ( schema, element );
}

/**
 * TODO: Investigate what needs to be supported here besides enumerations.
 * @param {Schema} schema
 * @param {DOMElement} element
 * @throws Schema.notSupportedException 
 */
SchemaSimpleType.prototype._parse = function ( schema, element ) {
	
	var restriction = schema.resolve ( "s:restriction", element );
	if ( restriction ) {
		this.restrictionType = restriction.getAttribute ( "base" ).split ( ":" )[ 1 ];	
	} else {
		throw Schema.notSupportedException;
	}
}

WebServiceResolver.prototype = new XPathResolver;
WebServiceResolver.prototype.constructor = WebServiceResolver;
WebServiceResolver.superclass = XPathResolver.prototype;

/**
 * @class
 * @param {string} url
 */
function WebServiceResolver ( url ) {

	/**
	 * @type {Logge
	 */
	this.logger = SystemLogger.getLogger ( "WebServiceResolver" );
	
	/**
	 * @type {DOMElement}
	 */
	this._root = this._getDocumentElement ( url );
	
	/**
	 * @type {Schema}
	 */
	this._schema = null;
	
	
	if ( this._root ) {
	
		this.setNamespacePrefixResolver ({
			"wsdl"	: Constants.NS_WSDL,
			"soap"	: Constants.NS_SOAP,
			"s" 	: Constants.NS_SCHEMA
		});
		
		this._schema = new Schema ( 
			this.resolve ( "wsdl:types/s:schema", this._root )
		);
	}
	
	/**
	 * We store this in order to hack the "getPortAddress" method below...
	 * @param {string} url
	 */
	this._WSDLURL = url;
}

/**
 * @param {string} url
 * return {DOMElement}
 */
WebServiceResolver.prototype._getDocumentElement = function ( url ) {

	var result = null;
	var request = DOMUtil.getXMLHTTPRequest ();
	request.open ( "get", url, false );
	request.send ( null );
	if ( request.responseXML ) {
		result = request.responseXML.documentElement;
	} else {
		alert ( request.responseText );
		throw new Error ( "WebServiceResolver: Could not read WSDL: " + url );
	}
	return result;
}

/**
 * Get webservice address.
 * @return {string}
 */
WebServiceResolver.prototype.getPortAddress = function () {
	
	/*
	 * Because of issues with certain cheap proxy servers, we don't extract  
	 * the webservice address from the WSDL. Instead we retrieve from the 
	 * from the given WSDL-address by hacking it the hardcode way... 
	 * 
	var soapAddress = this.resolve ( "wsdl:service/wsdl:port/soap:address", this._root );
	return soapAddress.getAttribute ( "location" );
	*/
	
	/*
	 * Hope MS doesn't change this convention...
	 */
	return this._WSDLURL.split ( "?WSDL" )[ 0 ];
}

/**
 * Get webservice namespace.
 * @return {string}
 */
WebServiceResolver.prototype.getTargetNamespace = function () {

	return this._root.getAttribute ( "targetNamespace" );
}

/**
 * Get webservice operations.
 * @return {List}
 */
WebServiceResolver.prototype.getOperations = function () {

	var result		= new List ();
	var elements 	= this.resolveAll ( "wsdl:portType/wsdl:operation", this._root ); // "wsdl:portType[@name='WebServicesSoap']/wsdl:operation"
	
	if ( elements.hasEntries ()) { 
		while ( elements.hasNext ()) {
		
			var element	= elements.getNext ();
			var name = element.getAttribute ( "name" );
			
			result.add (
				new WebServiceOperation ( 
					name,
					this.getPortAddress (),
					new SOAPEncoder ( this, name ),
					new SOAPDecoder ( this, name )
				)
			);
		}
	} else {
		
		/*
		 * This specific portype name is autogenerated by the NET webservice engine.
		 */
		throw new Error ( "WebServiceResolver: No portType found." );
	}
	return result;
}

/**
 * @return {Schema}
 */
WebServiceResolver.prototype.getSchema = function () {
	
	return this._schema;
}

/**
 * @class
 * @param {string} name
 * @param {string} address
 * @param {SOAPEncoder} encoder
 * @param {SOAPDecoder} decoder
 */
function WebServiceOperation ( name, address, encoder, decoder ) {
	
	this.name		= name;
	this.address	= address;
	this.encoder 	= encoder;
	this.decoder 	= decoder;
}

WebServiceOperation.prototype = {
	
	name : null,
	address : null,
	encoder : null,
	decoder : null
}

/**
 * Logging SOAP? This has NO EFFECT in operational mode (only in developer mode)!
 * @type {boolean}
 */
WebServiceProxy.isLoggingEnabled = true;

/**
 * Flip this when webservice requests should return instances 
 * of DOMDocument instead of javascript objects. 
 * Remember to flip it back again!
 * @type {boolean}
 */
WebServiceProxy.isDOMResult = false;

/**
 * If set to true, the WebServiceProxy will display a special dialog on soap faults.
 * Whenever you adjust this property, remember to reset the value to true.
 * TODO: come up with some sort of SOAPFaultHandler to provide in webservice calls?
 * @type {boolean}
 */
WebServiceProxy.isFaultHandler = true;

/**
 * @class
 */
function WebServiceProxy () {
	
	this.logger = SystemLogger.getLogger ( "WebServiceProxy" );
}

/**
 * Create webservice proxy.
 * @param {string} url
 * @return {WebServiceProxy}
 */
WebServiceProxy.createProxy = function ( url ) {
	
	var wsdl = new WebServiceResolver ( url );
	var proxy = new WebServiceProxy ();
	
	var operations 	= wsdl.getOperations ();	
	operations.each ( function ( operation ) {
		proxy [ operation.name ] = WebServiceProxy.createProxyOperation ( operation );
	});
	
	return proxy;
}

/** 
 * Logging SOAP in developermode.
 * @param {WebServiceOperation} operation
 * @param {SOAPMessage} soapMessage
 */
WebServiceProxy.prototype._log = function ( operation, soapMessage ) {
	
	if ( WebServiceProxy.isLoggingEnabled && Application.isDeveloperMode && soapMessage ) {
		var log = soapMessage instanceof SOAPRequest ? "SOAPRequest for " : "SOAPResponse from "; 
		log += operation.address + ": " + operation.name + "\n\n";
		log += DOMSerializer.serialize ( soapMessage.document, true )
		this.logger.fine ( log );
	}
}

/**
 * @param {WebServiceOperation} operation
 * @return {function}
 */
WebServiceProxy.createProxyOperation = function ( operation ) {
	
	/*
	 * Method returns a function which in turn returns:
	 * On request success, an {Object} or a {DOMDocument}.
	 * On request error, a {SOAPFault}.
	 */
	return function () {
		
		var result = null, request = operation.encoder.encode ( 
			new List ( arguments )
		);
		this._log ( operation, request );
		var response = request.invoke ( operation.address );
		this._log ( operation, response );
		
		if ( response ) {
			if ( response.fault ) {
				result = SOAPFault.newInstance ( operation, response.fault );
				if ( WebServiceProxy.isFaultHandler ) {
					WebServiceProxy.handleFault ( result, request, response );
				}
			} else {
				if ( WebServiceProxy.isDOMResult ) {
					result = response.document;
				} else {
					result = operation.decoder.decode ( response );
				}
			}
		}
		request.dispose ();
		return result;
	}
}

/**
 * Handle SOAP fault.
 * @param {SOAPFault} soapFault
 * @param {SOAPRequest} soapRequest
 * @param {SOAPRequestResponse} soapResponse
 */
WebServiceProxy.handleFault = function ( soapFault, soapRequest, soapResponse ) {
	
	try {
		Dialog.invokeModal ( 
			Dialog.URL_SERVICEFAULT,
			null, 
			{
				soapFault 		: soapFault,
				soapRequest 	: soapRequest,
				soapResponse 	: soapResponse
			}
		);
	} catch ( exception ) {
		alert ( 
			soapFault.getFaultString ()
		);
	}
}

/**
 * Animated when user logs in.
 * @see {Application#login}
 * @type {WebServiceProxy}
 */
var ConfigurationService = null;

/**
 * Animated when user logs in.
 * @see {Application#login}
 * @type {WebServiceProxy}
 */
var ConsoleMessageQueueService = null;

/**
 * Animated when user logs in.
 * @see {Application#login}
 * @type {WebServiceProxy}
 */
var EditorConfigurationService = null;

/**
 * Animated when user logs in.
 * @see {Application#login}
 * @type {WebServiceProxy}
 */
var FlowControllerService = null;

/**
 * Animated when KickStart kicks in.
 * @see {KickStart#fireOnLoad}
 * @type {WebServiceProxy}
 */
var InstallationService = null;

/**
 * Animated when user logs in.
 * @see {Application#login}
 * @type {WebServiceProxy}
 */
var LocalizationService = null;

/**
 * Animated when KickStart kicks in.
 * @see {KickStart#fireOnLoad}
 * @type {WebServiceProxy}
 */
var LoginService = null;

/**
 * Animated when user logs in.
 * @see {Application#login}
 * @type {WebServiceProxy}
 */
var MarkupFormatService = null;

/**
 * Animated when user logs in.
 * @see {Application#login}
 * @type {WebServiceProxy}
 */
var PageService = null;

/**
 * Animated when KickStart kicks in.
 * @see {KickStart#fireOnLoad}
 * @type {WebServiceProxy}
 */
var ReadyService = null;

/**
 * Animated when user logs in.
 * @see {Application#login}
 * @type {WebServiceProxy}
 */
var SecurityService = null;

/**
 * Animated when user logs in.
 * @see {Application#login}
 * @type {WebServiceProxy}
 */
var SEOService = null;

/**
 * Animated when user logs in.
 * @see {Application#login}
 * @type {WebServiceProxy}
 */
var SourceValidationService = null;

/**
 * Animated when user logs in.
 * @see {Application#login}
 * @type {WebServiceProxy}
 */
var StringService = null;

/**
 * Animated when user logs in.
 * @see {Application#login}
 * @type {WebServiceProxy}
 */
var TreeService = null;

/**
 * Animated when user logs in.
 * @see {Application#login}
 * @type {WebServiceProxy}
 */
var XhtmlTransformationsService = null;

/**
 * MessageQueue!
 */
window.MessageQueue = new function () {
	
	/**
	 * Update interval in milliseconds when server is online.	 
	 * @type {int}
	 */
	this.INTERVAL_ONLINE = 15 * 1000;
	
	/**
	 * Update interval in milliseconds when server is offline.
	 * @type {int}
	 */
	this.INTERVAL_OFFLINE = 4 * 1000;
	
	/**
	 * List of actions waiting to be executed.
	 * @type {List<object>}
	 */
	this._actions = new List ();
	
	/**
	 * Indexing action ID's to make sure we don't execute the same action twice.  
	 * This would happen on server restart, where server resets the sequencenumber.
	 * @type {HashMap<String><boolean>}
	 */
	this._index = {};
	
	/**
	 * Holds the hightest action sequencenumber sent from the server.
	 * @type {int}
	 */
	this.index = 0; // NOT equal to private variable "sequencenumber"
	
	/*
	 * Privates
	 */
	var logger = SystemLogger.getLogger ( "MessageQueue" );
	var service = null;
	var sequenceNumber = 0;
	var triggerhandle = null;
	var refreshingtrees = new Map ();
	var openingtreenodes = new Map ();
	var isOffline = false;
	var isAutoUpdate = false;
	
	/*
	 * Mapping dock locations. Hashmap keys correspond 
	 * to values of the servers "ViewType" property.
	 */
	var docklocation = {
	
		"Main" 				: DockBinding.MAIN,
		"BottomLeft" 		: DockBinding.BOTTOMLEFT,
		"BottomRight" 		: DockBinding.BOTTOMRIGHT,
		"RightTop" 			: DockBinding.RIGHTTOP,
		"RightBottom" 		: DockBinding.RIGHTBOTTOM,
		"AbsBottomLeft" 	: DockBinding.ABSBOTTOMLEFT,
		"AbsBottomRight" 	: DockBinding.ABSBOTTOMRIGHT
	}
	
	/**
	 * Initialize.
	 */
	this.initialize = function () {
	
		service = ConsoleMessageQueueService;
		sequenceNumber = service.GetCurrentSequenceNumber ( "dummyparam!" );
		
		this.index = sequenceNumber;
		
		EventBroadcaster.subscribe ( BroadcastMessages.VIEW_COMPLETED, this );
		EventBroadcaster.subscribe ( BroadcastMessages.VIEW_CLOSED, this );
		EventBroadcaster.subscribe ( BroadcastMessages.SERVER_OFFLINE, this );
		EventBroadcaster.subscribe ( BroadcastMessages.SERVER_ONLINE, this ); 
		
		window.messageQueueInterval = window.setInterval ( 
			MessageQueue._autoupdate, 
			MessageQueue.INTERVAL_ONLINE 
		);
	};
	
	/**
	 * Fetching actions from server. Note that  
	 * we don't request new actions while we are 
	 * already executing a list of actions.
	 */
	this._autoupdate = function () {
		
		/* 
		 * Note that you should not use the "this" keyword 
		 * around here since we are executed on a setInterval.
		 */
		if ( !isOffline ) {
			
			/*
			 * While an action sequence is being evaluated, 
			 * to further actions are retrieved from server.
			 */
			if ( !MessageQueue._actions.hasEntries ()) {
				var isEnabled = WebServiceProxy.isLoggingEnabled;
				if ( Application.isLoggedIn ) {
					isAutoUpdate = true;
					WebServiceProxy.isLoggingEnabled = false; // not logging the SOAP request
					MessageQueue.update ();
					WebServiceProxy.isLoggingEnabled = isEnabled;
					isAutoUpdate = false;
				}
			}
		}
	};
	
	/**
	 * When server is offline, this will be executed 
	 * on an interval to unlock GUI when ready.
	 * @see {MessageQueue#_lockSystem}
	 */
	this._pokeserver = function () {
		
		if ( isOffline == true ) {
			if ( ReadyService.IsServerReady ( true )) {
				MessageQueue._lockSystem ( false );
			}
		}
	}
	
	/**
	 * Fetch list of actions from server.
	 */
	this.update = function () {
		
		if ( Application.isLoggedIn ) { // otherwise no service...
		
			/*
			 * Note that we broadcast the boolean argument: isAutoUpdate 
			 */
			EventBroadcaster.broadcast ( BroadcastMessages.MESSAGEQUEUE_REQUESTED, isAutoUpdate );
			
			/*
			 * Fetch new actions; append them to current actions in execution chain.
			 * Response has two properties: The servers highest known action number 
			 * and a list of actions. The first property is needed because the server 
			 * will RESET the actionindex on restart.  
			 */
			var response = service.GetMessages ( Application.CONSOLE_ID, this.index );
			if ( response != null ) {
				if ( Types.isDefined ( response.CurrentSequenceNumber )) {
					var newindex = response.CurrentSequenceNumber;
					if ( newindex < this.index ) {
						logger.debug ( "SERVER WAS RESTARTED! old messagequeue index: " + this.index + ", new messagequeue index: " + newindex );
						// the server was restarted!
					}
					this.index = newindex;
					
					var actions = new List ( response.ConsoleActions );
					if ( actions.hasEntries ()) {
						this.evaluate ( actions );
					} else if ( !this._actions.hasEntries ()) {
						broadcastUpdateEvaluated ();
					}
				} else {
					logger.error ( "No sequencenumber in MessageQueue response!" );
				}
			}
		}
	}
	
	/**
	 * Evaluate a list of actions. These will be appended 
	 * to any actions currently scheduled for execution.
	 * @param {List} actions
	 */
	this.evaluate = function ( actions ) {
		
		var newactions = new List ();
		
		if ( actions.hasEntries ()) {
			
			/*
			 * Filter out actions that were already queued  
			 * up for evaluation (server restart scenario).
			 */
			actions.each ( function ( action ) {
				if ( this._index [ action.Id ] != true ) {
					newactions.add ( action );
				}
				this._index [ action.Id ] = true;
			}, this );
			
			if ( newactions.hasEntries ()) {
			
				// merge into existing actionlist?
				if ( this._actions.hasEntries ()) {
					this._actions.merge ( newactions );
				} else {
					this._actions = newactions;
				}
				
				// execute first action!
				this._nextAction ();
			}
		}
	};
	
	/**
	 * Close all views - with a flowHandle (important)!
	 * @param {object} params
	 */
	this._closeAllViews = function ( params ) {
		
		var reason = "(No reason)";
		if ( params != null ) {
			reason = params.Reason;
		}
		
		/*
		 * TODO: externalize strings!
		 */
		var title = "Warning";
		var text = "The server has requested a close of all active editors for the following reason: \"${reason}\". It is recommended that you accept this request by clicking OK.";
		text = text.replace ( "${reason}", reason );
		
		var self = this;
		Dialog.warning ( title, text, Dialog.BUTTONS_ACCEPT_CANCEL, {
			handleDialogResponse : function ( response ) {
				if ( response == Dialog.RESPONSE_ACCEPT ) {
					EventBroadcaster.broadcast ( BroadcastMessages.CLOSE_VIEWS );	
				}
				self._nextAction ();
			}
		})
	}
	
	/**
	 * Evaluate next action. This will update the sequencenumber.
	 */
	this._nextAction = function () {
		
		var params = null;
		
		if ( this._actions.hasEntries ()) {
			
			var action = this._actions.extractFirst ();
			sequenceNumber = action.SequenceNumber;
			logger.debug ( "MessageQueue action: " + action.ActionType + " > QUEUE-MAX-SEQNUM: " + this.index + " > CURRENT SEQNUM: " + sequenceNumber + " > ACTIONS-LEFT: " + this._actions.getLength ());
			
			/*
			 * Parse action.
			 */
			switch ( action.ActionType ) {
			
				case "OpenView" :
				 	params = action.OpenViewParams;
				 	if ( params.ViewType == "ModalDialog" ) {
				 		openDialogView ( params );
				 	} else {
				 		triggerhandle = params.ViewId;
					 	openView ( params );
					}
					break;
					
				case "CloseView" :
					params = action.CloseViewParams;
					triggerhandle = params.ViewId;
					closeView ( params );
					break;
				
				case "RefreshTree" :
					EventBroadcaster.subscribe ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHING, this );
					EventBroadcaster.subscribe ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHED, this );
					EventBroadcaster.broadcast (
						BroadcastMessages.SYSTEMTREEBINDING_REFRESH,
						action.RefreshTreeParams.EntityToken
					);
					
					var debug = "REFRESHING TREES: " + refreshingtrees.countEntries () + "\n";
					refreshingtrees.each ( function ( token ) {
						debug += "\n\tTOKEN: " + token;
					})
					logger.debug ( debug );
					
					/*
					 * The trees perform a timeout before refreshing 
					 * so that this code gets evaluted straight away 
					 * and not when the trees are done refreshing.
					 */
					if ( !refreshingtrees.hasEntries ()) {
						EventBroadcaster.unsubscribe ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHING, this );
						EventBroadcaster.unsubscribe ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHED, this );
						this._nextAction ();
					}
					break;
					
				case "MessageBox" :
					openMessageBox ( action.MessageBoxParams );
					break;
				
				case "OpenViewDefinition" :
					params = action.OpenViewDefinitionParams;
					triggerhandle = params.Handle;
					openViewDefinition ( params );
					break;
				
				case "LogEntry" :
				 	logEntry ( action.LogEntryParams );
				 	this._nextAction ();
				 	break;
					
				case "Reboot" :
					Application.reload ( true );
					break;
					
				case "LockSystem" :
					MessageQueue._lockSystem ( true );
					break;
					
				case "BroadcastMessage" :
					params = action.BroadcastMessageParams;
					logger.debug ( "Server says: EventBroadcaster.broadcast ( \"" + params.Name + "\", " + params.Value + " )" );
					EventBroadcaster.broadcast ( params.Name, params.Value );
					this._nextAction ();
					break;
					
				case "CollapseAndRefresh" :
					EventBroadcaster.broadcast ( BroadcastMessages.SYSTEMTREEBINDING_COLLAPSEALL );
					EventBroadcaster.subscribe ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHING, this );
					EventBroadcaster.subscribe ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHED, this );
					EventBroadcaster.broadcast ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHALL );
					if ( !refreshingtrees.hasEntries ()) {
						EventBroadcaster.unsubscribe ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHING, this );
						EventBroadcaster.unsubscribe ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHED, this );
						this._nextAction ();
					}
					break;
					
				case "CloseAllViews" :
					this._closeAllViews ( action.CloseAllViewsParams );
					break;
					
				case "SaveStatus" :
					saveStatus ( action.SaveStatusParams );
					this._nextAction ();
					break;
				
				case "DownloadFile" :
					Download.init ( action.DownloadFileParams.Url );
					this._nextAction ();
					break;	
					
				case "ExpandTreeNode" : // TODO: CLEAR THIS! 
					this._nextAction ();
					/*
					EventBroadcaster.subscribe ( BroadcastMessages.SYSTEMTREENODEBINDING_FORCING_OPEN, this );
					EventBroadcaster.subscribe ( BroadcastMessages.SYSTEMTREENODEBINDING_FORCED_OPEN, this );
					EventBroadcaster.broadcast (
						BroadcastMessages.SYSTEMTREENODEBINDING_FORCE_OPEN, 
						action.ExpandTreeNodeParams.EntityToken
					);
					if ( !openingtreenodes.hasEntries ()) {
						EventBroadcaster.unsubscribe ( BroadcastMessages.SYSTEMTREENODEBINDING_FORCING_OPEN, this );
						EventBroadcaster.unsubscribe ( BroadcastMessages.SYSTEMTREENODEBINDING_FORCED_OPEN, this );
						this._nextAction ();
					}
					*/
					break;
					
				case "BindEntityTokenToView" :
					params = action.BindEntityTokenToViewParams;
					EventBroadcaster.broadcast ( BroadcastMessages.BIND_TOKEN_TO_VIEW, {
						handle : params.ViewId,
						entityToken : params.EntityToken
					});
					this._nextAction ();
					break;
					
				case "OpenGenericView" :
					params = action.OpenGenericViewParams;
					openGenericView ( params );
					break;
				
				default :
					Dialog.error ( "Dysfunction", "Unhandled action: " + action.ActionType );
					break;
			}
		} else {
			
			broadcastUpdateEvaluated ();
		}
	}
	
	/**
	 * Note that we broadcast the boolean argument: isAutoUpdate
	 */ 
	function broadcastUpdateEvaluated () {
		
		EventBroadcaster.broadcast ( BroadcastMessages.MESSAGEQUEUE_EVALUATED, isAutoUpdate );
	}
	
	/** 
	 * Parse log entry.
	 * @param {object} params
	 */
	function logEntry ( params ) {
	
		var method = params.Level.toLowerCase ();
		SystemLogger.getLogger ( params.SenderId ) [ method ] ( params.Message );
	}
	
	/** 
	 * Parse view opening. Views targeted for editors dock 
	 * are presented with a "Loading..." label on startup, 
	 * this is handled by the DockTabBinding.
	 * @param {object} params
	 */
	function openView ( params ) {
		
		var list = paramsToList ( params.Argument );
		
		if ( list.hasEntries ()) {
			
			var def = ViewDefinition.clone ( "Composite.Management.PostBackView", params.ViewId );
			def.entityToken	= params.EntityToken;
			def.flowHandle 	= params.FlowHandle;
			def.position	= docklocation [ params.ViewType ],
			def.label		= params.Label;
			def.image		= params.Image;
			def.toolTip		= params.ToolTip;
			def.argument = {
				"url"	: params.Url,
				"list"	: list
			};
			StageBinding.presentViewDefinition ( def );
			
		} else {
		
			StageBinding.presentViewDefinition (
				new HostedViewDefinition ({
					handle 		: params.ViewId,
					entityToken	: params.EntityToken,
					flowHandle 	: params.FlowHandle,
					position	: docklocation [ params.ViewType ],
					url 		: params.Url,
					label		: params.Label,
					image		: params.Image,
					toolTip		: params.ToolTip
				})
			);
		}
	}
	
	/*
	 * Open modal dialog. This will delay next action until the dialog is closed!
	 * @param {object} params/
	 */
	function openDialogView ( params ) {
		
		StageBinding.presentViewDefinition (
			new DialogViewDefinition ({
				handle 		: params.ViewId,
				flowHandle 	: params.FlowHandle,
				position	: Dialog.MODAL,
				url 		: params.Url,
				handler : {
					handleDialogResponse : function () {
						setTimeout ( function () {
							MessageQueue._nextAction ();
						}, 250 );
					}
				}
			})
		);
	}
	
	/**
	 * Open standard dialog of type error, info or warning. 
	 * Question type dialogs not supported here. This will 
	 * delay next action until the dialog is closed!
	 * @param {object} params
	 */
	function openMessageBox ( params ) {
		
		var method = params.DialogType.toLowerCase ();			
		if ( method == "question" ) {
			throw "Not supported!";
		} else {
			Dialog [ method ] ( params.Title, params.Message, null, { 
				handleDialogResponse : function () {
					setTimeout ( function () {
						MessageQueue._nextAction ();
					}, 250 );
				}
			});
		}
	}
	
	/** 
	 * Open ViewDefinition.
	 * @param {object} params
	 */
	function openViewDefinition ( params ) {
		
		// var list = paramsToList ( params.Argument );
		
		/*
		 * TODO: Note on how this stuff differs from the paramsToList stuff...
		 */
		var map = {};
		var hasMap = false;
		new List ( params.Argument ).each ( function ( entry ) {
			map [ entry.Key ] = entry.Value;
			hasMap = true;
		});
		
		/* 
		 * Determine whether or not to open a new view or to reuse any opened view. 
		 * The Page Browser is a view-reuse example - it opens new tabs INSIDE a 
		 * singluar open instance.
		 */
		var proto = ViewDefinitions [ params.Handle ];
		
		if ( proto != null ) {
			
			var def = null;
			
			if ( proto.isMutable == false ) { // reuse the same view
				
				def = proto; // keeping original handle, ignoring server handle
			
			} else { // create new view by cloning the old
					
				def = new HostedViewDefinition ();
				for ( var prop in proto ) {
					def [ prop ] = proto [ prop ];
				}
				def.handle = params.ViewId; // assigning new handle, unique from server
			}
			
			//def.argument = list.hasEntries () ? list : null;
			def.argument = hasMap ? map : null;
			StageBinding.presentViewDefinition ( def );
			
		} else {
			throw "Unknown ViewDefinition: " + param.Handle;
		}
	}
	
	/**
	 * Open generic view. That is, a PageBinding with a WindowBinding that will 
	 * 1) Open a given URL - or, if params are specified...
	 * 2) Polulate a form with given params and post to a given URL
	 */
	function openGenericView ( params ) {
		
		var def = ViewBinding.clone ( "Composite.Management.GenericView", params.ViewId );
		def.label = params.Label;
		def.toolTip = params.ToolTip;
		def.image = params.Image;
		def.argument = {
			"url" : params.Url,
			"list" : paramsToList ( params.UrlPostArguments )
		}
		StageBinding.presentViewDefinition ( def );
		
	}
	 
	/** 
	 * Close view.
	 * @param {object} params
	 */
	function closeView ( params ) {
		
		if ( StageBinding.isViewOpen ( params.ViewId )) {
			// This broadcast will be intercepted by the ViewBinding.
			EventBroadcaster.broadcast ( BroadcastMessages.CLOSE_VIEW, params.ViewId );
		} else {
			// If the view is a dialog, user may have cancelled it already. 
			// In that case, we execute the next action straight away...
			MessageQueue._nextAction ();
		}
	}
	
	/** 
	 * Handle save status.
	 * @param {object} params
	 */
	function saveStatus ( params ) {
		
		/* 
		 * This broadcast will be intercepted by the DockTabBinding and 
		 * possibly the DockBinding.
		 */
		EventBroadcaster.broadcast ( BroadcastMessages.CURRENT_SAVED, {
			handle : params.ViewId,
			isSuccess : params.Succeeded
		});
	}
	
	/**
	 * Lock and unlock the system when  
	 * server goes offline and online.
	 * @param {boolean} isLock
	 */
	this._lockSystem = function ( isLock ) {
		
		var theatre = top.bindingMap.offlinetheatre;
		
		if ( isLock ) {
			theatre.play ( true );
			window.clearInterval ( window.messageQueueInterval ); 
			window.messageQueueInterval = window.setInterval ( 
				MessageQueue._pokeserver, 
				MessageQueue.INTERVAL_OFFLINE 
			);
		} else {
			theatre.stop ();
			window.clearInterval ( window.messageQueueInterval ); 
			window.messageQueueInterval = window.setInterval ( 
				MessageQueue._autoupdate, 
				MessageQueue.INTERVAL_ONLINE 
			);
			/*
			 * Note that we now execute any actions that were 
			 * stacked on the list BEFORE offline mode started. 
			 */
			var self = this;
			setTimeout ( function () {
				if ( self._actions.hasEntries ()) {
					self._nextAction ();
				}
			}, 0 );
		}
		isOffline = isLock;
	}
	
	
	// EVENTBROADCASTERSTUFF ...................................................
	
	/**
	 * @implements {IBroadcastListener}
	 * @param {string} broadcast
	 * @param {object} arg
	 */
	this.handleBroadcast = function ( broadcast, arg ) {
		
		switch ( broadcast ) {
		
			case BroadcastMessages.APPLICATION_LOGIN :
				this.initialize ();
				break;
			
			case BroadcastMessages.VIEW_COMPLETED :
			case BroadcastMessages.VIEW_CLOSED :
				if ( triggerhandle != null && arg == triggerhandle ) {
					triggerhandle = null;
					this._nextAction ();
				}
				break;
			
			/*
			 * Multiple trees may report in on this. We count 
			 * them all and await the broadcast seen below.
			 */
			case BroadcastMessages.SYSTEMTREEBINDING_REFRESHING :
				
				if ( arg != null ) {
					refreshingtrees.set ( arg, true );
				} else {
					logger.debug ( "Saa har vi balladen!" );
				}
				//logger.debug ( "REFRESHING! ... " + refreshingtrees.countEntries ());
				//logger.fatal ( "REFRESHING " + arg );
				break;
				
			/*
			 * Continue when all trees are reported refreshed.
			 */
			case BroadcastMessages.SYSTEMTREEBINDING_REFRESHED :
				
				//logger.debug ( "REFRESHED! ... " + refreshingtrees.countEntries ());
				//logger.fatal ( "REFRESHED " + arg );
				
				if ( refreshingtrees.hasEntries ()) {
					
					refreshingtrees.del ( arg );
					
					logger.debug ( "Refreshed tree: " + arg + "\n(" + refreshingtrees.countEntries () + " trees left!)" );
					
					//logger.debug ( "AND NOW: " + refreshingtrees.countEntries ());
					
					if ( !refreshingtrees.hasEntries ()) {
						
						//logger.debug ( "ALL REFRESHED! NEXT..." )
						
						EventBroadcaster.unsubscribe ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHING, this );
						EventBroadcaster.unsubscribe ( BroadcastMessages.SYSTEMTREEBINDING_REFRESHED, this );
						
						/*
						 * This timeout allows trees to calm down in case 
						 * the next action is another refreshtree request.
						 */
						setTimeout ( function () {
							MessageQueue._nextAction ();
						}, 0 );
					}
				}
				break
			
			/*
			 * Multiple treenodes may report in on this. We count 
			 * them all and await the broadcast seen below.
			 */
			case BroadcastMessages.SYSTEMTREENODEBINDING_FORCING_OPEN :
				
				openingtreenodes.set ( arg, true );
				break;
				
			/*
			 * Continue only when all treenodes are reported open.
			 */
			case BroadcastMessages.SYSTEMTREENODEBINDING_FORCED_OPEN :
					
				if ( openingtreenodes.hasEntries () == true ) {
					openingtreenodes.del ( arg );
					if ( !openingtreenodes.hasEntries ()) {
						EventBroadcaster.unsubscribe ( BroadcastMessages.SYSTEMTREENODEBINDING_FORCING_OPEN, this );
						EventBroadcaster.unsubscribe ( BroadcastMessages.SYSTEMTREENODEBINDING_FORCED_OPEN, this );
						MessageQueue._nextAction ();
					}
				}
				break
			
			/*
			 * Probably broadcasted by a {@link SOAPRequest}. 
			 */
			case BroadcastMessages.SERVER_OFFLINE :
				MessageQueue._lockSystem ( true );
				break;
				
			/*
			 * Probably broadcasted by a {@link SOAPRequest}. 
			 */
			case BroadcastMessages.SERVER_ONLINE :
				MessageQueue._lockSystem ( false );
				break;
		}
	}
	
	/**
	 * Convert array-of-key-value-objects into a plain old list.
	 * @param {Array} params Array of objects with "Key" and "Value" props.
	 * @return {List<object>} a list of objects with "name" and "value" props
	 */
	function paramsToList ( params ) {
		
		var list = new List ();
		new List ( params ).each ( function ( entry ) {
			list.add ({ 
				name : entry.Key,
				value : entry.Value  
			});
		});
		
		return list;
	}
	
	/* 
	 * File subscriptions.
	 */
	EventBroadcaster.subscribe ( BroadcastMessages.APPLICATION_LOGIN, this );
}


/**
 * @type {HashMap<string><ViewDefinition>}
 */
var ViewDefinitions = {
		
	/*
	 * The "null" definition is substituted for other definitions 
	 * when a view gets released from server control.
	 */
	"Composite.Management.Null" : new HostedViewDefinition ({
		isMutable	: true,
		handle 		: "Composite.Management.Null"
	}),
	
	/*
	 * Postback dialog.
	 */
	"Composite.Management.PostBackDialog" : new DialogViewDefinition ({
		handle 		: "Composite.Management.PostBackDialog",
		isMutable	: true,
		position 	: Dialog.MODAL,
		url			: "${root}/content/dialogs/postback/postbackdialog.aspx",
		argument 	: {
			"url"	: null,
			"list"	: null
		}
	}),
	
	/*
	 * Postback view. Load framework file using HTTP post (in addition to GET).  
	 * Use this to display framework stuff. Pages with a PageBinding, that is.
	 */
	"Composite.Management.PostBackView" : new HostedViewDefinition ({
		handle 		: "Composite.Management.PostBackView",
		isMutable	: true,
		position 	: DockBinding.MAIN,
		url			: "${root}/postback.aspx",
		argument 	: {
			"url"	: null,
			"list"	: null
		}
	}),
	 
	/*
	 * Generic views. Load PageBinding and inject any URL into a WindowBinding. 
	 * Use this to display non-framework stuff such as previews and thingies.
	 */
	"Composite.Management.GenericView" : new HostedViewDefinition ({
		handle 		: "Composite.Management.GenericView",
		isMutable	: true,
		position 	: DockBinding.MAIN,
		url 		: "${root}/content/views/generic/generic.aspx",
		label 		: null,
		image 		: null,
		toolTip		: null,
		argument 	: {
			"url"	: null,
			"list"	: null
		}
	}),
		
	/*
	 * Start.
	 */
	"Composite.Management.Start" : new HostedViewDefinition ({
		handle 		: "Composite.Management.Start",
		position 	: DockBinding.START,
		label 		: "Welcome Travellers", 
		url 		: "${root}/content/views/start/start.aspx"
	}),
	
	/*
	 * About.
	 */
	"Composite.Management.About" : new DialogViewDefinition ({
		handle 		: "Composite.Management.About",
		position 	: Dialog.MODAL,
		url 		: "${root}/content/dialogs/about/about.aspx"
	}),
	
	/*
	 * Permission editor.
	 */
	"Composite.Management.PermissionEditor" :  new HostedViewDefinition ({
		isMutable	: true,
		handle 		: "Composite.Management.PermissionEditor",
		position 	: DockBinding.MAIN,
		url 		: "${root}/content/views/editors/permissioneditor/permissioneditor.aspx",
		argument 	: {
			serializedEntityToken : "entityTokenType='Composite\\.Plugins\\.Elements\\.ElementProviders\\.VirtualElementProvider\\.VirtualElementProviderEntityToken,Composite'entityToken='_EntityToken_Type_=\\'Composite\\\\\\.Plugins\\\\\\.Elements\\\\\\.ElementProviders\\\\\\.VirtualElementProvider\\\\\\.VirtualElementProviderEntityToken,Composite\\'_EntityToken_Source_=\\'VirtualElementProvider\\'_EntityToken_Id_=\\'DesignPerspective\\''\""
		}
	}),
	
	/*
	 * System Log.
	 */
	"Composite.Management.SystemLog" : new HostedViewDefinition ({
		handle		: "Composite.Management.SystemLog",
		position 	: DockBinding.ABSBOTTOMLEFT,
		label 		: "System Log",
		url 		: "${root}/content/views/dev/systemlog/systemlog.aspx"
	}),
	
	/*
	 * Developer Panel.
	 */
	"Composite.Management.Developer" : new HostedViewDefinition ({
		handle 		: "Composite.Management.Developer",
		position 	: DockBinding.ABSBOTTOMRIGHT,
		label 		: "Developer", 
		url 		: "${root}/content/views/dev/developer/developer.aspx"
	}),
	
	/*
	 * Icon Pack System.
	 */
	"Composite.Management.IconPack.System" : new HostedViewDefinition ({
		handle 		: "Composite.Management.IconPack.System",
		position 	: DockBinding.ABSBOTTOMLEFT,
		label 		: "Freja",
		image		: "${icon:icon}",
		url 		: "${root}/content/views/dev/icons/system/Default.aspx"
	}),
	
	/*
	 * Icon Pack Republic.
	 */
	"Composite.Management.IconPack.Republic" : new HostedViewDefinition ({
		handle 		: "Composite.Management.IconPack.Republic",
		position 	: DockBinding.ABSBOTTOMLEFT,
		label 		: "Republic",
		image		: "${icon:icon}",
		url 		: "${root}/content/views/dev/icons/files/republic.aspx"
	}),
	
	/*
	 * Icon Pack Harmony.
	 */
	"Composite.Management.IconPack.Harmony" : new HostedViewDefinition ({
		handle 		: "Composite.Management.IconPack.Harmony",
		position 	: DockBinding.ABSBOTTOMLEFT,
		label 		: "Harmony",
		image		: "${icon:icon}",
		url 		: "${root}/content/views/dev/icons/files/harmony.aspx"
	}),
	
	/*
	 * Explorer.
	 */
	"Composite.Management.Explorer" : new HostedViewDefinition ({
		handle 		: "Composite.Management.Explorer",
		position 	: DockBinding.EXPLORER,
		url 		: "${root}/content/views/explorer/explorer.aspx",
		label 		: "Explorer"
	}),
	
	/*
	 * Options dialog.
	 */
	"Composite.Management.Options" : new DialogViewDefinition ({
		handle 		: "Composite.Management.Options",
		position 	: Dialog.MODAL,
		url 		: "${root}/content/dialogs/options/options.aspx",
		label		: "Options"
	}),
	
	/*
	 * VisualEditor dialog.
	 */
	"Composite.Management.VisualEditorDialog" : new DialogViewDefinition ({
		isMutable	: true,
		handle 		: "Composite.Management.VisualEditorDialog",
		position 	: Dialog.MODAL,
		url 		: "${root}/content/dialogs/wysiwygeditor/wysiwygeditordialog.aspx",
		width		: 600, // height : 500,
		argument	: {
			"formattingconfiguration"	: null,
			"elementclassconfiguration"	: null,
			"configurationstylesheet" 	: null,
			"presentationstylesheet" 	: null,
			"embedablefieldstypenames"	: null
		}
	}),
	
	/*
	 * MultiSelector dialog.
	 */
	"Composite.Management.MultiSelectorDialog" : new DialogViewDefinition ({
		isMutable	: true,
		handle 		: "Composite.Management.MultiSelectorDialog",
		position 	: Dialog.MODAL,
		url 		: "${root}/content/dialogs/multiselector/multiselectordialog.aspx"
	}),
	
	/*
	 * Search view.
	 */
	"Composite.Management.Search" : new HostedViewDefinition ({
		handle 		: "Composite.Management.Search",
		position	: DockBinding.RIGHTBOTTOM,
		url			: "${root}/content/views/search/search.aspx",
		label		: "Search",
		image		: "${icon:view_search}",
		argument	: null
	}),
	
	/*
	 * Page Browser.
	 */
	"Composite.Management.Browser" : new HostedViewDefinition ({
		isMutable	: false,
		handle 		: "Composite.Management.Browser",
		position	: DockBinding.MAIN,
		perspective	: ExplorerBinding.PERSPECTIVE_CONTENT,
		label		: "Page Browser",
		image		: "${icon:page-view-administrated-scope}",
		toolTip		: "Browse unpublished pages",
		url			: "${root}/content/views/browser/browser.aspx",
		argument	: { "URL" : null }
	}),
	
	/*
	 * SEO Assistant.
	 */
	"Composite.Management.SEOAssistant" : new HostedViewDefinition ({
		handle 		: "Composite.Management.SEOAssistant",
		position	: DockBinding.RIGHTTOP,
		perspective	: ExplorerBinding.PERSPECTIVE_CONTENT,
		url			: "${root}/content/views/seoassist/seoassist.aspx",
		label		: "${string:Composite.Web.SEOAssistant:SEOAssistant}",
		image		: "${icon:seoassistant}",
		toolTip		: "Search engine optimization"
	}),
	
	/*
	 * Source code viewer.
	 */
	"Composite.Management.SourceCodeViewer" : new HostedViewDefinition ({
		isMutable	: true,
		handle 		: "Composite.Management.SourceCodeViewer",
		position	:  DockBinding.ABSBOTTOMLEFT,
		url			: "${root}/content/views/dev/viewsource/viewsource.aspx",
		argument 	: { 
			"action" : null, // {string}
			"viewBinding" : null // {ViewBinding}
		}
	}),
	
	/*
	 * User source code viewer.
	 */
	"Composite.User.SourceCodeViewer" : new HostedViewDefinition ({
		isMutable	: true,
		handle 		: "Composite.User.SourceCodeViewer",
		position	:  DockBinding.BOTTOMLEFT,
		url			: "${root}/content/views/dev/viewsource/viewsource.aspx",
		argument 	: { 
			"action" : null, // {string}
			"viewBinding" : null // {ViewBinding}
		}
	}),
	
	/*
	 * Help.
	 */
	"Composite.Management.Help" : new HostedViewDefinition ({
		label		: "Help",
		image		: "${icon:help}", // ${root}/images/icons/republic/republic_0534/0534_16px_Republic_32bit_PNG.png
		handle 		: "Composite.Management.Help",
		position	:  DockBinding.ABSRIGHTTOP,
		url			: "${root}/content/views/help/help.aspx"
	}),
	
	/*
	 * Translations.
	 */
	"Composite.Management.Dialog.Translations" : new DialogViewDefinition ({
		handle 		: "Composite.Management.TranslationsDialog",
		position 	: Dialog.MODAL,
		url 		: "${root}/content/dialogs/translations/translations.aspx",
		label		: "Translations",
		image		: "${icon:users-changepublicculture}"
	}),
	
	
	// SELECTORS ......................................................................
	
	/*
	 * Image selector.
	 */
    "Composite.Management.ImageSelectorDialog": new DialogViewDefinition({
        isMutable   : true,
		handle 		: "Composite.Management.ImageSelectorDialog",
		position 	: Dialog.MODAL,
		url 		: Dialog.URL_IMAGESELECTOR,
		argument : {
			label 				: "Select Image",
			image				: "${icon:image}",
			selectionProperty 	: "ElementType",
			selectionValue		: "image/jpeg image/gif image/png image/bmp image/tiff",
			selectionResult		: "Uri",
			nodes : [{
				key : "MediaFileElementProvider",
				search : "MediaFileElementProvider.WebImages"
			}]
		}
	}),
	
	/*
	 * Embeddable media selector.
	 */
"Composite.Management.EmbeddableMediaSelectorDialog": new DialogViewDefinition({
        isMutable   : true,
		handle 		: "Composite.Management.EmbeddableMediaSelectorDialog",
		position 	: Dialog.MODAL,
		url 		: Dialog.URL_TREESELECTOR,
		argument : {
			label 				: "Select Media",
			image				: "${icon:media}",
			selectionProperty 	: "ElementType",
			selectionValue		: null,
			selectionResult		: "Uri",
			nodes : [{
				key : "MediaFileElementProvider",
				search : null //"MediaFileElementProvider.EmbeddableMedia" - kaput!
			}]
		}
	}),
	
	/*
	 * Frontend file selector.
	 */
	"Composite.Management.FrontendFileSelectorDialog" : new DialogViewDefinition ({
		handle 		: "Composite.Management.EmbeddableMediaSelectorDialog",
		position 	: Dialog.MODAL,
		url 		: Dialog.URL_TREESELECTOR,
		argument : {
			label 				: "Select Frontend File",
			image				: "${icon:media}",
			selectionProperty 	: "ElementType",
			selectionValue		: null,
			selectionResult		: "Uri",
			nodes : [{
				key : "LayoutFileElementProvider"
			}]
		}
	}),
	
	/*
	 * Page URL selector.
	 */
	"Composite.Management.PageSelectorDialog" : new DialogViewDefinition ({
		handle 		: "Composite.Management.PageSelectorDialog",
		position 	: Dialog.MODAL,
		url 		: Dialog.URL_TREESELECTOR,
		argument : {
			label 				: "Select Page",
			image				: "${icon:page}",
			selectionProperty 	: "Uri",
			selectionValue		: null, // MimeTypes.COMPOSITEPAGES
			selectionResult		: "Uri",
			nodes : [{
				key : "PageElementProvider"
			}]
		}
	}),

    /*
    * Page Id selector.
    */
    "Composite.Management.PageIdSelectorDialog": new DialogViewDefinition({
        handle: "Composite.Management.PageIdSelectorDialog",
        isMutable: true,
        position: Dialog.MODAL,
        url: Dialog.URL_TREESELECTOR,
        argument: {
            label: "Select Page",
            image: "${icon:page}",
            selectionProperty: "DataId",
            selectionValue: null, // MimeTypes.COMPOSITEPAGES
            selectionResult: "DataId",
            nodes: [{
                key: "PageElementProvider"
            }]
        }
    }),
	
	/*
	 * Linkable element selector (selecting pages and media files).
	 */
	"Composite.Management.LinkableSelectorDialog" : new DialogViewDefinition ({
		handle 		: "Composite.Management.LinkableSelectorDialog",
		position 	: Dialog.MODAL,
		url 		: Dialog.URL_TREESELECTOR,
		argument : {
			label 				: "Select Page or File",
			image				: "${icon:link}",
			selectionProperty 	: "Uri",
			selectionValue		: null,
			selectionResult		: "Uri",
			nodes : [
				{ key : "PageElementProvider" },
				{ key : "MediaFileElementProvider" }
			]
		}
	}),
	
	/*
	 * Media selector (images and other stuff).
	 */
	"Composite.Management.MediaSelectorDialog" : new DialogViewDefinition ({
		handle 		: "Composite.Management.MediaSelectorDialog",
		position 	: Dialog.MODAL,
		url 		: Dialog.URL_TREESELECTOR,
		argument : {
			label 				: "Select Page or File",
			image				: "${icon:link}",
			selectionProperty 	: "Uri",
			selectionValue		: null,
			selectionResult		: "Uri",
			nodes : [
				{ key : "MediaFileElementProvider" }
			]
		}
	}),
	
	/*
	 * Function selector (ALL TYPES).
	 */
	"Composite.Management.FunctionSelectorDialog" : new DialogViewDefinition ({
		handle 		: "Composite.Management.FunctionSelectorDialog",
		isMutable	: true,
		position 	: Dialog.MODAL,
		url 		: Dialog.URL_TREESELECTOR,
		argument : {
			label 				: "Select Function",
			image				: "${icon:functioncall}",
			selectionProperty 	: "ElementType",
			selectionValue		: MimeTypes.COMPOSITEFUNCTION,
			selectionResult		: "ElementId",
			nodes : [{
				key : "AllFunctionsElementProvider"
			}]
		}
	}),
	
	/*
	 * Function selector (widget functions).
	 */
	"Composite.Management.WidgetFunctionSelectorDialog" : new DialogViewDefinition ({
		handle 		: "Composite.Management.WidgetFunctionSelectorDialog",
		position 	: Dialog.MODAL,
		url 		: Dialog.URL_TREESELECTOR,
		argument : {
			label 				: "Select Widget",
			image				: "${icon:functioncall}",
			selectionProperty 	: "ElementType",
			selectionValue		: MimeTypes.COMPOSITEFUNCTION,
			selectionResult		: "ElementId",
			nodes : [{
				key : "AllWidgetFunctionsElementProvider"
			}]
		}
	}),
	
	/*
	 * Function selector (XHTML types).
	 */
	"Composite.Management.XhtmlDocumentFunctionSelectorDialog" : new DialogViewDefinition ({
		handle 		: "Composite.Management.XhtmlDocumentFunctionSelectorDialog",
		position 	: Dialog.MODAL,
		url 		: Dialog.URL_TREESELECTOR,
		argument : {
			label 				: "Select Function",
			image				: "${icon:functioncall}",
			selectionProperty 	: "ElementType",
			selectionValue		: MimeTypes.COMPOSITEFUNCTION,
			selectionResult		: "ElementId",
			nodes : [{
				key : "AllFunctionsElementProvider",
				search : "AllFunctionsElementProvider.XhtmlDocument"
			}]
		}
	})
}



/**
 * Kickstarting the entire shebang.
 */
var KickStart = new function () {
	
	var isLocalStoreReady = false;
	var isAudioReady = false;
	var isLoggedIn = null;
	var isFirstTime = false;
	var isQualified = Client.qualifies ();
	
	var DEVUSERNAME = "admin";
	var DEVPASSWORD = "123456";
	
	/*
	 * Fire on load!
	 */
	this.fireOnLoad = function () {
		
		if ( isQualified ) {
			
			Application.lock ( this );
			fileEventBroadcasterSubscriptions ( true );
			EventBroadcaster.subscribe ( BroadcastMessages.APPLICATION_SHUTDOWN, this );
			
			SetupService = WebServiceProxy.createProxy ( Constants.URL_WSDL_SETUPSERVICE );
			ReadyService = WebServiceProxy.createProxy ( Constants.URL_WSDL_READYSERVICE );
			LoginService =  WebServiceProxy.createProxy ( Constants.URL_WSDL_LOGINSERVICE );
			InstallationService = WebServiceProxy.createProxy ( Constants.URL_WSDL_INSTALLSERVICE );
			
			EventBroadcaster.broadcast ( BroadcastMessages.APPLICATION_KICKSTART );
			
		} else {
			
			document.location = "unsupported.aspx";
		}
	};
	
	/**
	 * @implements {IBroadcastListener}
	 * @param {string} broadcast
	 */
	this.handleBroadcast = function ( broadcast ) {
		
		switch ( broadcast ) {
		
			case BroadcastMessages.AUDIO_INITIALIZED :
			case BroadcastMessages.PERSISTANCE_INITIALIZED :
				kickStart ( broadcast );
				break;
				
			case BroadcastMessages.APPLICATION_STARTUP :
				// doStartUp (); hmmmm....
				break;
				
			case BroadcastMessages.KEY_ENTER :
				this.login ();
				break;
				
			case BroadcastMessages.APPLICATION_LOGIN :
				var appwindow = window.bindingMap.appwindow;
				appwindow.setURL ( "app.aspx" );
				break;
				
			case BroadcastMessages.APPLICATION_OPERATIONAL :
				showWorkbench ();
				break;
				
			case BroadcastMessages.APPLICATION_SHUTDOWN :
				if ( bindingMap.decks != null ) {
					bindingMap.decks.select ( "shutdowndeck" );
				}
				bindingMap.cover.show ();
				break;
		}
	}
	
	/**
	 * File and unfile EventBroadcaster subscriptions.
	 * @param {boolean} isSubscribe
	 */
	function fileEventBroadcasterSubscriptions ( isSubscribe ) {
		
		new List ([
		
			BroadcastMessages.AUDIO_INITIALIZED,
			BroadcastMessages.PERSISTANCE_INITIALIZED,
			BroadcastMessages.APPLICATION_STARTUP,
			BroadcastMessages.APPLICATION_LOGIN,
			BroadcastMessages.APPLICATION_OPERATIONAL
			
		]).each ( 
			function ( broadcast ) {
				if ( isSubscribe ) {
					EventBroadcaster.subscribe ( broadcast, KickStart );
				} else {
					EventBroadcaster.unsubscribe ( broadcast, KickStart );
				}
			}
		);
	}
	
	/**
	 * Freeze storyboard until Audio and Localstore initialize.
	 * If not registered, show registration. Otherwise show login.
	 * @param {string} broadcast
	 */
	function kickStart ( broadcast ) {
		
		switch ( broadcast ) {
			case BroadcastMessages.AUDIO_INITIALIZED :
				isAudioReady = true;
				setTimeout ( function () {
					Persistance.initialize (); // NOTE: We are not using this stuff!
				}, 0 );
				break;
			case BroadcastMessages.PERSISTANCE_INITIALIZED :
				isLocalStoreReady = true;
				break;
		}
		
		if ( isLocalStoreReady && isAudioReady ) {
			if ( bindingMap.decks != null && LoginService.IsLoggedIn ( true )) {
				accessGranted ();
			} else {
				if ( bindingMap.decks != null ) {
					splashScreenData ();
					showLogin ();
				} else {
					showWelcome ();
				}
			}
		}
	}
	
	/**
	 * Splash screen data.
	 */
	function splashScreenData () {
		
		var ver = document.getElementById ( "version" );	
		ver.firstChild.data = ver.firstChild.data.replace ( "${version}", Installation.versionPrettyString );
		
		var build = document.getElementById ( "build" );
		build.firstChild.data = build.firstChild.data.replace ( "${build}", Installation.versionString );
	}
	
	/*
	 * Show welcome screens on first time startup.
	 */
	function showWelcome () {
		
		Application.unlock ( KickStart );
		if ( window.Welcome != null ) {
			Welcome.test ();
		}
	}
	
	/*
	 * Show login screen.
	 */
	function showLogin () {
		
		EventBroadcaster.subscribe ( BroadcastMessages.KEY_ENTER, KickStart );
		Application.unlock ( KickStart );
		bindingMap.decks.select ( "logindeck" );
		setTimeout ( function () {
			if ( Application.isDeveloperMode && Application.isLocalHost ) {
				DataManager.getDataBinding ( "username" ).setValue ( DEVUSERNAME );
				DataManager.getDataBinding ( "password" ).setValue ( DEVPASSWORD );
			} 
			setTimeout ( function () {
				DataManager.getDataBinding ( "username" ).focus ();
			}, 250 );
		}, 0 );
	}
	
	/**
	 * When registered, monitor the servers readystate and continue to login screen when done.
	 */
	function watchProgress () {
		
		window.progressOnRegistrationInterval = window.setInterval ( function () {
			if ( ReadyService.IsServerReady ( true )) {
				window.clearInterval ( window.progressOnRegistrationInterval );
				window.progressOnRegistrationInterval = null;
				splashScreenData ();
				showLogin ();
			}
		}, 2000 );
	}
	
	/**
	 * Show it.
	 */
	function showWorkbench () {
	
		setTimeout ( function () {
			bindingMap.cover.hide ();
			fileEventBroadcasterSubscriptions ( false );
			Application.unlock ( KickStart );
		}, PageBinding.TIMEOUT );
	}
	
	/** 
	 * Note that we disable SOAP debugging during login. 
	 * Note that we may be able to do something intelligent with the SOAP response.
	 * Note that we didn't manage to come up with intelligent handling of the SOAP response.
	 */
	this.login = function () {
		
		Application.lock ( KickStart ); // unlocked by showWorkbench or if fields don't validate
		
		/*
		 * The timeout is here to block GUI with wait cursor.
		 */
		setTimeout ( function () {
		
			if ( bindingMap.toppage.validateAllDataBindings ()) {
				KickStart.doLogin ( 
					DataManager.getDataBinding ( "username" ).getResult (), 
					DataManager.getDataBinding ( "password" ).getResult ()
				);
			} else {
				Application.unlock ( KickStart );
			}
			
		}, 25 );
	}
	
	/**
	 * Isolated in order to be invoked by {@link Welcome}
	 * @param {String} username
	 * @param {String} password
	 */
	this.doLogin = function ( username, password ) {
		
		var wasEnabled = WebServiceProxy.isLoggingEnabled;
		WebServiceProxy.isLoggingEnabled = false;
		WebServiceProxy.isFaultHandler = false;
		
		var isAllowed = false;
		var result = LoginService.ValidateAndLogin ( username, password );
		if ( result instanceof SOAPFault ) {
			alert ( result.getFaultString ());
		} else {
			isAllowed = result;
		}
		
		if ( isAllowed ) {
			EventBroadcaster.unsubscribe ( BroadcastMessages.KEY_ENTER, KickStart );
			accessGranted ();
		} else {
			Application.unlock ( KickStart );
			if ( bindingMap.decks != null ) { // on Welcome we may get trapped here!
				accesssDenied ();
			}
		}
		WebServiceProxy.isFaultHandler = true;
		if ( wasEnabled ) {
			WebServiceProxy.isLoggingEnabled = true;
		}
	}
	
	/**
	 * Access granted.
	 */
	function accessGranted () {
		
		setTimeout ( function () {
			if ( bindingMap.decks != null ) {
				bindingMap.decks.select ( "loadingdeck" );
			}
			setTimeout ( function () {
				Application.login ();
			}, 0 );
		}, 0 );
	}
	
	/**
	 * Access denied.
	 */
	function accesssDenied () {
	
		var username = DataManager.getDataBinding ( "username" );
		var password = DataManager.getDataBinding ( "password" );
			
		username.blur ();
		password.blur ();
		username.setValue ( "" );
		password.setValue ( "" );
		username.clean ();
		password.clean ();
		username.focus ();
		
		document.getElementById ( "loginerror" ).style.display = "block";
		
		var handler = {
			handleAction : function ( action ) {
				document.getElementById ( "loginerror" ).style.display = "none";
				action.target.removeActionListener ( 
					Binding.ACTION_DIRTY, handler 
				);
			}
		}
		bindingMap.loginfields.addActionListener ( 
			Binding.ACTION_DIRTY, handler 
		);
	}
	
	/*
	 * Fire on load!
	 */
	WindowManager.fireOnLoad ( this );
	
	/*
	 * Non-qualified browsers would run into a javascript  
	 * error in the UpdateManager when switching to the 
	 * not supported page. Let's disable the UpdateManager.
	 */
	if ( !isQualified ) {
		UpdateManager.isEnabled = false;
	}
}

